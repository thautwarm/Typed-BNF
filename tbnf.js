(() => {
    "use strict";
    var e = {
        9629: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        8872: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        4108: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ANTLRInputStream = void 0;
            const i = r(9491);
            const o = r(6966);
            const s = r(3828);
            const a = 1024;
            const l = 1024;
            class ANTLRInputStream {
                constructor(e) {
                    this.p = 0;
                    this.data = e;
                    this.n = e.length
                }
                reset() {
                    this.p = 0
                }
                consume() {
                    if (this.p >= this.n) {
                        i(this.LA(1) === s.IntStream.EOF);
                        throw new Error("cannot consume EOF")
                    }
                    if (this.p < this.n) {
                        this.p++
                    }
                }
                LA(e) {
                    if (e === 0) {
                        return 0
                    }
                    if (e < 0) {
                        e++;
                        if (this.p + e - 1 < 0) {
                            return s.IntStream.EOF
                        }
                    }
                    if (this.p + e - 1 >= this.n) {
                        return s.IntStream.EOF
                    }
                    return this.data.charCodeAt(this.p + e - 1)
                }
                LT(e) {
                    return this.LA(e)
                }
                get index() {
                    return this.p
                }
                get size() {
                    return this.n
                }
                mark() {
                    return -1
                }
                release(e) {}
                seek(e) {
                    if (e <= this.p) {
                        this.p = e;
                        return
                    }
                    e = Math.min(e, this.n);
                    while (this.p < e) {
                        this.consume()
                    }
                }
                getText(e) {
                    let t = e.a;
                    let r = e.b;
                    if (r >= this.n) {
                        r = this.n - 1
                    }
                    let n = r - t + 1;
                    if (t >= this.n) {
                        return ""
                    }
                    return this.data.substr(t, n)
                }
                get sourceName() {
                    if (!this.name) {
                        return s.IntStream.UNKNOWN_SOURCE_NAME
                    }
                    return this.name
                }
                toString() {
                    return this.data
                }
            }
            n([o.Override], ANTLRInputStream.prototype, "consume", null);
            n([o.Override], ANTLRInputStream.prototype, "LA", null);
            n([o.Override], ANTLRInputStream.prototype, "index", null);
            n([o.Override], ANTLRInputStream.prototype, "size", null);
            n([o.Override], ANTLRInputStream.prototype, "mark", null);
            n([o.Override], ANTLRInputStream.prototype, "release", null);
            n([o.Override], ANTLRInputStream.prototype, "seek", null);
            n([o.Override], ANTLRInputStream.prototype, "getText", null);
            n([o.Override], ANTLRInputStream.prototype, "sourceName", null);
            n([o.Override], ANTLRInputStream.prototype, "toString", null);
            t.ANTLRInputStream = ANTLRInputStream
        },
        4003: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BailErrorStrategy = void 0;
            const i = r(488);
            const o = r(368);
            const s = r(6966);
            const a = r(8650);
            class BailErrorStrategy extends i.DefaultErrorStrategy {
                recover(e, t) {
                    for (let r = e.context; r; r = r.parent) {
                        r.exception = t
                    }
                    throw new a.ParseCancellationException(t)
                }
                recoverInline(e) {
                    let t = new o.InputMismatchException(e);
                    for (let r = e.context; r; r = r.parent) {
                        r.exception = t
                    }
                    throw new a.ParseCancellationException(t)
                }
                sync(e) {}
            }
            n([s.Override], BailErrorStrategy.prototype, "recover", null);
            n([s.Override], BailErrorStrategy.prototype, "recoverInline", null);
            n([s.Override], BailErrorStrategy.prototype, "sync", null);
            t.BailErrorStrategy = BailErrorStrategy
        },
        3810: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BufferedTokenStream = void 0;
            const o = r(9491);
            const s = r(3798);
            const a = r(6330);
            const l = r(1740);
            const _ = r(6966);
            const u = r(7528);
            let c = class BufferedTokenStream {
                constructor(e) {
                    this.tokens = [];
                    this.p = -1;
                    this.fetchedEOF = false;
                    if (e == null) {
                        throw new Error("tokenSource cannot be null")
                    }
                    this._tokenSource = e
                }
                get tokenSource() {
                    return this._tokenSource
                }
                set tokenSource(e) {
                    this._tokenSource = e;
                    this.tokens.length = 0;
                    this.p = -1;
                    this.fetchedEOF = false
                }
                get index() {
                    return this.p
                }
                mark() {
                    return 0
                }
                release(e) {}
                seek(e) {
                    this.lazyInit();
                    this.p = this.adjustSeekIndex(e)
                }
                get size() {
                    return this.tokens.length
                }
                consume() {
                    let e;
                    if (this.p >= 0) {
                        if (this.fetchedEOF) {
                            e = this.p < this.tokens.length - 1
                        } else {
                            e = this.p < this.tokens.length
                        }
                    } else {
                        e = false
                    }
                    if (!e && this.LA(1) === u.Token.EOF) {
                        throw new Error("cannot consume EOF")
                    }
                    if (this.sync(this.p + 1)) {
                        this.p = this.adjustSeekIndex(this.p + 1)
                    }
                }
                sync(e) {
                    o(e >= 0);
                    let t = e - this.tokens.length + 1;
                    if (t > 0) {
                        let e = this.fetch(t);
                        return e >= t
                    }
                    return true
                }
                fetch(e) {
                    if (this.fetchedEOF) {
                        return 0
                    }
                    for (let t = 0; t < e; t++) {
                        let e = this.tokenSource.nextToken();
                        if (this.isWritableToken(e)) {
                            e.tokenIndex = this.tokens.length
                        }
                        this.tokens.push(e);
                        if (e.type === u.Token.EOF) {
                            this.fetchedEOF = true;
                            return t + 1
                        }
                    }
                    return e
                }
                get(e) {
                    if (e < 0 || e >= this.tokens.length) {
                        throw new RangeError("token index " + e + " out of range 0.." + (this.tokens.length - 1))
                    }
                    return this.tokens[e]
                }
                getRange(e, t) {
                    if (e < 0 || t < 0) {
                        return []
                    }
                    this.lazyInit();
                    let r = new Array;
                    if (t >= this.tokens.length) {
                        t = this.tokens.length - 1
                    }
                    for (let n = e; n <= t; n++) {
                        let e = this.tokens[n];
                        if (e.type === u.Token.EOF) {
                            break
                        }
                        r.push(e)
                    }
                    return r
                }
                LA(e) {
                    let t = this.LT(e);
                    if (!t) {
                        return u.Token.INVALID_TYPE
                    }
                    return t.type
                }
                tryLB(e) {
                    if (this.p - e < 0) {
                        return undefined
                    }
                    return this.tokens[this.p - e]
                }
                LT(e) {
                    let t = this.tryLT(e);
                    if (t === undefined) {
                        throw new RangeError("requested lookback index out of range")
                    }
                    return t
                }
                tryLT(e) {
                    this.lazyInit();
                    if (e === 0) {
                        throw new RangeError("0 is not a valid lookahead index")
                    }
                    if (e < 0) {
                        return this.tryLB(-e)
                    }
                    let t = this.p + e - 1;
                    this.sync(t);
                    if (t >= this.tokens.length) {
                        return this.tokens[this.tokens.length - 1]
                    }
                    return this.tokens[t]
                }
                adjustSeekIndex(e) {
                    return e
                }
                lazyInit() {
                    if (this.p === -1) {
                        this.setup()
                    }
                }
                setup() {
                    this.sync(0);
                    this.p = this.adjustSeekIndex(0)
                }
                getTokens(e, t, r) {
                    this.lazyInit();
                    if (e === undefined) {
                        o(t === undefined && r === undefined);
                        return this.tokens
                    } else if (t === undefined) {
                        t = this.tokens.length - 1
                    }
                    if (e < 0 || t >= this.tokens.length || t < 0 || e >= this.tokens.length) {
                        throw new RangeError("start " + e + " or stop " + t + " not in 0.." + (this.tokens.length - 1))
                    }
                    if (e > t) {
                        return []
                    }
                    if (r === undefined) {
                        return this.tokens.slice(e, t + 1)
                    } else if (typeof r === "number") {
                        r = (new Set).add(r)
                    }
                    let n = r;
                    let i = this.tokens.slice(e, t + 1);
                    i = i.filter((e => n.has(e.type)));
                    return i
                }
                nextTokenOnChannel(e, t) {
                    this.sync(e);
                    if (e >= this.size) {
                        return this.size - 1
                    }
                    let r = this.tokens[e];
                    while (r.channel !== t) {
                        if (r.type === u.Token.EOF) {
                            return e
                        }
                        e++;
                        this.sync(e);
                        r = this.tokens[e]
                    }
                    return e
                }
                previousTokenOnChannel(e, t) {
                    this.sync(e);
                    if (e >= this.size) {
                        return this.size - 1
                    }
                    while (e >= 0) {
                        let r = this.tokens[e];
                        if (r.type === u.Token.EOF || r.channel === t) {
                            return e
                        }
                        e--
                    }
                    return e
                }
                getHiddenTokensToRight(e, t = -1) {
                    this.lazyInit();
                    if (e < 0 || e >= this.tokens.length) {
                        throw new RangeError(e + " not in 0.." + (this.tokens.length - 1))
                    }
                    let r = this.nextTokenOnChannel(e + 1, l.Lexer.DEFAULT_TOKEN_CHANNEL);
                    let n;
                    let i = e + 1;
                    if (r === -1) {
                        n = this.size - 1
                    } else {
                        n = r
                    }
                    return this.filterForChannel(i, n, t)
                }
                getHiddenTokensToLeft(e, t = -1) {
                    this.lazyInit();
                    if (e < 0 || e >= this.tokens.length) {
                        throw new RangeError(e + " not in 0.." + (this.tokens.length - 1))
                    }
                    if (e === 0) {
                        return []
                    }
                    let r = this.previousTokenOnChannel(e - 1, l.Lexer.DEFAULT_TOKEN_CHANNEL);
                    if (r === e - 1) {
                        return []
                    }
                    let n = r + 1;
                    let i = e - 1;
                    return this.filterForChannel(n, i, t)
                }
                filterForChannel(e, t, r) {
                    let n = new Array;
                    for (let i = e; i <= t; i++) {
                        let e = this.tokens[i];
                        if (r === -1) {
                            if (e.channel !== l.Lexer.DEFAULT_TOKEN_CHANNEL) {
                                n.push(e)
                            }
                        } else {
                            if (e.channel === r) {
                                n.push(e)
                            }
                        }
                    }
                    return n
                }
                get sourceName() {
                    return this.tokenSource.sourceName
                }
                getText(e) {
                    if (e === undefined) {
                        e = a.Interval.of(0, this.size - 1)
                    } else if (!(e instanceof a.Interval)) {
                        e = e.sourceInterval
                    }
                    let t = e.a;
                    let r = e.b;
                    if (t < 0 || r < 0) {
                        return ""
                    }
                    this.fill();
                    if (r >= this.tokens.length) {
                        r = this.tokens.length - 1
                    }
                    let n = "";
                    for (let e = t; e <= r; e++) {
                        let t = this.tokens[e];
                        if (t.type === u.Token.EOF) {
                            break
                        }
                        n += t.text
                    }
                    return n.toString()
                }
                getTextFromRange(e, t) {
                    if (this.isToken(e) && this.isToken(t)) {
                        return this.getText(a.Interval.of(e.tokenIndex, t.tokenIndex))
                    }
                    return ""
                }
                fill() {
                    this.lazyInit();
                    const e = 1e3;
                    while (true) {
                        let t = this.fetch(e);
                        if (t < e) {
                            return
                        }
                    }
                }
                isWritableToken(e) {
                    return e instanceof s.CommonToken
                }
                isToken(e) {
                    return e instanceof s.CommonToken
                }
            };
            n([_.NotNull], c.prototype, "_tokenSource", void 0);
            n([_.Override], c.prototype, "tokenSource", null);
            n([_.Override], c.prototype, "index", null);
            n([_.Override], c.prototype, "mark", null);
            n([_.Override], c.prototype, "release", null);
            n([_.Override], c.prototype, "seek", null);
            n([_.Override], c.prototype, "size", null);
            n([_.Override], c.prototype, "consume", null);
            n([_.Override], c.prototype, "get", null);
            n([_.Override], c.prototype, "LA", null);
            n([_.NotNull, _.Override], c.prototype, "LT", null);
            n([_.Override], c.prototype, "sourceName", null);
            n([_.NotNull, _.Override], c.prototype, "getText", null);
            n([_.NotNull, _.Override], c.prototype, "getTextFromRange", null);
            c = n([i(0, _.NotNull)], c);
            t.BufferedTokenStream = c
        },
        7677: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        4904: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CharStreams = void 0;
            const n = r(1013);
            const i = r(8951);
            const o = r(3828);
            var s;
            (function(e) {
                function fromString(e, t) {
                    if (t === undefined || t.length === 0) {
                        t = o.IntStream.UNKNOWN_SOURCE_NAME
                    }
                    let r = n.CodePointBuffer.builder(e.length);
                    let s = new Uint16Array(e.length);
                    for (let t = 0; t < e.length; t++) {
                        s[t] = e.charCodeAt(t)
                    }
                    r.append(s);
                    return i.CodePointCharStream.fromBuffer(r.build(), t)
                }
                e.fromString = fromString
            })(s = t.CharStreams || (t.CharStreams = {}))
        },
        1013: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CodePointBuffer = void 0;
            const n = r(9491);
            const i = r(286);
            class CodePointBuffer {
                constructor(e, t) {
                    this.buffer = e;
                    this._position = 0;
                    this._size = t
                }
                static withArray(e) {
                    return new CodePointBuffer(e, e.length)
                }
                get position() {
                    return this._position
                }
                set position(e) {
                    if (e < 0 || e > this._size) {
                        throw new RangeError
                    }
                    this._position = e
                }
                get remaining() {
                    return this._size - this.position
                }
                get(e) {
                    return this.buffer[e]
                }
                array() {
                    return this.buffer.slice(0, this._size)
                }
                static builder(e) {
                    return new CodePointBuffer.Builder(e)
                }
            }
            t.CodePointBuffer = CodePointBuffer;
            (function(e) {
                let t;
                (function(e) {
                    e[e["BYTE"] = 0] = "BYTE";
                    e[e["CHAR"] = 1] = "CHAR";
                    e[e["INT"] = 2] = "INT"
                })(t || (t = {}));
                class Builder {
                    constructor(e) {
                        this.type = 0;
                        this.buffer = new Uint8Array(e);
                        this.prevHighSurrogate = -1;
                        this.position = 0
                    }
                    build() {
                        return new e(this.buffer, this.position)
                    }
                    static roundUpToNextPowerOfTwo(e) {
                        let t = 32 - Math.clz32(e - 1);
                        return Math.pow(2, t)
                    }
                    ensureRemaining(e) {
                        switch (this.type) {
                            case 0:
                                if (this.buffer.length - this.position < e) {
                                    let t = Builder.roundUpToNextPowerOfTwo(this.buffer.length + e);
                                    let r = new Uint8Array(t);
                                    r.set(this.buffer.subarray(0, this.position), 0);
                                    this.buffer = r
                                }
                                break;
                            case 1:
                                if (this.buffer.length - this.position < e) {
                                    let t = Builder.roundUpToNextPowerOfTwo(this.buffer.length + e);
                                    let r = new Uint16Array(t);
                                    r.set(this.buffer.subarray(0, this.position), 0);
                                    this.buffer = r
                                }
                                break;
                            case 2:
                                if (this.buffer.length - this.position < e) {
                                    let t = Builder.roundUpToNextPowerOfTwo(this.buffer.length + e);
                                    let r = new Int32Array(t);
                                    r.set(this.buffer.subarray(0, this.position), 0);
                                    this.buffer = r
                                }
                                break
                        }
                    }
                    append(e) {
                        this.ensureRemaining(e.length);
                        this.appendArray(e)
                    }
                    appendArray(e) {
                        switch (this.type) {
                            case 0:
                                this.appendArrayByte(e);
                                break;
                            case 1:
                                this.appendArrayChar(e);
                                break;
                            case 2:
                                this.appendArrayInt(e);
                                break
                        }
                    }
                    appendArrayByte(e) {
                        n(this.prevHighSurrogate === -1);
                        let t = e;
                        let r = 0;
                        let o = e.length;
                        let s = this.buffer;
                        let a = this.position;
                        while (r < o) {
                            let n = t[r];
                            if (n <= 255) {
                                s[a] = n
                            } else {
                                e = e.subarray(r, o);
                                this.position = a;
                                if (!i.isHighSurrogate(n)) {
                                    this.byteToCharBuffer(e.length);
                                    this.appendArrayChar(e);
                                    return
                                } else {
                                    this.byteToIntBuffer(e.length);
                                    this.appendArrayInt(e);
                                    return
                                }
                            }
                            r++;
                            a++
                        }
                        this.position = a
                    }
                    appendArrayChar(e) {
                        n(this.prevHighSurrogate === -1);
                        let t = e;
                        let r = 0;
                        let o = e.length;
                        let s = this.buffer;
                        let a = this.position;
                        while (r < o) {
                            let n = t[r];
                            if (!i.isHighSurrogate(n)) {
                                s[a] = n
                            } else {
                                e = e.subarray(r, o);
                                this.position = a;
                                this.charToIntBuffer(e.length);
                                this.appendArrayInt(e);
                                return
                            }
                            r++;
                            a++
                        }
                        this.position = a
                    }
                    appendArrayInt(e) {
                        let t = e;
                        let r = 0;
                        let n = e.length;
                        let o = this.buffer;
                        let s = this.position;
                        while (r < n) {
                            let e = t[r];
                            r++;
                            if (this.prevHighSurrogate !== -1) {
                                if (i.isLowSurrogate(e)) {
                                    o[s] = String.fromCharCode(this.prevHighSurrogate, e).codePointAt(0);
                                    s++;
                                    this.prevHighSurrogate = -1
                                } else {
                                    o[s] = this.prevHighSurrogate;
                                    s++;
                                    if (i.isHighSurrogate(e)) {
                                        this.prevHighSurrogate = e
                                    } else {
                                        o[s] = e;
                                        s++;
                                        this.prevHighSurrogate = -1
                                    }
                                }
                            } else if (i.isHighSurrogate(e)) {
                                this.prevHighSurrogate = e
                            } else {
                                o[s] = e;
                                s++
                            }
                        }
                        if (this.prevHighSurrogate !== -1) {
                            o[s] = this.prevHighSurrogate;
                            s++
                        }
                        this.position = s
                    }
                    byteToCharBuffer(e) {
                        let t = new Uint16Array(Math.max(this.position + e, this.buffer.length >> 1));
                        t.set(this.buffer.subarray(0, this.position), 0);
                        this.type = 1;
                        this.buffer = t
                    }
                    byteToIntBuffer(e) {
                        let t = new Int32Array(Math.max(this.position + e, this.buffer.length >> 2));
                        t.set(this.buffer.subarray(0, this.position), 0);
                        this.type = 2;
                        this.buffer = t
                    }
                    charToIntBuffer(e) {
                        let t = new Int32Array(Math.max(this.position + e, this.buffer.length >> 1));
                        t.set(this.buffer.subarray(0, this.position), 0);
                        this.type = 2;
                        this.buffer = t
                    }
                }
                e.Builder = Builder
            })(CodePointBuffer = t.CodePointBuffer || (t.CodePointBuffer = {}))
        },
        8951: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CodePointCharStream = void 0;
            const i = r(9491);
            const o = r(3828);
            const s = r(6330);
            const a = r(6966);
            class CodePointCharStream {
                constructor(e, t, r, n) {
                    i(t === 0);
                    this._array = e;
                    this._size = r;
                    this._name = n;
                    this._position = 0
                }
                get internalStorage() {
                    return this._array
                }
                static fromBuffer(e, t) {
                    if (t === undefined || t.length === 0) {
                        t = o.IntStream.UNKNOWN_SOURCE_NAME
                    }
                    return new CodePointCharStream(e.array(), e.position, e.remaining, t)
                }
                consume() {
                    if (this._size - this._position === 0) {
                        i(this.LA(1) === o.IntStream.EOF);
                        throw new RangeError("cannot consume EOF")
                    }
                    this._position++
                }
                get index() {
                    return this._position
                }
                get size() {
                    return this._size
                }
                mark() {
                    return -1
                }
                release(e) {}
                seek(e) {
                    this._position = e
                }
                get sourceName() {
                    return this._name
                }
                toString() {
                    return this.getText(s.Interval.of(0, this.size - 1))
                }
                LA(e) {
                    let t;
                    switch (Math.sign(e)) {
                        case -1:
                            t = this.index + e;
                            if (t < 0) {
                                return o.IntStream.EOF
                            }
                            return this._array[t];
                        case 0:
                            return 0;
                        case 1:
                            t = this.index + e - 1;
                            if (t >= this.size) {
                                return o.IntStream.EOF
                            }
                            return this._array[t]
                    }
                    throw new RangeError("Not reached")
                }
                getText(e) {
                    const t = Math.min(e.a, this.size);
                    const r = Math.min(e.b - e.a + 1, this.size - t);
                    if (this._array instanceof Int32Array) {
                        return String.fromCodePoint(...Array.from(this._array.subarray(t, t + r)))
                    } else {
                        return String.fromCharCode(...Array.from(this._array.subarray(t, t + r)))
                    }
                }
            }
            n([a.Override], CodePointCharStream.prototype, "consume", null);
            n([a.Override], CodePointCharStream.prototype, "index", null);
            n([a.Override], CodePointCharStream.prototype, "size", null);
            n([a.Override], CodePointCharStream.prototype, "mark", null);
            n([a.Override], CodePointCharStream.prototype, "release", null);
            n([a.Override], CodePointCharStream.prototype, "seek", null);
            n([a.Override], CodePointCharStream.prototype, "sourceName", null);
            n([a.Override], CodePointCharStream.prototype, "toString", null);
            n([a.Override], CodePointCharStream.prototype, "LA", null);
            n([a.Override], CodePointCharStream.prototype, "getText", null);
            t.CodePointCharStream = CodePointCharStream
        },
        3798: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CommonToken = void 0;
            const o = r(6330);
            const s = r(6966);
            const a = r(7528);
            let l = class CommonToken {
                constructor(e, t, r = CommonToken.EMPTY_SOURCE, n = a.Token.DEFAULT_CHANNEL, i = 0, o = 0) {
                    this._line = 0;
                    this._charPositionInLine = -1;
                    this._channel = a.Token.DEFAULT_CHANNEL;
                    this.index = -1;
                    this._text = t;
                    this._type = e;
                    this.source = r;
                    this._channel = n;
                    this.start = i;
                    this.stop = o;
                    if (r.source != null) {
                        this._line = r.source.line;
                        this._charPositionInLine = r.source.charPositionInLine
                    }
                }
                static fromToken(e) {
                    let t = new CommonToken(e.type, undefined, CommonToken.EMPTY_SOURCE, e.channel, e.startIndex, e.stopIndex);
                    t._line = e.line;
                    t.index = e.tokenIndex;
                    t._charPositionInLine = e.charPositionInLine;
                    if (e instanceof CommonToken) {
                        t._text = e._text;
                        t.source = e.source
                    } else {
                        t._text = e.text;
                        t.source = {
                            source: e.tokenSource,
                            stream: e.inputStream
                        }
                    }
                    return t
                }
                get type() {
                    return this._type
                }
                set type(e) {
                    this._type = e
                }
                get line() {
                    return this._line
                }
                set line(e) {
                    this._line = e
                }
                get text() {
                    if (this._text != null) {
                        return this._text
                    }
                    let e = this.inputStream;
                    if (e == null) {
                        return undefined
                    }
                    let t = e.size;
                    if (this.start < t && this.stop < t) {
                        return e.getText(o.Interval.of(this.start, this.stop))
                    } else {
                        return "<EOF>"
                    }
                }
                set text(e) {
                    this._text = e
                }
                get charPositionInLine() {
                    return this._charPositionInLine
                }
                set charPositionInLine(e) {
                    this._charPositionInLine = e
                }
                get channel() {
                    return this._channel
                }
                set channel(e) {
                    this._channel = e
                }
                get startIndex() {
                    return this.start
                }
                set startIndex(e) {
                    this.start = e
                }
                get stopIndex() {
                    return this.stop
                }
                set stopIndex(e) {
                    this.stop = e
                }
                get tokenIndex() {
                    return this.index
                }
                set tokenIndex(e) {
                    this.index = e
                }
                get tokenSource() {
                    return this.source.source
                }
                get inputStream() {
                    return this.source.stream
                }
                toString(e) {
                    let t = "";
                    if (this._channel > 0) {
                        t = ",channel=" + this._channel
                    }
                    let r = this.text;
                    if (r != null) {
                        r = r.replace(/\n/g, "\\n");
                        r = r.replace(/\r/g, "\\r");
                        r = r.replace(/\t/g, "\\t")
                    } else {
                        r = "<no text>"
                    }
                    let n = String(this._type);
                    if (e) {
                        n = e.vocabulary.getDisplayName(this._type)
                    }
                    return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + r + "',<" + n + ">" + t + "," + this._line + ":" + this.charPositionInLine + "]"
                }
            };
            l.EMPTY_SOURCE = {
                source: undefined,
                stream: undefined
            };
            n([s.NotNull], l.prototype, "source", void 0);
            n([s.Override], l.prototype, "type", null);
            n([s.Override], l.prototype, "line", null);
            n([s.Override], l.prototype, "text", null);
            n([s.Override], l.prototype, "charPositionInLine", null);
            n([s.Override], l.prototype, "channel", null);
            n([s.Override], l.prototype, "startIndex", null);
            n([s.Override], l.prototype, "stopIndex", null);
            n([s.Override], l.prototype, "tokenIndex", null);
            n([s.Override], l.prototype, "tokenSource", null);
            n([s.Override], l.prototype, "inputStream", null);
            n([s.Override], l.prototype, "toString", null);
            n([i(0, s.NotNull)], l, "fromToken", null);
            l = n([i(2, s.NotNull)], l);
            t.CommonToken = l
        },
        8001: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CommonTokenFactory = void 0;
            const i = r(3798);
            const o = r(6330);
            const s = r(6966);
            class CommonTokenFactory {
                constructor(e = false) {
                    this.copyText = e
                }
                create(e, t, r, n, s, a, l, _) {
                    let u = new i.CommonToken(t, r, e, n, s, a);
                    u.line = l;
                    u.charPositionInLine = _;
                    if (r == null && this.copyText && e.stream != null) {
                        u.text = e.stream.getText(o.Interval.of(s, a))
                    }
                    return u
                }
                createSimple(e, t) {
                    return new i.CommonToken(e, t)
                }
            }
            n([s.Override], CommonTokenFactory.prototype, "create", null);
            n([s.Override], CommonTokenFactory.prototype, "createSimple", null);
            t.CommonTokenFactory = CommonTokenFactory;
            (function(e) {
                e.DEFAULT = new e
            })(CommonTokenFactory = t.CommonTokenFactory || (t.CommonTokenFactory = {}))
        },
        2757: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CommonTokenStream = void 0;
            const o = r(3810);
            const s = r(6966);
            const a = r(7528);
            let l = class CommonTokenStream extends o.BufferedTokenStream {
                constructor(e, t = a.Token.DEFAULT_CHANNEL) {
                    super(e);
                    this.channel = t
                }
                adjustSeekIndex(e) {
                    return this.nextTokenOnChannel(e, this.channel)
                }
                tryLB(e) {
                    if (this.p - e < 0) {
                        return undefined
                    }
                    let t = this.p;
                    let r = 1;
                    while (r <= e && t > 0) {
                        t = this.previousTokenOnChannel(t - 1, this.channel);
                        r++
                    }
                    if (t < 0) {
                        return undefined
                    }
                    return this.tokens[t]
                }
                tryLT(e) {
                    this.lazyInit();
                    if (e === 0) {
                        throw new RangeError("0 is not a valid lookahead index")
                    }
                    if (e < 0) {
                        return this.tryLB(-e)
                    }
                    let t = this.p;
                    let r = 1;
                    while (r < e) {
                        if (this.sync(t + 1)) {
                            t = this.nextTokenOnChannel(t + 1, this.channel)
                        }
                        r++
                    }
                    return this.tokens[t]
                }
                getNumberOfOnChannelTokens() {
                    let e = 0;
                    this.fill();
                    for (let t of this.tokens) {
                        if (t.channel === this.channel) {
                            e++
                        }
                        if (t.type === a.Token.EOF) {
                            break
                        }
                    }
                    return e
                }
            };
            n([s.Override], l.prototype, "adjustSeekIndex", null);
            n([s.Override], l.prototype, "tryLB", null);
            n([s.Override], l.prototype, "tryLT", null);
            l = n([i(0, s.NotNull)], l);
            t.CommonTokenStream = l
        },
        8125: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ConsoleErrorListener = void 0;
            class ConsoleErrorListener {
                syntaxError(e, t, r, n, i, o) {
                    console.error(`line ${r}:${n} ${i}`)
                }
            }
            t.ConsoleErrorListener = ConsoleErrorListener;
            ConsoleErrorListener.INSTANCE = new ConsoleErrorListener
        },
        6966: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SuppressWarnings = t.Override = t.Nullable = t.NotNull = void 0;

            function NotNull(e, t, r) {}
            t.NotNull = NotNull;

            function Nullable(e, t, r) {}
            t.Nullable = Nullable;

            function Override(e, t, r) {}
            t.Override = Override;

            function SuppressWarnings(e) {
                return (e, t, r) => {}
            }
            t.SuppressWarnings = SuppressWarnings
        },
        488: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DefaultErrorStrategy = void 0;
            const o = r(2210);
            const s = r(1765);
            const a = r(5575);
            const l = r(368);
            const _ = r(7108);
            const u = r(1914);
            const c = r(5047);
            const d = r(7528);
            const p = r(6966);
            class DefaultErrorStrategy {
                constructor() {
                    this.errorRecoveryMode = false;
                    this.lastErrorIndex = -1;
                    this.nextTokensState = o.ATNState.INVALID_STATE_NUMBER
                }
                reset(e) {
                    this.endErrorCondition(e)
                }
                beginErrorCondition(e) {
                    this.errorRecoveryMode = true
                }
                inErrorRecoveryMode(e) {
                    return this.errorRecoveryMode
                }
                endErrorCondition(e) {
                    this.errorRecoveryMode = false;
                    this.lastErrorStates = undefined;
                    this.lastErrorIndex = -1
                }
                reportMatch(e) {
                    this.endErrorCondition(e)
                }
                reportError(e, t) {
                    if (this.inErrorRecoveryMode(e)) {
                        return
                    }
                    this.beginErrorCondition(e);
                    if (t instanceof u.NoViableAltException) {
                        this.reportNoViableAlternative(e, t)
                    } else if (t instanceof l.InputMismatchException) {
                        this.reportInputMismatch(e, t)
                    } else if (t instanceof a.FailedPredicateException) {
                        this.reportFailedPredicate(e, t)
                    } else {
                        console.error(`unknown recognition error type: ${t}`);
                        this.notifyErrorListeners(e, t.toString(), t)
                    }
                }
                notifyErrorListeners(e, t, r) {
                    let n = r.getOffendingToken(e);
                    if (n === undefined) {
                        n = null
                    }
                    e.notifyErrorListeners(t, n, r)
                }
                recover(e, t) {
                    if (this.lastErrorIndex === e.inputStream.index && this.lastErrorStates && this.lastErrorStates.contains(e.state)) {
                        e.consume()
                    }
                    this.lastErrorIndex = e.inputStream.index;
                    if (!this.lastErrorStates) {
                        this.lastErrorStates = new _.IntervalSet
                    }
                    this.lastErrorStates.add(e.state);
                    let r = this.getErrorRecoverySet(e);
                    this.consumeUntil(e, r)
                }
                sync(e) {
                    let t = e.interpreter.atn.states[e.state];
                    if (this.inErrorRecoveryMode(e)) {
                        return
                    }
                    let r = e.inputStream;
                    let n = r.LA(1);
                    let i = e.atn.nextTokens(t);
                    if (i.contains(n)) {
                        this.nextTokensContext = undefined;
                        this.nextTokensState = o.ATNState.INVALID_STATE_NUMBER;
                        return
                    }
                    if (i.contains(d.Token.EPSILON)) {
                        if (this.nextTokensContext === undefined) {
                            this.nextTokensContext = e.context;
                            this.nextTokensState = e.state
                        }
                        return
                    }
                    switch (t.stateType) {
                        case s.ATNStateType.BLOCK_START:
                        case s.ATNStateType.STAR_BLOCK_START:
                        case s.ATNStateType.PLUS_BLOCK_START:
                        case s.ATNStateType.STAR_LOOP_ENTRY:
                            if (this.singleTokenDeletion(e)) {
                                return
                            }
                            throw new l.InputMismatchException(e);
                        case s.ATNStateType.PLUS_LOOP_BACK:
                        case s.ATNStateType.STAR_LOOP_BACK:
                            this.reportUnwantedToken(e);
                            let t = e.getExpectedTokens();
                            let r = t.or(this.getErrorRecoverySet(e));
                            this.consumeUntil(e, r);
                            break;
                        default:
                            break
                    }
                }
                reportNoViableAlternative(e, t) {
                    let r = e.inputStream;
                    let n;
                    if (r) {
                        if (t.startToken.type === d.Token.EOF) {
                            n = "<EOF>"
                        } else {
                            n = r.getTextFromRange(t.startToken, t.getOffendingToken())
                        }
                    } else {
                        n = "<unknown input>"
                    }
                    let i = "no viable alternative at input " + this.escapeWSAndQuote(n);
                    this.notifyErrorListeners(e, i, t)
                }
                reportInputMismatch(e, t) {
                    let r = t.expectedTokens;
                    let n = r ? r.toStringVocabulary(e.vocabulary) : "";
                    let i = "mismatched input " + this.getTokenErrorDisplay(t.getOffendingToken(e)) + " expecting " + n;
                    this.notifyErrorListeners(e, i, t)
                }
                reportFailedPredicate(e, t) {
                    let r = e.ruleNames[e.context.ruleIndex];
                    let n = "rule " + r + " " + t.message;
                    this.notifyErrorListeners(e, n, t)
                }
                reportUnwantedToken(e) {
                    if (this.inErrorRecoveryMode(e)) {
                        return
                    }
                    this.beginErrorCondition(e);
                    let t = e.currentToken;
                    let r = this.getTokenErrorDisplay(t);
                    let n = this.getExpectedTokens(e);
                    let i = "extraneous input " + r + " expecting " + n.toStringVocabulary(e.vocabulary);
                    e.notifyErrorListeners(i, t, undefined)
                }
                reportMissingToken(e) {
                    if (this.inErrorRecoveryMode(e)) {
                        return
                    }
                    this.beginErrorCondition(e);
                    let t = e.currentToken;
                    let r = this.getExpectedTokens(e);
                    let n = "missing " + r.toStringVocabulary(e.vocabulary) + " at " + this.getTokenErrorDisplay(t);
                    e.notifyErrorListeners(n, t, undefined)
                }
                recoverInline(e) {
                    let t = this.singleTokenDeletion(e);
                    if (t) {
                        e.consume();
                        return t
                    }
                    if (this.singleTokenInsertion(e)) {
                        return this.getMissingSymbol(e)
                    }
                    if (this.nextTokensContext === undefined) {
                        throw new l.InputMismatchException(e)
                    } else {
                        throw new l.InputMismatchException(e, this.nextTokensState, this.nextTokensContext)
                    }
                }
                singleTokenInsertion(e) {
                    let t = e.inputStream.LA(1);
                    let r = e.interpreter.atn.states[e.state];
                    let n = r.transition(0).target;
                    let i = e.interpreter.atn;
                    let o = i.nextTokens(n, c.PredictionContext.fromRuleContext(i, e.context));
                    if (o.contains(t)) {
                        this.reportMissingToken(e);
                        return true
                    }
                    return false
                }
                singleTokenDeletion(e) {
                    let t = e.inputStream.LA(2);
                    let r = this.getExpectedTokens(e);
                    if (r.contains(t)) {
                        this.reportUnwantedToken(e);
                        e.consume();
                        let t = e.currentToken;
                        this.reportMatch(e);
                        return t
                    }
                    return undefined
                }
                getMissingSymbol(e) {
                    let t = e.currentToken;
                    let r = this.getExpectedTokens(e);
                    let n = d.Token.INVALID_TYPE;
                    if (!r.isNil) {
                        n = r.minElement
                    }
                    let i;
                    if (n === d.Token.EOF) {
                        i = "<missing EOF>"
                    } else {
                        i = "<missing " + e.vocabulary.getDisplayName(n) + ">"
                    }
                    let o = t;
                    let s = e.inputStream.tryLT(-1);
                    if (o.type === d.Token.EOF && s != null) {
                        o = s
                    }
                    return this.constructToken(e.inputStream.tokenSource, n, i, o)
                }
                constructToken(e, t, r, n) {
                    let i = e.tokenFactory;
                    let o = n.tokenSource;
                    let s = o ? o.inputStream : undefined;
                    return i.create({
                        source: e,
                        stream: s
                    }, t, r, d.Token.DEFAULT_CHANNEL, -1, -1, n.line, n.charPositionInLine)
                }
                getExpectedTokens(e) {
                    return e.getExpectedTokens()
                }
                getTokenErrorDisplay(e) {
                    if (!e) {
                        return "<no token>"
                    }
                    let t = this.getSymbolText(e);
                    if (!t) {
                        if (this.getSymbolType(e) === d.Token.EOF) {
                            t = "<EOF>"
                        } else {
                            t = `<${this.getSymbolType(e)}>`
                        }
                    }
                    return this.escapeWSAndQuote(t)
                }
                getSymbolText(e) {
                    return e.text
                }
                getSymbolType(e) {
                    return e.type
                }
                escapeWSAndQuote(e) {
                    e = e.replace("\n", "\\n");
                    e = e.replace("\r", "\\r");
                    e = e.replace("\t", "\\t");
                    return "'" + e + "'"
                }
                getErrorRecoverySet(e) {
                    let t = e.interpreter.atn;
                    let r = e.context;
                    let n = new _.IntervalSet;
                    while (r && r.invokingState >= 0) {
                        let e = t.states[r.invokingState];
                        let i = e.transition(0);
                        let o = t.nextTokens(i.followState);
                        n.addAll(o);
                        r = r._parent
                    }
                    n.remove(d.Token.EPSILON);
                    return n
                }
                consumeUntil(e, t) {
                    let r = e.inputStream.LA(1);
                    while (r !== d.Token.EOF && !t.contains(r)) {
                        e.consume();
                        r = e.inputStream.LA(1)
                    }
                }
            }
            n([p.Override], DefaultErrorStrategy.prototype, "reset", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "beginErrorCondition", null);
            n([p.Override], DefaultErrorStrategy.prototype, "inErrorRecoveryMode", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "endErrorCondition", null);
            n([p.Override], DefaultErrorStrategy.prototype, "reportMatch", null);
            n([p.Override], DefaultErrorStrategy.prototype, "reportError", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "notifyErrorListeners", null);
            n([p.Override], DefaultErrorStrategy.prototype, "recover", null);
            n([p.Override], DefaultErrorStrategy.prototype, "sync", null);
            n([i(0, p.NotNull), i(1, p.NotNull)], DefaultErrorStrategy.prototype, "reportNoViableAlternative", null);
            n([i(0, p.NotNull), i(1, p.NotNull)], DefaultErrorStrategy.prototype, "reportInputMismatch", null);
            n([i(0, p.NotNull), i(1, p.NotNull)], DefaultErrorStrategy.prototype, "reportFailedPredicate", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "reportUnwantedToken", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "reportMissingToken", null);
            n([p.Override], DefaultErrorStrategy.prototype, "recoverInline", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "singleTokenInsertion", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "singleTokenDeletion", null);
            n([p.NotNull, i(0, p.NotNull)], DefaultErrorStrategy.prototype, "getMissingSymbol", null);
            n([p.NotNull, i(0, p.NotNull)], DefaultErrorStrategy.prototype, "getExpectedTokens", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "getSymbolText", null);
            n([i(0, p.NotNull)], DefaultErrorStrategy.prototype, "getSymbolType", null);
            n([p.NotNull, i(0, p.NotNull)], DefaultErrorStrategy.prototype, "escapeWSAndQuote", null);
            n([p.NotNull, i(0, p.NotNull)], DefaultErrorStrategy.prototype, "getErrorRecoverySet", null);
            n([i(0, p.NotNull), i(1, p.NotNull)], DefaultErrorStrategy.prototype, "consumeUntil", null);
            t.DefaultErrorStrategy = DefaultErrorStrategy
        },
        3690: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Dependents = void 0;
            var r;
            (function(e) {
                e[e["SELF"] = 0] = "SELF";
                e[e["PARENTS"] = 1] = "PARENTS";
                e[e["CHILDREN"] = 2] = "CHILDREN";
                e[e["ANCESTORS"] = 3] = "ANCESTORS";
                e[e["DESCENDANTS"] = 4] = "DESCENDANTS";
                e[e["SIBLINGS"] = 5] = "SIBLINGS";
                e[e["PRECEEDING_SIBLINGS"] = 6] = "PRECEEDING_SIBLINGS";
                e[e["FOLLOWING_SIBLINGS"] = 7] = "FOLLOWING_SIBLINGS";
                e[e["PRECEEDING"] = 8] = "PRECEEDING";
                e[e["FOLLOWING"] = 9] = "FOLLOWING"
            })(r = t.Dependents || (t.Dependents = {}))
        },
        1666: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DiagnosticErrorListener = void 0;
            const o = r(4980);
            const s = r(6966);
            const a = r(6330);
            class DiagnosticErrorListener {
                constructor(e = true) {
                    this.exactOnly = e;
                    this.exactOnly = e
                }
                syntaxError(e, t, r, n, i, o) {}
                reportAmbiguity(e, t, r, n, i, o, s) {
                    if (this.exactOnly && !i) {
                        return
                    }
                    let l = this.getDecisionDescription(e, t);
                    let _ = this.getConflictingAlts(o, s);
                    let u = e.inputStream.getText(a.Interval.of(r, n));
                    let c = `reportAmbiguity d=${l}: ambigAlts=${_}, input='${u}'`;
                    e.notifyErrorListeners(c)
                }
                reportAttemptingFullContext(e, t, r, n, i, o) {
                    let s = "reportAttemptingFullContext d=%s, input='%s'";
                    let l = this.getDecisionDescription(e, t);
                    let _ = e.inputStream.getText(a.Interval.of(r, n));
                    let u = `reportAttemptingFullContext d=${l}, input='${_}'`;
                    e.notifyErrorListeners(u)
                }
                reportContextSensitivity(e, t, r, n, i, o) {
                    let s = "reportContextSensitivity d=%s, input='%s'";
                    let l = this.getDecisionDescription(e, t);
                    let _ = e.inputStream.getText(a.Interval.of(r, n));
                    let u = `reportContextSensitivity d=${l}, input='${_}'`;
                    e.notifyErrorListeners(u)
                }
                getDecisionDescription(e, t) {
                    let r = t.decision;
                    let n = t.atnStartState.ruleIndex;
                    let i = e.ruleNames;
                    if (n < 0 || n >= i.length) {
                        return r.toString()
                    }
                    let o = i[n];
                    if (!o) {
                        return r.toString()
                    }
                    return `${r} (${o})`
                }
                getConflictingAlts(e, t) {
                    if (e != null) {
                        return e
                    }
                    let r = new o.BitSet;
                    for (let e of t) {
                        r.set(e.alt)
                    }
                    return r
                }
            }
            n([s.Override], DiagnosticErrorListener.prototype, "syntaxError", null);
            n([s.Override, i(0, s.NotNull), i(1, s.NotNull), i(6, s.NotNull)], DiagnosticErrorListener.prototype, "reportAmbiguity", null);
            n([s.Override, i(0, s.NotNull), i(1, s.NotNull), i(5, s.NotNull)], DiagnosticErrorListener.prototype, "reportAttemptingFullContext", null);
            n([s.Override, i(0, s.NotNull), i(1, s.NotNull), i(5, s.NotNull)], DiagnosticErrorListener.prototype, "reportContextSensitivity", null);
            n([i(0, s.NotNull), i(1, s.NotNull)], DiagnosticErrorListener.prototype, "getDecisionDescription", null);
            n([s.NotNull, i(1, s.NotNull)], DiagnosticErrorListener.prototype, "getConflictingAlts", null);
            t.DiagnosticErrorListener = DiagnosticErrorListener
        },
        5575: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.FailedPredicateException = void 0;
            const o = r(8145);
            const s = r(6966);
            const a = r(1652);
            let l = class FailedPredicateException extends o.RecognitionException {
                constructor(e, t, r) {
                    super(e, e.inputStream, e.context, FailedPredicateException.formatMessage(t, r));
                    let n = e.interpreter.atn.states[e.state];
                    let i = n.transition(0);
                    if (i instanceof a.PredicateTransition) {
                        this._ruleIndex = i.ruleIndex;
                        this._predicateIndex = i.predIndex
                    } else {
                        this._ruleIndex = 0;
                        this._predicateIndex = 0
                    }
                    this._predicate = t;
                    super.setOffendingToken(e, e.currentToken)
                }
                get ruleIndex() {
                    return this._ruleIndex
                }
                get predicateIndex() {
                    return this._predicateIndex
                }
                get predicate() {
                    return this._predicate
                }
                static formatMessage(e, t) {
                    if (t) {
                        return t
                    }
                    return `failed predicate: {${e}}?`
                }
            };
            n([s.NotNull], l, "formatMessage", null);
            l = n([i(0, s.NotNull)], l);
            t.FailedPredicateException = l
        },
        368: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.InputMismatchException = void 0;
            const o = r(8145);
            const s = r(6966);
            let a = class InputMismatchException extends o.RecognitionException {
                constructor(e, t, r) {
                    if (r === undefined) {
                        r = e.context
                    }
                    super(e, e.inputStream, r);
                    if (t !== undefined) {
                        this.setOffendingState(t)
                    }
                    this.setOffendingToken(e, e.currentToken)
                }
            };
            a = n([i(0, s.NotNull)], a);
            t.InputMismatchException = a
        },
        3828: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.IntStream = void 0;
            var r;
            (function(e) {
                e.EOF = -1;
                e.UNKNOWN_SOURCE_NAME = "<unknown>"
            })(r = t.IntStream || (t.IntStream = {}))
        },
        790: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.InterpreterRuleContext = void 0;
            const i = r(6966);
            const o = r(9562);
            class InterpreterRuleContext extends o.ParserRuleContext {
                constructor(e, t, r) {
                    if (r !== undefined) {
                        super(t, r)
                    } else {
                        super()
                    }
                    this._ruleIndex = e
                }
                get ruleIndex() {
                    return this._ruleIndex
                }
            }
            n([i.Override], InterpreterRuleContext.prototype, "ruleIndex", null);
            t.InterpreterRuleContext = InterpreterRuleContext
        },
        1740: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Lexer = void 0;
            const i = r(8001);
            const o = r(7356);
            const s = r(6330);
            const a = r(3828);
            const l = r(3262);
            const _ = r(3638);
            const u = r(6966);
            const c = r(3602);
            const d = r(7528);
            class Lexer extends c.Recognizer {
                constructor(e) {
                    super();
                    this._factory = i.CommonTokenFactory.DEFAULT;
                    this._tokenStartCharIndex = -1;
                    this._tokenStartLine = 0;
                    this._tokenStartCharPositionInLine = 0;
                    this._hitEOF = false;
                    this._channel = 0;
                    this._type = 0;
                    this._modeStack = new o.IntegerStack;
                    this._mode = Lexer.DEFAULT_MODE;
                    this._input = e;
                    this._tokenFactorySourcePair = {
                        source: this,
                        stream: e
                    }
                }
                static get DEFAULT_TOKEN_CHANNEL() {
                    return d.Token.DEFAULT_CHANNEL
                }
                static get HIDDEN() {
                    return d.Token.HIDDEN_CHANNEL
                }
                reset(e) {
                    if (e === undefined || e) {
                        this._input.seek(0)
                    }
                    this._token = undefined;
                    this._type = d.Token.INVALID_TYPE;
                    this._channel = d.Token.DEFAULT_CHANNEL;
                    this._tokenStartCharIndex = -1;
                    this._tokenStartCharPositionInLine = -1;
                    this._tokenStartLine = -1;
                    this._text = undefined;
                    this._hitEOF = false;
                    this._mode = Lexer.DEFAULT_MODE;
                    this._modeStack.clear();
                    this.interpreter.reset()
                }
                nextToken() {
                    if (this._input == null) {
                        throw new Error("nextToken requires a non-null input stream.")
                    }
                    let e = this._input.mark();
                    try {
                        e: while (true) {
                            if (this._hitEOF) {
                                return this.emitEOF()
                            }
                            this._token = undefined;
                            this._channel = d.Token.DEFAULT_CHANNEL;
                            this._tokenStartCharIndex = this._input.index;
                            this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;
                            this._tokenStartLine = this.interpreter.line;
                            this._text = undefined;
                            do {
                                this._type = d.Token.INVALID_TYPE;
                                let e;
                                try {
                                    e = this.interpreter.match(this._input, this._mode)
                                } catch (t) {
                                    if (t instanceof _.LexerNoViableAltException) {
                                        this.notifyListeners(t);
                                        this.recover(t);
                                        e = Lexer.SKIP
                                    } else {
                                        throw t
                                    }
                                }
                                if (this._input.LA(1) === a.IntStream.EOF) {
                                    this._hitEOF = true
                                }
                                if (this._type === d.Token.INVALID_TYPE) {
                                    this._type = e
                                }
                                if (this._type === Lexer.SKIP) {
                                    continue e
                                }
                            } while (this._type === Lexer.MORE);
                            if (this._token == null) {
                                return this.emit()
                            }
                            return this._token
                        }
                    }
                    finally {
                        this._input.release(e)
                    }
                }
                skip() {
                    this._type = Lexer.SKIP
                }
                more() {
                    this._type = Lexer.MORE
                }
                mode(e) {
                    this._mode = e
                }
                pushMode(e) {
                    if (l.LexerATNSimulator.debug) {
                        console.log("pushMode " + e)
                    }
                    this._modeStack.push(this._mode);
                    this.mode(e)
                }
                popMode() {
                    if (this._modeStack.isEmpty) {
                        throw new Error("EmptyStackException")
                    }
                    if (l.LexerATNSimulator.debug) {
                        console.log("popMode back to " + this._modeStack.peek())
                    }
                    this.mode(this._modeStack.pop());
                    return this._mode
                }
                get tokenFactory() {
                    return this._factory
                }
                set tokenFactory(e) {
                    this._factory = e
                }
                get inputStream() {
                    return this._input
                }
                set inputStream(e) {
                    this.reset(false);
                    this._input = e;
                    this._tokenFactorySourcePair = {
                        source: this,
                        stream: this._input
                    }
                }
                get sourceName() {
                    return this._input.sourceName
                }
                emit(e) {
                    if (!e) {
                        e = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine)
                    }
                    this._token = e;
                    return e
                }
                emitEOF() {
                    let e = this.charPositionInLine;
                    let t = this.line;
                    let r = this._factory.create(this._tokenFactorySourcePair, d.Token.EOF, undefined, d.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, t, e);
                    this.emit(r);
                    return r
                }
                get line() {
                    return this.interpreter.line
                }
                set line(e) {
                    this.interpreter.line = e
                }
                get charPositionInLine() {
                    return this.interpreter.charPositionInLine
                }
                set charPositionInLine(e) {
                    this.interpreter.charPositionInLine = e
                }
                get charIndex() {
                    return this._input.index
                }
                get text() {
                    if (this._text != null) {
                        return this._text
                    }
                    return this.interpreter.getText(this._input)
                }
                set text(e) {
                    this._text = e
                }
                get token() {
                    return this._token
                }
                set token(e) {
                    this._token = e
                }
                set type(e) {
                    this._type = e
                }
                get type() {
                    return this._type
                }
                set channel(e) {
                    this._channel = e
                }
                get channel() {
                    return this._channel
                }
                getAllTokens() {
                    let e = [];
                    let t = this.nextToken();
                    while (t.type !== d.Token.EOF) {
                        e.push(t);
                        t = this.nextToken()
                    }
                    return e
                }
                notifyListeners(e) {
                    let t = this._input.getText(s.Interval.of(this._tokenStartCharIndex, this._input.index));
                    let r = "token recognition error at: '" + this.getErrorDisplay(t) + "'";
                    let n = this.getErrorListenerDispatch();
                    if (n.syntaxError) {
                        n.syntaxError(this, undefined, this._tokenStartLine, this._tokenStartCharPositionInLine, r, e)
                    }
                }
                getErrorDisplay(e) {
                    if (typeof e === "number") {
                        switch (e) {
                            case d.Token.EOF:
                                return "<EOF>";
                            case 10:
                                return "\\n";
                            case 9:
                                return "\\t";
                            case 13:
                                return "\\r"
                        }
                        return String.fromCharCode(e)
                    }
                    return e.replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r")
                }
                getCharErrorDisplay(e) {
                    let t = this.getErrorDisplay(e);
                    return "'" + t + "'"
                }
                recover(e) {
                    if (e instanceof _.LexerNoViableAltException) {
                        if (this._input.LA(1) !== a.IntStream.EOF) {
                            this.interpreter.consume(this._input)
                        }
                    } else {
                        this._input.consume()
                    }
                }
            }
            Lexer.DEFAULT_MODE = 0;
            Lexer.MORE = -2;
            Lexer.SKIP = -3;
            Lexer.MIN_CHAR_VALUE = 0;
            Lexer.MAX_CHAR_VALUE = 1114111;
            n([u.Override], Lexer.prototype, "nextToken", null);
            n([u.Override], Lexer.prototype, "tokenFactory", null);
            n([u.Override], Lexer.prototype, "inputStream", null);
            n([u.Override], Lexer.prototype, "sourceName", null);
            n([u.Override], Lexer.prototype, "line", null);
            n([u.Override], Lexer.prototype, "charPositionInLine", null);
            t.Lexer = Lexer
        },
        5828: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerInterpreter = void 0;
            const o = r(1740);
            const s = r(3262);
            const a = r(6966);
            const l = r(6966);
            let _ = class LexerInterpreter extends o.Lexer {
                constructor(e, t, r, n, i, o, a) {
                    super(a);
                    if (o.grammarType !== 0) {
                        throw new Error("IllegalArgumentException: The ATN must be a lexer ATN.")
                    }
                    this._grammarFileName = e;
                    this._atn = o;
                    this._ruleNames = r.slice(0);
                    this._channelNames = n.slice(0);
                    this._modeNames = i.slice(0);
                    this._vocabulary = t;
                    this._interp = new s.LexerATNSimulator(o, this)
                }
                get atn() {
                    return this._atn
                }
                get grammarFileName() {
                    return this._grammarFileName
                }
                get ruleNames() {
                    return this._ruleNames
                }
                get channelNames() {
                    return this._channelNames
                }
                get modeNames() {
                    return this._modeNames
                }
                get vocabulary() {
                    return this._vocabulary
                }
            };
            n([a.NotNull], _.prototype, "_vocabulary", void 0);
            n([l.Override], _.prototype, "atn", null);
            n([l.Override], _.prototype, "grammarFileName", null);
            n([l.Override], _.prototype, "ruleNames", null);
            n([l.Override], _.prototype, "channelNames", null);
            n([l.Override], _.prototype, "modeNames", null);
            n([l.Override], _.prototype, "vocabulary", null);
            _ = n([i(1, a.NotNull)], _);
            t.LexerInterpreter = _
        },
        3638: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerNoViableAltException = void 0;
            const o = r(8145);
            const s = r(6966);
            const a = r(6330);
            const l = r(2925);
            let _ = class LexerNoViableAltException extends o.RecognitionException {
                constructor(e, t, r, n) {
                    super(e, t);
                    this._startIndex = r;
                    this._deadEndConfigs = n
                }
                get startIndex() {
                    return this._startIndex
                }
                get deadEndConfigs() {
                    return this._deadEndConfigs
                }
                get inputStream() {
                    return super.inputStream
                }
                toString() {
                    let e = "";
                    if (this._startIndex >= 0 && this._startIndex < this.inputStream.size) {
                        e = this.inputStream.getText(a.Interval.of(this._startIndex, this._startIndex));
                        e = l.escapeWhitespace(e, false)
                    }
                    return `LexerNoViableAltException('${e}')`
                }
            };
            n([s.Override], _.prototype, "inputStream", null);
            n([s.Override], _.prototype, "toString", null);
            _ = n([i(1, s.NotNull)], _);
            t.LexerNoViableAltException = _
        },
        7715: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ListTokenSource = void 0;
            const o = r(8001);
            const s = r(6966);
            const a = r(7528);
            let l = class ListTokenSource {
                constructor(e, t) {
                    this.i = 0;
                    this._factory = o.CommonTokenFactory.DEFAULT;
                    if (e == null) {
                        throw new Error("tokens cannot be null")
                    }
                    this.tokens = e;
                    this._sourceName = t
                }
                get charPositionInLine() {
                    if (this.i < this.tokens.length) {
                        return this.tokens[this.i].charPositionInLine
                    } else if (this.eofToken != null) {
                        return this.eofToken.charPositionInLine
                    } else if (this.tokens.length > 0) {
                        let e = this.tokens[this.tokens.length - 1];
                        let t = e.text;
                        if (t != null) {
                            let e = t.lastIndexOf("\n");
                            if (e >= 0) {
                                return t.length - e - 1
                            }
                        }
                        return e.charPositionInLine + e.stopIndex - e.startIndex + 1
                    }
                    return 0
                }
                nextToken() {
                    if (this.i >= this.tokens.length) {
                        if (this.eofToken == null) {
                            let e = -1;
                            if (this.tokens.length > 0) {
                                let t = this.tokens[this.tokens.length - 1].stopIndex;
                                if (t !== -1) {
                                    e = t + 1
                                }
                            }
                            let t = Math.max(-1, e - 1);
                            this.eofToken = this._factory.create({
                                source: this,
                                stream: this.inputStream
                            }, a.Token.EOF, "EOF", a.Token.DEFAULT_CHANNEL, e, t, this.line, this.charPositionInLine)
                        }
                        return this.eofToken
                    }
                    let e = this.tokens[this.i];
                    if (this.i === this.tokens.length - 1 && e.type === a.Token.EOF) {
                        this.eofToken = e
                    }
                    this.i++;
                    return e
                }
                get line() {
                    if (this.i < this.tokens.length) {
                        return this.tokens[this.i].line
                    } else if (this.eofToken != null) {
                        return this.eofToken.line
                    } else if (this.tokens.length > 0) {
                        let e = this.tokens[this.tokens.length - 1];
                        let t = e.line;
                        let r = e.text;
                        if (r != null) {
                            for (let e = 0; e < r.length; e++) {
                                if (r.charAt(e) === "\n") {
                                    t++
                                }
                            }
                        }
                        return t
                    }
                    return 1
                }
                get inputStream() {
                    if (this.i < this.tokens.length) {
                        return this.tokens[this.i].inputStream
                    } else if (this.eofToken != null) {
                        return this.eofToken.inputStream
                    } else if (this.tokens.length > 0) {
                        return this.tokens[this.tokens.length - 1].inputStream
                    }
                    return undefined
                }
                get sourceName() {
                    if (this._sourceName) {
                        return this._sourceName
                    }
                    let e = this.inputStream;
                    if (e != null) {
                        return e.sourceName
                    }
                    return "List"
                }
                set tokenFactory(e) {
                    this._factory = e
                }
                get tokenFactory() {
                    return this._factory
                }
            };
            n([s.Override], l.prototype, "charPositionInLine", null);
            n([s.Override], l.prototype, "nextToken", null);
            n([s.Override], l.prototype, "line", null);
            n([s.Override], l.prototype, "inputStream", null);
            n([s.Override], l.prototype, "sourceName", null);
            n([s.Override, s.NotNull, i(0, s.NotNull)], l.prototype, "tokenFactory", null);
            l = n([i(0, s.NotNull)], l);
            t.ListTokenSource = l
        },
        1914: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NoViableAltException = void 0;
            const i = r(8871);
            const o = r(8145);
            const s = r(6966);
            class NoViableAltException extends o.RecognitionException {
                constructor(e, t, r, n, o, s) {
                    if (e instanceof i.Parser) {
                        if (t === undefined) {
                            t = e.inputStream
                        }
                        if (r === undefined) {
                            r = e.currentToken
                        }
                        if (n === undefined) {
                            n = e.currentToken
                        }
                        if (s === undefined) {
                            s = e.context
                        }
                    }
                    super(e, t, s);
                    this._deadEndConfigs = o;
                    this._startToken = r;
                    this.setOffendingToken(e, n)
                }
                get startToken() {
                    return this._startToken
                }
                get deadEndConfigs() {
                    return this._deadEndConfigs
                }
            }
            n([s.NotNull], NoViableAltException.prototype, "_startToken", void 0);
            t.NoViableAltException = NoViableAltException
        },
        8871: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            var o = this && this.__awaiter || function(e, t, r, n) {
                function adopt(e) {
                    return e instanceof r ? e : new r((function(t) {
                        t(e)
                    }))
                }
                return new(r || (r = Promise))((function(r, i) {
                    function fulfilled(e) {
                        try {
                            step(n.next(e))
                        } catch (e) {
                            i(e)
                        }
                    }

                    function rejected(e) {
                        try {
                            step(n["throw"](e))
                        } catch (e) {
                            i(e)
                        }
                    }

                    function step(e) {
                        e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected)
                    }
                    step((n = n.apply(e, t || [])).next())
                }))
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Parser = void 0;
            const s = r(2925);
            const a = r(2832);
            const l = r(6027);
            const _ = r(488);
            const u = r(8817);
            const c = r(7356);
            const d = r(1740);
            const p = r(6966);
            const f = r(5765);
            const h = r(9851);
            const g = r(5932);
            const m = r(3602);
            const y = r(4292);
            const S = r(7528);
            class TraceListener {
                constructor(e, t) {
                    this.ruleNames = e;
                    this.tokenStream = t
                }
                enterEveryRule(e) {
                    console.log("enter   " + this.ruleNames[e.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text)
                }
                exitEveryRule(e) {
                    console.log("exit    " + this.ruleNames[e.ruleIndex] + ", LT(1)=" + this.tokenStream.LT(1).text)
                }
                visitErrorNode(e) {}
                visitTerminal(e) {
                    let t = e.parent.ruleContext;
                    let r = e.symbol;
                    console.log("consume " + r + " rule " + this.ruleNames[t.ruleIndex])
                }
            }
            n([p.Override], TraceListener.prototype, "enterEveryRule", null);
            n([p.Override], TraceListener.prototype, "exitEveryRule", null);
            n([p.Override], TraceListener.prototype, "visitErrorNode", null);
            n([p.Override], TraceListener.prototype, "visitTerminal", null);
            class Parser extends m.Recognizer {
                constructor(e) {
                    super();
                    this._errHandler = new _.DefaultErrorStrategy;
                    this._precedenceStack = new c.IntegerStack;
                    this._buildParseTrees = true;
                    this._parseListeners = [];
                    this._syntaxErrors = 0;
                    this.matchedEOF = false;
                    this._precedenceStack.push(0);
                    this.inputStream = e
                }
                reset(e) {
                    if (e === undefined || e) {
                        this.inputStream.seek(0)
                    }
                    this._errHandler.reset(this);
                    this._ctx = undefined;
                    this._syntaxErrors = 0;
                    this.matchedEOF = false;
                    this.isTrace = false;
                    this._precedenceStack.clear();
                    this._precedenceStack.push(0);
                    let t = this.interpreter;
                    if (t != null) {
                        t.reset()
                    }
                }
                match(e) {
                    let t = this.currentToken;
                    if (t.type === e) {
                        if (e === S.Token.EOF) {
                            this.matchedEOF = true
                        }
                        this._errHandler.reportMatch(this);
                        this.consume()
                    } else {
                        t = this._errHandler.recoverInline(this);
                        if (this._buildParseTrees && t.tokenIndex === -1) {
                            this._ctx.addErrorNode(this.createErrorNode(this._ctx, t))
                        }
                    }
                    return t
                }
                matchWildcard() {
                    let e = this.currentToken;
                    if (e.type > 0) {
                        this._errHandler.reportMatch(this);
                        this.consume()
                    } else {
                        e = this._errHandler.recoverInline(this);
                        if (this._buildParseTrees && e.tokenIndex === -1) {
                            this._ctx.addErrorNode(this.createErrorNode(this._ctx, e))
                        }
                    }
                    return e
                }
                set buildParseTree(e) {
                    this._buildParseTrees = e
                }
                get buildParseTree() {
                    return this._buildParseTrees
                }
                getParseListeners() {
                    return this._parseListeners
                }
                addParseListener(e) {
                    if (e == null) {
                        throw new TypeError("listener cannot be null")
                    }
                    this._parseListeners.push(e)
                }
                removeParseListener(e) {
                    let t = this._parseListeners.findIndex((t => t === e));
                    if (t !== -1) {
                        this._parseListeners.splice(t, 1)
                    }
                }
                removeParseListeners() {
                    this._parseListeners.length = 0
                }
                triggerEnterRuleEvent() {
                    for (let e of this._parseListeners) {
                        if (e.enterEveryRule) {
                            e.enterEveryRule(this._ctx)
                        }
                        this._ctx.enterRule(e)
                    }
                }
                triggerExitRuleEvent() {
                    for (let e = this._parseListeners.length - 1; e >= 0; e--) {
                        let t = this._parseListeners[e];
                        this._ctx.exitRule(t);
                        if (t.exitEveryRule) {
                            t.exitEveryRule(this._ctx)
                        }
                    }
                }
                get numberOfSyntaxErrors() {
                    return this._syntaxErrors
                }
                get tokenFactory() {
                    return this._input.tokenSource.tokenFactory
                }
                getATNWithBypassAlts() {
                    let e = this.serializedATN;
                    if (e == null) {
                        throw new Error("The current parser does not support an ATN with bypass alternatives.")
                    }
                    let t = Parser.bypassAltsAtnCache.get(e);
                    if (t == null) {
                        let r = new a.ATNDeserializationOptions;
                        r.isGenerateRuleBypassTransitions = true;
                        t = new l.ATNDeserializer(r).deserialize(s.toCharArray(e));
                        Parser.bypassAltsAtnCache.set(e, t)
                    }
                    return t
                }
                compileParseTreePattern(e, t, n) {
                    return o(this, void 0, void 0, (function*() {
                        if (!n) {
                            if (this.inputStream) {
                                let e = this.inputStream.tokenSource;
                                if (e instanceof d.Lexer) {
                                    n = e
                                }
                            }
                            if (!n) {
                                throw new Error("Parser can't discover a lexer to use")
                            }
                        }
                        let i = n;
                        let o = yield Promise.resolve().then((() => r(5497)));
                        let s = new o.ParseTreePatternMatcher(i, this);
                        return s.compile(e, t)
                    }))
                }
                get errorHandler() {
                    return this._errHandler
                }
                set errorHandler(e) {
                    this._errHandler = e
                }
                get inputStream() {
                    return this._input
                }
                set inputStream(e) {
                    this.reset(false);
                    this._input = e
                }
                get currentToken() {
                    return this._input.LT(1)
                }
                notifyErrorListeners(e, t, r) {
                    if (t === undefined) {
                        t = this.currentToken
                    } else if (t === null) {
                        t = undefined
                    }
                    this._syntaxErrors++;
                    let n = -1;
                    let i = -1;
                    if (t != null) {
                        n = t.line;
                        i = t.charPositionInLine
                    }
                    let o = this.getErrorListenerDispatch();
                    if (o.syntaxError) {
                        o.syntaxError(this, t, n, i, e, r)
                    }
                }
                consume() {
                    let e = this.currentToken;
                    if (e.type !== Parser.EOF) {
                        this.inputStream.consume()
                    }
                    let t = this._parseListeners.length !== 0;
                    if (this._buildParseTrees || t) {
                        if (this._errHandler.inErrorRecoveryMode(this)) {
                            let r = this._ctx.addErrorNode(this.createErrorNode(this._ctx, e));
                            if (t) {
                                for (let e of this._parseListeners) {
                                    if (e.visitErrorNode) {
                                        e.visitErrorNode(r)
                                    }
                                }
                            }
                        } else {
                            let r = this.createTerminalNode(this._ctx, e);
                            this._ctx.addChild(r);
                            if (t) {
                                for (let e of this._parseListeners) {
                                    if (e.visitTerminal) {
                                        e.visitTerminal(r)
                                    }
                                }
                            }
                        }
                    }
                    return e
                }
                createTerminalNode(e, t) {
                    return new y.TerminalNode(t)
                }
                createErrorNode(e, t) {
                    return new u.ErrorNode(t)
                }
                addContextToParseTree() {
                    let e = this._ctx._parent;
                    if (e != null) {
                        e.addChild(this._ctx)
                    }
                }
                enterRule(e, t, r) {
                    this.state = t;
                    this._ctx = e;
                    this._ctx._start = this._input.LT(1);
                    if (this._buildParseTrees) {
                        this.addContextToParseTree()
                    }
                    this.triggerEnterRuleEvent()
                }
                enterLeftFactoredRule(e, t, r) {
                    this.state = t;
                    if (this._buildParseTrees) {
                        let t = this._ctx.getChild(this._ctx.childCount - 1);
                        this._ctx.removeLastChild();
                        t._parent = e;
                        e.addChild(t)
                    }
                    this._ctx = e;
                    this._ctx._start = this._input.LT(1);
                    if (this._buildParseTrees) {
                        this.addContextToParseTree()
                    }
                    this.triggerEnterRuleEvent()
                }
                exitRule() {
                    if (this.matchedEOF) {
                        this._ctx._stop = this._input.LT(1)
                    } else {
                        this._ctx._stop = this._input.tryLT(-1)
                    }
                    this.triggerExitRuleEvent();
                    this.state = this._ctx.invokingState;
                    this._ctx = this._ctx._parent
                }
                enterOuterAlt(e, t) {
                    e.altNumber = t;
                    if (this._buildParseTrees && this._ctx !== e) {
                        let t = this._ctx._parent;
                        if (t != null) {
                            t.removeLastChild();
                            t.addChild(e)
                        }
                    }
                    this._ctx = e
                }
                get precedence() {
                    if (this._precedenceStack.isEmpty) {
                        return -1
                    }
                    return this._precedenceStack.peek()
                }
                enterRecursionRule(e, t, r, n) {
                    this.state = t;
                    this._precedenceStack.push(n);
                    this._ctx = e;
                    this._ctx._start = this._input.LT(1);
                    this.triggerEnterRuleEvent()
                }
                pushNewRecursionContext(e, t, r) {
                    let n = this._ctx;
                    n._parent = e;
                    n.invokingState = t;
                    n._stop = this._input.tryLT(-1);
                    this._ctx = e;
                    this._ctx._start = n._start;
                    if (this._buildParseTrees) {
                        this._ctx.addChild(n)
                    }
                    this.triggerEnterRuleEvent()
                }
                unrollRecursionContexts(e) {
                    this._precedenceStack.pop();
                    this._ctx._stop = this._input.tryLT(-1);
                    let t = this._ctx;
                    if (this._parseListeners.length > 0) {
                        while (this._ctx !== e) {
                            this.triggerExitRuleEvent();
                            this._ctx = this._ctx._parent
                        }
                    } else {
                        this._ctx = e
                    }
                    t._parent = e;
                    if (this._buildParseTrees && e != null) {
                        e.addChild(t)
                    }
                }
                getInvokingContext(e) {
                    let t = this._ctx;
                    while (t && t.ruleIndex !== e) {
                        t = t._parent
                    }
                    return t
                }
                get context() {
                    return this._ctx
                }
                set context(e) {
                    this._ctx = e
                }
                precpred(e, t) {
                    return t >= this._precedenceStack.peek()
                }
                getErrorListenerDispatch() {
                    return new g.ProxyParserErrorListener(this.getErrorListeners())
                }
                inContext(e) {
                    return false
                }
                isExpectedToken(e) {
                    let t = this.interpreter.atn;
                    let r = this._ctx;
                    let n = t.states[this.state];
                    let i = t.nextTokens(n);
                    if (i.contains(e)) {
                        return true
                    }
                    if (!i.contains(S.Token.EPSILON)) {
                        return false
                    }
                    while (r != null && r.invokingState >= 0 && i.contains(S.Token.EPSILON)) {
                        let n = t.states[r.invokingState];
                        let o = n.transition(0);
                        i = t.nextTokens(o.followState);
                        if (i.contains(e)) {
                            return true
                        }
                        r = r._parent
                    }
                    if (i.contains(S.Token.EPSILON) && e === S.Token.EOF) {
                        return true
                    }
                    return false
                }
                get isMatchedEOF() {
                    return this.matchedEOF
                }
                getExpectedTokens() {
                    return this.atn.getExpectedTokens(this.state, this.context)
                }
                getExpectedTokensWithinCurrentRule() {
                    let e = this.interpreter.atn;
                    let t = e.states[this.state];
                    return e.nextTokens(t)
                }
                getRuleIndex(e) {
                    let t = this.getRuleIndexMap().get(e);
                    if (t != null) {
                        return t
                    }
                    return -1
                }
                get ruleContext() {
                    return this._ctx
                }
                getRuleInvocationStack(e = this._ctx) {
                    let t = e;
                    let r = this.ruleNames;
                    let n = [];
                    while (t != null) {
                        let e = t.ruleIndex;
                        if (e < 0) {
                            n.push("n/a")
                        } else {
                            n.push(r[e])
                        }
                        t = t._parent
                    }
                    return n
                }
                getDFAStrings() {
                    let e = [];
                    for (let t of this._interp.atn.decisionToDFA) {
                        e.push(t.toString(this.vocabulary, this.ruleNames))
                    }
                    return e
                }
                dumpDFA() {
                    let e = false;
                    for (let t of this._interp.atn.decisionToDFA) {
                        if (!t.isEmpty) {
                            if (e) {
                                console.log()
                            }
                            console.log("Decision " + t.decision + ":");
                            process.stdout.write(t.toString(this.vocabulary, this.ruleNames));
                            e = true
                        }
                    }
                }
                get sourceName() {
                    return this._input.sourceName
                }
                get parseInfo() {
                    return Promise.resolve().then((() => r(6517))).then((e => {
                        let t = this.interpreter;
                        if (t instanceof e.ProfilingATNSimulator) {
                            return new f.ParseInfo(t)
                        }
                        return undefined
                    }))
                }
                setProfile(e) {
                    return o(this, void 0, void 0, (function*() {
                        let t = yield Promise.resolve().then((() => r(6517)));
                        let n = this.interpreter;
                        if (e) {
                            if (!(n instanceof t.ProfilingATNSimulator)) {
                                this.interpreter = new t.ProfilingATNSimulator(this)
                            }
                        } else if (n instanceof t.ProfilingATNSimulator) {
                            this.interpreter = new h.ParserATNSimulator(this.atn, this)
                        }
                        this.interpreter.setPredictionMode(n.getPredictionMode())
                    }))
                }
                set isTrace(e) {
                    if (!e) {
                        if (this._tracer) {
                            this.removeParseListener(this._tracer);
                            this._tracer = undefined
                        }
                    } else {
                        if (this._tracer) {
                            this.removeParseListener(this._tracer)
                        } else {
                            this._tracer = new TraceListener(this.ruleNames, this._input)
                        }
                        this.addParseListener(this._tracer)
                    }
                }
                get isTrace() {
                    return this._tracer != null
                }
            }
            Parser.bypassAltsAtnCache = new Map;
            n([p.NotNull], Parser.prototype, "_errHandler", void 0);
            n([p.NotNull], Parser.prototype, "match", null);
            n([p.NotNull], Parser.prototype, "matchWildcard", null);
            n([p.NotNull], Parser.prototype, "getParseListeners", null);
            n([i(0, p.NotNull)], Parser.prototype, "addParseListener", null);
            n([p.NotNull], Parser.prototype, "getATNWithBypassAlts", null);
            n([p.NotNull, i(0, p.NotNull)], Parser.prototype, "errorHandler", null);
            n([p.Override], Parser.prototype, "inputStream", null);
            n([p.NotNull], Parser.prototype, "currentToken", null);
            n([i(0, p.NotNull)], Parser.prototype, "enterRule", null);
            n([p.Override, i(0, p.Nullable)], Parser.prototype, "precpred", null);
            n([p.Override], Parser.prototype, "getErrorListenerDispatch", null);
            n([p.NotNull], Parser.prototype, "getExpectedTokens", null);
            n([p.NotNull], Parser.prototype, "getExpectedTokensWithinCurrentRule", null);
            n([p.Override], Parser.prototype, "parseInfo", null);
            t.Parser = Parser
        },
        708: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        18: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ParserInterpreter = void 0;
            const o = r(2210);
            const s = r(1765);
            const a = r(4980);
            const l = r(5575);
            const _ = r(368);
            const u = r(790);
            const c = r(6994);
            const d = r(6966);
            const p = r(6966);
            const f = r(8871);
            const h = r(9851);
            const g = r(8145);
            const m = r(8734);
            const y = r(7528);
            let S = class ParserInterpreter extends f.Parser {
                constructor(e, t, r, n, i) {
                    super(e instanceof ParserInterpreter ? e.inputStream : i);
                    this._parentContextStack = [];
                    this.overrideDecision = -1;
                    this.overrideDecisionInputIndex = -1;
                    this.overrideDecisionAlt = -1;
                    this.overrideDecisionReached = false;
                    this._overrideDecisionRoot = undefined;
                    if (e instanceof ParserInterpreter) {
                        let t = e;
                        this._grammarFileName = t._grammarFileName;
                        this._atn = t._atn;
                        this.pushRecursionContextStates = t.pushRecursionContextStates;
                        this._ruleNames = t._ruleNames;
                        this._vocabulary = t._vocabulary;
                        this.interpreter = new h.ParserATNSimulator(this._atn, this)
                    } else {
                        t = t;
                        r = r;
                        n = n;
                        this._grammarFileName = e;
                        this._atn = n;
                        this._ruleNames = r.slice(0);
                        this._vocabulary = t;
                        this.pushRecursionContextStates = new a.BitSet(n.states.length);
                        for (let e of n.states) {
                            if (!(e instanceof m.StarLoopEntryState)) {
                                continue
                            }
                            if (e.precedenceRuleDecision) {
                                this.pushRecursionContextStates.set(e.stateNumber)
                            }
                        }
                        this.interpreter = new h.ParserATNSimulator(n, this)
                    }
                }
                reset(e) {
                    if (e === undefined) {
                        super.reset()
                    } else {
                        super.reset(e)
                    }
                    this.overrideDecisionReached = false;
                    this._overrideDecisionRoot = undefined
                }
                get atn() {
                    return this._atn
                }
                get vocabulary() {
                    return this._vocabulary
                }
                get ruleNames() {
                    return this._ruleNames
                }
                get grammarFileName() {
                    return this._grammarFileName
                }
                parse(e) {
                    let t = this._atn.ruleToStartState[e];
                    this._rootContext = this.createInterpreterRuleContext(undefined, o.ATNState.INVALID_STATE_NUMBER, e);
                    if (t.isPrecedenceRule) {
                        this.enterRecursionRule(this._rootContext, t.stateNumber, e, 0)
                    } else {
                        this.enterRule(this._rootContext, t.stateNumber, e)
                    }
                    while (true) {
                        let e = this.atnState;
                        switch (e.stateType) {
                            case s.ATNStateType.RULE_STOP:
                                if (this._ctx.isEmpty) {
                                    if (t.isPrecedenceRule) {
                                        let e = this._ctx;
                                        let t = this._parentContextStack.pop();
                                        this.unrollRecursionContexts(t[0]);
                                        return e
                                    } else {
                                        this.exitRule();
                                        return this._rootContext
                                    }
                                }
                                this.visitRuleStopState(e);
                                break;
                            default:
                                try {
                                    this.visitState(e)
                                } catch (t) {
                                    if (t instanceof g.RecognitionException) {
                                        this.state = this._atn.ruleToStopState[e.ruleIndex].stateNumber;
                                        this.context.exception = t;
                                        this.errorHandler.reportError(this, t);
                                        this.recover(t)
                                    } else {
                                        throw t
                                    }
                                }
                                break
                        }
                    }
                }
                enterRecursionRule(e, t, r, n) {
                    this._parentContextStack.push([this._ctx, e.invokingState]);
                    super.enterRecursionRule(e, t, r, n)
                }
                get atnState() {
                    return this._atn.states[this.state]
                }
                visitState(e) {
                    let t = 1;
                    if (e.numberOfTransitions > 1) {
                        t = this.visitDecisionState(e)
                    }
                    let r = e.transition(t - 1);
                    switch (r.serializationType) {
                        case 1:
                            if (this.pushRecursionContextStates.get(e.stateNumber) && !(r.target instanceof c.LoopEndState)) {
                                let t = this._parentContextStack[this._parentContextStack.length - 1];
                                let r = this.createInterpreterRuleContext(t[0], t[1], this._ctx.ruleIndex);
                                this.pushNewRecursionContext(r, this._atn.ruleToStartState[e.ruleIndex].stateNumber, this._ctx.ruleIndex)
                            }
                            break;
                        case 5:
                            this.match(r._label);
                            break;
                        case 2:
                        case 7:
                        case 8:
                            if (!r.matches(this._input.LA(1), y.Token.MIN_USER_TOKEN_TYPE, 65535)) {
                                this.recoverInline()
                            }
                            this.matchWildcard();
                            break;
                        case 9:
                            this.matchWildcard();
                            break;
                        case 3:
                            let t = r.target;
                            let n = t.ruleIndex;
                            let i = this.createInterpreterRuleContext(this._ctx, e.stateNumber, n);
                            if (t.isPrecedenceRule) {
                                this.enterRecursionRule(i, t.stateNumber, n, r.precedence)
                            } else {
                                this.enterRule(i, r.target.stateNumber, n)
                            }
                            break;
                        case 4:
                            let o = r;
                            if (!this.sempred(this._ctx, o.ruleIndex, o.predIndex)) {
                                throw new l.FailedPredicateException(this)
                            }
                            break;
                        case 6:
                            let s = r;
                            this.action(this._ctx, s.ruleIndex, s.actionIndex);
                            break;
                        case 10:
                            if (!this.precpred(this._ctx, r.precedence)) {
                                let e = r.precedence;
                                throw new l.FailedPredicateException(this, `precpred(_ctx, ${e})`)
                            }
                            break;
                        default:
                            throw new Error("UnsupportedOperationException: Unrecognized ATN transition type.")
                    }
                    this.state = r.target.stateNumber
                }
                visitDecisionState(e) {
                    let t;
                    this.errorHandler.sync(this);
                    let r = e.decision;
                    if (r === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {
                        t = this.overrideDecisionAlt;
                        this.overrideDecisionReached = true
                    } else {
                        t = this.interpreter.adaptivePredict(this._input, r, this._ctx)
                    }
                    return t
                }
                createInterpreterRuleContext(e, t, r) {
                    return new u.InterpreterRuleContext(r, e, t)
                }
                visitRuleStopState(e) {
                    let t = this._atn.ruleToStartState[e.ruleIndex];
                    if (t.isPrecedenceRule) {
                        let e = this._parentContextStack.pop();
                        this.unrollRecursionContexts(e[0]);
                        this.state = e[1]
                    } else {
                        this.exitRule()
                    }
                    let r = this._atn.states[this.state].transition(0);
                    this.state = r.followState.stateNumber
                }
                addDecisionOverride(e, t, r) {
                    this.overrideDecision = e;
                    this.overrideDecisionInputIndex = t;
                    this.overrideDecisionAlt = r
                }
                get overrideDecisionRoot() {
                    return this._overrideDecisionRoot
                }
                recover(e) {
                    let t = this._input.index;
                    this.errorHandler.recover(this, e);
                    if (this._input.index === t) {
                        let t = e.getOffendingToken();
                        if (!t) {
                            throw new Error("Expected exception to have an offending token")
                        }
                        let r = t.tokenSource;
                        let n = r !== undefined ? r.inputStream : undefined;
                        let i = {
                            source: r,
                            stream: n
                        };
                        if (e instanceof _.InputMismatchException) {
                            let r = e.expectedTokens;
                            if (r === undefined) {
                                throw new Error("Expected the exception to provide expected tokens")
                            }
                            let n = y.Token.INVALID_TYPE;
                            if (!r.isNil) {
                                n = r.minElement
                            }
                            let o = this.tokenFactory.create(i, n, t.text, y.Token.DEFAULT_CHANNEL, -1, -1, t.line, t.charPositionInLine);
                            this._ctx.addErrorNode(this.createErrorNode(this._ctx, o))
                        } else {
                            let e = t.tokenSource;
                            let r = this.tokenFactory.create(i, y.Token.INVALID_TYPE, t.text, y.Token.DEFAULT_CHANNEL, -1, -1, t.line, t.charPositionInLine);
                            this._ctx.addErrorNode(this.createErrorNode(this._ctx, r))
                        }
                    }
                }
                recoverInline() {
                    return this._errHandler.recoverInline(this)
                }
                get rootContext() {
                    return this._rootContext
                }
            };
            n([d.NotNull], S.prototype, "_vocabulary", void 0);
            n([p.Override], S.prototype, "reset", null);
            n([p.Override], S.prototype, "atn", null);
            n([p.Override], S.prototype, "vocabulary", null);
            n([p.Override], S.prototype, "ruleNames", null);
            n([p.Override], S.prototype, "grammarFileName", null);
            n([p.Override], S.prototype, "enterRecursionRule", null);
            S = n([i(1, d.NotNull)], S);
            t.ParserInterpreter = S
        },
        9562: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ParserRuleContext = void 0;
            const i = r(8817);
            const o = r(6330);
            const s = r(6966);
            const a = r(8617);
            const l = r(4292);
            class ParserRuleContext extends a.RuleContext {
                constructor(e, t) {
                    if (t == null) {
                        super()
                    } else {
                        super(e, t)
                    }
                }
                static emptyContext() {
                    return ParserRuleContext.EMPTY
                }
                copyFrom(e) {
                    this._parent = e._parent;
                    this.invokingState = e.invokingState;
                    this._start = e._start;
                    this._stop = e._stop;
                    if (e.children) {
                        this.children = [];
                        for (let t of e.children) {
                            if (t instanceof i.ErrorNode) {
                                this.addChild(t)
                            }
                        }
                    }
                }
                enterRule(e) {}
                exitRule(e) {}
                addAnyChild(e) {
                    if (!this.children) {
                        this.children = [e]
                    } else {
                        this.children.push(e)
                    }
                    return e
                }
                addChild(e) {
                    let t;
                    if (e instanceof l.TerminalNode) {
                        e.setParent(this);
                        this.addAnyChild(e);
                        return
                    } else if (e instanceof a.RuleContext) {
                        this.addAnyChild(e);
                        return
                    } else {
                        e = new l.TerminalNode(e);
                        this.addAnyChild(e);
                        e.setParent(this);
                        return e
                    }
                }
                addErrorNode(e) {
                    if (e instanceof i.ErrorNode) {
                        const t = e;
                        t.setParent(this);
                        return this.addAnyChild(t)
                    } else {
                        const t = e;
                        let r = new i.ErrorNode(t);
                        this.addAnyChild(r);
                        r.setParent(this);
                        return r
                    }
                }
                removeLastChild() {
                    if (this.children) {
                        this.children.pop()
                    }
                }
                get parent() {
                    let e = super.parent;
                    if (e === undefined || e instanceof ParserRuleContext) {
                        return e
                    }
                    throw new TypeError("Invalid parent type for ParserRuleContext")
                }
                getChild(e, t) {
                    if (!this.children || e < 0 || e >= this.children.length) {
                        throw new RangeError("index parameter must be between >= 0 and <= number of children.")
                    }
                    if (t == null) {
                        return this.children[e]
                    }
                    let r = this.tryGetChild(e, t);
                    if (r === undefined) {
                        throw new Error("The specified node does not exist")
                    }
                    return r
                }
                tryGetChild(e, t) {
                    if (!this.children || e < 0 || e >= this.children.length) {
                        return undefined
                    }
                    let r = -1;
                    for (let n of this.children) {
                        if (n instanceof t) {
                            r++;
                            if (r === e) {
                                return n
                            }
                        }
                    }
                    return undefined
                }
                getToken(e, t) {
                    let r = this.tryGetToken(e, t);
                    if (r === undefined) {
                        throw new Error("The specified token does not exist")
                    }
                    return r
                }
                tryGetToken(e, t) {
                    if (!this.children || t < 0 || t >= this.children.length) {
                        return undefined
                    }
                    let r = -1;
                    for (let n of this.children) {
                        if (n instanceof l.TerminalNode) {
                            let i = n.symbol;
                            if (i.type === e) {
                                r++;
                                if (r === t) {
                                    return n
                                }
                            }
                        }
                    }
                    return undefined
                }
                getTokens(e) {
                    let t = [];
                    if (!this.children) {
                        return t
                    }
                    for (let r of this.children) {
                        if (r instanceof l.TerminalNode) {
                            let n = r.symbol;
                            if (n.type === e) {
                                t.push(r)
                            }
                        }
                    }
                    return t
                }
                get ruleContext() {
                    return this
                }
                getRuleContext(e, t) {
                    return this.getChild(e, t)
                }
                tryGetRuleContext(e, t) {
                    return this.tryGetChild(e, t)
                }
                getRuleContexts(e) {
                    let t = [];
                    if (!this.children) {
                        return t
                    }
                    for (let r of this.children) {
                        if (r instanceof e) {
                            t.push(r)
                        }
                    }
                    return t
                }
                get childCount() {
                    return this.children ? this.children.length : 0
                }
                get sourceInterval() {
                    if (!this._start) {
                        return o.Interval.INVALID
                    }
                    if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {
                        return o.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1)
                    }
                    return o.Interval.of(this._start.tokenIndex, this._stop.tokenIndex)
                }
                get start() {
                    return this._start
                }
                get stop() {
                    return this._stop
                }
                toInfoString(e) {
                    let t = e.getRuleInvocationStack(this).reverse();
                    return "ParserRuleContext" + t + "{" + "start=" + this._start + ", stop=" + this._stop + "}"
                }
            }
            ParserRuleContext.EMPTY = new ParserRuleContext;
            n([s.Override], ParserRuleContext.prototype, "parent", null);
            n([s.Override], ParserRuleContext.prototype, "childCount", null);
            n([s.Override], ParserRuleContext.prototype, "sourceInterval", null);
            t.ParserRuleContext = ParserRuleContext
        },
        319: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ProxyErrorListener = void 0;
            const o = r(6966);
            class ProxyErrorListener {
                constructor(e) {
                    this.delegates = e;
                    if (!e) {
                        throw new Error("Invalid delegates")
                    }
                }
                getDelegates() {
                    return this.delegates
                }
                syntaxError(e, t, r, n, i, o) {
                    this.delegates.forEach((s => {
                        if (s.syntaxError) {
                            s.syntaxError(e, t, r, n, i, o)
                        }
                    }))
                }
            }
            n([o.Override, i(0, o.NotNull), i(4, o.NotNull)], ProxyErrorListener.prototype, "syntaxError", null);
            t.ProxyErrorListener = ProxyErrorListener
        },
        5932: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ProxyParserErrorListener = void 0;
            const i = r(319);
            const o = r(6966);
            class ProxyParserErrorListener extends i.ProxyErrorListener {
                constructor(e) {
                    super(e)
                }
                reportAmbiguity(e, t, r, n, i, o, s) {
                    this.getDelegates().forEach((a => {
                        if (a.reportAmbiguity) {
                            a.reportAmbiguity(e, t, r, n, i, o, s)
                        }
                    }))
                }
                reportAttemptingFullContext(e, t, r, n, i, o) {
                    this.getDelegates().forEach((s => {
                        if (s.reportAttemptingFullContext) {
                            s.reportAttemptingFullContext(e, t, r, n, i, o)
                        }
                    }))
                }
                reportContextSensitivity(e, t, r, n, i, o) {
                    this.getDelegates().forEach((s => {
                        if (s.reportContextSensitivity) {
                            s.reportContextSensitivity(e, t, r, n, i, o)
                        }
                    }))
                }
            }
            n([o.Override], ProxyParserErrorListener.prototype, "reportAmbiguity", null);
            n([o.Override], ProxyParserErrorListener.prototype, "reportAttemptingFullContext", null);
            n([o.Override], ProxyParserErrorListener.prototype, "reportContextSensitivity", null);
            t.ProxyParserErrorListener = ProxyParserErrorListener
        },
        8145: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RecognitionException = void 0;
            class RecognitionException extends Error {
                constructor(e, t, r, n) {
                    super(n);
                    this._offendingState = -1;
                    this._recognizer = e;
                    this.input = t;
                    this.ctx = r;
                    if (e) {
                        this._offendingState = e.state
                    }
                }
                get offendingState() {
                    return this._offendingState
                }
                setOffendingState(e) {
                    this._offendingState = e
                }
                get expectedTokens() {
                    if (this._recognizer) {
                        return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx)
                    }
                    return undefined
                }
                get context() {
                    return this.ctx
                }
                get inputStream() {
                    return this.input
                }
                getOffendingToken(e) {
                    if (e && e !== this._recognizer) {
                        return undefined
                    }
                    return this.offendingToken
                }
                setOffendingToken(e, t) {
                    if (e === this._recognizer) {
                        this.offendingToken = t
                    }
                }
                get recognizer() {
                    return this._recognizer
                }
            }
            t.RecognitionException = RecognitionException
        },
        3602: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Recognizer = void 0;
            const o = r(8125);
            const s = r(319);
            const a = r(6966);
            const l = r(7528);
            const _ = r(2925);
            class Recognizer {
                constructor() {
                    this._listeners = [o.ConsoleErrorListener.INSTANCE];
                    this._stateNumber = -1
                }
                getTokenTypeMap() {
                    let e = this.vocabulary;
                    let t = Recognizer.tokenTypeMapCache.get(e);
                    if (t == null) {
                        let r = new Map;
                        for (let t = 0; t <= this.atn.maxTokenType; t++) {
                            let n = e.getLiteralName(t);
                            if (n != null) {
                                r.set(n, t)
                            }
                            let i = e.getSymbolicName(t);
                            if (i != null) {
                                r.set(i, t)
                            }
                        }
                        r.set("EOF", l.Token.EOF);
                        t = r;
                        Recognizer.tokenTypeMapCache.set(e, t)
                    }
                    return t
                }
                getRuleIndexMap() {
                    let e = this.ruleNames;
                    if (e == null) {
                        throw new Error("The current recognizer does not provide a list of rule names.")
                    }
                    let t = Recognizer.ruleIndexMapCache.get(e);
                    if (t == null) {
                        t = _.toMap(e);
                        Recognizer.ruleIndexMapCache.set(e, t)
                    }
                    return t
                }
                getTokenType(e) {
                    let t = this.getTokenTypeMap().get(e);
                    if (t != null) {
                        return t
                    }
                    return l.Token.INVALID_TYPE
                }
                get serializedATN() {
                    throw new Error("there is no serialized ATN")
                }
                get atn() {
                    return this._interp.atn
                }
                get interpreter() {
                    return this._interp
                }
                set interpreter(e) {
                    this._interp = e
                }
                get parseInfo() {
                    return Promise.resolve(undefined)
                }
                getErrorHeader(e) {
                    let t = e.getOffendingToken();
                    if (!t) {
                        return ""
                    }
                    let r = t.line;
                    let n = t.charPositionInLine;
                    return "line " + r + ":" + n
                }
                addErrorListener(e) {
                    if (!e) {
                        throw new TypeError("listener must not be null")
                    }
                    this._listeners.push(e)
                }
                removeErrorListener(e) {
                    let t = this._listeners.indexOf(e);
                    if (t !== -1) {
                        this._listeners.splice(t, 1)
                    }
                }
                removeErrorListeners() {
                    this._listeners.length = 0
                }
                getErrorListeners() {
                    return this._listeners.slice(0)
                }
                getErrorListenerDispatch() {
                    return new s.ProxyErrorListener(this.getErrorListeners())
                }
                sempred(e, t, r) {
                    return true
                }
                precpred(e, t) {
                    return true
                }
                action(e, t, r) {}
                get state() {
                    return this._stateNumber
                }
                set state(e) {
                    this._stateNumber = e
                }
            }
            Recognizer.EOF = -1;
            Recognizer.tokenTypeMapCache = new WeakMap;
            Recognizer.ruleIndexMapCache = new WeakMap;
            n([a.SuppressWarnings("serial"), a.NotNull], Recognizer.prototype, "_listeners", void 0);
            n([a.NotNull], Recognizer.prototype, "getTokenTypeMap", null);
            n([a.NotNull], Recognizer.prototype, "getRuleIndexMap", null);
            n([a.NotNull], Recognizer.prototype, "serializedATN", null);
            n([a.NotNull], Recognizer.prototype, "atn", null);
            n([a.NotNull, i(0, a.NotNull)], Recognizer.prototype, "interpreter", null);
            n([a.NotNull, i(0, a.NotNull)], Recognizer.prototype, "getErrorHeader", null);
            n([i(0, a.NotNull)], Recognizer.prototype, "addErrorListener", null);
            n([i(0, a.NotNull)], Recognizer.prototype, "removeErrorListener", null);
            n([a.NotNull], Recognizer.prototype, "getErrorListeners", null);
            t.Recognizer = Recognizer
        },
        8617: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleContext = void 0;
            const i = r(7747);
            const o = r(3602);
            const s = r(2123);
            const a = r(6330);
            const l = r(6966);
            const _ = r(4569);
            const u = r(9562);
            class RuleContext extends s.RuleNode {
                constructor(e, t) {
                    super();
                    this._parent = e;
                    this.invokingState = t != null ? t : -1
                }
                static getChildContext(e, t) {
                    return new RuleContext(e, t)
                }
                depth() {
                    let e = 0;
                    let t = this;
                    while (t) {
                        t = t._parent;
                        e++
                    }
                    return e
                }
                get isEmpty() {
                    return this.invokingState === -1
                }
                get sourceInterval() {
                    return a.Interval.INVALID
                }
                get ruleContext() {
                    return this
                }
                get parent() {
                    return this._parent
                }
                setParent(e) {
                    this._parent = e
                }
                get payload() {
                    return this
                }
                get text() {
                    if (this.childCount === 0) {
                        return ""
                    }
                    let e = "";
                    for (let t = 0; t < this.childCount; t++) {
                        e += this.getChild(t).text
                    }
                    return e.toString()
                }
                get ruleIndex() {
                    return -1
                }
                get altNumber() {
                    return i.ATN.INVALID_ALT_NUMBER
                }
                set altNumber(e) {}
                getChild(e) {
                    throw new RangeError("i must be greater than or equal to 0 and less than childCount")
                }
                get childCount() {
                    return 0
                }
                accept(e) {
                    return e.visitChildren(this)
                }
                toStringTree(e) {
                    return _.Trees.toStringTree(this, e)
                }
                toString(e, t) {
                    const r = e instanceof o.Recognizer ? e.ruleNames : e;
                    t = t || u.ParserRuleContext.emptyContext();
                    let n = "";
                    let i = this;
                    n += "[";
                    while (i && i !== t) {
                        if (!r) {
                            if (!i.isEmpty) {
                                n += i.invokingState
                            }
                        } else {
                            let e = i.ruleIndex;
                            let t = e >= 0 && e < r.length ? r[e] : e.toString();
                            n += t
                        }
                        if (i._parent && (r || !i._parent.isEmpty)) {
                            n += " "
                        }
                        i = i._parent
                    }
                    n += "]";
                    return n.toString()
                }
            }
            n([l.Override], RuleContext.prototype, "sourceInterval", null);
            n([l.Override], RuleContext.prototype, "ruleContext", null);
            n([l.Override], RuleContext.prototype, "parent", null);
            n([l.Override], RuleContext.prototype, "setParent", null);
            n([l.Override], RuleContext.prototype, "payload", null);
            n([l.Override], RuleContext.prototype, "text", null);
            n([l.Override], RuleContext.prototype, "getChild", null);
            n([l.Override], RuleContext.prototype, "childCount", null);
            n([l.Override], RuleContext.prototype, "accept", null);
            n([l.Override], RuleContext.prototype, "toStringTree", null);
            t.RuleContext = RuleContext
        },
        6218: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleContextWithAltNum = void 0;
            const i = r(7747);
            const o = r(6966);
            const s = r(9562);
            class RuleContextWithAltNum extends s.ParserRuleContext {
                constructor(e, t) {
                    if (t !== undefined) {
                        super(e, t)
                    } else {
                        super()
                    }
                    this._altNumber = i.ATN.INVALID_ALT_NUMBER
                }
                get altNumber() {
                    return this._altNumber
                }
                set altNumber(e) {
                    this._altNumber = e
                }
            }
            n([o.Override], RuleContextWithAltNum.prototype, "altNumber", null);
            t.RuleContextWithAltNum = RuleContextWithAltNum
        },
        85: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleDependency = void 0;

            function RuleDependency(e) {
                return (e, t, r) => {}
            }
            t.RuleDependency = RuleDependency
        },
        9480: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleVersion = void 0;

            function RuleVersion(e) {
                return (e, t, r) => {}
            }
            t.RuleVersion = RuleVersion
        },
        7528: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Token = void 0;
            const n = r(3828);
            var i;
            (function(e) {
                e.INVALID_TYPE = 0;
                e.EPSILON = -2;
                e.MIN_USER_TOKEN_TYPE = 1;
                e.EOF = n.IntStream.EOF;
                e.DEFAULT_CHANNEL = 0;
                e.HIDDEN_CHANNEL = 1;
                e.MIN_USER_CHANNEL_VALUE = 2
            })(i = t.Token || (t.Token = {}))
        },
        9535: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        4416: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        9550: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        9427: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RewriteOperation = t.TokenStreamRewriter = void 0;
            const i = r(6330);
            const o = r(6966);
            const s = r(7528);
            class TokenStreamRewriter {
                constructor(e) {
                    this.tokens = e;
                    this.programs = new Map;
                    this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);
                    this.lastRewriteTokenIndexes = new Map
                }
                getTokenStream() {
                    return this.tokens
                }
                rollback(e, t = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                    let r = this.programs.get(t);
                    if (r != null) {
                        this.programs.set(t, r.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, e))
                    }
                }
                deleteProgram(e = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                    this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, e)
                }
                insertAfter(e, t, r = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                    let n;
                    if (typeof e === "number") {
                        n = e
                    } else {
                        n = e.tokenIndex
                    }
                    let i = this.getProgram(r);
                    let o = new InsertAfterOp(this.tokens, n, i.length, t);
                    i.push(o)
                }
                insertBefore(e, t, r = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                    let n;
                    if (typeof e === "number") {
                        n = e
                    } else {
                        n = e.tokenIndex
                    }
                    let i = this.getProgram(r);
                    let o = new InsertBeforeOp(this.tokens, n, i.length, t);
                    i.push(o)
                }
                replaceSingle(e, t) {
                    if (typeof e === "number") {
                        this.replace(e, e, t)
                    } else {
                        this.replace(e, e, t)
                    }
                }
                replace(e, t, r, n = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                    if (typeof e !== "number") {
                        e = e.tokenIndex
                    }
                    if (typeof t !== "number") {
                        t = t.tokenIndex
                    }
                    if (e > t || e < 0 || t < 0 || t >= this.tokens.size) {
                        throw new RangeError(`replace: range invalid: ${e}..${t}(size=${this.tokens.size})`)
                    }
                    let i = this.getProgram(n);
                    let o = new ReplaceOp(this.tokens, e, t, i.length, r);
                    i.push(o)
                }
                delete(e, t, r = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                    if (t === undefined) {
                        t = e
                    }
                    if (typeof e === "number") {
                        this.replace(e, t, "", r)
                    } else {
                        this.replace(e, t, "", r)
                    }
                }
                getLastRewriteTokenIndex(e = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                    let t = this.lastRewriteTokenIndexes.get(e);
                    if (t == null) {
                        return -1
                    }
                    return t
                }
                setLastRewriteTokenIndex(e, t) {
                    this.lastRewriteTokenIndexes.set(e, t)
                }
                getProgram(e) {
                    let t = this.programs.get(e);
                    if (t == null) {
                        t = this.initializeProgram(e)
                    }
                    return t
                }
                initializeProgram(e) {
                    let t = [];
                    this.programs.set(e, t);
                    return t
                }
                getText(e, t = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {
                    let r;
                    if (e instanceof i.Interval) {
                        r = e
                    } else {
                        r = i.Interval.of(0, this.tokens.size - 1)
                    }
                    if (typeof e === "string") {
                        t = e
                    }
                    let n = this.programs.get(t);
                    let o = r.a;
                    let a = r.b;
                    if (a > this.tokens.size - 1) {
                        a = this.tokens.size - 1
                    }
                    if (o < 0) {
                        o = 0
                    }
                    if (n == null || n.length === 0) {
                        return this.tokens.getText(r)
                    }
                    let l = [];
                    let _ = this.reduceToSingleOperationPerIndex(n);
                    let u = o;
                    while (u <= a && u < this.tokens.size) {
                        let e = _.get(u);
                        _.delete(u);
                        let t = this.tokens.get(u);
                        if (e == null) {
                            if (t.type !== s.Token.EOF) {
                                l.push(String(t.text))
                            }
                            u++
                        } else {
                            u = e.execute(l)
                        }
                    }
                    if (a === this.tokens.size - 1) {
                        for (let e of _.values()) {
                            if (e.index >= this.tokens.size - 1) {
                                l.push(e.text.toString())
                            }
                        }
                    }
                    return l.join("")
                }
                reduceToSingleOperationPerIndex(e) {
                    for (let t = 0; t < e.length; t++) {
                        let r = e[t];
                        if (r == null) {
                            continue
                        }
                        if (!(r instanceof ReplaceOp)) {
                            continue
                        }
                        let n = r;
                        let i = this.getKindOfOps(e, InsertBeforeOp, t);
                        for (let t of i) {
                            if (t.index === n.index) {
                                e[t.instructionIndex] = undefined;
                                n.text = t.text.toString() + (n.text != null ? n.text.toString() : "")
                            } else if (t.index > n.index && t.index <= n.lastIndex) {
                                e[t.instructionIndex] = undefined
                            }
                        }
                        let o = this.getKindOfOps(e, ReplaceOp, t);
                        for (let t of o) {
                            if (t.index >= n.index && t.lastIndex <= n.lastIndex) {
                                e[t.instructionIndex] = undefined;
                                continue
                            }
                            let r = t.lastIndex < n.index || t.index > n.lastIndex;
                            if (t.text == null && n.text == null && !r) {
                                e[t.instructionIndex] = undefined;
                                n.index = Math.min(t.index, n.index);
                                n.lastIndex = Math.max(t.lastIndex, n.lastIndex)
                            } else if (!r) {
                                throw new Error(`replace op boundaries of ${n} overlap with previous ${t}`)
                            }
                        }
                    }
                    for (let t = 0; t < e.length; t++) {
                        let r = e[t];
                        if (r == null) {
                            continue
                        }
                        if (!(r instanceof InsertBeforeOp)) {
                            continue
                        }
                        let n = r;
                        let i = this.getKindOfOps(e, InsertBeforeOp, t);
                        for (let t of i) {
                            if (t.index === n.index) {
                                if (t instanceof InsertAfterOp) {
                                    n.text = this.catOpText(t.text, n.text);
                                    e[t.instructionIndex] = undefined
                                } else if (t instanceof InsertBeforeOp) {
                                    n.text = this.catOpText(n.text, t.text);
                                    e[t.instructionIndex] = undefined
                                }
                            }
                        }
                        let o = this.getKindOfOps(e, ReplaceOp, t);
                        for (let r of o) {
                            if (n.index === r.index) {
                                r.text = this.catOpText(n.text, r.text);
                                e[t] = undefined;
                                continue
                            }
                            if (n.index >= r.index && n.index <= r.lastIndex) {
                                throw new Error(`insert op ${n} within boundaries of previous ${r}`)
                            }
                        }
                    }
                    let t = new Map;
                    for (let r of e) {
                        if (r == null) {
                            continue
                        }
                        if (t.get(r.index) != null) {
                            throw new Error("should only be one op per index")
                        }
                        t.set(r.index, r)
                    }
                    return t
                }
                catOpText(e, t) {
                    let r = "";
                    let n = "";
                    if (e != null) {
                        r = e.toString()
                    }
                    if (t != null) {
                        n = t.toString()
                    }
                    return r + n
                }
                getKindOfOps(e, t, r) {
                    let n = [];
                    for (let i = 0; i < r && i < e.length; i++) {
                        let r = e[i];
                        if (r == null) {
                            continue
                        }
                        if (r instanceof t) {
                            n.push(r)
                        }
                    }
                    return n
                }
            }
            t.TokenStreamRewriter = TokenStreamRewriter;
            TokenStreamRewriter.DEFAULT_PROGRAM_NAME = "default";
            TokenStreamRewriter.PROGRAM_INIT_SIZE = 100;
            TokenStreamRewriter.MIN_TOKEN_INDEX = 0;
            class RewriteOperation {
                constructor(e, t, r, n) {
                    this.tokens = e;
                    this.instructionIndex = r;
                    this.index = t;
                    this.text = n === undefined ? "" : n
                }
                execute(e) {
                    return this.index
                }
                toString() {
                    let e = this.constructor.name;
                    let t = e.indexOf("$");
                    e = e.substring(t + 1, e.length);
                    return "<" + e + "@" + this.tokens.get(this.index) + ':"' + this.text + '">'
                }
            }
            n([o.Override], RewriteOperation.prototype, "toString", null);
            t.RewriteOperation = RewriteOperation;
            class InsertBeforeOp extends RewriteOperation {
                constructor(e, t, r, n) {
                    super(e, t, r, n)
                }
                execute(e) {
                    e.push(this.text.toString());
                    if (this.tokens.get(this.index).type !== s.Token.EOF) {
                        e.push(String(this.tokens.get(this.index).text))
                    }
                    return this.index + 1
                }
            }
            n([o.Override], InsertBeforeOp.prototype, "execute", null);
            class InsertAfterOp extends InsertBeforeOp {
                constructor(e, t, r, n) {
                    super(e, t + 1, r, n)
                }
            }
            class ReplaceOp extends RewriteOperation {
                constructor(e, t, r, n, i) {
                    super(e, t, n, i);
                    this.lastIndex = r
                }
                execute(e) {
                    if (this.text != null) {
                        e.push(this.text.toString())
                    }
                    return this.lastIndex + 1
                }
                toString() {
                    if (this.text == null) {
                        return "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">"
                    }
                    return "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">'
                }
            }
            n([o.Override], ReplaceOp.prototype, "execute", null);
            n([o.Override], ReplaceOp.prototype, "toString", null)
        },
        8780: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        7847: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.VocabularyImpl = void 0;
            const i = r(6966);
            const o = r(7528);
            class VocabularyImpl {
                constructor(e, t, r) {
                    this.literalNames = e;
                    this.symbolicNames = t;
                    this.displayNames = r;
                    this._maxTokenType = Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1
                }
                get maxTokenType() {
                    return this._maxTokenType
                }
                getLiteralName(e) {
                    if (e >= 0 && e < this.literalNames.length) {
                        return this.literalNames[e]
                    }
                    return undefined
                }
                getSymbolicName(e) {
                    if (e >= 0 && e < this.symbolicNames.length) {
                        return this.symbolicNames[e]
                    }
                    if (e === o.Token.EOF) {
                        return "EOF"
                    }
                    return undefined
                }
                getDisplayName(e) {
                    if (e >= 0 && e < this.displayNames.length) {
                        let t = this.displayNames[e];
                        if (t) {
                            return t
                        }
                    }
                    let t = this.getLiteralName(e);
                    if (t) {
                        return t
                    }
                    let r = this.getSymbolicName(e);
                    if (r) {
                        return r
                    }
                    return String(e)
                }
            }
            VocabularyImpl.EMPTY_VOCABULARY = new VocabularyImpl([], [], []);
            n([i.NotNull], VocabularyImpl.prototype, "literalNames", void 0);
            n([i.NotNull], VocabularyImpl.prototype, "symbolicNames", void 0);
            n([i.NotNull], VocabularyImpl.prototype, "displayNames", void 0);
            n([i.Override], VocabularyImpl.prototype, "maxTokenType", null);
            n([i.Override], VocabularyImpl.prototype, "getLiteralName", null);
            n([i.Override], VocabularyImpl.prototype, "getSymbolicName", null);
            n([i.Override, i.NotNull], VocabularyImpl.prototype, "getDisplayName", null);
            n([i.NotNull], VocabularyImpl, "EMPTY_VOCABULARY", void 0);
            t.VocabularyImpl = VocabularyImpl
        },
        7017: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            })
        },
        7747: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ATN = void 0;
            const o = r(9605);
            const s = r(8878);
            const a = r(7108);
            const l = r(7833);
            const _ = r(3369);
            const u = r(6966);
            const c = r(4880);
            const d = r(5047);
            const p = r(7528);
            const f = r(9491);
            let h = class ATN {
                constructor(e, t) {
                    this.states = [];
                    this.decisionToState = [];
                    this.modeNameToStartState = new Map;
                    this.modeToStartState = [];
                    this.contextCache = new o.Array2DHashMap(c.ObjectEqualityComparator.INSTANCE);
                    this.decisionToDFA = [];
                    this.modeToDFA = [];
                    this.LL1Table = new Map;
                    this.grammarType = e;
                    this.maxTokenType = t
                }
                clearDFA() {
                    this.decisionToDFA = new Array(this.decisionToState.length);
                    for (let e = 0; e < this.decisionToDFA.length; e++) {
                        this.decisionToDFA[e] = new s.DFA(this.decisionToState[e], e)
                    }
                    this.modeToDFA = new Array(this.modeToStartState.length);
                    for (let e = 0; e < this.modeToDFA.length; e++) {
                        this.modeToDFA[e] = new s.DFA(this.modeToStartState[e])
                    }
                    this.contextCache.clear();
                    this.LL1Table.clear()
                }
                get contextCacheSize() {
                    return this.contextCache.size
                }
                getCachedContext(e) {
                    return d.PredictionContext.getCachedContext(e, this.contextCache, new d.PredictionContext.IdentityHashMap)
                }
                getDecisionToDFA() {
                    f(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);
                    return this.decisionToDFA
                }
                nextTokens(e, t) {
                    if (t) {
                        let r = new _.LL1Analyzer(this);
                        let n = r.LOOK(e, t);
                        return n
                    } else {
                        if (e.nextTokenWithinRule) {
                            return e.nextTokenWithinRule
                        }
                        e.nextTokenWithinRule = this.nextTokens(e, d.PredictionContext.EMPTY_LOCAL);
                        e.nextTokenWithinRule.setReadonly(true);
                        return e.nextTokenWithinRule
                    }
                }
                addState(e) {
                    e.atn = this;
                    e.stateNumber = this.states.length;
                    this.states.push(e)
                }
                removeState(e) {
                    let t = new l.InvalidState;
                    t.atn = this;
                    t.stateNumber = e.stateNumber;
                    this.states[e.stateNumber] = t
                }
                defineMode(e, t) {
                    this.modeNameToStartState.set(e, t);
                    this.modeToStartState.push(t);
                    this.modeToDFA.push(new s.DFA(t));
                    this.defineDecisionState(t)
                }
                defineDecisionState(e) {
                    this.decisionToState.push(e);
                    e.decision = this.decisionToState.length - 1;
                    this.decisionToDFA.push(new s.DFA(e, e.decision));
                    return e.decision
                }
                getDecisionState(e) {
                    if (this.decisionToState.length > 0) {
                        return this.decisionToState[e]
                    }
                    return undefined
                }
                get numberOfDecisions() {
                    return this.decisionToState.length
                }
                getExpectedTokens(e, t) {
                    if (e < 0 || e >= this.states.length) {
                        throw new RangeError("Invalid state number.")
                    }
                    let r = t;
                    let n = this.states[e];
                    let i = this.nextTokens(n);
                    if (!i.contains(p.Token.EPSILON)) {
                        return i
                    }
                    let o = new a.IntervalSet;
                    o.addAll(i);
                    o.remove(p.Token.EPSILON);
                    while (r != null && r.invokingState >= 0 && i.contains(p.Token.EPSILON)) {
                        let e = this.states[r.invokingState];
                        let t = e.transition(0);
                        i = this.nextTokens(t.followState);
                        o.addAll(i);
                        o.remove(p.Token.EPSILON);
                        r = r._parent
                    }
                    if (i.contains(p.Token.EPSILON)) {
                        o.add(p.Token.EOF)
                    }
                    return o
                }
            };
            n([u.NotNull], h.prototype, "states", void 0);
            n([u.NotNull], h.prototype, "decisionToState", void 0);
            n([u.NotNull], h.prototype, "modeNameToStartState", void 0);
            n([u.NotNull], h.prototype, "modeToStartState", void 0);
            n([u.NotNull], h.prototype, "decisionToDFA", void 0);
            n([u.NotNull], h.prototype, "modeToDFA", void 0);
            n([u.NotNull], h.prototype, "nextTokens", null);
            n([i(0, u.NotNull)], h.prototype, "removeState", null);
            n([i(0, u.NotNull), i(1, u.NotNull)], h.prototype, "defineMode", null);
            n([i(0, u.NotNull)], h.prototype, "defineDecisionState", null);
            n([u.NotNull], h.prototype, "getExpectedTokens", null);
            h = n([i(0, u.NotNull)], h);
            t.ATN = h;
            (function(e) {
                e.INVALID_ALT_NUMBER = 0
            })(h = t.ATN || (t.ATN = {}));
            t.ATN = h
        },
        1690: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ATNConfig = void 0;
            const o = r(9605);
            const s = r(4402);
            const a = r(5032);
            const l = r(6966);
            const _ = r(4880);
            const u = r(5047);
            const c = r(4806);
            const d = r(9491);
            const p = 2147483648;
            let f = class ATNConfig {
                constructor(e, t, r) {
                    if (typeof t === "number") {
                        d((t & 16777215) === t);
                        this._state = e;
                        this.altAndOuterContextDepth = t;
                        this._context = r
                    } else {
                        this._state = e;
                        this.altAndOuterContextDepth = t.altAndOuterContextDepth;
                        this._context = r
                    }
                }
                static create(e, t, r, n = c.SemanticContext.NONE, i) {
                    if (n !== c.SemanticContext.NONE) {
                        if (i != null) {
                            return new m(i, n, e, t, r, false)
                        } else {
                            return new h(n, e, t, r)
                        }
                    } else if (i != null) {
                        return new g(i, e, t, r, false)
                    } else {
                        return new ATNConfig(e, t, r)
                    }
                }
                get state() {
                    return this._state
                }
                get alt() {
                    return this.altAndOuterContextDepth & 16777215
                }
                get context() {
                    return this._context
                }
                set context(e) {
                    this._context = e
                }
                get reachesIntoOuterContext() {
                    return this.outerContextDepth !== 0
                }
                get outerContextDepth() {
                    return this.altAndOuterContextDepth >>> 24 & 127
                }
                set outerContextDepth(e) {
                    d(e >= 0);
                    e = Math.min(e, 127);
                    this.altAndOuterContextDepth = e << 24 | (this.altAndOuterContextDepth & ~2130706432) >>> 0
                }
                get lexerActionExecutor() {
                    return undefined
                }
                get semanticContext() {
                    return c.SemanticContext.NONE
                }
                get hasPassedThroughNonGreedyDecision() {
                    return false
                }
                clone() {
                    return this.transform(this.state, false)
                }
                transform(e, t, r) {
                    if (r == null) {
                        return this.transformImpl(e, this._context, this.semanticContext, t, this.lexerActionExecutor)
                    } else if (r instanceof u.PredictionContext) {
                        return this.transformImpl(e, r, this.semanticContext, t, this.lexerActionExecutor)
                    } else if (r instanceof c.SemanticContext) {
                        return this.transformImpl(e, this._context, r, t, this.lexerActionExecutor)
                    } else {
                        return this.transformImpl(e, this._context, this.semanticContext, t, r)
                    }
                }
                transformImpl(e, t, r, n, i) {
                    let o = n && ATNConfig.checkNonGreedyDecision(this, e);
                    if (r !== c.SemanticContext.NONE) {
                        if (i != null || o) {
                            return new m(i, r, e, this, t, o)
                        } else {
                            return new h(r, e, this, t)
                        }
                    } else if (i != null || o) {
                        return new g(i, e, this, t, o)
                    } else {
                        return new ATNConfig(e, this, t)
                    }
                }
                static checkNonGreedyDecision(e, t) {
                    return e.hasPassedThroughNonGreedyDecision || t instanceof s.DecisionState && t.nonGreedy
                }
                appendContext(e, t) {
                    if (typeof e === "number") {
                        let r = this.context.appendSingleContext(e, t);
                        let n = this.transform(this.state, false, r);
                        return n
                    } else {
                        let r = this.context.appendContext(e, t);
                        let n = this.transform(this.state, false, r);
                        return n
                    }
                }
                contains(e) {
                    if (this.state.stateNumber !== e.state.stateNumber || this.alt !== e.alt || !this.semanticContext.equals(e.semanticContext)) {
                        return false
                    }
                    let t = [];
                    let r = [];
                    t.push(this.context);
                    r.push(e.context);
                    while (true) {
                        let e = t.pop();
                        let n = r.pop();
                        if (!e || !n) {
                            break
                        }
                        if (e === n) {
                            return true
                        }
                        if (e.size < n.size) {
                            return false
                        }
                        if (n.isEmpty) {
                            return e.hasEmpty
                        } else {
                            for (let i = 0; i < n.size; i++) {
                                let o = e.findReturnState(n.getReturnState(i));
                                if (o < 0) {
                                    return false
                                }
                                t.push(e.getParent(o));
                                r.push(n.getParent(i))
                            }
                        }
                    }
                    return false
                }
                get isPrecedenceFilterSuppressed() {
                    return (this.altAndOuterContextDepth & p) !== 0
                }
                set isPrecedenceFilterSuppressed(e) {
                    if (e) {
                        this.altAndOuterContextDepth |= p
                    } else {
                        this.altAndOuterContextDepth &= ~p
                    }
                }
                equals(e) {
                    if (this === e) {
                        return true
                    } else if (!(e instanceof ATNConfig)) {
                        return false
                    }
                    return this.state.stateNumber === e.state.stateNumber && this.alt === e.alt && this.reachesIntoOuterContext === e.reachesIntoOuterContext && this.context.equals(e.context) && this.semanticContext.equals(e.semanticContext) && this.isPrecedenceFilterSuppressed === e.isPrecedenceFilterSuppressed && this.hasPassedThroughNonGreedyDecision === e.hasPassedThroughNonGreedyDecision && _.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, e.lexerActionExecutor)
                }
                hashCode() {
                    let e = a.MurmurHash.initialize(7);
                    e = a.MurmurHash.update(e, this.state.stateNumber);
                    e = a.MurmurHash.update(e, this.alt);
                    e = a.MurmurHash.update(e, this.reachesIntoOuterContext ? 1 : 0);
                    e = a.MurmurHash.update(e, this.context);
                    e = a.MurmurHash.update(e, this.semanticContext);
                    e = a.MurmurHash.update(e, this.hasPassedThroughNonGreedyDecision ? 1 : 0);
                    e = a.MurmurHash.update(e, this.lexerActionExecutor);
                    e = a.MurmurHash.finish(e, 7);
                    return e
                }
                toDotString() {
                    let e = "";
                    e += "digraph G {\n";
                    e += "rankdir=LR;\n";
                    let t = new o.Array2DHashMap(u.PredictionContext.IdentityEqualityComparator.INSTANCE);
                    let r = [];

                    function getOrAddContext(e) {
                        let n = t.size;
                        let i = t.putIfAbsent(e, n);
                        if (i != null) {
                            return i
                        }
                        r.push(e);
                        return n
                    }
                    r.push(this.context);
                    t.put(this.context, 0);
                    while (true) {
                        let t = r.pop();
                        if (!t) {
                            break
                        }
                        for (let r = 0; r < t.size; r++) {
                            e += "  s" + getOrAddContext(t);
                            e += "->";
                            e += "s" + getOrAddContext(t.getParent(r));
                            e += '[label="' + t.getReturnState(r) + '"];\n'
                        }
                    }
                    e += "}\n";
                    return e.toString()
                }
                toString(e, t, r) {
                    if (r == null) {
                        r = t != null
                    }
                    if (t == null) {
                        t = true
                    }
                    let n = "";
                    let i;
                    if (r) {
                        i = this.context.toStrings(e, this.state.stateNumber)
                    } else {
                        i = ["?"]
                    }
                    let o = true;
                    for (let e of i) {
                        if (o) {
                            o = false
                        } else {
                            n += ", "
                        }
                        n += "(";
                        n += this.state;
                        if (t) {
                            n += ",";
                            n += this.alt
                        }
                        if (this.context) {
                            n += ",";
                            n += e
                        }
                        if (this.semanticContext !== c.SemanticContext.NONE) {
                            n += ",";
                            n += this.semanticContext
                        }
                        if (this.reachesIntoOuterContext) {
                            n += ",up=" + this.outerContextDepth
                        }
                        n += ")"
                    }
                    return n.toString()
                }
            };
            n([l.NotNull], f.prototype, "_state", void 0);
            n([l.NotNull], f.prototype, "_context", void 0);
            n([l.NotNull], f.prototype, "state", null);
            n([l.NotNull, i(0, l.NotNull)], f.prototype, "context", null);
            n([l.NotNull], f.prototype, "semanticContext", null);
            n([l.Override], f.prototype, "clone", null);
            n([i(0, l.NotNull), i(2, l.NotNull)], f.prototype, "transformImpl", null);
            n([l.Override], f.prototype, "equals", null);
            n([l.Override], f.prototype, "hashCode", null);
            n([i(0, l.NotNull), i(3, l.NotNull)], f, "create", null);
            f = n([i(0, l.NotNull), i(2, l.NotNull)], f);
            t.ATNConfig = f;
            let h = class SemanticContextATNConfig extends f {
                constructor(e, t, r, n) {
                    if (typeof r === "number") {
                        super(t, r, n)
                    } else {
                        super(t, r, n)
                    }
                    this._semanticContext = e
                }
                get semanticContext() {
                    return this._semanticContext
                }
            };
            n([l.NotNull], h.prototype, "_semanticContext", void 0);
            n([l.Override], h.prototype, "semanticContext", null);
            h = n([i(1, l.NotNull), i(2, l.NotNull)], h);
            let g = class ActionATNConfig extends f {
                constructor(e, t, r, n, i) {
                    if (typeof r === "number") {
                        super(t, r, n)
                    } else {
                        super(t, r, n);
                        if (r.semanticContext !== c.SemanticContext.NONE) {
                            throw new Error("Not supported")
                        }
                    }
                    this._lexerActionExecutor = e;
                    this.passedThroughNonGreedyDecision = i
                }
                get lexerActionExecutor() {
                    return this._lexerActionExecutor
                }
                get hasPassedThroughNonGreedyDecision() {
                    return this.passedThroughNonGreedyDecision
                }
            };
            n([l.Override], g.prototype, "lexerActionExecutor", null);
            n([l.Override], g.prototype, "hasPassedThroughNonGreedyDecision", null);
            g = n([i(1, l.NotNull), i(2, l.NotNull)], g);
            let m = class ActionSemanticContextATNConfig extends h {
                constructor(e, t, r, n, i, o) {
                    if (typeof n === "number") {
                        super(t, r, n, i)
                    } else {
                        super(t, r, n, i)
                    }
                    this._lexerActionExecutor = e;
                    this.passedThroughNonGreedyDecision = o
                }
                get lexerActionExecutor() {
                    return this._lexerActionExecutor
                }
                get hasPassedThroughNonGreedyDecision() {
                    return this.passedThroughNonGreedyDecision
                }
            };
            n([l.Override], m.prototype, "lexerActionExecutor", null);
            n([l.Override], m.prototype, "hasPassedThroughNonGreedyDecision", null);
            m = n([i(1, l.NotNull), i(2, l.NotNull)], m)
        },
        9576: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ATNConfigSet = void 0;
            const i = r(9605);
            const o = r(112);
            const s = r(8069);
            const a = r(7747);
            const l = r(1690);
            const _ = r(4980);
            const u = r(6966);
            const c = r(4880);
            const d = r(5047);
            const p = r(7545);
            const f = r(4806);
            const h = r(9491);
            const g = r(2925);
            class KeyTypeEqualityComparer {
                hashCode(e) {
                    return e.state ^ e.alt
                }
                equals(e, t) {
                    return e.state === t.state && e.alt === t.alt
                }
            }
            KeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer;

            function NewKeyedConfigMap(e) {
                if (e) {
                    return new i.Array2DHashMap(e)
                } else {
                    return new i.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE)
                }
            }
            class ATNConfigSet {
                constructor(e, t) {
                    this._uniqueAlt = 0;
                    this._hasSemanticContext = false;
                    this._dipsIntoOuterContext = false;
                    this.outermostConfigSet = false;
                    this.cachedHashCode = -1;
                    if (!e) {
                        this.mergedConfigs = NewKeyedConfigMap();
                        this.unmerged = [];
                        this.configs = [];
                        this._uniqueAlt = a.ATN.INVALID_ALT_NUMBER
                    } else {
                        if (t) {
                            this.mergedConfigs = undefined;
                            this.unmerged = undefined
                        } else if (!e.isReadOnly) {
                            this.mergedConfigs = NewKeyedConfigMap(e.mergedConfigs);
                            this.unmerged = e.unmerged.slice(0)
                        } else {
                            this.mergedConfigs = NewKeyedConfigMap();
                            this.unmerged = []
                        }
                        this.configs = e.configs.slice(0);
                        this._dipsIntoOuterContext = e._dipsIntoOuterContext;
                        this._hasSemanticContext = e._hasSemanticContext;
                        this.outermostConfigSet = e.outermostConfigSet;
                        if (t || !e.isReadOnly) {
                            this._uniqueAlt = e._uniqueAlt;
                            this._conflictInfo = e._conflictInfo
                        }
                    }
                }
                getRepresentedAlternatives() {
                    if (this._conflictInfo != null) {
                        return this._conflictInfo.conflictedAlts.clone()
                    }
                    let e = new _.BitSet;
                    for (let t of this) {
                        e.set(t.alt)
                    }
                    return e
                }
                get isReadOnly() {
                    return this.mergedConfigs == null
                }
                get isOutermostConfigSet() {
                    return this.outermostConfigSet
                }
                set isOutermostConfigSet(e) {
                    if (this.outermostConfigSet && !e) {
                        throw new Error("IllegalStateException")
                    }
                    h(!e || !this._dipsIntoOuterContext);
                    this.outermostConfigSet = e
                }
                getStates() {
                    let e = new o.Array2DHashSet(c.ObjectEqualityComparator.INSTANCE);
                    for (let t of this.configs) {
                        e.add(t.state)
                    }
                    return e
                }
                optimizeConfigs(e) {
                    if (this.configs.length === 0) {
                        return
                    }
                    for (let t of this.configs) {
                        t.context = e.atn.getCachedContext(t.context)
                    }
                }
                clone(e) {
                    let t = new ATNConfigSet(this, e);
                    if (!e && this.isReadOnly) {
                        t.addAll(this.configs)
                    }
                    return t
                }
                get size() {
                    return this.configs.length
                }
                get isEmpty() {
                    return this.configs.length === 0
                }
                contains(e) {
                    if (!(e instanceof l.ATNConfig)) {
                        return false
                    }
                    if (this.mergedConfigs && this.unmerged) {
                        let t = e;
                        let r = this.getKey(t);
                        let n = this.mergedConfigs.get(r);
                        if (n != null && this.canMerge(t, r, n)) {
                            return n.contains(t)
                        }
                        for (let t of this.unmerged) {
                            if (t.contains(e)) {
                                return true
                            }
                        }
                    } else {
                        for (let t of this.configs) {
                            if (t.contains(e)) {
                                return true
                            }
                        }
                    }
                    return false
                }*[Symbol.iterator]() {
                    yield* this.configs
                }
                toArray() {
                    return this.configs
                }
                add(e, t) {
                    this.ensureWritable();
                    if (!this.mergedConfigs || !this.unmerged) {
                        throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation")
                    }
                    h(!this.outermostConfigSet || !e.reachesIntoOuterContext);
                    if (t == null) {
                        t = p.PredictionContextCache.UNCACHED
                    }
                    let r;
                    let n = this.getKey(e);
                    let i = this.mergedConfigs.get(n);
                    r = i == null;
                    if (i != null && this.canMerge(e, n, i)) {
                        i.outerContextDepth = Math.max(i.outerContextDepth, e.outerContextDepth);
                        if (e.isPrecedenceFilterSuppressed) {
                            i.isPrecedenceFilterSuppressed = true
                        }
                        let r = d.PredictionContext.join(i.context, e.context, t);
                        this.updatePropertiesForMergedConfig(e);
                        if (i.context === r) {
                            return false
                        }
                        i.context = r;
                        return true
                    }
                    for (let i = 0; i < this.unmerged.length; i++) {
                        let o = this.unmerged[i];
                        if (this.canMerge(e, n, o)) {
                            o.outerContextDepth = Math.max(o.outerContextDepth, e.outerContextDepth);
                            if (e.isPrecedenceFilterSuppressed) {
                                o.isPrecedenceFilterSuppressed = true
                            }
                            let s = d.PredictionContext.join(o.context, e.context, t);
                            this.updatePropertiesForMergedConfig(e);
                            if (o.context === s) {
                                return false
                            }
                            o.context = s;
                            if (r) {
                                this.mergedConfigs.put(n, o);
                                this.unmerged.splice(i, 1)
                            }
                            return true
                        }
                    }
                    this.configs.push(e);
                    if (r) {
                        this.mergedConfigs.put(n, e)
                    } else {
                        this.unmerged.push(e)
                    }
                    this.updatePropertiesForAddedConfig(e);
                    return true
                }
                updatePropertiesForMergedConfig(e) {
                    this._dipsIntoOuterContext = this._dipsIntoOuterContext || e.reachesIntoOuterContext;
                    h(!this.outermostConfigSet || !this._dipsIntoOuterContext)
                }
                updatePropertiesForAddedConfig(e) {
                    if (this.configs.length === 1) {
                        this._uniqueAlt = e.alt
                    } else if (this._uniqueAlt !== e.alt) {
                        this._uniqueAlt = a.ATN.INVALID_ALT_NUMBER
                    }
                    this._hasSemanticContext = this._hasSemanticContext || !f.SemanticContext.NONE.equals(e.semanticContext);
                    this._dipsIntoOuterContext = this._dipsIntoOuterContext || e.reachesIntoOuterContext;
                    h(!this.outermostConfigSet || !this._dipsIntoOuterContext)
                }
                canMerge(e, t, r) {
                    if (e.state.stateNumber !== r.state.stateNumber) {
                        return false
                    }
                    if (t.alt !== r.alt) {
                        return false
                    }
                    return e.semanticContext.equals(r.semanticContext)
                }
                getKey(e) {
                    return {
                        state: e.state.stateNumber,
                        alt: e.alt
                    }
                }
                containsAll(e) {
                    for (let t of e) {
                        if (!(t instanceof l.ATNConfig)) {
                            return false
                        }
                        if (!this.contains(t)) {
                            return false
                        }
                    }
                    return true
                }
                addAll(e, t) {
                    this.ensureWritable();
                    let r = false;
                    for (let n of e) {
                        if (this.add(n, t)) {
                            r = true
                        }
                    }
                    return r
                }
                clear() {
                    this.ensureWritable();
                    if (!this.mergedConfigs || !this.unmerged) {
                        throw new Error("Covered by ensureWritable but duplicated here for strict null check limitation")
                    }
                    this.mergedConfigs.clear();
                    this.unmerged.length = 0;
                    this.configs.length = 0;
                    this._dipsIntoOuterContext = false;
                    this._hasSemanticContext = false;
                    this._uniqueAlt = a.ATN.INVALID_ALT_NUMBER;
                    this._conflictInfo = undefined
                }
                equals(e) {
                    if (this === e) {
                        return true
                    }
                    if (!(e instanceof ATNConfigSet)) {
                        return false
                    }
                    return this.outermostConfigSet === e.outermostConfigSet && g.equals(this._conflictInfo, e._conflictInfo) && s.ArrayEqualityComparator.INSTANCE.equals(this.configs, e.configs)
                }
                hashCode() {
                    if (this.isReadOnly && this.cachedHashCode !== -1) {
                        return this.cachedHashCode
                    }
                    let e = 1;
                    e = 5 * e ^ (this.outermostConfigSet ? 1 : 0);
                    e = 5 * e ^ s.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);
                    if (this.isReadOnly) {
                        this.cachedHashCode = e
                    }
                    return e
                }
                toString(e) {
                    if (e == null) {
                        e = false
                    }
                    let t = "";
                    let r = this.configs.slice(0);
                    r.sort(((e, t) => {
                        if (e.alt !== t.alt) {
                            return e.alt - t.alt
                        } else if (e.state.stateNumber !== t.state.stateNumber) {
                            return e.state.stateNumber - t.state.stateNumber
                        } else {
                            return e.semanticContext.toString().localeCompare(t.semanticContext.toString())
                        }
                    }));
                    t += "[";
                    for (let n = 0; n < r.length; n++) {
                        if (n > 0) {
                            t += ", "
                        }
                        t += r[n].toString(undefined, true, e)
                    }
                    t += "]";
                    if (this._hasSemanticContext) {
                        t += ",hasSemanticContext=" + this._hasSemanticContext
                    }
                    if (this._uniqueAlt !== a.ATN.INVALID_ALT_NUMBER) {
                        t += ",uniqueAlt=" + this._uniqueAlt
                    }
                    if (this._conflictInfo != null) {
                        t += ",conflictingAlts=" + this._conflictInfo.conflictedAlts;
                        if (!this._conflictInfo.isExact) {
                            t += "*"
                        }
                    }
                    if (this._dipsIntoOuterContext) {
                        t += ",dipsIntoOuterContext"
                    }
                    return t.toString()
                }
                get uniqueAlt() {
                    return this._uniqueAlt
                }
                get hasSemanticContext() {
                    return this._hasSemanticContext
                }
                set hasSemanticContext(e) {
                    this.ensureWritable();
                    this._hasSemanticContext = e
                }
                get conflictInfo() {
                    return this._conflictInfo
                }
                set conflictInfo(e) {
                    this.ensureWritable();
                    this._conflictInfo = e
                }
                get conflictingAlts() {
                    if (this._conflictInfo == null) {
                        return undefined
                    }
                    return this._conflictInfo.conflictedAlts
                }
                get isExactConflict() {
                    if (this._conflictInfo == null) {
                        return false
                    }
                    return this._conflictInfo.isExact
                }
                get dipsIntoOuterContext() {
                    return this._dipsIntoOuterContext
                }
                get(e) {
                    return this.configs[e]
                }
                ensureWritable() {
                    if (this.isReadOnly) {
                        throw new Error("This ATNConfigSet is read only.")
                    }
                }
            }
            n([u.NotNull], ATNConfigSet.prototype, "getRepresentedAlternatives", null);
            n([u.Override], ATNConfigSet.prototype, "size", null);
            n([u.Override], ATNConfigSet.prototype, "isEmpty", null);
            n([u.Override], ATNConfigSet.prototype, "contains", null);
            n([u.Override], ATNConfigSet.prototype, Symbol.iterator, null);
            n([u.Override], ATNConfigSet.prototype, "toArray", null);
            n([u.Override], ATNConfigSet.prototype, "containsAll", null);
            n([u.Override], ATNConfigSet.prototype, "clear", null);
            n([u.Override], ATNConfigSet.prototype, "equals", null);
            n([u.Override], ATNConfigSet.prototype, "hashCode", null);
            t.ATNConfigSet = ATNConfigSet
        },
        2832: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ATNDeserializationOptions = void 0;
            const i = r(6966);
            class ATNDeserializationOptions {
                constructor(e) {
                    this.readOnly = false;
                    if (e) {
                        this.verifyATN = e.verifyATN;
                        this.generateRuleBypassTransitions = e.generateRuleBypassTransitions;
                        this.optimize = e.optimize
                    } else {
                        this.verifyATN = true;
                        this.generateRuleBypassTransitions = false;
                        this.optimize = true
                    }
                }
                static get defaultOptions() {
                    if (ATNDeserializationOptions._defaultOptions == null) {
                        ATNDeserializationOptions._defaultOptions = new ATNDeserializationOptions;
                        ATNDeserializationOptions._defaultOptions.makeReadOnly()
                    }
                    return ATNDeserializationOptions._defaultOptions
                }
                get isReadOnly() {
                    return this.readOnly
                }
                makeReadOnly() {
                    this.readOnly = true
                }
                get isVerifyATN() {
                    return this.verifyATN
                }
                set isVerifyATN(e) {
                    this.throwIfReadOnly();
                    this.verifyATN = e
                }
                get isGenerateRuleBypassTransitions() {
                    return this.generateRuleBypassTransitions
                }
                set isGenerateRuleBypassTransitions(e) {
                    this.throwIfReadOnly();
                    this.generateRuleBypassTransitions = e
                }
                get isOptimize() {
                    return this.optimize
                }
                set isOptimize(e) {
                    this.throwIfReadOnly();
                    this.optimize = e
                }
                throwIfReadOnly() {
                    if (this.isReadOnly) {
                        throw new Error("The object is read only.")
                    }
                }
            }
            n([i.NotNull], ATNDeserializationOptions, "defaultOptions", null);
            t.ATNDeserializationOptions = ATNDeserializationOptions
        },
        6027: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ATNDeserializer = void 0;
            const o = r(4983);
            const s = r(112);
            const a = r(7747);
            const l = r(2832);
            const _ = r(1765);
            const u = r(583);
            const c = r(5285);
            const d = r(9151);
            const p = r(4980);
            const f = r(2948);
            const h = r(6039);
            const g = r(4402);
            const m = r(8878);
            const y = r(9050);
            const S = r(7108);
            const T = r(7833);
            const x = r(823);
            const C = r(6342);
            const N = r(7165);
            const A = r(3231);
            const E = r(2069);
            const v = r(9174);
            const M = r(829);
            const w = r(6407);
            const b = r(6994);
            const F = r(6966);
            const B = r(4063);
            const I = r(9851);
            const L = r(6198);
            const P = r(2389);
            const O = r(3148);
            const R = r(1652);
            const D = r(285);
            const k = r(612);
            const $ = r(8557);
            const j = r(7785);
            const U = r(5864);
            const Z = r(7989);
            const q = r(8146);
            const H = r(8734);
            const z = r(7528);
            const K = r(4562);
            const G = r(4316);
            const V = r(884);
            var W;
            (function(e) {
                e[e["UNICODE_BMP"] = 0] = "UNICODE_BMP";
                e[e["UNICODE_SMP"] = 1] = "UNICODE_SMP"
            })(W || (W = {}));
            class ATNDeserializer {
                constructor(e) {
                    if (e === undefined) {
                        e = l.ATNDeserializationOptions.defaultOptions
                    }
                    this.deserializationOptions = e
                }
                static get SERIALIZED_VERSION() {
                    return 3
                }
                static isFeatureSupported(e, t) {
                    let r = ATNDeserializer.SUPPORTED_UUIDS.findIndex((t => t.equals(e)));
                    if (r < 0) {
                        return false
                    }
                    return ATNDeserializer.SUPPORTED_UUIDS.findIndex((e => e.equals(t))) >= r
                }
                static getUnicodeDeserializer(e) {
                    if (e === 0) {
                        return {
                            readUnicode: (e, t) => ATNDeserializer.toInt(e[t]),
                            size: 1
                        }
                    } else {
                        return {
                            readUnicode: (e, t) => ATNDeserializer.toInt32(e, t),
                            size: 2
                        }
                    }
                }
                deserialize(e) {
                    e = e.slice(0);
                    for (let t = 1; t < e.length; t++) {
                        e[t] = e[t] - 2 & 65535
                    }
                    let t = 0;
                    let r = ATNDeserializer.toInt(e[t++]);
                    if (r !== ATNDeserializer.SERIALIZED_VERSION) {
                        let e = `Could not deserialize ATN with version ${r} (expected ${ATNDeserializer.SERIALIZED_VERSION}).`;
                        throw new Error(e)
                    }
                    let n = ATNDeserializer.toUUID(e, t);
                    t += 8;
                    if (ATNDeserializer.SUPPORTED_UUIDS.findIndex((e => e.equals(n))) < 0) {
                        let e = `Could not deserialize ATN with UUID ${n} (expected ${ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;
                        throw new Error(e)
                    }
                    let i = ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, n);
                    let l = ATNDeserializer.toInt(e[t++]);
                    let p = ATNDeserializer.toInt(e[t++]);
                    let g = new a.ATN(l, p);
                    let S = [];
                    let x = [];
                    let N = ATNDeserializer.toInt(e[t++]);
                    for (let r = 0; r < N; r++) {
                        let r = ATNDeserializer.toInt(e[t++]);
                        if (r === _.ATNStateType.INVALID_TYPE) {
                            g.addState(new T.InvalidState);
                            continue
                        }
                        let n = ATNDeserializer.toInt(e[t++]);
                        if (n === 65535) {
                            n = -1
                        }
                        let i = this.stateFactory(r, n);
                        if (r === _.ATNStateType.LOOP_END) {
                            let r = ATNDeserializer.toInt(e[t++]);
                            S.push([i, r])
                        } else if (i instanceof h.BlockStartState) {
                            let r = ATNDeserializer.toInt(e[t++]);
                            x.push([i, r])
                        }
                        g.addState(i)
                    }
                    for (let e of S) {
                        e[0].loopBackState = g.states[e[1]]
                    }
                    for (let e of x) {
                        e[0].endState = g.states[e[1]]
                    }
                    let A = ATNDeserializer.toInt(e[t++]);
                    for (let r = 0; r < A; r++) {
                        let r = ATNDeserializer.toInt(e[t++]);
                        g.states[r].nonGreedy = true
                    }
                    let E = ATNDeserializer.toInt(e[t++]);
                    for (let r = 0; r < E; r++) {
                        let r = ATNDeserializer.toInt(e[t++]);
                        g.states[r].sll = true
                    }
                    let v = ATNDeserializer.toInt(e[t++]);
                    for (let r = 0; r < v; r++) {
                        let r = ATNDeserializer.toInt(e[t++]);
                        g.states[r].isPrecedenceRule = true
                    }
                    let M = ATNDeserializer.toInt(e[t++]);
                    if (g.grammarType === 0) {
                        g.ruleToTokenType = new Int32Array(M)
                    }
                    g.ruleToStartState = new Array(M);
                    for (let r = 0; r < M; r++) {
                        let i = ATNDeserializer.toInt(e[t++]);
                        let o = g.states[i];
                        o.leftFactored = ATNDeserializer.toInt(e[t++]) !== 0;
                        g.ruleToStartState[r] = o;
                        if (g.grammarType === 0) {
                            let i = ATNDeserializer.toInt(e[t++]);
                            if (i === 65535) {
                                i = z.Token.EOF
                            }
                            g.ruleToTokenType[r] = i;
                            if (!ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, n)) {
                                let r = ATNDeserializer.toInt(e[t++]);
                                if (r === 65535) {
                                    r = -1
                                }
                            }
                        }
                    }
                    g.ruleToStopState = new Array(M);
                    for (let e of g.states) {
                        if (!(e instanceof $.RuleStopState)) {
                            continue
                        }
                        g.ruleToStopState[e.ruleIndex] = e;
                        g.ruleToStartState[e.ruleIndex].stopState = e
                    }
                    let w = ATNDeserializer.toInt(e[t++]);
                    for (let r = 0; r < w; r++) {
                        let r = ATNDeserializer.toInt(e[t++]);
                        g.modeToStartState.push(g.states[r])
                    }
                    g.modeToDFA = new Array(w);
                    for (let e = 0; e < w; e++) {
                        g.modeToDFA[e] = new m.DFA(g.modeToStartState[e])
                    }
                    let F = [];
                    t = this.deserializeSets(e, t, F, ATNDeserializer.getUnicodeDeserializer(0));
                    if (ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_UNICODE_SMP, n)) {
                        t = this.deserializeSets(e, t, F, ATNDeserializer.getUnicodeDeserializer(1))
                    }
                    let B = ATNDeserializer.toInt(e[t++]);
                    for (let r = 0; r < B; r++) {
                        let r = ATNDeserializer.toInt(e[t]);
                        let n = ATNDeserializer.toInt(e[t + 1]);
                        let i = ATNDeserializer.toInt(e[t + 2]);
                        let o = ATNDeserializer.toInt(e[t + 3]);
                        let s = ATNDeserializer.toInt(e[t + 4]);
                        let a = ATNDeserializer.toInt(e[t + 5]);
                        let l = this.edgeFactory(g, i, r, n, o, s, a, F);
                        let _ = g.states[r];
                        _.addTransition(l);
                        t += 6
                    }
                    let I = new s.Array2DHashSet({
                        hashCode: e => e.stopState ^ e.returnState ^ e.outermostPrecedenceReturn,
                        equals: (e, t) => e.stopState === t.stopState && e.returnState === t.returnState && e.outermostPrecedenceReturn === t.outermostPrecedenceReturn
                    });
                    let O = [];
                    for (let e of g.states) {
                        let t = e.ruleIndex >= 0 && g.ruleToStartState[e.ruleIndex].leftFactored;
                        for (let r = 0; r < e.numberOfTransitions; r++) {
                            let n = e.transition(r);
                            if (!(n instanceof j.RuleTransition)) {
                                continue
                            }
                            let i = n;
                            let o = g.ruleToStartState[i.target.ruleIndex].leftFactored;
                            if (!o && t) {
                                continue
                            }
                            let s = -1;
                            if (g.ruleToStartState[i.target.ruleIndex].isPrecedenceRule) {
                                if (i.precedence === 0) {
                                    s = i.target.ruleIndex
                                }
                            }
                            let a = {
                                stopState: i.target.ruleIndex,
                                returnState: i.followState.stateNumber,
                                outermostPrecedenceReturn: s
                            };
                            if (I.add(a)) {
                                O.push(a)
                            }
                        }
                    }
                    for (let e of O) {
                        let t = new y.EpsilonTransition(g.states[e.returnState], e.outermostPrecedenceReturn);
                        g.ruleToStopState[e.stopState].addTransition(t)
                    }
                    for (let e of g.states) {
                        if (e instanceof h.BlockStartState) {
                            if (e.endState === undefined) {
                                throw new Error("IllegalStateException")
                            }
                            if (e.endState.startState !== undefined) {
                                throw new Error("IllegalStateException")
                            }
                            e.endState.startState = e
                        }
                        if (e instanceof P.PlusLoopbackState) {
                            let t = e;
                            for (let e = 0; e < t.numberOfTransitions; e++) {
                                let r = t.transition(e).target;
                                if (r instanceof L.PlusBlockStartState) {
                                    r.loopBackState = t
                                }
                            }
                        } else if (e instanceof q.StarLoopbackState) {
                            let t = e;
                            for (let e = 0; e < t.numberOfTransitions; e++) {
                                let r = t.transition(e).target;
                                if (r instanceof H.StarLoopEntryState) {
                                    r.loopBackState = t
                                }
                            }
                        }
                    }
                    let R = ATNDeserializer.toInt(e[t++]);
                    for (let r = 1; r <= R; r++) {
                        let n = ATNDeserializer.toInt(e[t++]);
                        let i = g.states[n];
                        g.decisionToState.push(i);
                        i.decision = r - 1
                    }
                    if (g.grammarType === 0) {
                        if (i) {
                            g.lexerActions = new Array(ATNDeserializer.toInt(e[t++]));
                            for (let r = 0; r < g.lexerActions.length; r++) {
                                let n = ATNDeserializer.toInt(e[t++]);
                                let i = ATNDeserializer.toInt(e[t++]);
                                if (i === 65535) {
                                    i = -1
                                }
                                let o = ATNDeserializer.toInt(e[t++]);
                                if (o === 65535) {
                                    o = -1
                                }
                                let s = this.lexerActionFactory(n, i, o);
                                g.lexerActions[r] = s
                            }
                        } else {
                            let e = [];
                            for (let t of g.states) {
                                for (let r = 0; r < t.numberOfTransitions; r++) {
                                    let n = t.transition(r);
                                    if (!(n instanceof o.ActionTransition)) {
                                        continue
                                    }
                                    let i = n.ruleIndex;
                                    let s = n.actionIndex;
                                    let a = new C.LexerCustomAction(i, s);
                                    t.setTransition(r, new o.ActionTransition(n.target, i, e.length, false));
                                    e.push(a)
                                }
                            }
                            g.lexerActions = e
                        }
                    }
                    this.markPrecedenceDecisions(g);
                    g.decisionToDFA = new Array(R);
                    for (let e = 0; e < R; e++) {
                        g.decisionToDFA[e] = new m.DFA(g.decisionToState[e], e)
                    }
                    if (this.deserializationOptions.isVerifyATN) {
                        this.verifyATN(g)
                    }
                    if (this.deserializationOptions.isGenerateRuleBypassTransitions && g.grammarType === 1) {
                        g.ruleToTokenType = new Int32Array(g.ruleToStartState.length);
                        for (let e = 0; e < g.ruleToStartState.length; e++) {
                            g.ruleToTokenType[e] = g.maxTokenType + e + 1
                        }
                        for (let e = 0; e < g.ruleToStartState.length; e++) {
                            let t = new c.BasicBlockStartState;
                            t.ruleIndex = e;
                            g.addState(t);
                            let r = new f.BlockEndState;
                            r.ruleIndex = e;
                            g.addState(r);
                            t.endState = r;
                            g.defineDecisionState(t);
                            r.startState = t;
                            let n;
                            let i;
                            if (g.ruleToStartState[e].isPrecedenceRule) {
                                n = undefined;
                                for (let t of g.states) {
                                    if (t.ruleIndex !== e) {
                                        continue
                                    }
                                    if (!(t instanceof H.StarLoopEntryState)) {
                                        continue
                                    }
                                    let r = t.transition(t.numberOfTransitions - 1).target;
                                    if (!(r instanceof b.LoopEndState)) {
                                        continue
                                    }
                                    if (r.epsilonOnlyTransitions && r.transition(0).target instanceof $.RuleStopState) {
                                        n = t;
                                        break
                                    }
                                }
                                if (!n) {
                                    throw new Error("Couldn't identify final state of the precedence rule prefix section.")
                                }
                                i = n.loopBackState.transition(0)
                            } else {
                                n = g.ruleToStopState[e]
                            }
                            for (let e of g.states) {
                                for (let t = 0; t < e.numberOfTransitions; t++) {
                                    let o = e.transition(t);
                                    if (o === i) {
                                        continue
                                    }
                                    if (o.target === n) {
                                        o.target = r
                                    }
                                }
                            }
                            while (g.ruleToStartState[e].numberOfTransitions > 0) {
                                let r = g.ruleToStartState[e].removeTransition(g.ruleToStartState[e].numberOfTransitions - 1);
                                t.addTransition(r)
                            }
                            g.ruleToStartState[e].addTransition(new y.EpsilonTransition(t));
                            r.addTransition(new y.EpsilonTransition(n));
                            let o = new d.BasicState;
                            g.addState(o);
                            o.addTransition(new u.AtomTransition(r, g.ruleToTokenType[e]));
                            t.addTransition(new y.EpsilonTransition(o))
                        }
                        if (this.deserializationOptions.isVerifyATN) {
                            this.verifyATN(g)
                        }
                    }
                    if (this.deserializationOptions.isOptimize) {
                        while (true) {
                            let e = 0;
                            e += ATNDeserializer.inlineSetRules(g);
                            e += ATNDeserializer.combineChainedEpsilons(g);
                            let t = g.grammarType === 0;
                            e += ATNDeserializer.optimizeSets(g, t);
                            if (e === 0) {
                                break
                            }
                        }
                        if (this.deserializationOptions.isVerifyATN) {
                            this.verifyATN(g)
                        }
                    }
                    ATNDeserializer.identifyTailCalls(g);
                    return g
                }
                deserializeSets(e, t, r, n) {
                    let i = ATNDeserializer.toInt(e[t++]);
                    for (let o = 0; o < i; o++) {
                        let i = ATNDeserializer.toInt(e[t]);
                        t++;
                        let o = new S.IntervalSet;
                        r.push(o);
                        let s = ATNDeserializer.toInt(e[t++]) !== 0;
                        if (s) {
                            o.add(-1)
                        }
                        for (let r = 0; r < i; r++) {
                            let r = n.readUnicode(e, t);
                            t += n.size;
                            let i = n.readUnicode(e, t);
                            t += n.size;
                            o.add(r, i)
                        }
                    }
                    return t
                }
                markPrecedenceDecisions(e) {
                    let t = new Map;
                    for (let r of e.states) {
                        if (!(r instanceof H.StarLoopEntryState)) {
                            continue
                        }
                        if (e.ruleToStartState[r.ruleIndex].isPrecedenceRule) {
                            let n = r.transition(r.numberOfTransitions - 1).target;
                            if (n instanceof b.LoopEndState) {
                                if (n.epsilonOnlyTransitions && n.transition(0).target instanceof $.RuleStopState) {
                                    t.set(r.ruleIndex, r);
                                    r.precedenceRuleDecision = true;
                                    r.precedenceLoopbackStates = new p.BitSet(e.states.length)
                                }
                            }
                        }
                    }
                    for (let r of t) {
                        for (let t of e.ruleToStopState[r[0]].getTransitions()) {
                            if (t.serializationType !== 1) {
                                continue
                            }
                            let e = t;
                            if (e.outermostPrecedenceReturn !== -1) {
                                continue
                            }
                            r[1].precedenceLoopbackStates.set(t.target.stateNumber)
                        }
                    }
                }
                verifyATN(e) {
                    for (let t of e.states) {
                        this.checkCondition(t !== undefined, "ATN states should not be undefined.");
                        if (t.stateType === _.ATNStateType.INVALID_TYPE) {
                            continue
                        }
                        this.checkCondition(t.onlyHasEpsilonTransitions || t.numberOfTransitions <= 1);
                        if (t instanceof L.PlusBlockStartState) {
                            this.checkCondition(t.loopBackState !== undefined)
                        }
                        if (t instanceof H.StarLoopEntryState) {
                            let e = t;
                            this.checkCondition(e.loopBackState !== undefined);
                            this.checkCondition(e.numberOfTransitions === 2);
                            if (e.transition(0).target instanceof Z.StarBlockStartState) {
                                this.checkCondition(e.transition(1).target instanceof b.LoopEndState);
                                this.checkCondition(!e.nonGreedy)
                            } else if (e.transition(0).target instanceof b.LoopEndState) {
                                this.checkCondition(e.transition(1).target instanceof Z.StarBlockStartState);
                                this.checkCondition(e.nonGreedy)
                            } else {
                                throw new Error("IllegalStateException")
                            }
                        }
                        if (t instanceof q.StarLoopbackState) {
                            this.checkCondition(t.numberOfTransitions === 1);
                            this.checkCondition(t.transition(0).target instanceof H.StarLoopEntryState)
                        }
                        if (t instanceof b.LoopEndState) {
                            this.checkCondition(t.loopBackState !== undefined)
                        }
                        if (t instanceof k.RuleStartState) {
                            this.checkCondition(t.stopState !== undefined)
                        }
                        if (t instanceof h.BlockStartState) {
                            this.checkCondition(t.endState !== undefined)
                        }
                        if (t instanceof f.BlockEndState) {
                            this.checkCondition(t.startState !== undefined)
                        }
                        if (t instanceof g.DecisionState) {
                            let e = t;
                            this.checkCondition(e.numberOfTransitions <= 1 || e.decision >= 0)
                        } else {
                            this.checkCondition(t.numberOfTransitions <= 1 || t instanceof $.RuleStopState)
                        }
                    }
                }
                checkCondition(e, t) {
                    if (!e) {
                        throw new Error("IllegalStateException: " + t)
                    }
                }
                static inlineSetRules(e) {
                    let t = 0;
                    let r = new Array(e.ruleToStartState.length);
                    for (let t = 0; t < e.ruleToStartState.length; t++) {
                        let n = e.ruleToStartState[t];
                        let i = n;
                        while (i.onlyHasEpsilonTransitions && i.numberOfOptimizedTransitions === 1 && i.getOptimizedTransition(0).serializationType === 1) {
                            i = i.getOptimizedTransition(0).target
                        }
                        if (i.numberOfOptimizedTransitions !== 1) {
                            continue
                        }
                        let o = i.getOptimizedTransition(0);
                        let s = o.target;
                        if (o.isEpsilon || !s.onlyHasEpsilonTransitions || s.numberOfOptimizedTransitions !== 1 || !(s.getOptimizedTransition(0).target instanceof $.RuleStopState)) {
                            continue
                        }
                        switch (o.serializationType) {
                            case 5:
                            case 2:
                            case 7:
                                r[t] = o;
                                break;
                            case 8:
                            case 9:
                                continue;
                            default:
                                continue
                        }
                    }
                    for (let n of e.states) {
                        if (n.ruleIndex < 0) {
                            continue
                        }
                        let i;
                        for (let o = 0; o < n.numberOfOptimizedTransitions; o++) {
                            let s = n.getOptimizedTransition(o);
                            if (!(s instanceof j.RuleTransition)) {
                                if (i !== undefined) {
                                    i.push(s)
                                }
                                continue
                            }
                            let a = s;
                            let l = r[a.target.ruleIndex];
                            if (l === undefined) {
                                if (i !== undefined) {
                                    i.push(s)
                                }
                                continue
                            }
                            if (i === undefined) {
                                i = [];
                                for (let e = 0; e < o; e++) {
                                    i.push(n.getOptimizedTransition(o))
                                }
                            }
                            t++;
                            let _ = a.followState;
                            let c = new d.BasicState;
                            c.setRuleIndex(_.ruleIndex);
                            e.addState(c);
                            i.push(new y.EpsilonTransition(c));
                            switch (l.serializationType) {
                                case 5:
                                    c.addTransition(new u.AtomTransition(_, l._label));
                                    break;
                                case 2:
                                    c.addTransition(new D.RangeTransition(_, l.from, l.to));
                                    break;
                                case 7:
                                    c.addTransition(new U.SetTransition(_, l.label));
                                    break;
                                default:
                                    throw new Error("UnsupportedOperationException")
                            }
                        }
                        if (i !== undefined) {
                            if (n.isOptimized) {
                                while (n.numberOfOptimizedTransitions > 0) {
                                    n.removeOptimizedTransition(n.numberOfOptimizedTransitions - 1)
                                }
                            }
                            for (let e of i) {
                                n.addOptimizedTransition(e)
                            }
                        }
                    }
                    if (I.ParserATNSimulator.debug) {
                        console.log("ATN runtime optimizer removed " + t + " rule invocations by inlining sets.")
                    }
                    return t
                }
                static combineChainedEpsilons(e) {
                    let t = 0;
                    for (let r of e.states) {
                        if (!r.onlyHasEpsilonTransitions || r instanceof $.RuleStopState) {
                            continue
                        }
                        let e;
                        e: for (let n = 0; n < r.numberOfOptimizedTransitions; n++) {
                            let i = r.getOptimizedTransition(n);
                            let o = i.target;
                            if (i.serializationType !== 1 || i.outermostPrecedenceReturn !== -1 || o.stateType !== _.ATNStateType.BASIC || !o.onlyHasEpsilonTransitions) {
                                if (e !== undefined) {
                                    e.push(i)
                                }
                                continue e
                            }
                            for (let t = 0; t < o.numberOfOptimizedTransitions; t++) {
                                if (o.getOptimizedTransition(t).serializationType !== 1 || o.getOptimizedTransition(t).outermostPrecedenceReturn !== -1) {
                                    if (e !== undefined) {
                                        e.push(i)
                                    }
                                    continue e
                                }
                            }
                            t++;
                            if (e === undefined) {
                                e = [];
                                for (let t = 0; t < n; t++) {
                                    e.push(r.getOptimizedTransition(t))
                                }
                            }
                            for (let t = 0; t < o.numberOfOptimizedTransitions; t++) {
                                let r = o.getOptimizedTransition(t).target;
                                e.push(new y.EpsilonTransition(r))
                            }
                        }
                        if (e !== undefined) {
                            if (r.isOptimized) {
                                while (r.numberOfOptimizedTransitions > 0) {
                                    r.removeOptimizedTransition(r.numberOfOptimizedTransitions - 1)
                                }
                            }
                            for (let t of e) {
                                r.addOptimizedTransition(t)
                            }
                        }
                    }
                    if (I.ParserATNSimulator.debug) {
                        console.log("ATN runtime optimizer removed " + t + " transitions by combining chained epsilon transitions.")
                    }
                    return t
                }
                static optimizeSets(e, t) {
                    if (t) {
                        return 0
                    }
                    let r = 0;
                    let n = e.decisionToState;
                    for (let t of n) {
                        let n = new S.IntervalSet;
                        for (let e = 0; e < t.numberOfOptimizedTransitions; e++) {
                            let r = t.getOptimizedTransition(e);
                            if (!(r instanceof y.EpsilonTransition)) {
                                continue
                            }
                            if (r.target.numberOfOptimizedTransitions !== 1) {
                                continue
                            }
                            let i = r.target.getOptimizedTransition(0);
                            if (!(i.target instanceof f.BlockEndState)) {
                                continue
                            }
                            if (i instanceof B.NotSetTransition) {
                                continue
                            }
                            if (i instanceof u.AtomTransition || i instanceof D.RangeTransition || i instanceof U.SetTransition) {
                                n.add(e)
                            }
                        }
                        if (n.size <= 1) {
                            continue
                        }
                        let i = [];
                        for (let e = 0; e < t.numberOfOptimizedTransitions; e++) {
                            if (!n.contains(e)) {
                                i.push(t.getOptimizedTransition(e))
                            }
                        }
                        let o = t.getOptimizedTransition(n.minElement).target.getOptimizedTransition(0).target;
                        let s = new S.IntervalSet;
                        for (let e of n.intervals) {
                            for (let r = e.a; r <= e.b; r++) {
                                let e = t.getOptimizedTransition(r).target.getOptimizedTransition(0);
                                if (e instanceof B.NotSetTransition) {
                                    throw new Error("Not yet implemented.")
                                } else {
                                    s.addAll(e.label)
                                }
                            }
                        }
                        let a;
                        if (s.intervals.length === 1) {
                            if (s.size === 1) {
                                a = new u.AtomTransition(o, s.minElement)
                            } else {
                                let e = s.intervals[0];
                                a = new D.RangeTransition(o, e.a, e.b)
                            }
                        } else {
                            a = new U.SetTransition(o, s)
                        }
                        let l = new d.BasicState;
                        l.setRuleIndex(t.ruleIndex);
                        e.addState(l);
                        l.addTransition(a);
                        i.push(new y.EpsilonTransition(l));
                        r += t.numberOfOptimizedTransitions - i.length;
                        if (t.isOptimized) {
                            while (t.numberOfOptimizedTransitions > 0) {
                                t.removeOptimizedTransition(t.numberOfOptimizedTransitions - 1)
                            }
                        }
                        for (let e of i) {
                            t.addOptimizedTransition(e)
                        }
                    }
                    if (I.ParserATNSimulator.debug) {
                        console.log("ATN runtime optimizer removed " + r + " paths by collapsing sets.")
                    }
                    return r
                }
                static identifyTailCalls(e) {
                    for (let t of e.states) {
                        for (let r = 0; r < t.numberOfTransitions; r++) {
                            let n = t.transition(r);
                            if (!(n instanceof j.RuleTransition)) {
                                continue
                            }
                            n.tailCall = this.testTailCall(e, n, false);
                            n.optimizedTailCall = this.testTailCall(e, n, true)
                        }
                        if (!t.isOptimized) {
                            continue
                        }
                        for (let r = 0; r < t.numberOfOptimizedTransitions; r++) {
                            let n = t.getOptimizedTransition(r);
                            if (!(n instanceof j.RuleTransition)) {
                                continue
                            }
                            n.tailCall = this.testTailCall(e, n, false);
                            n.optimizedTailCall = this.testTailCall(e, n, true)
                        }
                    }
                }
                static testTailCall(e, t, r) {
                    if (!r && t.tailCall) {
                        return true
                    }
                    if (r && t.optimizedTailCall) {
                        return true
                    }
                    let n = new p.BitSet(e.states.length);
                    let i = [];
                    i.push(t.followState);
                    while (true) {
                        let e = i.pop();
                        if (!e) {
                            break
                        }
                        if (n.get(e.stateNumber)) {
                            continue
                        }
                        if (e instanceof $.RuleStopState) {
                            continue
                        }
                        if (!e.onlyHasEpsilonTransitions) {
                            return false
                        }
                        let t = r ? e.numberOfOptimizedTransitions : e.numberOfTransitions;
                        for (let n = 0; n < t; n++) {
                            let t = r ? e.getOptimizedTransition(n) : e.transition(n);
                            if (t.serializationType !== 1) {
                                return false
                            }
                            i.push(t.target)
                        }
                    }
                    return true
                }
                static toInt(e) {
                    return e
                }
                static toInt32(e, t) {
                    return (e[t] | e[t + 1] << 16) >>> 0
                }
                static toUUID(e, t) {
                    let r = ATNDeserializer.toInt32(e, t);
                    let n = ATNDeserializer.toInt32(e, t + 2);
                    let i = ATNDeserializer.toInt32(e, t + 4);
                    let o = ATNDeserializer.toInt32(e, t + 6);
                    return new G.UUID(o, i, n, r)
                }
                edgeFactory(e, t, r, n, i, s, a, l) {
                    let _ = e.states[n];
                    switch (t) {
                        case 1:
                            return new y.EpsilonTransition(_);
                        case 2:
                            if (a !== 0) {
                                return new D.RangeTransition(_, z.Token.EOF, s)
                            } else {
                                return new D.RangeTransition(_, i, s)
                            }
                            case 3:
                                let t = new j.RuleTransition(e.states[i], s, a, _);
                                return t;
                            case 4:
                                let r = new R.PredicateTransition(_, i, s, a !== 0);
                                return r;
                            case 10:
                                return new O.PrecedencePredicateTransition(_, i);
                            case 5:
                                if (a !== 0) {
                                    return new u.AtomTransition(_, z.Token.EOF)
                                } else {
                                    return new u.AtomTransition(_, i)
                                }
                                case 6:
                                    let n = new o.ActionTransition(_, i, s, a !== 0);
                                    return n;
                                case 7:
                                    return new U.SetTransition(_, l[i]);
                                case 8:
                                    return new B.NotSetTransition(_, l[i]);
                                case 9:
                                    return new V.WildcardTransition(_)
                    }
                    throw new Error("The specified transition type is not valid.")
                }
                stateFactory(e, t) {
                    let r;
                    switch (e) {
                        case _.ATNStateType.INVALID_TYPE:
                            return new T.InvalidState;
                        case _.ATNStateType.BASIC:
                            r = new d.BasicState;
                            break;
                        case _.ATNStateType.RULE_START:
                            r = new k.RuleStartState;
                            break;
                        case _.ATNStateType.BLOCK_START:
                            r = new c.BasicBlockStartState;
                            break;
                        case _.ATNStateType.PLUS_BLOCK_START:
                            r = new L.PlusBlockStartState;
                            break;
                        case _.ATNStateType.STAR_BLOCK_START:
                            r = new Z.StarBlockStartState;
                            break;
                        case _.ATNStateType.TOKEN_START:
                            r = new K.TokensStartState;
                            break;
                        case _.ATNStateType.RULE_STOP:
                            r = new $.RuleStopState;
                            break;
                        case _.ATNStateType.BLOCK_END:
                            r = new f.BlockEndState;
                            break;
                        case _.ATNStateType.STAR_LOOP_BACK:
                            r = new q.StarLoopbackState;
                            break;
                        case _.ATNStateType.STAR_LOOP_ENTRY:
                            r = new H.StarLoopEntryState;
                            break;
                        case _.ATNStateType.PLUS_LOOP_BACK:
                            r = new P.PlusLoopbackState;
                            break;
                        case _.ATNStateType.LOOP_END:
                            r = new b.LoopEndState;
                            break;
                        default:
                            let t = `The specified state type ${e} is not valid.`;
                            throw new Error(t)
                    }
                    r.ruleIndex = t;
                    return r
                }
                lexerActionFactory(e, t, r) {
                    switch (e) {
                        case 0:
                            return new x.LexerChannelAction(t);
                        case 1:
                            return new C.LexerCustomAction(t, r);
                        case 2:
                            return new N.LexerModeAction(t);
                        case 3:
                            return A.LexerMoreAction.INSTANCE;
                        case 4:
                            return E.LexerPopModeAction.INSTANCE;
                        case 5:
                            return new v.LexerPushModeAction(t);
                        case 6:
                            return M.LexerSkipAction.INSTANCE;
                        case 7:
                            return new w.LexerTypeAction(t);
                        default:
                            let n = `The specified lexer action type ${e} is not valid.`;
                            throw new Error(n)
                    }
                }
            }
            ATNDeserializer.BASE_SERIALIZED_UUID = G.UUID.fromString("E4178468-DF95-44D0-AD87-F22A5D5FB6D3");
            ATNDeserializer.ADDED_LEXER_ACTIONS = G.UUID.fromString("AB35191A-1603-487E-B75A-479B831EAF6D");
            ATNDeserializer.ADDED_UNICODE_SMP = G.UUID.fromString("C23FEA89-0605-4f51-AFB8-058BCAB8C91B");
            ATNDeserializer.SUPPORTED_UUIDS = [ATNDeserializer.BASE_SERIALIZED_UUID, ATNDeserializer.ADDED_LEXER_ACTIONS, ATNDeserializer.ADDED_UNICODE_SMP];
            ATNDeserializer.SERIALIZED_UUID = ATNDeserializer.ADDED_UNICODE_SMP;
            n([F.NotNull], ATNDeserializer.prototype, "deserializationOptions", void 0);
            n([i(0, F.NotNull)], ATNDeserializer.prototype, "deserialize", null);
            n([i(0, F.NotNull)], ATNDeserializer.prototype, "markPrecedenceDecisions", null);
            n([F.NotNull, i(0, F.NotNull)], ATNDeserializer.prototype, "edgeFactory", null);
            t.ATNDeserializer = ATNDeserializer
        },
        9336: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ATNSimulator = void 0;
            const o = r(9576);
            const s = r(5149);
            const a = r(6966);
            const l = r(5047);
            let _ = class ATNSimulator {
                constructor(e) {
                    this.atn = e
                }
                static get ERROR() {
                    if (!ATNSimulator._ERROR) {
                        ATNSimulator._ERROR = new s.DFAState(new o.ATNConfigSet);
                        ATNSimulator._ERROR.stateNumber = l.PredictionContext.EMPTY_FULL_STATE_KEY
                    }
                    return ATNSimulator._ERROR
                }
                clearDFA() {
                    this.atn.clearDFA()
                }
            };
            n([a.NotNull], _.prototype, "atn", void 0);
            n([a.NotNull], _, "ERROR", null);
            _ = n([i(0, a.NotNull)], _);
            t.ATNSimulator = _;
            (function(e) {
                const t = "$";
                const r = "$lf$";
                const n = "$nolf$"
            })(_ = t.ATNSimulator || (t.ATNSimulator = {}));
            t.ATNSimulator = _
        },
        2210: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ATNState = void 0;
            const i = r(6966);
            const o = 4;
            class ATNState {
                constructor() {
                    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
                    this.ruleIndex = 0;
                    this.epsilonOnlyTransitions = false;
                    this.transitions = [];
                    this.optimizedTransitions = this.transitions
                }
                getStateNumber() {
                    return this.stateNumber
                }
                get nonStopStateNumber() {
                    return this.getStateNumber()
                }
                hashCode() {
                    return this.stateNumber
                }
                equals(e) {
                    if (e instanceof ATNState) {
                        return this.stateNumber === e.stateNumber
                    }
                    return false
                }
                get isNonGreedyExitState() {
                    return false
                }
                toString() {
                    return String(this.stateNumber)
                }
                getTransitions() {
                    return this.transitions.slice(0)
                }
                get numberOfTransitions() {
                    return this.transitions.length
                }
                addTransition(e, t) {
                    if (this.transitions.length === 0) {
                        this.epsilonOnlyTransitions = e.isEpsilon
                    } else if (this.epsilonOnlyTransitions !== e.isEpsilon) {
                        this.epsilonOnlyTransitions = false;
                        throw new Error("ATN state " + this.stateNumber + " has both epsilon and non-epsilon transitions.")
                    }
                    this.transitions.splice(t !== undefined ? t : this.transitions.length, 0, e)
                }
                transition(e) {
                    return this.transitions[e]
                }
                setTransition(e, t) {
                    this.transitions[e] = t
                }
                removeTransition(e) {
                    return this.transitions.splice(e, 1)[0]
                }
                get onlyHasEpsilonTransitions() {
                    return this.epsilonOnlyTransitions
                }
                setRuleIndex(e) {
                    this.ruleIndex = e
                }
                get isOptimized() {
                    return this.optimizedTransitions !== this.transitions
                }
                get numberOfOptimizedTransitions() {
                    return this.optimizedTransitions.length
                }
                getOptimizedTransition(e) {
                    return this.optimizedTransitions[e]
                }
                addOptimizedTransition(e) {
                    if (!this.isOptimized) {
                        this.optimizedTransitions = new Array
                    }
                    this.optimizedTransitions.push(e)
                }
                setOptimizedTransition(e, t) {
                    if (!this.isOptimized) {
                        throw new Error("This ATNState is not optimized.")
                    }
                    this.optimizedTransitions[e] = t
                }
                removeOptimizedTransition(e) {
                    if (!this.isOptimized) {
                        throw new Error("This ATNState is not optimized.")
                    }
                    this.optimizedTransitions.splice(e, 1)
                }
            }
            n([i.Override], ATNState.prototype, "hashCode", null);
            n([i.Override], ATNState.prototype, "equals", null);
            n([i.Override], ATNState.prototype, "toString", null);
            t.ATNState = ATNState;
            (function(e) {
                e.INVALID_STATE_NUMBER = -1
            })(ATNState = t.ATNState || (t.ATNState = {}))
        },
        1765: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ATNStateType = void 0;
            var r;
            (function(e) {
                e[e["INVALID_TYPE"] = 0] = "INVALID_TYPE";
                e[e["BASIC"] = 1] = "BASIC";
                e[e["RULE_START"] = 2] = "RULE_START";
                e[e["BLOCK_START"] = 3] = "BLOCK_START";
                e[e["PLUS_BLOCK_START"] = 4] = "PLUS_BLOCK_START";
                e[e["STAR_BLOCK_START"] = 5] = "STAR_BLOCK_START";
                e[e["TOKEN_START"] = 6] = "TOKEN_START";
                e[e["RULE_STOP"] = 7] = "RULE_STOP";
                e[e["BLOCK_END"] = 8] = "BLOCK_END";
                e[e["STAR_LOOP_BACK"] = 9] = "STAR_LOOP_BACK";
                e[e["STAR_LOOP_ENTRY"] = 10] = "STAR_LOOP_ENTRY";
                e[e["PLUS_LOOP_BACK"] = 11] = "PLUS_LOOP_BACK";
                e[e["LOOP_END"] = 12] = "LOOP_END"
            })(r = t.ATNStateType || (t.ATNStateType = {}))
        },
        9020: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.AbstractPredicateTransition = void 0;
            const n = r(9563);
            class AbstractPredicateTransition extends n.Transition {
                constructor(e) {
                    super(e)
                }
            }
            t.AbstractPredicateTransition = AbstractPredicateTransition
        },
        4983: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ActionTransition = void 0;
            const o = r(6966);
            const s = r(9563);
            let a = class ActionTransition extends s.Transition {
                constructor(e, t, r = -1, n = false) {
                    super(e);
                    this.ruleIndex = t;
                    this.actionIndex = r;
                    this.isCtxDependent = n
                }
                get serializationType() {
                    return 6
                }
                get isEpsilon() {
                    return true
                }
                matches(e, t, r) {
                    return false
                }
                toString() {
                    return "action_" + this.ruleIndex + ":" + this.actionIndex
                }
            };
            n([o.Override], a.prototype, "serializationType", null);
            n([o.Override], a.prototype, "isEpsilon", null);
            n([o.Override], a.prototype, "matches", null);
            n([o.Override], a.prototype, "toString", null);
            a = n([i(0, o.NotNull)], a);
            t.ActionTransition = a
        },
        5746: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.AmbiguityInfo = void 0;
            const o = r(4166);
            const s = r(6966);
            let a = class AmbiguityInfo extends o.DecisionEventInfo {
                constructor(e, t, r, n, i, o) {
                    super(e, t, n, i, o, t.useContext);
                    this.ambigAlts = r
                }
                get ambiguousAlternatives() {
                    return this.ambigAlts
                }
            };
            n([s.NotNull], a.prototype, "ambigAlts", void 0);
            n([s.NotNull], a.prototype, "ambiguousAlternatives", null);
            a = n([i(1, s.NotNull), i(2, s.NotNull), i(3, s.NotNull)], a);
            t.AmbiguityInfo = a
        },
        583: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.AtomTransition = void 0;
            const o = r(7108);
            const s = r(6966);
            const a = r(9563);
            let l = class AtomTransition extends a.Transition {
                constructor(e, t) {
                    super(e);
                    this._label = t
                }
                get serializationType() {
                    return 5
                }
                get label() {
                    return o.IntervalSet.of(this._label)
                }
                matches(e, t, r) {
                    return this._label === e
                }
                toString() {
                    return String(this.label)
                }
            };
            n([s.Override], l.prototype, "serializationType", null);
            n([s.Override, s.NotNull], l.prototype, "label", null);
            n([s.Override], l.prototype, "matches", null);
            n([s.Override, s.NotNull], l.prototype, "toString", null);
            l = n([i(0, s.NotNull)], l);
            t.AtomTransition = l
        },
        5285: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BasicBlockStartState = void 0;
            const i = r(1765);
            const o = r(6039);
            const s = r(6966);
            class BasicBlockStartState extends o.BlockStartState {
                get stateType() {
                    return i.ATNStateType.BLOCK_START
                }
            }
            n([s.Override], BasicBlockStartState.prototype, "stateType", null);
            t.BasicBlockStartState = BasicBlockStartState
        },
        9151: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BasicState = void 0;
            const i = r(2210);
            const o = r(1765);
            const s = r(6966);
            class BasicState extends i.ATNState {
                get stateType() {
                    return o.ATNStateType.BASIC
                }
            }
            n([s.Override], BasicState.prototype, "stateType", null);
            t.BasicState = BasicState
        },
        2948: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BlockEndState = void 0;
            const i = r(2210);
            const o = r(1765);
            const s = r(6966);
            class BlockEndState extends i.ATNState {
                get stateType() {
                    return o.ATNStateType.BLOCK_END
                }
            }
            n([s.Override], BlockEndState.prototype, "stateType", null);
            t.BlockEndState = BlockEndState
        },
        6039: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BlockStartState = void 0;
            const n = r(4402);
            class BlockStartState extends n.DecisionState {}
            t.BlockStartState = BlockStartState
        },
        5568: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ConflictInfo = void 0;
            const i = r(6966);
            const o = r(2925);
            class ConflictInfo {
                constructor(e, t) {
                    this._conflictedAlts = e;
                    this.exact = t
                }
                get conflictedAlts() {
                    return this._conflictedAlts
                }
                get isExact() {
                    return this.exact
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof ConflictInfo)) {
                        return false
                    }
                    return this.isExact === e.isExact && o.equals(this.conflictedAlts, e.conflictedAlts)
                }
                hashCode() {
                    return this.conflictedAlts.hashCode()
                }
            }
            n([i.Override], ConflictInfo.prototype, "equals", null);
            n([i.Override], ConflictInfo.prototype, "hashCode", null);
            t.ConflictInfo = ConflictInfo
        },
        7484: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ContextSensitivityInfo = void 0;
            const o = r(4166);
            const s = r(6966);
            let a = class ContextSensitivityInfo extends o.DecisionEventInfo {
                constructor(e, t, r, n, i) {
                    super(e, t, r, n, i, true)
                }
            };
            a = n([i(1, s.NotNull), i(2, s.NotNull)], a);
            t.ContextSensitivityInfo = a
        },
        4166: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DecisionEventInfo = void 0;
            const o = r(6966);
            let s = class DecisionEventInfo {
                constructor(e, t, r, n, i, o) {
                    this.decision = e;
                    this.fullCtx = o;
                    this.stopIndex = i;
                    this.input = r;
                    this.startIndex = n;
                    this.state = t
                }
            };
            n([o.NotNull], s.prototype, "input", void 0);
            s = n([i(2, o.NotNull)], s);
            t.DecisionEventInfo = s
        },
        1518: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DecisionInfo = void 0;
            const i = r(6966);
            class DecisionInfo {
                constructor(e) {
                    this.invocations = 0;
                    this.timeInPrediction = 0;
                    this.SLL_TotalLook = 0;
                    this.SLL_MinLook = 0;
                    this.SLL_MaxLook = 0;
                    this.LL_TotalLook = 0;
                    this.LL_MinLook = 0;
                    this.LL_MaxLook = 0;
                    this.contextSensitivities = [];
                    this.errors = [];
                    this.ambiguities = [];
                    this.predicateEvals = [];
                    this.SLL_ATNTransitions = 0;
                    this.SLL_DFATransitions = 0;
                    this.LL_Fallback = 0;
                    this.LL_ATNTransitions = 0;
                    this.LL_DFATransitions = 0;
                    this.decision = e
                }
                toString() {
                    return "{" + "decision=" + this.decision + ", contextSensitivities=" + this.contextSensitivities.length + ", errors=" + this.errors.length + ", ambiguities=" + this.ambiguities.length + ", SLL_lookahead=" + this.SLL_TotalLook + ", SLL_ATNTransitions=" + this.SLL_ATNTransitions + ", SLL_DFATransitions=" + this.SLL_DFATransitions + ", LL_Fallback=" + this.LL_Fallback + ", LL_lookahead=" + this.LL_TotalLook + ", LL_ATNTransitions=" + this.LL_ATNTransitions + "}"
                }
            }
            n([i.Override], DecisionInfo.prototype, "toString", null);
            t.DecisionInfo = DecisionInfo
        },
        4402: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DecisionState = void 0;
            const n = r(2210);
            class DecisionState extends n.ATNState {
                constructor() {
                    super(...arguments);
                    this.decision = -1;
                    this.nonGreedy = false;
                    this.sll = false
                }
            }
            t.DecisionState = DecisionState
        },
        9050: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.EpsilonTransition = void 0;
            const o = r(6966);
            const s = r(9563);
            let a = class EpsilonTransition extends s.Transition {
                constructor(e, t = -1) {
                    super(e);
                    this._outermostPrecedenceReturn = t
                }
                get outermostPrecedenceReturn() {
                    return this._outermostPrecedenceReturn
                }
                get serializationType() {
                    return 1
                }
                get isEpsilon() {
                    return true
                }
                matches(e, t, r) {
                    return false
                }
                toString() {
                    return "epsilon"
                }
            };
            n([o.Override], a.prototype, "serializationType", null);
            n([o.Override], a.prototype, "isEpsilon", null);
            n([o.Override], a.prototype, "matches", null);
            n([o.Override, o.NotNull], a.prototype, "toString", null);
            a = n([i(0, o.NotNull)], a);
            t.EpsilonTransition = a
        },
        1214: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ErrorInfo = void 0;
            const o = r(4166);
            const s = r(6966);
            let a = class ErrorInfo extends o.DecisionEventInfo {
                constructor(e, t, r, n, i) {
                    super(e, t, r, n, i, t.useContext)
                }
            };
            a = n([i(1, s.NotNull), i(2, s.NotNull)], a);
            t.ErrorInfo = a
        },
        7833: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.InvalidState = void 0;
            const i = r(1765);
            const o = r(9151);
            const s = r(6966);
            class InvalidState extends o.BasicState {
                get stateType() {
                    return i.ATNStateType.INVALID_TYPE
                }
            }
            n([s.Override], InvalidState.prototype, "stateType", null);
            t.InvalidState = InvalidState
        },
        3369: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LL1Analyzer = void 0;
            const o = r(9020);
            const s = r(112);
            const a = r(1690);
            const l = r(4980);
            const _ = r(7108);
            const u = r(6966);
            const c = r(4063);
            const d = r(4880);
            const p = r(5047);
            const f = r(8557);
            const h = r(7785);
            const g = r(7528);
            const m = r(884);
            let y = class LL1Analyzer {
                constructor(e) {
                    this.atn = e
                }
                getDecisionLookahead(e) {
                    if (e == null) {
                        return undefined
                    }
                    let t = new Array(e.numberOfTransitions);
                    for (let r = 0; r < e.numberOfTransitions; r++) {
                        let n = new _.IntervalSet;
                        t[r] = n;
                        let i = new s.Array2DHashSet(d.ObjectEqualityComparator.INSTANCE);
                        let o = false;
                        this._LOOK(e.transition(r).target, undefined, p.PredictionContext.EMPTY_LOCAL, n, i, new l.BitSet, o, false);
                        if (n.size === 0 || n.contains(LL1Analyzer.HIT_PRED)) {
                            n = undefined;
                            t[r] = n
                        }
                    }
                    return t
                }
                LOOK(e, t, r) {
                    if (r === undefined) {
                        if (e.atn == null) {
                            throw new Error("Illegal state")
                        }
                        r = e.atn.ruleToStopState[e.ruleIndex]
                    } else if (r === null) {
                        r = undefined
                    }
                    let n = new _.IntervalSet;
                    let i = true;
                    let o = true;
                    this._LOOK(e, r, t, n, new s.Array2DHashSet, new l.BitSet, i, o);
                    return n
                }
                _LOOK(e, t, r, n, i, s, l, u) {
                    let d = a.ATNConfig.create(e, 0, r);
                    if (!i.add(d)) {
                        return
                    }
                    if (e === t) {
                        if (p.PredictionContext.isEmptyLocal(r)) {
                            n.add(g.Token.EPSILON);
                            return
                        } else if (r.isEmpty) {
                            if (u) {
                                n.add(g.Token.EOF)
                            }
                            return
                        }
                    }
                    if (e instanceof f.RuleStopState) {
                        if (r.isEmpty && !p.PredictionContext.isEmptyLocal(r)) {
                            if (u) {
                                n.add(g.Token.EOF)
                            }
                            return
                        }
                        let o = s.get(e.ruleIndex);
                        try {
                            s.clear(e.ruleIndex);
                            for (let e = 0; e < r.size; e++) {
                                if (r.getReturnState(e) === p.PredictionContext.EMPTY_FULL_STATE_KEY) {
                                    continue
                                }
                                let o = this.atn.states[r.getReturnState(e)];
                                this._LOOK(o, t, r.getParent(e), n, i, s, l, u)
                            }
                        } finally {
                            if (o) {
                                s.set(e.ruleIndex)
                            }
                        }
                    }
                    let y = e.numberOfTransitions;
                    for (let a = 0; a < y; a++) {
                        let d = e.transition(a);
                        if (d instanceof h.RuleTransition) {
                            if (s.get(d.ruleIndex)) {
                                continue
                            }
                            let e = r.getChild(d.followState.stateNumber);
                            try {
                                s.set(d.ruleIndex);
                                this._LOOK(d.target, t, e, n, i, s, l, u)
                            } finally {
                                s.clear(d.ruleIndex)
                            }
                        } else if (d instanceof o.AbstractPredicateTransition) {
                            if (l) {
                                this._LOOK(d.target, t, r, n, i, s, l, u)
                            } else {
                                n.add(LL1Analyzer.HIT_PRED)
                            }
                        } else if (d.isEpsilon) {
                            this._LOOK(d.target, t, r, n, i, s, l, u)
                        } else if (d instanceof m.WildcardTransition) {
                            n.addAll(_.IntervalSet.of(g.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType))
                        } else {
                            let e = d.label;
                            if (e != null) {
                                if (d instanceof c.NotSetTransition) {
                                    e = e.complement(_.IntervalSet.of(g.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType))
                                }
                                n.addAll(e)
                            }
                        }
                    }
                }
            };
            y.HIT_PRED = g.Token.INVALID_TYPE;
            n([u.NotNull], y.prototype, "atn", void 0);
            n([u.NotNull, i(0, u.NotNull), i(1, u.NotNull)], y.prototype, "LOOK", null);
            n([i(0, u.NotNull), i(2, u.NotNull), i(3, u.NotNull), i(4, u.NotNull), i(5, u.NotNull)], y.prototype, "_LOOK", null);
            y = n([i(0, u.NotNull)], y);
            t.LL1Analyzer = y
        },
        3262: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerATNSimulator = void 0;
            const o = r(1353);
            const s = r(7747);
            const a = r(1690);
            const l = r(9576);
            const _ = r(9336);
            const u = r(5149);
            const c = r(6330);
            const d = r(3828);
            const p = r(1740);
            const f = r(6047);
            const h = r(3638);
            const g = r(6966);
            const m = r(9979);
            const y = r(5047);
            const S = r(8557);
            const T = r(7528);
            const x = r(9491);
            let C = class LexerATNSimulator extends _.ATNSimulator {
                constructor(e, t) {
                    super(e);
                    this.optimize_tail_calls = true;
                    this.startIndex = -1;
                    this._line = 1;
                    this._charPositionInLine = 0;
                    this.mode = p.Lexer.DEFAULT_MODE;
                    this.prevAccept = new LexerATNSimulator.SimState;
                    this.recog = t
                }
                copyState(e) {
                    this._charPositionInLine = e.charPositionInLine;
                    this._line = e._line;
                    this.mode = e.mode;
                    this.startIndex = e.startIndex
                }
                match(e, t) {
                    this.mode = t;
                    let r = e.mark();
                    try {
                        this.startIndex = e.index;
                        this.prevAccept.reset();
                        let n = this.atn.modeToDFA[t].s0;
                        if (n == null) {
                            return this.matchATN(e)
                        } else {
                            return this.execATN(e, n)
                        }
                    } finally {
                        e.release(r)
                    }
                }
                reset() {
                    this.prevAccept.reset();
                    this.startIndex = -1;
                    this._line = 1;
                    this._charPositionInLine = 0;
                    this.mode = p.Lexer.DEFAULT_MODE
                }
                matchATN(e) {
                    let t = this.atn.modeToStartState[this.mode];
                    if (LexerATNSimulator.debug) {
                        console.log(`matchATN mode ${this.mode} start: ${t}`)
                    }
                    let r = this.mode;
                    let n = this.computeStartState(e, t);
                    let i = n.hasSemanticContext;
                    if (i) {
                        n.hasSemanticContext = false
                    }
                    let o = this.addDFAState(n);
                    if (!i) {
                        let e = this.atn.modeToDFA[this.mode];
                        if (!e.s0) {
                            e.s0 = o
                        } else {
                            o = e.s0
                        }
                    }
                    let s = this.execATN(e, o);
                    if (LexerATNSimulator.debug) {
                        console.log(`DFA after matchATN: ${this.atn.modeToDFA[r].toLexerString()}`)
                    }
                    return s
                }
                execATN(e, t) {
                    if (LexerATNSimulator.debug) {
                        console.log(`start state closure=${t.configs}`)
                    }
                    if (t.isAcceptState) {
                        this.captureSimState(this.prevAccept, e, t)
                    }
                    let r = e.LA(1);
                    let n = t;
                    while (true) {
                        if (LexerATNSimulator.debug) {
                            console.log(`execATN loop starting closure: ${n.configs}`)
                        }
                        let t = this.getExistingTargetState(n, r);
                        if (t == null) {
                            t = this.computeTargetState(e, n, r)
                        }
                        if (t === _.ATNSimulator.ERROR) {
                            break
                        }
                        if (r !== d.IntStream.EOF) {
                            this.consume(e)
                        }
                        if (t.isAcceptState) {
                            this.captureSimState(this.prevAccept, e, t);
                            if (r === d.IntStream.EOF) {
                                break
                            }
                        }
                        r = e.LA(1);
                        n = t
                    }
                    return this.failOrAccept(this.prevAccept, e, n.configs, r)
                }
                getExistingTargetState(e, t) {
                    let r = e.getTarget(t);
                    if (LexerATNSimulator.debug && r != null) {
                        console.log("reuse state " + e.stateNumber + " edge to " + r.stateNumber)
                    }
                    return r
                }
                computeTargetState(e, t, r) {
                    let n = new m.OrderedATNConfigSet;
                    this.getReachableConfigSet(e, t.configs, n, r);
                    if (n.isEmpty) {
                        if (!n.hasSemanticContext) {
                            this.addDFAEdge(t, r, _.ATNSimulator.ERROR)
                        }
                        return _.ATNSimulator.ERROR
                    }
                    return this.addDFAEdge(t, r, n)
                }
                failOrAccept(e, t, r, n) {
                    if (e.dfaState != null) {
                        let r = e.dfaState.lexerActionExecutor;
                        this.accept(t, r, this.startIndex, e.index, e.line, e.charPos);
                        return e.dfaState.prediction
                    } else {
                        if (n === d.IntStream.EOF && t.index === this.startIndex) {
                            return T.Token.EOF
                        }
                        throw new h.LexerNoViableAltException(this.recog, t, this.startIndex, r)
                    }
                }
                getReachableConfigSet(e, t, r, n) {
                    let i = s.ATN.INVALID_ALT_NUMBER;
                    for (let o of t) {
                        let t = o.alt === i;
                        if (t && o.hasPassedThroughNonGreedyDecision) {
                            continue
                        }
                        if (LexerATNSimulator.debug) {
                            console.log(`testing ${this.getTokenName(n)} at ${o.toString(this.recog,true)}`)
                        }
                        let s = o.state.numberOfOptimizedTransitions;
                        for (let a = 0; a < s; a++) {
                            let s = o.state.getOptimizedTransition(a);
                            let l = this.getReachableTarget(s, n);
                            if (l != null) {
                                let s = o.lexerActionExecutor;
                                let a;
                                if (s != null) {
                                    s = s.fixOffsetBeforeMatch(e.index - this.startIndex);
                                    a = o.transform(l, true, s)
                                } else {
                                    x(o.lexerActionExecutor == null);
                                    a = o.transform(l, true)
                                }
                                let _ = n === d.IntStream.EOF;
                                if (this.closure(e, a, r, t, true, _)) {
                                    i = o.alt;
                                    break
                                }
                            }
                        }
                    }
                }
                accept(e, t, r, n, i, o) {
                    if (LexerATNSimulator.debug) {
                        console.log(`ACTION ${t}`)
                    }
                    e.seek(n);
                    this._line = i;
                    this._charPositionInLine = o;
                    if (t != null && this.recog != null) {
                        t.execute(this.recog, e, r)
                    }
                }
                getReachableTarget(e, t) {
                    if (e.matches(t, p.Lexer.MIN_CHAR_VALUE, p.Lexer.MAX_CHAR_VALUE)) {
                        return e.target
                    }
                    return undefined
                }
                computeStartState(e, t) {
                    let r = y.PredictionContext.EMPTY_FULL;
                    let n = new m.OrderedATNConfigSet;
                    for (let i = 0; i < t.numberOfTransitions; i++) {
                        let o = t.transition(i).target;
                        let s = a.ATNConfig.create(o, i + 1, r);
                        this.closure(e, s, n, false, false, false)
                    }
                    return n
                }
                closure(e, t, r, n, i, o) {
                    if (LexerATNSimulator.debug) {
                        console.log("closure(" + t.toString(this.recog, true) + ")")
                    }
                    if (t.state instanceof S.RuleStopState) {
                        if (LexerATNSimulator.debug) {
                            if (this.recog != null) {
                                console.log(`closure at ${this.recog.ruleNames[t.state.ruleIndex]} rule stop ${t}`)
                            } else {
                                console.log(`closure at rule stop ${t}`)
                            }
                        }
                        let s = t.context;
                        if (s.isEmpty) {
                            r.add(t);
                            return true
                        } else if (s.hasEmpty) {
                            r.add(t.transform(t.state, true, y.PredictionContext.EMPTY_FULL));
                            n = true
                        }
                        for (let a = 0; a < s.size; a++) {
                            let l = s.getReturnState(a);
                            if (l === y.PredictionContext.EMPTY_FULL_STATE_KEY) {
                                continue
                            }
                            let _ = s.getParent(a);
                            let u = this.atn.states[l];
                            let c = t.transform(u, false, _);
                            n = this.closure(e, c, r, n, i, o)
                        }
                        return n
                    }
                    if (!t.state.onlyHasEpsilonTransitions) {
                        if (!n || !t.hasPassedThroughNonGreedyDecision) {
                            r.add(t)
                        }
                    }
                    let s = t.state;
                    for (let a = 0; a < s.numberOfOptimizedTransitions; a++) {
                        let l = s.getOptimizedTransition(a);
                        let _ = this.getEpsilonTarget(e, t, l, r, i, o);
                        if (_ != null) {
                            n = this.closure(e, _, r, n, i, o)
                        }
                    }
                    return n
                }
                getEpsilonTarget(e, t, r, n, i, o) {
                    let s;
                    switch (r.serializationType) {
                        case 3:
                            let a = r;
                            if (this.optimize_tail_calls && a.optimizedTailCall && !t.context.hasEmpty) {
                                s = t.transform(r.target, true)
                            } else {
                                let e = t.context.getChild(a.followState.stateNumber);
                                s = t.transform(r.target, true, e)
                            }
                            break;
                        case 10:
                            throw new Error("Precedence predicates are not supported in lexers.");
                        case 4:
                            let l = r;
                            if (LexerATNSimulator.debug) {
                                console.log("EVAL rule " + l.ruleIndex + ":" + l.predIndex)
                            }
                            n.hasSemanticContext = true;
                            if (this.evaluatePredicate(e, l.ruleIndex, l.predIndex, i)) {
                                s = t.transform(r.target, true)
                            } else {
                                s = undefined
                            }
                            break;
                        case 6:
                            if (t.context.hasEmpty) {
                                let e = f.LexerActionExecutor.append(t.lexerActionExecutor, this.atn.lexerActions[r.actionIndex]);
                                s = t.transform(r.target, true, e);
                                break
                            } else {
                                s = t.transform(r.target, true);
                                break
                            }
                            case 1:
                                s = t.transform(r.target, true);
                                break;
                            case 5:
                            case 2:
                            case 7:
                                if (o) {
                                    if (r.matches(d.IntStream.EOF, p.Lexer.MIN_CHAR_VALUE, p.Lexer.MAX_CHAR_VALUE)) {
                                        s = t.transform(r.target, false);
                                        break
                                    }
                                }
                                s = undefined;
                                break;
                            default:
                                s = undefined;
                                break
                    }
                    return s
                }
                evaluatePredicate(e, t, r, n) {
                    if (this.recog == null) {
                        return true
                    }
                    if (!n) {
                        return this.recog.sempred(undefined, t, r)
                    }
                    let i = this._charPositionInLine;
                    let o = this._line;
                    let s = e.index;
                    let a = e.mark();
                    try {
                        this.consume(e);
                        return this.recog.sempred(undefined, t, r)
                    } finally {
                        this._charPositionInLine = i;
                        this._line = o;
                        e.seek(s);
                        e.release(a)
                    }
                }
                captureSimState(e, t, r) {
                    e.index = t.index;
                    e.line = this._line;
                    e.charPos = this._charPositionInLine;
                    e.dfaState = r
                }
                addDFAEdge(e, t, r) {
                    if (r instanceof l.ATNConfigSet) {
                        let n = r.hasSemanticContext;
                        if (n) {
                            r.hasSemanticContext = false
                        }
                        let i = this.addDFAState(r);
                        if (n) {
                            return i
                        }
                        this.addDFAEdge(e, t, i);
                        return i
                    } else {
                        if (LexerATNSimulator.debug) {
                            console.log("EDGE " + e + " -> " + r + " upon " + String.fromCharCode(t))
                        }
                        if (e != null) {
                            e.setTarget(t, r)
                        }
                    }
                }
                addDFAState(e) {
                    x(!e.hasSemanticContext);
                    let t = new u.DFAState(e);
                    let r = this.atn.modeToDFA[this.mode].states.get(t);
                    if (r != null) {
                        return r
                    }
                    e.optimizeConfigs(this);
                    let n = new u.DFAState(e.clone(true));
                    let i;
                    for (let t of e) {
                        if (t.state instanceof S.RuleStopState) {
                            i = t;
                            break
                        }
                    }
                    if (i != null) {
                        let e = this.atn.ruleToTokenType[i.state.ruleIndex];
                        let t = i.lexerActionExecutor;
                        n.acceptStateInfo = new o.AcceptStateInfo(e, t)
                    }
                    return this.atn.modeToDFA[this.mode].addState(n)
                }
                getDFA(e) {
                    return this.atn.modeToDFA[e]
                }
                getText(e) {
                    return e.getText(c.Interval.of(this.startIndex, e.index - 1))
                }
                get line() {
                    return this._line
                }
                set line(e) {
                    this._line = e
                }
                get charPositionInLine() {
                    return this._charPositionInLine
                }
                set charPositionInLine(e) {
                    this._charPositionInLine = e
                }
                consume(e) {
                    let t = e.LA(1);
                    if (t === "\n".charCodeAt(0)) {
                        this._line++;
                        this._charPositionInLine = 0
                    } else {
                        this._charPositionInLine++
                    }
                    e.consume()
                }
                getTokenName(e) {
                    if (e === -1) {
                        return "EOF"
                    }
                    return "'" + String.fromCharCode(e) + "'"
                }
            };
            n([g.NotNull], C.prototype, "prevAccept", void 0);
            n([i(0, g.NotNull)], C.prototype, "copyState", null);
            n([i(0, g.NotNull)], C.prototype, "match", null);
            n([g.Override], C.prototype, "reset", null);
            n([i(0, g.NotNull)], C.prototype, "matchATN", null);
            n([i(0, g.NotNull), i(1, g.NotNull)], C.prototype, "execATN", null);
            n([i(0, g.NotNull)], C.prototype, "getExistingTargetState", null);
            n([g.NotNull, i(0, g.NotNull), i(1, g.NotNull)], C.prototype, "computeTargetState", null);
            n([i(0, g.NotNull), i(1, g.NotNull), i(2, g.NotNull)], C.prototype, "getReachableConfigSet", null);
            n([i(0, g.NotNull)], C.prototype, "accept", null);
            n([g.NotNull, i(0, g.NotNull), i(1, g.NotNull)], C.prototype, "computeStartState", null);
            n([i(0, g.NotNull), i(1, g.NotNull), i(2, g.NotNull)], C.prototype, "closure", null);
            n([i(0, g.NotNull), i(1, g.NotNull), i(2, g.NotNull), i(3, g.NotNull)], C.prototype, "getEpsilonTarget", null);
            n([i(0, g.NotNull)], C.prototype, "evaluatePredicate", null);
            n([i(0, g.NotNull), i(1, g.NotNull), i(2, g.NotNull)], C.prototype, "captureSimState", null);
            n([g.NotNull, i(0, g.NotNull)], C.prototype, "addDFAState", null);
            n([g.NotNull], C.prototype, "getDFA", null);
            n([g.NotNull, i(0, g.NotNull)], C.prototype, "getText", null);
            n([i(0, g.NotNull)], C.prototype, "consume", null);
            n([g.NotNull], C.prototype, "getTokenName", null);
            C = n([i(0, g.NotNull)], C);
            t.LexerATNSimulator = C;
            (function(e) {
                e.debug = false;
                e.dfa_debug = false;
                class SimState {
                    constructor() {
                        this.index = -1;
                        this.line = 0;
                        this.charPos = -1
                    }
                    reset() {
                        this.index = -1;
                        this.line = 0;
                        this.charPos = -1;
                        this.dfaState = undefined
                    }
                }
                e.SimState = SimState
            })(C = t.LexerATNSimulator || (t.LexerATNSimulator = {}));
            t.LexerATNSimulator = C
        },
        6047: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerActionExecutor = void 0;
            const o = r(8069);
            const s = r(3886);
            const a = r(5032);
            const l = r(6966);
            let _ = class LexerActionExecutor {
                constructor(e) {
                    this._lexerActions = e;
                    let t = a.MurmurHash.initialize();
                    for (let r of e) {
                        t = a.MurmurHash.update(t, r)
                    }
                    this.cachedHashCode = a.MurmurHash.finish(t, e.length)
                }
                static append(e, t) {
                    if (!e) {
                        return new LexerActionExecutor([t])
                    }
                    let r = e._lexerActions.slice(0);
                    r.push(t);
                    return new LexerActionExecutor(r)
                }
                fixOffsetBeforeMatch(e) {
                    let t;
                    for (let r = 0; r < this._lexerActions.length; r++) {
                        if (this._lexerActions[r].isPositionDependent && !(this._lexerActions[r] instanceof s.LexerIndexedCustomAction)) {
                            if (!t) {
                                t = this._lexerActions.slice(0)
                            }
                            t[r] = new s.LexerIndexedCustomAction(e, this._lexerActions[r])
                        }
                    }
                    if (!t) {
                        return this
                    }
                    return new LexerActionExecutor(t)
                }
                get lexerActions() {
                    return this._lexerActions
                }
                execute(e, t, r) {
                    let n = false;
                    let i = t.index;
                    try {
                        for (let o of this._lexerActions) {
                            if (o instanceof s.LexerIndexedCustomAction) {
                                let e = o.offset;
                                t.seek(r + e);
                                o = o.action;
                                n = r + e !== i
                            } else if (o.isPositionDependent) {
                                t.seek(i);
                                n = false
                            }
                            o.execute(e)
                        }
                    } finally {
                        if (n) {
                            t.seek(i)
                        }
                    }
                }
                hashCode() {
                    return this.cachedHashCode
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof LexerActionExecutor)) {
                        return false
                    }
                    return this.cachedHashCode === e.cachedHashCode && o.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, e._lexerActions)
                }
            };
            n([l.NotNull], _.prototype, "_lexerActions", void 0);
            n([l.NotNull], _.prototype, "lexerActions", null);
            n([i(0, l.NotNull)], _.prototype, "execute", null);
            n([l.Override], _.prototype, "hashCode", null);
            n([l.Override], _.prototype, "equals", null);
            n([l.NotNull, i(1, l.NotNull)], _, "append", null);
            _ = n([i(0, l.NotNull)], _);
            t.LexerActionExecutor = _
        },
        823: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerChannelAction = void 0;
            const o = r(5032);
            const s = r(6966);
            class LexerChannelAction {
                constructor(e) {
                    this._channel = e
                }
                get channel() {
                    return this._channel
                }
                get actionType() {
                    return 0
                }
                get isPositionDependent() {
                    return false
                }
                execute(e) {
                    e.channel = this._channel
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this.actionType);
                    e = o.MurmurHash.update(e, this._channel);
                    return o.MurmurHash.finish(e, 2)
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof LexerChannelAction)) {
                        return false
                    }
                    return this._channel === e._channel
                }
                toString() {
                    return `channel(${this._channel})`
                }
            }
            n([s.Override], LexerChannelAction.prototype, "actionType", null);
            n([s.Override], LexerChannelAction.prototype, "isPositionDependent", null);
            n([s.Override, i(0, s.NotNull)], LexerChannelAction.prototype, "execute", null);
            n([s.Override], LexerChannelAction.prototype, "hashCode", null);
            n([s.Override], LexerChannelAction.prototype, "equals", null);
            n([s.Override], LexerChannelAction.prototype, "toString", null);
            t.LexerChannelAction = LexerChannelAction
        },
        6342: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerCustomAction = void 0;
            const o = r(5032);
            const s = r(6966);
            class LexerCustomAction {
                constructor(e, t) {
                    this._ruleIndex = e;
                    this._actionIndex = t
                }
                get ruleIndex() {
                    return this._ruleIndex
                }
                get actionIndex() {
                    return this._actionIndex
                }
                get actionType() {
                    return 1
                }
                get isPositionDependent() {
                    return true
                }
                execute(e) {
                    e.action(undefined, this._ruleIndex, this._actionIndex)
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this.actionType);
                    e = o.MurmurHash.update(e, this._ruleIndex);
                    e = o.MurmurHash.update(e, this._actionIndex);
                    return o.MurmurHash.finish(e, 3)
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof LexerCustomAction)) {
                        return false
                    }
                    return this._ruleIndex === e._ruleIndex && this._actionIndex === e._actionIndex
                }
            }
            n([s.Override], LexerCustomAction.prototype, "actionType", null);
            n([s.Override], LexerCustomAction.prototype, "isPositionDependent", null);
            n([s.Override, i(0, s.NotNull)], LexerCustomAction.prototype, "execute", null);
            n([s.Override], LexerCustomAction.prototype, "hashCode", null);
            n([s.Override], LexerCustomAction.prototype, "equals", null);
            t.LexerCustomAction = LexerCustomAction
        },
        3886: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerIndexedCustomAction = void 0;
            const o = r(5032);
            const s = r(6966);
            let a = class LexerIndexedCustomAction {
                constructor(e, t) {
                    this._offset = e;
                    this._action = t
                }
                get offset() {
                    return this._offset
                }
                get action() {
                    return this._action
                }
                get actionType() {
                    return this._action.actionType
                }
                get isPositionDependent() {
                    return true
                }
                execute(e) {
                    this._action.execute(e)
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this._offset);
                    e = o.MurmurHash.update(e, this._action);
                    return o.MurmurHash.finish(e, 2)
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof LexerIndexedCustomAction)) {
                        return false
                    }
                    return this._offset === e._offset && this._action.equals(e._action)
                }
            };
            n([s.NotNull], a.prototype, "action", null);
            n([s.Override], a.prototype, "actionType", null);
            n([s.Override], a.prototype, "isPositionDependent", null);
            n([s.Override], a.prototype, "execute", null);
            n([s.Override], a.prototype, "hashCode", null);
            n([s.Override], a.prototype, "equals", null);
            a = n([i(1, s.NotNull)], a);
            t.LexerIndexedCustomAction = a
        },
        7165: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerModeAction = void 0;
            const o = r(5032);
            const s = r(6966);
            class LexerModeAction {
                constructor(e) {
                    this._mode = e
                }
                get mode() {
                    return this._mode
                }
                get actionType() {
                    return 2
                }
                get isPositionDependent() {
                    return false
                }
                execute(e) {
                    e.mode(this._mode)
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this.actionType);
                    e = o.MurmurHash.update(e, this._mode);
                    return o.MurmurHash.finish(e, 2)
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof LexerModeAction)) {
                        return false
                    }
                    return this._mode === e._mode
                }
                toString() {
                    return `mode(${this._mode})`
                }
            }
            n([s.Override], LexerModeAction.prototype, "actionType", null);
            n([s.Override], LexerModeAction.prototype, "isPositionDependent", null);
            n([s.Override, i(0, s.NotNull)], LexerModeAction.prototype, "execute", null);
            n([s.Override], LexerModeAction.prototype, "hashCode", null);
            n([s.Override], LexerModeAction.prototype, "equals", null);
            n([s.Override], LexerModeAction.prototype, "toString", null);
            t.LexerModeAction = LexerModeAction
        },
        3231: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerMoreAction = void 0;
            const o = r(5032);
            const s = r(6966);
            class LexerMoreAction {
                constructor() {}
                get actionType() {
                    return 3
                }
                get isPositionDependent() {
                    return false
                }
                execute(e) {
                    e.more()
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this.actionType);
                    return o.MurmurHash.finish(e, 1)
                }
                equals(e) {
                    return e === this
                }
                toString() {
                    return "more"
                }
            }
            n([s.Override], LexerMoreAction.prototype, "actionType", null);
            n([s.Override], LexerMoreAction.prototype, "isPositionDependent", null);
            n([s.Override, i(0, s.NotNull)], LexerMoreAction.prototype, "execute", null);
            n([s.Override], LexerMoreAction.prototype, "hashCode", null);
            n([s.Override], LexerMoreAction.prototype, "equals", null);
            n([s.Override], LexerMoreAction.prototype, "toString", null);
            t.LexerMoreAction = LexerMoreAction;
            (function(e) {
                e.INSTANCE = new e
            })(LexerMoreAction = t.LexerMoreAction || (t.LexerMoreAction = {}))
        },
        2069: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerPopModeAction = void 0;
            const o = r(5032);
            const s = r(6966);
            class LexerPopModeAction {
                constructor() {}
                get actionType() {
                    return 4
                }
                get isPositionDependent() {
                    return false
                }
                execute(e) {
                    e.popMode()
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this.actionType);
                    return o.MurmurHash.finish(e, 1)
                }
                equals(e) {
                    return e === this
                }
                toString() {
                    return "popMode"
                }
            }
            n([s.Override], LexerPopModeAction.prototype, "actionType", null);
            n([s.Override], LexerPopModeAction.prototype, "isPositionDependent", null);
            n([s.Override, i(0, s.NotNull)], LexerPopModeAction.prototype, "execute", null);
            n([s.Override], LexerPopModeAction.prototype, "hashCode", null);
            n([s.Override], LexerPopModeAction.prototype, "equals", null);
            n([s.Override], LexerPopModeAction.prototype, "toString", null);
            t.LexerPopModeAction = LexerPopModeAction;
            (function(e) {
                e.INSTANCE = new e
            })(LexerPopModeAction = t.LexerPopModeAction || (t.LexerPopModeAction = {}))
        },
        9174: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerPushModeAction = void 0;
            const o = r(5032);
            const s = r(6966);
            class LexerPushModeAction {
                constructor(e) {
                    this._mode = e
                }
                get mode() {
                    return this._mode
                }
                get actionType() {
                    return 5
                }
                get isPositionDependent() {
                    return false
                }
                execute(e) {
                    e.pushMode(this._mode)
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this.actionType);
                    e = o.MurmurHash.update(e, this._mode);
                    return o.MurmurHash.finish(e, 2)
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof LexerPushModeAction)) {
                        return false
                    }
                    return this._mode === e._mode
                }
                toString() {
                    return `pushMode(${this._mode})`
                }
            }
            n([s.Override], LexerPushModeAction.prototype, "actionType", null);
            n([s.Override], LexerPushModeAction.prototype, "isPositionDependent", null);
            n([s.Override, i(0, s.NotNull)], LexerPushModeAction.prototype, "execute", null);
            n([s.Override], LexerPushModeAction.prototype, "hashCode", null);
            n([s.Override], LexerPushModeAction.prototype, "equals", null);
            n([s.Override], LexerPushModeAction.prototype, "toString", null);
            t.LexerPushModeAction = LexerPushModeAction
        },
        829: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerSkipAction = void 0;
            const o = r(5032);
            const s = r(6966);
            class LexerSkipAction {
                constructor() {}
                get actionType() {
                    return 6
                }
                get isPositionDependent() {
                    return false
                }
                execute(e) {
                    e.skip()
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this.actionType);
                    return o.MurmurHash.finish(e, 1)
                }
                equals(e) {
                    return e === this
                }
                toString() {
                    return "skip"
                }
            }
            n([s.Override], LexerSkipAction.prototype, "actionType", null);
            n([s.Override], LexerSkipAction.prototype, "isPositionDependent", null);
            n([s.Override, i(0, s.NotNull)], LexerSkipAction.prototype, "execute", null);
            n([s.Override], LexerSkipAction.prototype, "hashCode", null);
            n([s.Override], LexerSkipAction.prototype, "equals", null);
            n([s.Override], LexerSkipAction.prototype, "toString", null);
            t.LexerSkipAction = LexerSkipAction;
            (function(e) {
                e.INSTANCE = new e
            })(LexerSkipAction = t.LexerSkipAction || (t.LexerSkipAction = {}))
        },
        6407: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerTypeAction = void 0;
            const o = r(5032);
            const s = r(6966);
            class LexerTypeAction {
                constructor(e) {
                    this._type = e
                }
                get type() {
                    return this._type
                }
                get actionType() {
                    return 7
                }
                get isPositionDependent() {
                    return false
                }
                execute(e) {
                    e.type = this._type
                }
                hashCode() {
                    let e = o.MurmurHash.initialize();
                    e = o.MurmurHash.update(e, this.actionType);
                    e = o.MurmurHash.update(e, this._type);
                    return o.MurmurHash.finish(e, 2)
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof LexerTypeAction)) {
                        return false
                    }
                    return this._type === e._type
                }
                toString() {
                    return `type(${this._type})`
                }
            }
            n([s.Override], LexerTypeAction.prototype, "actionType", null);
            n([s.Override], LexerTypeAction.prototype, "isPositionDependent", null);
            n([s.Override, i(0, s.NotNull)], LexerTypeAction.prototype, "execute", null);
            n([s.Override], LexerTypeAction.prototype, "hashCode", null);
            n([s.Override], LexerTypeAction.prototype, "equals", null);
            n([s.Override], LexerTypeAction.prototype, "toString", null);
            t.LexerTypeAction = LexerTypeAction
        },
        47: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LookaheadEventInfo = void 0;
            const o = r(4166);
            const s = r(6966);
            let a = class LookaheadEventInfo extends o.DecisionEventInfo {
                constructor(e, t, r, n, i, o, s) {
                    super(e, t, n, i, o, s);
                    this.predictedAlt = r
                }
            };
            a = n([i(3, s.NotNull)], a);
            t.LookaheadEventInfo = a
        },
        6994: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LoopEndState = void 0;
            const i = r(2210);
            const o = r(1765);
            const s = r(6966);
            class LoopEndState extends i.ATNState {
                get stateType() {
                    return o.ATNStateType.LOOP_END
                }
            }
            n([s.Override], LoopEndState.prototype, "stateType", null);
            t.LoopEndState = LoopEndState
        },
        4063: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NotSetTransition = void 0;
            const o = r(6966);
            const s = r(5864);
            let a = class NotSetTransition extends s.SetTransition {
                constructor(e, t) {
                    super(e, t)
                }
                get serializationType() {
                    return 8
                }
                matches(e, t, r) {
                    return e >= t && e <= r && !super.matches(e, t, r)
                }
                toString() {
                    return "~" + super.toString()
                }
            };
            n([o.Override], a.prototype, "serializationType", null);
            n([o.Override], a.prototype, "matches", null);
            n([o.Override], a.prototype, "toString", null);
            a = n([i(0, o.NotNull), i(1, o.Nullable)], a);
            t.NotSetTransition = a
        },
        9979: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.OrderedATNConfigSet = void 0;
            const i = r(9576);
            const o = r(6966);
            class OrderedATNConfigSet extends i.ATNConfigSet {
                constructor(e, t) {
                    if (e != null && t != null) {
                        super(e, t)
                    } else {
                        super()
                    }
                }
                clone(e) {
                    let t = new OrderedATNConfigSet(this, e);
                    if (!e && this.isReadOnly) {
                        t.addAll(this)
                    }
                    return t
                }
                getKey(e) {
                    return {
                        state: 0,
                        alt: e.hashCode()
                    }
                }
                canMerge(e, t, r) {
                    return e.equals(r)
                }
            }
            n([o.Override], OrderedATNConfigSet.prototype, "clone", null);
            n([o.Override], OrderedATNConfigSet.prototype, "getKey", null);
            n([o.Override], OrderedATNConfigSet.prototype, "canMerge", null);
            t.OrderedATNConfigSet = OrderedATNConfigSet
        },
        5765: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ParseInfo = void 0;
            const o = r(6966);
            let s = class ParseInfo {
                constructor(e) {
                    this.atnSimulator = e
                }
                getDecisionInfo() {
                    return this.atnSimulator.getDecisionInfo()
                }
                getLLDecisions() {
                    let e = this.atnSimulator.getDecisionInfo();
                    let t = [];
                    for (let r = 0; r < e.length; r++) {
                        let n = e[r].LL_Fallback;
                        if (n > 0) {
                            t.push(r)
                        }
                    }
                    return t
                }
                getTotalTimeInPrediction() {
                    let e = this.atnSimulator.getDecisionInfo();
                    let t = 0;
                    for (let r of e) {
                        t += r.timeInPrediction
                    }
                    return t
                }
                getTotalSLLLookaheadOps() {
                    let e = this.atnSimulator.getDecisionInfo();
                    let t = 0;
                    for (let r of e) {
                        t += r.SLL_TotalLook
                    }
                    return t
                }
                getTotalLLLookaheadOps() {
                    let e = this.atnSimulator.getDecisionInfo();
                    let t = 0;
                    for (let r of e) {
                        t += r.LL_TotalLook
                    }
                    return t
                }
                getTotalSLLATNLookaheadOps() {
                    let e = this.atnSimulator.getDecisionInfo();
                    let t = 0;
                    for (let r of e) {
                        t += r.SLL_ATNTransitions
                    }
                    return t
                }
                getTotalLLATNLookaheadOps() {
                    let e = this.atnSimulator.getDecisionInfo();
                    let t = 0;
                    for (let r of e) {
                        t += r.LL_ATNTransitions
                    }
                    return t
                }
                getTotalATNLookaheadOps() {
                    let e = this.atnSimulator.getDecisionInfo();
                    let t = 0;
                    for (let r of e) {
                        t += r.SLL_ATNTransitions;
                        t += r.LL_ATNTransitions
                    }
                    return t
                }
                getDFASize(e) {
                    if (e) {
                        let t = this.atnSimulator.atn.decisionToDFA[e];
                        return t.states.size
                    } else {
                        let e = 0;
                        let t = this.atnSimulator.atn.decisionToDFA;
                        for (let r = 0; r < t.length; r++) {
                            e += this.getDFASize(r)
                        }
                        return e
                    }
                }
            };
            n([o.NotNull], s.prototype, "getDecisionInfo", null);
            n([o.NotNull], s.prototype, "getLLDecisions", null);
            s = n([i(0, o.NotNull)], s);
            t.ParseInfo = s
        },
        9851: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ParserATNSimulator = void 0;
            const o = r(1353);
            const s = r(4983);
            const a = r(112);
            const l = r(4797);
            const _ = r(7747);
            const u = r(1690);
            const c = r(9576);
            const d = r(9336);
            const p = r(1765);
            const f = r(583);
            const h = r(4980);
            const g = r(5568);
            const m = r(4402);
            const y = r(5149);
            const S = r(2446);
            const T = r(6330);
            const x = r(3828);
            const C = r(6966);
            const N = r(4063);
            const A = r(1914);
            const E = r(4880);
            const v = r(9562);
            const M = r(5047);
            const w = r(7545);
            const b = r(2093);
            const F = r(8557);
            const B = r(7785);
            const I = r(4806);
            const L = r(5864);
            const P = r(1533);
            const O = r(7528);
            const R = r(7847);
            const D = r(9491);
            const k = 65535;
            const $ = -(1 << 31 >>> 0);
            let j = class ParserATNSimulator extends d.ATNSimulator {
                constructor(e, t) {
                    super(e);
                    this.predictionMode = b.PredictionMode.LL;
                    this.force_global_context = false;
                    this.always_try_local_context = true;
                    this.enable_global_context_dfa = false;
                    this.optimize_unique_closure = true;
                    this.optimize_ll1 = true;
                    this.optimize_tail_calls = true;
                    this.tail_call_preserves_sll = true;
                    this.treat_sllk1_conflict_as_ambiguity = false;
                    this.reportAmbiguities = false;
                    this.userWantsCtxSensitive = true;
                    this._parser = t
                }
                getPredictionMode() {
                    return this.predictionMode
                }
                setPredictionMode(e) {
                    this.predictionMode = e
                }
                reset() {}
                adaptivePredict(e, t, r, n) {
                    if (n === undefined) {
                        n = false
                    }
                    let i = this.atn.decisionToDFA[t];
                    D(i != null);
                    if (this.optimize_ll1 && !i.isPrecedenceDfa && !i.isEmpty) {
                        let r = e.LA(1);
                        if (r >= 0 && r <= 65535) {
                            let e = (t << 16 >>> 0) + r;
                            let n = this.atn.LL1Table.get(e);
                            if (n != null) {
                                return n
                            }
                        }
                    }
                    this.dfa = i;
                    if (this.force_global_context) {
                        n = true
                    } else if (!this.always_try_local_context) {
                        n = n || i.isContextSensitive
                    }
                    this.userWantsCtxSensitive = n || this.predictionMode !== b.PredictionMode.SLL && r != null && !this.atn.decisionToState[t].sll;
                    if (r == null) {
                        r = v.ParserRuleContext.emptyContext()
                    }
                    let o;
                    if (!i.isEmpty) {
                        o = this.getStartState(i, e, r, n)
                    }
                    if (o == null) {
                        if (r == null) {
                            r = v.ParserRuleContext.emptyContext()
                        }
                        if (ParserATNSimulator.debug) {
                            console.log("ATN decision " + i.decision + " exec LA(1)==" + this.getLookaheadName(e) + ", outerContext=" + r.toString(this._parser))
                        }
                        o = this.computeStartState(i, r, n)
                    }
                    let s = e.mark();
                    let a = e.index;
                    try {
                        let t = this.execDFA(i, e, a, o);
                        if (ParserATNSimulator.debug) {
                            console.log("DFA after predictATN: " + i.toString(this._parser.vocabulary, this._parser.ruleNames))
                        }
                        return t
                    } finally {
                        this.dfa = undefined;
                        e.seek(a);
                        e.release(s)
                    }
                }
                getStartState(e, t, r, n) {
                    if (!n) {
                        if (e.isPrecedenceDfa) {
                            let t = e.getPrecedenceStartState(this._parser.precedence, false);
                            if (t == null) {
                                return undefined
                            }
                            return new P.SimulatorState(r, t, false, r)
                        } else {
                            if (e.s0 == null) {
                                return undefined
                            }
                            return new P.SimulatorState(r, e.s0, false, r)
                        }
                    }
                    if (!this.enable_global_context_dfa) {
                        return undefined
                    }
                    let i = r;
                    D(r != null);
                    let o;
                    if (e.isPrecedenceDfa) {
                        o = e.getPrecedenceStartState(this._parser.precedence, true)
                    } else {
                        o = e.s0full
                    }
                    while (i != null && o != null && o.isContextSensitive) {
                        i = this.skipTailCalls(i);
                        o = o.getContextTarget(this.getReturnState(i));
                        if (i.isEmpty) {
                            D(o == null || !o.isContextSensitive)
                        } else {
                            i = i.parent
                        }
                    }
                    if (o == null) {
                        return undefined
                    }
                    return new P.SimulatorState(r, o, n, i)
                }
                execDFA(e, t, r, n) {
                    let i = n.outerContext;
                    if (ParserATNSimulator.dfa_debug) {
                        console.log("DFA decision " + e.decision + " exec LA(1)==" + this.getLookaheadName(t) + ", outerContext=" + i.toString(this._parser))
                    }
                    if (ParserATNSimulator.dfa_debug) {
                        console.log(e.toString(this._parser.vocabulary, this._parser.ruleNames))
                    }
                    let o = n.s0;
                    let s = t.LA(1);
                    let a = n.remainingOuterContext;
                    while (true) {
                        if (ParserATNSimulator.dfa_debug) {
                            console.log("DFA state " + o.stateNumber + " LA(1)==" + this.getLookaheadName(t))
                        }
                        if (n.useContext) {
                            while (o.isContextSymbol(s)) {
                                let i;
                                if (a != null) {
                                    a = this.skipTailCalls(a);
                                    i = o.getContextTarget(this.getReturnState(a))
                                }
                                if (i == null) {
                                    let i = new P.SimulatorState(n.outerContext, o, n.useContext, a);
                                    return this.execATN(e, t, r, i)
                                }
                                D(a != null);
                                a = a.parent;
                                o = i
                            }
                        }
                        if (this.isAcceptState(o, n.useContext)) {
                            if (o.predicates != null) {
                                if (ParserATNSimulator.dfa_debug) {
                                    console.log("accept " + o)
                                }
                            } else {
                                if (ParserATNSimulator.dfa_debug) {
                                    console.log("accept; predict " + o.prediction + " in state " + o.stateNumber)
                                }
                            }
                            break
                        }
                        D(!this.isAcceptState(o, n.useContext));
                        let l = this.getExistingTargetState(o, s);
                        if (l == null) {
                            if (ParserATNSimulator.dfa_debug && s >= 0) {
                                console.log("no edge for " + this._parser.vocabulary.getDisplayName(s))
                            }
                            let l;
                            if (ParserATNSimulator.dfa_debug) {
                                let e = T.Interval.of(r, this._parser.inputStream.index);
                                console.log("ATN exec upon " + this._parser.inputStream.getText(e) + " at DFA state " + o.stateNumber)
                            }
                            let _ = new P.SimulatorState(i, o, n.useContext, a);
                            l = this.execATN(e, t, r, _);
                            if (ParserATNSimulator.dfa_debug) {
                                console.log("back from DFA update, alt=" + l + ", dfa=\n" + e.toString(this._parser.vocabulary, this._parser.ruleNames))
                            }
                            if (ParserATNSimulator.dfa_debug) {
                                console.log("DFA decision " + e.decision + " predicts " + l)
                            }
                            return l
                        } else if (l === d.ATNSimulator.ERROR) {
                            let e = new P.SimulatorState(i, o, n.useContext, a);
                            return this.handleNoViableAlt(t, r, e)
                        }
                        o = l;
                        if (!this.isAcceptState(o, n.useContext) && s !== x.IntStream.EOF) {
                            t.consume();
                            s = t.LA(1)
                        }
                    }
                    if (!n.useContext && o.configs.conflictInfo != null) {
                        if (e.atnStartState instanceof m.DecisionState) {
                            if (!this.userWantsCtxSensitive || !o.configs.dipsIntoOuterContext && o.configs.isExactConflict || this.treat_sllk1_conflict_as_ambiguity && t.index === r) {} else {
                                D(!n.useContext);
                                let s;
                                let l = o.predicates;
                                if (l != null) {
                                    let e = t.index;
                                    if (e !== r) {
                                        t.seek(r)
                                    }
                                    s = this.evalSemanticContext(l, i, true);
                                    if (s.cardinality() === 1) {
                                        return s.nextSetBit(0)
                                    }
                                    if (e !== r) {
                                        t.seek(e)
                                    }
                                }
                                if (this.reportAmbiguities) {
                                    let l = new P.SimulatorState(i, o, n.useContext, a);
                                    this.reportAttemptingFullContext(e, s, l, r, t.index)
                                }
                                t.seek(r);
                                return this.adaptivePredict(t, e.decision, i, true)
                            }
                        }
                    }
                    let l = o.predicates;
                    if (l != null) {
                        let n = t.index;
                        if (r !== n) {
                            t.seek(r)
                        }
                        let s = this.evalSemanticContext(l, i, this.reportAmbiguities && this.predictionMode === b.PredictionMode.LL_EXACT_AMBIG_DETECTION);
                        switch (s.cardinality()) {
                            case 0:
                                throw this.noViableAlt(t, i, o.configs, r);
                            case 1:
                                return s.nextSetBit(0);
                            default:
                                if (r !== n) {
                                    t.seek(n)
                                }
                                this.reportAmbiguity(e, o, r, n, o.configs.isExactConflict, s, o.configs);
                                return s.nextSetBit(0)
                        }
                    }
                    if (ParserATNSimulator.dfa_debug) {
                        console.log("DFA decision " + e.decision + " predicts " + o.prediction)
                    }
                    return o.prediction
                }
                isAcceptState(e, t) {
                    if (!e.isAcceptState) {
                        return false
                    }
                    if (e.configs.conflictingAlts == null) {
                        return true
                    }
                    if (t && this.predictionMode === b.PredictionMode.LL_EXACT_AMBIG_DETECTION) {
                        return e.configs.isExactConflict
                    }
                    return true
                }
                execATN(e, t, r, n) {
                    if (ParserATNSimulator.debug) {
                        console.log("execATN decision " + e.decision + " exec LA(1)==" + this.getLookaheadName(t))
                    }
                    let i = n.outerContext;
                    let o = n.useContext;
                    let s = t.LA(1);
                    let a = n;
                    let l = new w.PredictionContextCache;
                    while (true) {
                        let n = this.computeReachSet(e, a, s, l);
                        if (n == null) {
                            this.setDFAEdge(a.s0, t.LA(1), d.ATNSimulator.ERROR);
                            return this.handleNoViableAlt(t, r, a)
                        }
                        let u = n.s0;
                        D(u.isAcceptState || u.prediction === _.ATN.INVALID_ALT_NUMBER);
                        D(u.isAcceptState || u.configs.conflictInfo == null);
                        if (this.isAcceptState(u, o)) {
                            let a = u.configs.conflictingAlts;
                            let l = a == null ? u.prediction : _.ATN.INVALID_ALT_NUMBER;
                            if (l !== _.ATN.INVALID_ALT_NUMBER) {
                                if (this.optimize_ll1 && t.index === r && !e.isPrecedenceDfa && n.outerContext === n.remainingOuterContext && e.decision >= 0 && !u.configs.hasSemanticContext) {
                                    if (s >= 0 && s <= k) {
                                        let t = (e.decision << 16 >>> 0) + s;
                                        this.atn.LL1Table.set(t, l)
                                    }
                                }
                                if (o && this.always_try_local_context) {
                                    this.reportContextSensitivity(e, l, n, r, t.index)
                                }
                            }
                            l = u.prediction;
                            let c = a != null && this.userWantsCtxSensitive;
                            if (c) {
                                c = !o && (u.configs.dipsIntoOuterContext || !u.configs.isExactConflict) && (!this.treat_sllk1_conflict_as_ambiguity || t.index !== r)
                            }
                            if (u.configs.hasSemanticContext) {
                                let e = u.predicates;
                                if (e != null) {
                                    let n = t.index;
                                    if (n !== r) {
                                        t.seek(r)
                                    }
                                    a = this.evalSemanticContext(e, i, c || this.reportAmbiguities);
                                    switch (a.cardinality()) {
                                        case 0:
                                            throw this.noViableAlt(t, i, u.configs, r);
                                        case 1:
                                            return a.nextSetBit(0);
                                        default:
                                            break
                                    }
                                    if (n !== r) {
                                        t.seek(n)
                                    }
                                }
                            }
                            if (!c) {
                                if (a != null) {
                                    if (this.reportAmbiguities && a.cardinality() > 1) {
                                        this.reportAmbiguity(e, u, r, t.index, u.configs.isExactConflict, a, u.configs)
                                    }
                                    l = a.nextSetBit(0)
                                }
                                return l
                            } else {
                                D(!o);
                                D(this.isAcceptState(u, false));
                                if (ParserATNSimulator.debug) {
                                    console.log("RETRY with outerContext=" + i)
                                }
                                let s = this.computeStartState(e, i, true);
                                if (this.reportAmbiguities) {
                                    this.reportAttemptingFullContext(e, a, n, r, t.index)
                                }
                                t.seek(r);
                                return this.execATN(e, t, r, s)
                            }
                        }
                        a = n;
                        if (s !== x.IntStream.EOF) {
                            t.consume();
                            s = t.LA(1)
                        }
                    }
                }
                handleNoViableAlt(e, t, r) {
                    if (r.s0 != null) {
                        let n = new h.BitSet;
                        let i = 0;
                        for (let e of r.s0.configs) {
                            if (e.reachesIntoOuterContext || e.state instanceof F.RuleStopState) {
                                n.set(e.alt);
                                i = Math.max(i, e.alt)
                            }
                        }
                        switch (n.cardinality()) {
                            case 0:
                                break;
                            case 1:
                                return n.nextSetBit(0);
                            default:
                                if (!r.s0.configs.hasSemanticContext) {
                                    return n.nextSetBit(0)
                                }
                                let o = new c.ATNConfigSet;
                                for (let e of r.s0.configs) {
                                    if (e.reachesIntoOuterContext || e.state instanceof F.RuleStopState) {
                                        o.add(e)
                                    }
                                }
                                let s = this.getPredsForAmbigAlts(n, o, i);
                                if (s != null) {
                                    let i = this.getPredicatePredictions(n, s);
                                    if (i != null) {
                                        let n = e.index;
                                        try {
                                            e.seek(t);
                                            let o = this.evalSemanticContext(i, r.outerContext, false);
                                            if (!o.isEmpty) {
                                                return o.nextSetBit(0)
                                            }
                                        } finally {
                                            e.seek(n)
                                        }
                                    }
                                }
                                return n.nextSetBit(0)
                        }
                    }
                    throw this.noViableAlt(e, r.outerContext, r.s0.configs, t)
                }
                computeReachSet(e, t, r, n) {
                    let i = t.useContext;
                    let o = t.remainingOuterContext;
                    let s = t.s0;
                    if (i) {
                        while (s.isContextSymbol(r)) {
                            let e;
                            if (o != null) {
                                o = this.skipTailCalls(o);
                                e = s.getContextTarget(this.getReturnState(o))
                            }
                            if (e == null) {
                                break
                            }
                            D(o != null);
                            o = o.parent;
                            s = e
                        }
                    }
                    D(!this.isAcceptState(s, i));
                    if (this.isAcceptState(s, i)) {
                        return new P.SimulatorState(t.outerContext, s, i, o)
                    }
                    let a = s;
                    let l = this.getExistingTargetState(a, r);
                    if (l == null) {
                        let t = this.computeTargetState(e, a, o, r, i, n);
                        l = t[0];
                        o = t[1]
                    }
                    if (l === d.ATNSimulator.ERROR) {
                        return undefined
                    }
                    D(!i || !l.configs.dipsIntoOuterContext);
                    return new P.SimulatorState(t.outerContext, l, i, o)
                }
                getExistingTargetState(e, t) {
                    return e.getTarget(t)
                }
                computeTargetState(e, t, r, n, i, o) {
                    let s = t.configs.toArray();
                    let a;
                    let l = new c.ATNConfigSet;
                    let u;
                    do {
                        let e = !i || r != null;
                        if (!e) {
                            l.isOutermostConfigSet = true
                        }
                        let t = new c.ATNConfigSet;
                        let d;
                        for (let e of s) {
                            if (ParserATNSimulator.debug) {
                                console.log("testing " + this.getTokenName(n) + " at " + e.toString())
                            }
                            if (e.state instanceof F.RuleStopState) {
                                D(e.context.isEmpty);
                                if (i && !e.reachesIntoOuterContext || n === x.IntStream.EOF) {
                                    if (d == null) {
                                        d = []
                                    }
                                    d.push(e)
                                }
                                continue
                            }
                            let r = e.state.numberOfOptimizedTransitions;
                            for (let i = 0; i < r; i++) {
                                let r = e.state.getOptimizedTransition(i);
                                let s = this.getReachableTarget(e, r, n);
                                if (s != null) {
                                    t.add(e.transform(s, false), o)
                                }
                            }
                        }
                        if (this.optimize_unique_closure && d == null && n !== O.Token.EOF && t.uniqueAlt !== _.ATN.INVALID_ALT_NUMBER) {
                            t.isOutermostConfigSet = l.isOutermostConfigSet;
                            l = t;
                            break
                        }
                        let p = false;
                        let f = n === O.Token.EOF;
                        this.closure(t, l, p, e, o, f);
                        u = l.dipsIntoOuterContext;
                        if (n === x.IntStream.EOF) {
                            l = this.removeAllConfigsNotInRuleStopState(l, o)
                        }
                        if (d != null && (!i || !b.PredictionMode.hasConfigInRuleStopState(l))) {
                            D(d.length > 0);
                            for (let e of d) {
                                l.add(e, o)
                            }
                        }
                        if (i && u) {
                            l.clear();
                            r = r;
                            r = this.skipTailCalls(r);
                            let e = this.getReturnState(r);
                            if (a == null) {
                                a = new S.IntegerList
                            }
                            if (r.isEmpty) {
                                r = undefined
                            } else {
                                r = r.parent
                            }
                            a.add(e);
                            if (e !== M.PredictionContext.EMPTY_FULL_STATE_KEY) {
                                for (let t = 0; t < s.length; t++) {
                                    s[t] = s[t].appendContext(e, o)
                                }
                            }
                        }
                    } while (i && u);
                    if (l.isEmpty) {
                        this.setDFAEdge(t, n, d.ATNSimulator.ERROR);
                        return [d.ATNSimulator.ERROR, r]
                    }
                    let p = this.addDFAEdge(e, t, n, a, l, o);
                    return [p, r]
                }
                removeAllConfigsNotInRuleStopState(e, t) {
                    if (b.PredictionMode.allConfigsInRuleStopStates(e)) {
                        return e
                    }
                    let r = new c.ATNConfigSet;
                    for (let n of e) {
                        if (!(n.state instanceof F.RuleStopState)) {
                            continue
                        }
                        r.add(n, t)
                    }
                    return r
                }
                computeStartState(e, t, r) {
                    let n = e.isPrecedenceDfa ? e.getPrecedenceStartState(this._parser.precedence, r) : r ? e.s0full : e.s0;
                    if (n != null) {
                        if (!r) {
                            return new P.SimulatorState(t, n, r, t)
                        }
                        n.setContextSensitive(this.atn)
                    }
                    let i = e.decision;
                    let o = e.atnStartState;
                    let s = 0;
                    let a = t;
                    let l = r ? M.PredictionContext.EMPTY_FULL : M.PredictionContext.EMPTY_LOCAL;
                    let _ = new w.PredictionContextCache;
                    if (r) {
                        if (!this.enable_global_context_dfa) {
                            while (a != null) {
                                if (a.isEmpty) {
                                    s = M.PredictionContext.EMPTY_FULL_STATE_KEY;
                                    a = undefined
                                } else {
                                    s = this.getReturnState(a);
                                    l = l.appendSingleContext(s, _);
                                    a = a.parent
                                }
                            }
                        }
                        while (n != null && n.isContextSensitive && a != null) {
                            let e;
                            a = this.skipTailCalls(a);
                            if (a.isEmpty) {
                                e = n.getContextTarget(M.PredictionContext.EMPTY_FULL_STATE_KEY);
                                s = M.PredictionContext.EMPTY_FULL_STATE_KEY;
                                a = undefined
                            } else {
                                s = this.getReturnState(a);
                                e = n.getContextTarget(s);
                                l = l.appendSingleContext(s, _);
                                a = a.parent
                            }
                            if (e == null) {
                                break
                            }
                            n = e
                        }
                    }
                    if (n != null && !n.isContextSensitive) {
                        return new P.SimulatorState(t, n, r, a)
                    }
                    let d = new c.ATNConfigSet;
                    while (true) {
                        let i = new c.ATNConfigSet;
                        let p = o.numberOfTransitions;
                        for (let e = 0; e < p; e++) {
                            let t = o.transition(e).target;
                            i.add(u.ATNConfig.create(t, e + 1, l))
                        }
                        let f = a != null;
                        if (!f) {
                            d.isOutermostConfigSet = true
                        }
                        let h = true;
                        this.closure(i, d, h, f, _, false);
                        let g = d.dipsIntoOuterContext;
                        let m;
                        if (r && !this.enable_global_context_dfa) {
                            n = this.addDFAState(e, d, _);
                            break
                        } else if (n == null) {
                            if (!e.isPrecedenceDfa) {
                                m = this.addDFAState(e, d, _);
                                if (r) {
                                    if (!e.s0full) {
                                        e.s0full = m
                                    } else {
                                        m = e.s0full
                                    }
                                } else {
                                    if (!e.s0) {
                                        e.s0 = m
                                    } else {
                                        m = e.s0
                                    }
                                }
                            } else {
                                d = this.applyPrecedenceFilter(d, t, _);
                                m = this.addDFAState(e, d, _);
                                e.setPrecedenceStartState(this._parser.precedence, r, m)
                            }
                        } else {
                            if (e.isPrecedenceDfa) {
                                d = this.applyPrecedenceFilter(d, t, _)
                            }
                            m = this.addDFAState(e, d, _);
                            n.setContextTarget(s, m)
                        }
                        n = m;
                        if (!r || !g) {
                            break
                        }
                        m.setContextSensitive(this.atn);
                        a = a;
                        d.clear();
                        a = this.skipTailCalls(a);
                        let y = this.getReturnState(a);
                        if (a.isEmpty) {
                            a = undefined
                        } else {
                            a = a.parent
                        }
                        if (y !== M.PredictionContext.EMPTY_FULL_STATE_KEY) {
                            l = l.appendSingleContext(y, _)
                        }
                        s = y
                    }
                    return new P.SimulatorState(t, n, r, a)
                }
                applyPrecedenceFilter(e, t, r) {
                    let n = new Map;
                    let i = new c.ATNConfigSet;
                    for (let o of e) {
                        if (o.alt !== 1) {
                            continue
                        }
                        let e = o.semanticContext.evalPrecedence(this._parser, t);
                        if (e == null) {
                            continue
                        }
                        n.set(o.state.stateNumber, o.context);
                        if (e !== o.semanticContext) {
                            i.add(o.transform(o.state, false, e), r)
                        } else {
                            i.add(o, r)
                        }
                    }
                    for (let t of e) {
                        if (t.alt === 1) {
                            continue
                        }
                        if (!t.isPrecedenceFilterSuppressed) {
                            let e = n.get(t.state.stateNumber);
                            if (e != null && e.equals(t.context)) {
                                continue
                            }
                        }
                        i.add(t, r)
                    }
                    return i
                }
                getReachableTarget(e, t, r) {
                    if (t.matches(r, 0, this.atn.maxTokenType)) {
                        return t.target
                    }
                    return undefined
                }
                predicateDFAState(e, t, r) {
                    let n = this.getConflictingAltsFromConfigSet(t);
                    if (!n) {
                        throw new Error("This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.")
                    }
                    if (ParserATNSimulator.debug) {
                        console.log("predicateDFAState " + e)
                    }
                    let i = this.getPredsForAmbigAlts(n, t, r);
                    let o;
                    if (i != null) {
                        o = this.getPredicatePredictions(n, i);
                        e.predicates = o
                    }
                    return o
                }
                getPredsForAmbigAlts(e, t, r) {
                    let n = new Array(r + 1);
                    let i = n.length;
                    for (let r of t) {
                        if (e.get(r.alt)) {
                            n[r.alt] = I.SemanticContext.or(n[r.alt], r.semanticContext)
                        }
                    }
                    let o = 0;
                    for (let e = 0; e < i; e++) {
                        if (n[e] == null) {
                            n[e] = I.SemanticContext.NONE
                        } else if (n[e] !== I.SemanticContext.NONE) {
                            o++
                        }
                    }
                    let s = n;
                    if (o === 0) {
                        s = undefined
                    }
                    if (ParserATNSimulator.debug) {
                        console.log("getPredsForAmbigAlts result " + (s ? l.Arrays.toString(s) : "undefined"))
                    }
                    return s
                }
                getPredicatePredictions(e, t) {
                    let r = [];
                    let n = false;
                    for (let i = 1; i < t.length; i++) {
                        let o = t[i];
                        D(o != null);
                        if (e != null && e.get(i) && o === I.SemanticContext.NONE) {
                            r.push(new y.DFAState.PredPrediction(o, i))
                        } else if (o !== I.SemanticContext.NONE) {
                            n = true;
                            r.push(new y.DFAState.PredPrediction(o, i))
                        }
                    }
                    if (!n) {
                        return undefined
                    }
                    return r
                }
                evalSemanticContext(e, t, r) {
                    let n = new h.BitSet;
                    for (let i of e) {
                        if (i.pred === I.SemanticContext.NONE) {
                            n.set(i.alt);
                            if (!r) {
                                break
                            }
                            continue
                        }
                        let e = this.evalSemanticContextImpl(i.pred, t, i.alt);
                        if (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {
                            console.log("eval pred " + i + "=" + e)
                        }
                        if (e) {
                            if (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {
                                console.log("PREDICT " + i.alt)
                            }
                            n.set(i.alt);
                            if (!r) {
                                break
                            }
                        }
                    }
                    return n
                }
                evalSemanticContextImpl(e, t, r) {
                    return e.eval(this._parser, t)
                }
                closure(e, t, r, n, i, o) {
                    if (i == null) {
                        i = w.PredictionContextCache.UNCACHED
                    }
                    let s = e;
                    let l = new a.Array2DHashSet(E.ObjectEqualityComparator.INSTANCE);
                    while (s.size > 0) {
                        let e = new c.ATNConfigSet;
                        for (let a of s) {
                            this.closureImpl(a, t, e, l, r, n, i, 0, o)
                        }
                        s = e
                    }
                }
                closureImpl(e, t, r, n, i, o, a, l, _) {
                    if (ParserATNSimulator.debug) {
                        console.log("closure(" + e.toString(this._parser, true) + ")")
                    }
                    if (e.state instanceof F.RuleStopState) {
                        if (!e.context.isEmpty) {
                            let s = e.context.hasEmpty;
                            let c = e.context.size - (s ? 1 : 0);
                            for (let s = 0; s < c; s++) {
                                let c = e.context.getParent(s);
                                let d = this.atn.states[e.context.getReturnState(s)];
                                let p = u.ATNConfig.create(d, e.alt, c, e.semanticContext);
                                p.outerContextDepth = e.outerContextDepth;
                                p.isPrecedenceFilterSuppressed = e.isPrecedenceFilterSuppressed;
                                D(l > $);
                                this.closureImpl(p, t, r, n, i, o, a, l - 1, _)
                            }
                            if (!s || !o) {
                                return
                            }
                            e = e.transform(e.state, false, M.PredictionContext.EMPTY_LOCAL)
                        } else if (!o) {
                            t.add(e, a);
                            return
                        } else {
                            if (ParserATNSimulator.debug) {
                                console.log("FALLING off rule " + this.getRuleName(e.state.ruleIndex))
                            }
                            if (e.context === M.PredictionContext.EMPTY_FULL) {
                                e = e.transform(e.state, false, M.PredictionContext.EMPTY_LOCAL)
                            } else if (!e.reachesIntoOuterContext && M.PredictionContext.isEmptyLocal(e.context)) {
                                t.add(e, a)
                            }
                        }
                    }
                    let c = e.state;
                    if (!c.onlyHasEpsilonTransitions) {
                        t.add(e, a);
                        if (ParserATNSimulator.debug) {
                            console.log("added config " + t)
                        }
                    }
                    for (let u = 0; u < c.numberOfOptimizedTransitions; u++) {
                        if (u === 0 && c.stateType === p.ATNStateType.STAR_LOOP_ENTRY && c.precedenceRuleDecision && !e.context.hasEmpty) {
                            let t = c;
                            let r = true;
                            for (let n = 0; n < e.context.size; n++) {
                                if (!t.precedenceLoopbackStates.get(e.context.getReturnState(n))) {
                                    r = false;
                                    break
                                }
                            }
                            if (r) {
                                continue
                            }
                        }
                        let d = c.getOptimizedTransition(u);
                        let f = !(d instanceof s.ActionTransition) && i;
                        let h = this.getEpsilonTarget(e, d, f, l === 0, a, _);
                        if (h != null) {
                            if (d instanceof B.RuleTransition) {
                                if (r != null && !i) {
                                    r.add(h, a);
                                    continue
                                }
                            }
                            let s = l;
                            if (e.state instanceof F.RuleStopState) {
                                if (this.dfa != null && this.dfa.isPrecedenceDfa) {
                                    let e = d.outermostPrecedenceReturn;
                                    if (e === this.dfa.atnStartState.ruleIndex) {
                                        h.isPrecedenceFilterSuppressed = true
                                    }
                                }
                                h.outerContextDepth = h.outerContextDepth + 1;
                                if (!n.add(h)) {
                                    continue
                                }
                                D(s > $);
                                s--;
                                if (ParserATNSimulator.debug) {
                                    console.log("dips into outer ctx: " + h)
                                }
                            } else if (d instanceof B.RuleTransition) {
                                if (this.optimize_tail_calls && d.optimizedTailCall && (!this.tail_call_preserves_sll || !M.PredictionContext.isEmptyLocal(e.context))) {
                                    D(h.context === e.context);
                                    if (s === 0) {
                                        s--;
                                        if (!this.tail_call_preserves_sll && M.PredictionContext.isEmptyLocal(e.context)) {
                                            h.outerContextDepth = h.outerContextDepth + 1
                                        }
                                    }
                                } else {
                                    if (s >= 0) {
                                        s++
                                    }
                                }
                            } else {
                                if (!d.isEpsilon && !n.add(h)) {
                                    continue
                                }
                            }
                            this.closureImpl(h, t, r, n, f, o, a, s, _)
                        }
                    }
                }
                getRuleName(e) {
                    if (this._parser != null && e >= 0) {
                        return this._parser.ruleNames[e]
                    }
                    return "<rule " + e + ">"
                }
                getEpsilonTarget(e, t, r, n, i, o) {
                    switch (t.serializationType) {
                        case 3:
                            return this.ruleTransition(e, t, i);
                        case 10:
                            return this.precedenceTransition(e, t, r, n);
                        case 4:
                            return this.predTransition(e, t, r, n);
                        case 6:
                            return this.actionTransition(e, t);
                        case 1:
                            return e.transform(t.target, false);
                        case 5:
                        case 2:
                        case 7:
                            if (o) {
                                if (t.matches(O.Token.EOF, 0, 1)) {
                                    return e.transform(t.target, false)
                                }
                            }
                            return undefined;
                        default:
                            return undefined
                    }
                }
                actionTransition(e, t) {
                    if (ParserATNSimulator.debug) {
                        console.log("ACTION edge " + t.ruleIndex + ":" + t.actionIndex)
                    }
                    return e.transform(t.target, false)
                }
                precedenceTransition(e, t, r, n) {
                    if (ParserATNSimulator.debug) {
                        console.log("PRED (collectPredicates=" + r + ") " + t.precedence + ">=_p" + ", ctx dependent=true");
                        if (this._parser != null) {
                            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack())
                        }
                    }
                    let i;
                    if (r && n) {
                        let r = I.SemanticContext.and(e.semanticContext, t.predicate);
                        i = e.transform(t.target, false, r)
                    } else {
                        i = e.transform(t.target, false)
                    }
                    if (ParserATNSimulator.debug) {
                        console.log("config from pred transition=" + i)
                    }
                    return i
                }
                predTransition(e, t, r, n) {
                    if (ParserATNSimulator.debug) {
                        console.log("PRED (collectPredicates=" + r + ") " + t.ruleIndex + ":" + t.predIndex + ", ctx dependent=" + t.isCtxDependent);
                        if (this._parser != null) {
                            console.log("context surrounding pred is " + this._parser.getRuleInvocationStack())
                        }
                    }
                    let i;
                    if (r && (!t.isCtxDependent || t.isCtxDependent && n)) {
                        let r = I.SemanticContext.and(e.semanticContext, t.predicate);
                        i = e.transform(t.target, false, r)
                    } else {
                        i = e.transform(t.target, false)
                    }
                    if (ParserATNSimulator.debug) {
                        console.log("config from pred transition=" + i)
                    }
                    return i
                }
                ruleTransition(e, t, r) {
                    if (ParserATNSimulator.debug) {
                        console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + e.context)
                    }
                    let n = t.followState;
                    let i;
                    if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !M.PredictionContext.isEmptyLocal(e.context))) {
                        i = e.context
                    } else if (r != null) {
                        i = r.getChild(e.context, n.stateNumber)
                    } else {
                        i = e.context.getChild(n.stateNumber)
                    }
                    return e.transform(t.target, false, i)
                }
                isConflicted(e, t) {
                    if (e.uniqueAlt !== _.ATN.INVALID_ALT_NUMBER || e.size <= 1) {
                        return undefined
                    }
                    let r = e.toArray();
                    r.sort(ParserATNSimulator.STATE_ALT_SORT_COMPARATOR);
                    let n = !e.dipsIntoOuterContext;
                    let i = new h.BitSet;
                    let o = r[0].alt;
                    i.set(o);
                    let s = r[0].state.nonStopStateNumber;
                    for (let e of r) {
                        let t = e.state.nonStopStateNumber;
                        if (t !== s) {
                            if (e.alt !== o) {
                                return undefined
                            }
                            s = t
                        }
                    }
                    let a;
                    if (n) {
                        s = r[0].state.nonStopStateNumber;
                        a = new h.BitSet;
                        let e = o;
                        for (let t of r) {
                            if (t.state.nonStopStateNumber !== s) {
                                break
                            }
                            let r = t.alt;
                            a.set(r);
                            e = r
                        }
                        s = r[0].state.nonStopStateNumber;
                        let t = o;
                        for (let i of r) {
                            let r = i.state.nonStopStateNumber;
                            let l = i.alt;
                            if (r !== s) {
                                if (t !== e) {
                                    n = false;
                                    break
                                }
                                s = r;
                                t = o
                            } else if (l !== t) {
                                if (l !== a.nextSetBit(t + 1)) {
                                    n = false;
                                    break
                                }
                                t = l
                            }
                        }
                    }
                    s = r[0].state.nonStopStateNumber;
                    let l = 0;
                    let u = 0;
                    let c = r[0].context;
                    for (let e = 1; e < r.length; e++) {
                        let n = r[e];
                        if (n.alt !== o) {
                            break
                        }
                        if (n.state.nonStopStateNumber !== s) {
                            break
                        }
                        u = e;
                        c = t.join(c, r[e].context)
                    }
                    for (let e = u + 1; e < r.length; e++) {
                        let a = r[e];
                        let _ = a.state;
                        i.set(a.alt);
                        if (_.nonStopStateNumber !== s) {
                            s = _.nonStopStateNumber;
                            l = e;
                            u = e;
                            c = a.context;
                            for (let e = l + 1; e < r.length; e++) {
                                let n = r[e];
                                if (n.alt !== o) {
                                    break
                                }
                                if (n.state.nonStopStateNumber !== s) {
                                    break
                                }
                                u = e;
                                c = t.join(c, n.context)
                            }
                            e = u;
                            continue
                        }
                        let d = a.context;
                        let p = a.alt;
                        let f = e;
                        for (let e = f + 1; e < r.length; e++) {
                            let n = r[e];
                            if (n.alt !== p) {
                                break
                            }
                            if (n.state.nonStopStateNumber !== s) {
                                break
                            }
                            f = e;
                            d = t.join(d, n.context)
                        }
                        e = f;
                        let h = t.join(c, d);
                        if (!c.equals(h)) {
                            return undefined
                        }
                        n = n && c.equals(d)
                    }
                    return new g.ConflictInfo(i, n)
                }
                getConflictingAltsFromConfigSet(e) {
                    let t = e.conflictingAlts;
                    if (t == null && e.uniqueAlt !== _.ATN.INVALID_ALT_NUMBER) {
                        t = new h.BitSet;
                        t.set(e.uniqueAlt)
                    }
                    return t
                }
                getTokenName(e) {
                    if (e === O.Token.EOF) {
                        return "EOF"
                    }
                    let t = this._parser != null ? this._parser.vocabulary : R.VocabularyImpl.EMPTY_VOCABULARY;
                    let r = t.getDisplayName(e);
                    if (r === String(e)) {
                        return r
                    }
                    return r + "<" + e + ">"
                }
                getLookaheadName(e) {
                    return this.getTokenName(e.LA(1))
                }
                dumpDeadEndConfigs(e) {
                    console.log("dead end configs: ");
                    let t = e.deadEndConfigs;
                    if (!t) {
                        return
                    }
                    for (let e of t) {
                        let t = "no edges";
                        if (e.state.numberOfOptimizedTransitions > 0) {
                            let r = e.state.getOptimizedTransition(0);
                            if (r instanceof f.AtomTransition) {
                                t = "Atom " + this.getTokenName(r._label)
                            } else if (r instanceof L.SetTransition) {
                                let e = r instanceof N.NotSetTransition;
                                t = (e ? "~" : "") + "Set " + r.set.toString()
                            }
                        }
                        console.log(e.toString(this._parser, true) + ":" + t)
                    }
                }
                noViableAlt(e, t, r, n) {
                    return new A.NoViableAltException(this._parser, e, e.get(n), e.LT(1), r, t)
                }
                getUniqueAlt(e) {
                    let t = _.ATN.INVALID_ALT_NUMBER;
                    for (let r of e) {
                        if (t === _.ATN.INVALID_ALT_NUMBER) {
                            t = r.alt
                        } else if (r.alt !== t) {
                            return _.ATN.INVALID_ALT_NUMBER
                        }
                    }
                    return t
                }
                configWithAltAtStopState(e, t) {
                    for (let r of e) {
                        if (r.alt === t) {
                            if (r.state instanceof F.RuleStopState) {
                                return true
                            }
                        }
                    }
                    return false
                }
                addDFAEdge(e, t, r, n, i, o) {
                    D(n == null || n.isEmpty || e.isContextSensitive);
                    let s = t;
                    let a = this.addDFAState(e, i, o);
                    if (n != null) {
                        for (let t of n.toArray()) {
                            if (t === M.PredictionContext.EMPTY_FULL_STATE_KEY) {
                                if (s.configs.isOutermostConfigSet) {
                                    continue
                                }
                            }
                            s.setContextSensitive(this.atn);
                            s.setContextSymbol(r);
                            let n = s.getContextTarget(t);
                            if (n != null) {
                                s = n;
                                continue
                            }
                            n = this.addDFAContextState(e, s.configs, t, o);
                            D(t !== M.PredictionContext.EMPTY_FULL_STATE_KEY || n.configs.isOutermostConfigSet);
                            s.setContextTarget(t, n);
                            s = n
                        }
                    }
                    if (ParserATNSimulator.debug) {
                        console.log("EDGE " + s + " -> " + a + " upon " + this.getTokenName(r))
                    }
                    this.setDFAEdge(s, r, a);
                    if (ParserATNSimulator.debug) {
                        console.log("DFA=\n" + e.toString(this._parser != null ? this._parser.vocabulary : R.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : undefined))
                    }
                    return a
                }
                setDFAEdge(e, t, r) {
                    if (e != null) {
                        e.setTarget(t, r)
                    }
                }
                addDFAContextState(e, t, r, n) {
                    if (r !== M.PredictionContext.EMPTY_FULL_STATE_KEY) {
                        let i = new c.ATNConfigSet;
                        for (let e of t) {
                            i.add(e.appendContext(r, n))
                        }
                        return this.addDFAState(e, i, n)
                    } else {
                        D(!t.isOutermostConfigSet, "Shouldn't be adding a duplicate edge.");
                        t = t.clone(true);
                        t.isOutermostConfigSet = true;
                        return this.addDFAState(e, t, n)
                    }
                }
                addDFAState(e, t, r) {
                    let n = this.enable_global_context_dfa || !t.isOutermostConfigSet;
                    if (n) {
                        if (!t.isReadOnly) {
                            t.optimizeConfigs(this)
                        }
                        let r = this.createDFAState(e, t);
                        let n = e.states.get(r);
                        if (n != null) {
                            return n
                        }
                    }
                    if (!t.isReadOnly) {
                        if (t.conflictInfo == null) {
                            t.conflictInfo = this.isConflicted(t, r)
                        }
                    }
                    let i = this.createDFAState(e, t.clone(true));
                    let s = this.atn.getDecisionState(e.decision);
                    let a = this.getUniqueAlt(t);
                    if (a !== _.ATN.INVALID_ALT_NUMBER) {
                        i.acceptStateInfo = new o.AcceptStateInfo(a)
                    } else if (t.conflictingAlts != null) {
                        let e = t.conflictingAlts;
                        if (e) {
                            i.acceptStateInfo = new o.AcceptStateInfo(e.nextSetBit(0))
                        }
                    }
                    if (i.isAcceptState && t.hasSemanticContext) {
                        this.predicateDFAState(i, t, s.numberOfTransitions)
                    }
                    if (!n) {
                        return i
                    }
                    let l = e.addState(i);
                    if (ParserATNSimulator.debug && l === i) {
                        console.log("adding new DFA state: " + i)
                    }
                    return l
                }
                createDFAState(e, t) {
                    return new y.DFAState(t)
                }
                reportAttemptingFullContext(e, t, r, n, i) {
                    if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {
                        let t = T.Interval.of(n, i);
                        console.log("reportAttemptingFullContext decision=" + e.decision + ":" + r.s0.configs + ", input=" + this._parser.inputStream.getText(t))
                    }
                    if (this._parser != null) {
                        let o = this._parser.getErrorListenerDispatch();
                        if (o.reportAttemptingFullContext) {
                            o.reportAttemptingFullContext(this._parser, e, n, i, t, r)
                        }
                    }
                }
                reportContextSensitivity(e, t, r, n, i) {
                    if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {
                        let t = T.Interval.of(n, i);
                        console.log("reportContextSensitivity decision=" + e.decision + ":" + r.s0.configs + ", input=" + this._parser.inputStream.getText(t))
                    }
                    if (this._parser != null) {
                        let o = this._parser.getErrorListenerDispatch();
                        if (o.reportContextSensitivity) {
                            o.reportContextSensitivity(this._parser, e, n, i, t, r)
                        }
                    }
                }
                reportAmbiguity(e, t, r, n, i, o, s) {
                    if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {
                        let e = T.Interval.of(r, n);
                        console.log("reportAmbiguity " + o + ":" + s + ", input=" + this._parser.inputStream.getText(e))
                    }
                    if (this._parser != null) {
                        let t = this._parser.getErrorListenerDispatch();
                        if (t.reportAmbiguity) {
                            t.reportAmbiguity(this._parser, e, r, n, i, o, s)
                        }
                    }
                }
                getReturnState(e) {
                    if (e.isEmpty) {
                        return M.PredictionContext.EMPTY_FULL_STATE_KEY
                    }
                    let t = this.atn.states[e.invokingState];
                    let r = t.transition(0);
                    return r.followState.stateNumber
                }
                skipTailCalls(e) {
                    if (!this.optimize_tail_calls) {
                        return e
                    }
                    while (!e.isEmpty) {
                        let t = this.atn.states[e.invokingState];
                        D(t.numberOfTransitions === 1 && t.transition(0).serializationType === 3);
                        let r = t.transition(0);
                        if (!r.tailCall) {
                            break
                        }
                        e = e.parent
                    }
                    return e
                }
                get parser() {
                    return this._parser
                }
            };
            j.debug = false;
            j.dfa_debug = false;
            j.retry_debug = false;
            j.STATE_ALT_SORT_COMPARATOR = (e, t) => {
                let r = e.state.nonStopStateNumber - t.state.nonStopStateNumber;
                if (r !== 0) {
                    return r
                }
                r = e.alt - t.alt;
                if (r !== 0) {
                    return r
                }
                return 0
            };
            n([C.NotNull], j.prototype, "predictionMode", void 0);
            n([C.NotNull], j.prototype, "getPredictionMode", null);
            n([i(0, C.NotNull)], j.prototype, "setPredictionMode", null);
            n([C.Override], j.prototype, "reset", null);
            n([i(0, C.NotNull)], j.prototype, "adaptivePredict", null);
            n([i(0, C.NotNull), i(1, C.NotNull), i(2, C.NotNull)], j.prototype, "getStartState", null);
            n([i(0, C.NotNull), i(1, C.NotNull), i(3, C.NotNull)], j.prototype, "execDFA", null);
            n([i(0, C.NotNull), i(1, C.NotNull), i(3, C.NotNull)], j.prototype, "execATN", null);
            n([i(0, C.NotNull), i(2, C.NotNull)], j.prototype, "handleNoViableAlt", null);
            n([i(0, C.NotNull)], j.prototype, "getExistingTargetState", null);
            n([C.NotNull, i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "computeTargetState", null);
            n([C.NotNull, i(0, C.NotNull)], j.prototype, "removeAllConfigsNotInRuleStopState", null);
            n([C.NotNull], j.prototype, "computeStartState", null);
            n([C.NotNull, i(0, C.NotNull)], j.prototype, "applyPrecedenceFilter", null);
            n([i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "getReachableTarget", null);
            n([i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "getPredsForAmbigAlts", null);
            n([i(0, C.NotNull)], j.prototype, "evalSemanticContext", null);
            n([i(0, C.NotNull)], j.prototype, "evalSemanticContextImpl", null);
            n([i(1, C.NotNull), i(4, C.Nullable)], j.prototype, "closure", null);
            n([i(0, C.NotNull), i(1, C.NotNull), i(2, C.Nullable), i(3, C.NotNull), i(6, C.NotNull)], j.prototype, "closureImpl", null);
            n([C.NotNull], j.prototype, "getRuleName", null);
            n([i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "getEpsilonTarget", null);
            n([C.NotNull, i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "actionTransition", null);
            n([C.Nullable, i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "precedenceTransition", null);
            n([C.Nullable, i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "predTransition", null);
            n([C.NotNull, i(0, C.NotNull), i(1, C.NotNull), i(2, C.Nullable)], j.prototype, "ruleTransition", null);
            n([i(0, C.NotNull)], j.prototype, "isConflicted", null);
            n([C.NotNull], j.prototype, "getTokenName", null);
            n([i(0, C.NotNull)], j.prototype, "dumpDeadEndConfigs", null);
            n([C.NotNull, i(0, C.NotNull), i(1, C.NotNull), i(2, C.NotNull)], j.prototype, "noViableAlt", null);
            n([i(0, C.NotNull)], j.prototype, "getUniqueAlt", null);
            n([i(0, C.NotNull)], j.prototype, "configWithAltAtStopState", null);
            n([C.NotNull, i(0, C.NotNull), i(1, C.NotNull), i(4, C.NotNull)], j.prototype, "addDFAEdge", null);
            n([i(0, C.Nullable), i(2, C.Nullable)], j.prototype, "setDFAEdge", null);
            n([C.NotNull, i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "addDFAContextState", null);
            n([C.NotNull, i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "addDFAState", null);
            n([C.NotNull, i(0, C.NotNull), i(1, C.NotNull)], j.prototype, "createDFAState", null);
            n([i(0, C.NotNull), i(2, C.NotNull)], j.prototype, "reportAttemptingFullContext", null);
            n([i(0, C.NotNull), i(2, C.NotNull)], j.prototype, "reportContextSensitivity", null);
            n([i(0, C.NotNull), i(5, C.NotNull), i(6, C.NotNull)], j.prototype, "reportAmbiguity", null);
            j = n([i(0, C.NotNull)], j);
            t.ParserATNSimulator = j
        },
        6198: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PlusBlockStartState = void 0;
            const i = r(1765);
            const o = r(6039);
            const s = r(6966);
            class PlusBlockStartState extends o.BlockStartState {
                get stateType() {
                    return i.ATNStateType.PLUS_BLOCK_START
                }
            }
            n([s.Override], PlusBlockStartState.prototype, "stateType", null);
            t.PlusBlockStartState = PlusBlockStartState
        },
        2389: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PlusLoopbackState = void 0;
            const i = r(1765);
            const o = r(4402);
            const s = r(6966);
            class PlusLoopbackState extends o.DecisionState {
                get stateType() {
                    return i.ATNStateType.PLUS_LOOP_BACK
                }
            }
            n([s.Override], PlusLoopbackState.prototype, "stateType", null);
            t.PlusLoopbackState = PlusLoopbackState
        },
        3148: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PrecedencePredicateTransition = void 0;
            const o = r(9020);
            const s = r(6966);
            const a = r(4806);
            let l = class PrecedencePredicateTransition extends o.AbstractPredicateTransition {
                constructor(e, t) {
                    super(e);
                    this.precedence = t
                }
                get serializationType() {
                    return 10
                }
                get isEpsilon() {
                    return true
                }
                matches(e, t, r) {
                    return false
                }
                get predicate() {
                    return new a.SemanticContext.PrecedencePredicate(this.precedence)
                }
                toString() {
                    return this.precedence + " >= _p"
                }
            };
            n([s.Override], l.prototype, "serializationType", null);
            n([s.Override], l.prototype, "isEpsilon", null);
            n([s.Override], l.prototype, "matches", null);
            n([s.Override], l.prototype, "toString", null);
            l = n([i(0, s.NotNull)], l);
            t.PrecedencePredicateTransition = l
        },
        704: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PredicateEvalInfo = void 0;
            const o = r(4166);
            const s = r(6966);
            let a = class PredicateEvalInfo extends o.DecisionEventInfo {
                constructor(e, t, r, n, i, o, s, a) {
                    super(t, e, r, n, i, e.useContext);
                    this.semctx = o;
                    this.evalResult = s;
                    this.predictedAlt = a
                }
            };
            a = n([i(0, s.NotNull), i(2, s.NotNull), i(5, s.NotNull)], a);
            t.PredicateEvalInfo = a
        },
        1652: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PredicateTransition = void 0;
            const o = r(9020);
            const s = r(6966);
            const a = r(4806);
            let l = class PredicateTransition extends o.AbstractPredicateTransition {
                constructor(e, t, r, n) {
                    super(e);
                    this.ruleIndex = t;
                    this.predIndex = r;
                    this.isCtxDependent = n
                }
                get serializationType() {
                    return 4
                }
                get isEpsilon() {
                    return true
                }
                matches(e, t, r) {
                    return false
                }
                get predicate() {
                    return new a.SemanticContext.Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent)
                }
                toString() {
                    return "pred_" + this.ruleIndex + ":" + this.predIndex
                }
            };
            n([s.Override], l.prototype, "serializationType", null);
            n([s.Override], l.prototype, "isEpsilon", null);
            n([s.Override], l.prototype, "matches", null);
            n([s.Override, s.NotNull], l.prototype, "toString", null);
            l = n([i(0, s.NotNull)], l);
            t.PredicateTransition = l
        },
        5047: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SingletonPredictionContext = t.PredictionContext = void 0;
            const o = r(9605);
            const s = r(112);
            const a = r(4797);
            const l = r(5032);
            const _ = r(6966);
            const u = r(7545);
            const c = r(9491);
            const d = 1;
            class PredictionContext {
                constructor(e) {
                    this.cachedHashCode = e
                }
                static calculateEmptyHashCode() {
                    let e = l.MurmurHash.initialize(d);
                    e = l.MurmurHash.finish(e, 0);
                    return e
                }
                static calculateSingleHashCode(e, t) {
                    let r = l.MurmurHash.initialize(d);
                    r = l.MurmurHash.update(r, e);
                    r = l.MurmurHash.update(r, t);
                    r = l.MurmurHash.finish(r, 2);
                    return r
                }
                static calculateHashCode(e, t) {
                    let r = l.MurmurHash.initialize(d);
                    for (let t of e) {
                        r = l.MurmurHash.update(r, t)
                    }
                    for (let e of t) {
                        r = l.MurmurHash.update(r, e)
                    }
                    r = l.MurmurHash.finish(r, 2 * e.length);
                    return r
                }
                static fromRuleContext(e, t, r = true) {
                    if (t.isEmpty) {
                        return r ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL
                    }
                    let n;
                    if (t._parent) {
                        n = PredictionContext.fromRuleContext(e, t._parent, r)
                    } else {
                        n = r ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL
                    }
                    let i = e.states[t.invokingState];
                    let o = i.transition(0);
                    return n.getChild(o.followState.stateNumber)
                }
                static addEmptyContext(e) {
                    return e.addEmptyContext()
                }
                static removeEmptyContext(e) {
                    return e.removeEmptyContext()
                }
                static join(e, t, r = u.PredictionContextCache.UNCACHED) {
                    if (e === t) {
                        return e
                    }
                    if (e.isEmpty) {
                        return PredictionContext.isEmptyLocal(e) ? e : PredictionContext.addEmptyContext(t)
                    } else if (t.isEmpty) {
                        return PredictionContext.isEmptyLocal(t) ? t : PredictionContext.addEmptyContext(e)
                    }
                    let n = e.size;
                    let i = t.size;
                    if (n === 1 && i === 1 && e.getReturnState(0) === t.getReturnState(0)) {
                        let n = r.join(e.getParent(0), t.getParent(0));
                        if (n === e.getParent(0)) {
                            return e
                        } else if (n === t.getParent(0)) {
                            return t
                        } else {
                            return n.getChild(e.getReturnState(0))
                        }
                    }
                    let o = 0;
                    let s = new Array(n + i);
                    let a = new Array(s.length);
                    let l = 0;
                    let _ = 0;
                    let d = true;
                    let h = true;
                    while (l < n && _ < i) {
                        if (e.getReturnState(l) === t.getReturnState(_)) {
                            s[o] = r.join(e.getParent(l), t.getParent(_));
                            a[o] = e.getReturnState(l);
                            d = d && s[o] === e.getParent(l);
                            h = h && s[o] === t.getParent(_);
                            l++;
                            _++
                        } else if (e.getReturnState(l) < t.getReturnState(_)) {
                            s[o] = e.getParent(l);
                            a[o] = e.getReturnState(l);
                            h = false;
                            l++
                        } else {
                            c(t.getReturnState(_) < e.getReturnState(l));
                            s[o] = t.getParent(_);
                            a[o] = t.getReturnState(_);
                            d = false;
                            _++
                        }
                        o++
                    }
                    while (l < n) {
                        s[o] = e.getParent(l);
                        a[o] = e.getReturnState(l);
                        l++;
                        h = false;
                        o++
                    }
                    while (_ < i) {
                        s[o] = t.getParent(_);
                        a[o] = t.getReturnState(_);
                        _++;
                        d = false;
                        o++
                    }
                    if (d) {
                        return e
                    } else if (h) {
                        return t
                    }
                    if (o < s.length) {
                        s = s.slice(0, o);
                        a = a.slice(0, o)
                    }
                    if (s.length === 0) {
                        return PredictionContext.EMPTY_FULL
                    } else if (s.length === 1) {
                        return new f(s[0], a[0])
                    } else {
                        return new p(s, a)
                    }
                }
                static isEmptyLocal(e) {
                    return e === PredictionContext.EMPTY_LOCAL
                }
                static getCachedContext(e, t, r) {
                    if (e.isEmpty) {
                        return e
                    }
                    let n = r.get(e);
                    if (n) {
                        return n
                    }
                    n = t.get(e);
                    if (n) {
                        r.put(e, n);
                        return n
                    }
                    let i = false;
                    let o = new Array(e.size);
                    for (let n = 0; n < o.length; n++) {
                        let s = PredictionContext.getCachedContext(e.getParent(n), t, r);
                        if (i || s !== e.getParent(n)) {
                            if (!i) {
                                o = new Array(e.size);
                                for (let t = 0; t < e.size; t++) {
                                    o[t] = e.getParent(t)
                                }
                                i = true
                            }
                            o[n] = s
                        }
                    }
                    if (!i) {
                        n = t.putIfAbsent(e, e);
                        r.put(e, n != null ? n : e);
                        return e
                    }
                    let s;
                    if (o.length === 1) {
                        s = new f(o[0], e.getReturnState(0))
                    } else {
                        let t = new Array(e.size);
                        for (let r = 0; r < e.size; r++) {
                            t[r] = e.getReturnState(r)
                        }
                        s = new p(o, t, e.hashCode())
                    }
                    n = t.putIfAbsent(s, s);
                    r.put(s, n || s);
                    r.put(e, n || s);
                    return s
                }
                appendSingleContext(e, t) {
                    return this.appendContext(PredictionContext.EMPTY_FULL.getChild(e), t)
                }
                getChild(e) {
                    return new f(this, e)
                }
                hashCode() {
                    return this.cachedHashCode
                }
                toStrings(e, t, r = PredictionContext.EMPTY_FULL) {
                    let n = [];
                    e: for (let i = 0;; i++) {
                        let o = 0;
                        let s = true;
                        let a = this;
                        let l = t;
                        let _ = "";
                        _ += "[";
                        while (!a.isEmpty && a !== r) {
                            let t = 0;
                            if (a.size > 0) {
                                let e = 1;
                                while (1 << e >>> 0 < a.size) {
                                    e++
                                }
                                let r = (1 << e >>> 0) - 1;
                                t = i >> o & r;
                                s = s && t >= a.size - 1;
                                if (t >= a.size) {
                                    continue e
                                }
                                o += e
                            }
                            if (e) {
                                if (_.length > 1) {
                                    _ += " "
                                }
                                let t = e.atn;
                                let r = t.states[l];
                                let n = e.ruleNames[r.ruleIndex];
                                _ += n
                            } else if (a.getReturnState(t) !== PredictionContext.EMPTY_FULL_STATE_KEY) {
                                if (!a.isEmpty) {
                                    if (_.length > 1) {
                                        _ += " "
                                    }
                                    _ += a.getReturnState(t)
                                }
                            }
                            l = a.getReturnState(t);
                            a = a.getParent(t)
                        }
                        _ += "]";
                        n.push(_);
                        if (s) {
                            break
                        }
                    }
                    return n
                }
            }
            n([_.Override], PredictionContext.prototype, "hashCode", null);
            n([i(0, _.NotNull), i(1, _.NotNull), i(2, _.NotNull)], PredictionContext, "join", null);
            n([i(0, _.NotNull), i(1, _.NotNull), i(2, _.NotNull)], PredictionContext, "getCachedContext", null);
            t.PredictionContext = PredictionContext;
            class EmptyPredictionContext extends PredictionContext {
                constructor(e) {
                    super(PredictionContext.calculateEmptyHashCode());
                    this.fullContext = e
                }
                get isFullContext() {
                    return this.fullContext
                }
                addEmptyContext() {
                    return this
                }
                removeEmptyContext() {
                    throw new Error("Cannot remove the empty context from itself.")
                }
                getParent(e) {
                    throw new Error("index out of bounds")
                }
                getReturnState(e) {
                    throw new Error("index out of bounds")
                }
                findReturnState(e) {
                    return -1
                }
                get size() {
                    return 0
                }
                appendSingleContext(e, t) {
                    return t.getChild(this, e)
                }
                appendContext(e, t) {
                    return e
                }
                get isEmpty() {
                    return true
                }
                get hasEmpty() {
                    return true
                }
                equals(e) {
                    return this === e
                }
                toStrings(e, t, r) {
                    return ["[]"]
                }
            }
            n([_.Override], EmptyPredictionContext.prototype, "addEmptyContext", null);
            n([_.Override], EmptyPredictionContext.prototype, "removeEmptyContext", null);
            n([_.Override], EmptyPredictionContext.prototype, "getParent", null);
            n([_.Override], EmptyPredictionContext.prototype, "getReturnState", null);
            n([_.Override], EmptyPredictionContext.prototype, "findReturnState", null);
            n([_.Override], EmptyPredictionContext.prototype, "size", null);
            n([_.Override], EmptyPredictionContext.prototype, "appendSingleContext", null);
            n([_.Override], EmptyPredictionContext.prototype, "appendContext", null);
            n([_.Override], EmptyPredictionContext.prototype, "isEmpty", null);
            n([_.Override], EmptyPredictionContext.prototype, "hasEmpty", null);
            n([_.Override], EmptyPredictionContext.prototype, "equals", null);
            n([_.Override], EmptyPredictionContext.prototype, "toStrings", null);
            let p = class ArrayPredictionContext extends PredictionContext {
                constructor(e, t, r) {
                    super(r || PredictionContext.calculateHashCode(e, t));
                    c(e.length === t.length);
                    c(t.length > 1 || t[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, "Should be using PredictionContext.EMPTY instead.");
                    this.parents = e;
                    this.returnStates = t
                }
                getParent(e) {
                    return this.parents[e]
                }
                getReturnState(e) {
                    return this.returnStates[e]
                }
                findReturnState(e) {
                    return a.Arrays.binarySearch(this.returnStates, e)
                }
                get size() {
                    return this.returnStates.length
                }
                get isEmpty() {
                    return false
                }
                get hasEmpty() {
                    return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY
                }
                addEmptyContext() {
                    if (this.hasEmpty) {
                        return this
                    }
                    let e = this.parents.slice(0);
                    let t = this.returnStates.slice(0);
                    e.push(PredictionContext.EMPTY_FULL);
                    t.push(PredictionContext.EMPTY_FULL_STATE_KEY);
                    return new ArrayPredictionContext(e, t)
                }
                removeEmptyContext() {
                    if (!this.hasEmpty) {
                        return this
                    }
                    if (this.returnStates.length === 2) {
                        return new f(this.parents[0], this.returnStates[0])
                    } else {
                        let e = this.parents.slice(0, this.parents.length - 1);
                        let t = this.returnStates.slice(0, this.returnStates.length - 1);
                        return new ArrayPredictionContext(e, t)
                    }
                }
                appendContext(e, t) {
                    return ArrayPredictionContext.appendContextImpl(this, e, new PredictionContext.IdentityHashMap)
                }
                static appendContextImpl(e, t, r) {
                    if (t.isEmpty) {
                        if (PredictionContext.isEmptyLocal(t)) {
                            if (e.hasEmpty) {
                                return PredictionContext.EMPTY_LOCAL
                            }
                            throw new Error("what to do here?")
                        }
                        return e
                    }
                    if (t.size !== 1) {
                        throw new Error("Appending a tree suffix is not yet supported.")
                    }
                    let n = r.get(e);
                    if (!n) {
                        if (e.isEmpty) {
                            n = t
                        } else {
                            let i = e.size;
                            if (e.hasEmpty) {
                                i--
                            }
                            let o = new Array(i);
                            let s = new Array(i);
                            for (let t = 0; t < i; t++) {
                                s[t] = e.getReturnState(t)
                            }
                            for (let n = 0; n < i; n++) {
                                o[n] = ArrayPredictionContext.appendContextImpl(e.getParent(n), t, r)
                            }
                            if (o.length === 1) {
                                n = new f(o[0], s[0])
                            } else {
                                c(o.length > 1);
                                n = new ArrayPredictionContext(o, s)
                            }
                            if (e.hasEmpty) {
                                n = PredictionContext.join(n, t)
                            }
                        }
                        r.put(e, n)
                    }
                    return n
                }
                equals(e) {
                    if (this === e) {
                        return true
                    } else if (!(e instanceof ArrayPredictionContext)) {
                        return false
                    }
                    if (this.hashCode() !== e.hashCode()) {
                        return false
                    }
                    let t = e;
                    return this.equalsImpl(t, new s.Array2DHashSet)
                }
                equalsImpl(e, t) {
                    let r = [];
                    let n = [];
                    r.push(this);
                    n.push(e);
                    while (true) {
                        let e = r.pop();
                        let i = n.pop();
                        if (!e || !i) {
                            break
                        }
                        let o = new u.PredictionContextCache.IdentityCommutativePredictionContextOperands(e, i);
                        if (!t.add(o)) {
                            continue
                        }
                        let s = o.x.size;
                        if (s === 0) {
                            if (!o.x.equals(o.y)) {
                                return false
                            }
                            continue
                        }
                        let a = o.y.size;
                        if (s !== a) {
                            return false
                        }
                        for (let e = 0; e < s; e++) {
                            if (o.x.getReturnState(e) !== o.y.getReturnState(e)) {
                                return false
                            }
                            let t = o.x.getParent(e);
                            let i = o.y.getParent(e);
                            if (t.hashCode() !== i.hashCode()) {
                                return false
                            }
                            if (t !== i) {
                                r.push(t);
                                n.push(i)
                            }
                        }
                    }
                    return true
                }
            };
            n([_.NotNull], p.prototype, "parents", void 0);
            n([_.NotNull], p.prototype, "returnStates", void 0);
            n([_.Override], p.prototype, "getParent", null);
            n([_.Override], p.prototype, "getReturnState", null);
            n([_.Override], p.prototype, "findReturnState", null);
            n([_.Override], p.prototype, "size", null);
            n([_.Override], p.prototype, "isEmpty", null);
            n([_.Override], p.prototype, "hasEmpty", null);
            n([_.Override], p.prototype, "addEmptyContext", null);
            n([_.Override], p.prototype, "removeEmptyContext", null);
            n([_.Override], p.prototype, "appendContext", null);
            n([_.Override], p.prototype, "equals", null);
            p = n([i(0, _.NotNull)], p);
            let f = class SingletonPredictionContext extends PredictionContext {
                constructor(e, t) {
                    super(PredictionContext.calculateSingleHashCode(e, t));
                    this.parent = e;
                    this.returnState = t
                }
                getParent(e) {
                    return this.parent
                }
                getReturnState(e) {
                    return this.returnState
                }
                findReturnState(e) {
                    return this.returnState === e ? 0 : -1
                }
                get size() {
                    return 1
                }
                get isEmpty() {
                    return false
                }
                get hasEmpty() {
                    return false
                }
                appendContext(e, t) {
                    return t.getChild(this.parent.appendContext(e, t), this.returnState)
                }
                addEmptyContext() {
                    let e = [this.parent, PredictionContext.EMPTY_FULL];
                    let t = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];
                    return new p(e, t)
                }
                removeEmptyContext() {
                    return this
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof SingletonPredictionContext)) {
                        return false
                    }
                    let t = e;
                    if (this.hashCode() !== t.hashCode()) {
                        return false
                    }
                    return this.returnState === t.returnState && this.parent.equals(t.parent)
                }
            };
            n([_.NotNull], f.prototype, "parent", void 0);
            n([_.Override], f.prototype, "getParent", null);
            n([_.Override], f.prototype, "getReturnState", null);
            n([_.Override], f.prototype, "findReturnState", null);
            n([_.Override], f.prototype, "size", null);
            n([_.Override], f.prototype, "isEmpty", null);
            n([_.Override], f.prototype, "hasEmpty", null);
            n([_.Override], f.prototype, "appendContext", null);
            n([_.Override], f.prototype, "addEmptyContext", null);
            n([_.Override], f.prototype, "removeEmptyContext", null);
            n([_.Override], f.prototype, "equals", null);
            f = n([i(0, _.NotNull)], f);
            t.SingletonPredictionContext = f;
            (function(e) {
                e.EMPTY_LOCAL = new EmptyPredictionContext(false);
                e.EMPTY_FULL = new EmptyPredictionContext(true);
                e.EMPTY_LOCAL_STATE_KEY = -(1 << 31 >>> 0);
                e.EMPTY_FULL_STATE_KEY = (1 << 31 >>> 0) - 1;
                class IdentityHashMap extends o.Array2DHashMap {
                    constructor() {
                        super(IdentityEqualityComparator.INSTANCE)
                    }
                }
                e.IdentityHashMap = IdentityHashMap;
                class IdentityEqualityComparator {
                    IdentityEqualityComparator() {}
                    hashCode(e) {
                        return e.hashCode()
                    }
                    equals(e, t) {
                        return e === t
                    }
                }
                IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator;
                n([_.Override], IdentityEqualityComparator.prototype, "hashCode", null);
                n([_.Override], IdentityEqualityComparator.prototype, "equals", null);
                e.IdentityEqualityComparator = IdentityEqualityComparator
            })(PredictionContext = t.PredictionContext || (t.PredictionContext = {}))
        },
        7545: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PredictionContextCache = void 0;
            const i = r(9605);
            const o = r(6966);
            const s = r(4880);
            const a = r(5047);
            const l = r(9491);
            class PredictionContextCache {
                constructor(e = true) {
                    this.contexts = new i.Array2DHashMap(s.ObjectEqualityComparator.INSTANCE);
                    this.childContexts = new i.Array2DHashMap(s.ObjectEqualityComparator.INSTANCE);
                    this.joinContexts = new i.Array2DHashMap(s.ObjectEqualityComparator.INSTANCE);
                    this.enableCache = e
                }
                getAsCached(e) {
                    if (!this.enableCache) {
                        return e
                    }
                    let t = this.contexts.get(e);
                    if (!t) {
                        t = e;
                        this.contexts.put(e, e)
                    }
                    return t
                }
                getChild(e, t) {
                    if (!this.enableCache) {
                        return e.getChild(t)
                    }
                    let r = new PredictionContextCache.PredictionContextAndInt(e, t);
                    let n = this.childContexts.get(r);
                    if (!n) {
                        n = e.getChild(t);
                        n = this.getAsCached(n);
                        this.childContexts.put(r, n)
                    }
                    return n
                }
                join(e, t) {
                    if (!this.enableCache) {
                        return a.PredictionContext.join(e, t, this)
                    }
                    let r = new PredictionContextCache.IdentityCommutativePredictionContextOperands(e, t);
                    let n = this.joinContexts.get(r);
                    if (n) {
                        return n
                    }
                    n = a.PredictionContext.join(e, t, this);
                    n = this.getAsCached(n);
                    this.joinContexts.put(r, n);
                    return n
                }
            }
            t.PredictionContextCache = PredictionContextCache;
            PredictionContextCache.UNCACHED = new PredictionContextCache(false);
            (function(e) {
                class PredictionContextAndInt {
                    constructor(e, t) {
                        this.obj = e;
                        this.value = t
                    }
                    equals(e) {
                        if (!(e instanceof PredictionContextAndInt)) {
                            return false
                        } else if (e === this) {
                            return true
                        }
                        let t = e;
                        return this.value === t.value && (this.obj === t.obj || this.obj != null && this.obj.equals(t.obj))
                    }
                    hashCode() {
                        let e = 5;
                        e = 7 * e + (this.obj != null ? this.obj.hashCode() : 0);
                        e = 7 * e + this.value;
                        return e
                    }
                }
                n([o.Override], PredictionContextAndInt.prototype, "equals", null);
                n([o.Override], PredictionContextAndInt.prototype, "hashCode", null);
                e.PredictionContextAndInt = PredictionContextAndInt;
                class IdentityCommutativePredictionContextOperands {
                    constructor(e, t) {
                        l(e != null);
                        l(t != null);
                        this._x = e;
                        this._y = t
                    }
                    get x() {
                        return this._x
                    }
                    get y() {
                        return this._y
                    }
                    equals(e) {
                        if (!(e instanceof IdentityCommutativePredictionContextOperands)) {
                            return false
                        } else if (this === e) {
                            return true
                        }
                        let t = e;
                        return this._x === t._x && this._y === t._y || this._x === t._y && this._y === t._x
                    }
                    hashCode() {
                        return this._x.hashCode() ^ this._y.hashCode()
                    }
                }
                n([o.Override], IdentityCommutativePredictionContextOperands.prototype, "equals", null);
                n([o.Override], IdentityCommutativePredictionContextOperands.prototype, "hashCode", null);
                e.IdentityCommutativePredictionContextOperands = IdentityCommutativePredictionContextOperands
            })(PredictionContextCache = t.PredictionContextCache || (t.PredictionContextCache = {}))
        },
        2093: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.PredictionMode = void 0;
            const i = r(9605);
            const o = r(5032);
            const s = r(6966);
            const a = r(8557);
            var l;
            (function(e) {
                e[e["SLL"] = 0] = "SLL";
                e[e["LL"] = 1] = "LL";
                e[e["LL_EXACT_AMBIG_DETECTION"] = 2] = "LL_EXACT_AMBIG_DETECTION"
            })(l = t.PredictionMode || (t.PredictionMode = {}));
            (function(e) {
                class AltAndContextMap extends i.Array2DHashMap {
                    constructor() {
                        super(AltAndContextConfigEqualityComparator.INSTANCE)
                    }
                }
                class AltAndContextConfigEqualityComparator {
                    AltAndContextConfigEqualityComparator() {}
                    hashCode(e) {
                        let t = o.MurmurHash.initialize(7);
                        t = o.MurmurHash.update(t, e.state.stateNumber);
                        t = o.MurmurHash.update(t, e.context);
                        t = o.MurmurHash.finish(t, 2);
                        return t
                    }
                    equals(e, t) {
                        if (e === t) {
                            return true
                        }
                        if (e == null || t == null) {
                            return false
                        }
                        return e.state.stateNumber === t.state.stateNumber && e.context.equals(t.context)
                    }
                }
                AltAndContextConfigEqualityComparator.INSTANCE = new AltAndContextConfigEqualityComparator;
                n([s.Override], AltAndContextConfigEqualityComparator.prototype, "hashCode", null);
                n([s.Override], AltAndContextConfigEqualityComparator.prototype, "equals", null);

                function hasConfigInRuleStopState(e) {
                    for (let t of e) {
                        if (t.state instanceof a.RuleStopState) {
                            return true
                        }
                    }
                    return false
                }
                e.hasConfigInRuleStopState = hasConfigInRuleStopState;

                function allConfigsInRuleStopStates(e) {
                    for (let t of e) {
                        if (!(t.state instanceof a.RuleStopState)) {
                            return false
                        }
                    }
                    return true
                }
                e.allConfigsInRuleStopStates = allConfigsInRuleStopStates
            })(l = t.PredictionMode || (t.PredictionMode = {}))
        },
        6517: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ProfilingATNSimulator = void 0;
            const o = r(5746);
            const s = r(7747);
            const a = r(9336);
            const l = r(7484);
            const _ = r(1518);
            const u = r(1214);
            const c = r(6966);
            const d = r(47);
            const p = r(9851);
            const f = r(704);
            const h = r(4806);
            const g = r(1533);
            class ProfilingATNSimulator extends p.ParserATNSimulator {
                constructor(e) {
                    super(e.interpreter.atn, e);
                    this._startIndex = 0;
                    this._sllStopIndex = 0;
                    this._llStopIndex = 0;
                    this.currentDecision = 0;
                    this.conflictingAltResolvedBySLL = 0;
                    this.optimize_ll1 = false;
                    this.reportAmbiguities = true;
                    this.numDecisions = this.atn.decisionToState.length;
                    this.decisions = [];
                    for (let e = 0; e < this.numDecisions; e++) {
                        this.decisions.push(new _.DecisionInfo(e))
                    }
                }
                adaptivePredict(e, t, r, n) {
                    if (n !== undefined) {
                        return super.adaptivePredict(e, t, r, n)
                    }
                    try {
                        this._input = e;
                        this._startIndex = e.index;
                        this._sllStopIndex = this._startIndex - 1;
                        this._llStopIndex = -1;
                        this.currentDecision = t;
                        this.currentState = undefined;
                        this.conflictingAltResolvedBySLL = s.ATN.INVALID_ALT_NUMBER;
                        let n = process.hrtime();
                        let i = super.adaptivePredict(e, t, r);
                        let o = process.hrtime();
                        let a = (o[0] - n[0]) * 1e9;
                        if (a === 0) {
                            a = o[1] - n[1]
                        } else {
                            a += 1e9 - n[1] + o[1]
                        }
                        this.decisions[t].timeInPrediction += a;
                        this.decisions[t].invocations++;
                        let l = this._sllStopIndex - this._startIndex + 1;
                        this.decisions[t].SLL_TotalLook += l;
                        this.decisions[t].SLL_MinLook = this.decisions[t].SLL_MinLook === 0 ? l : Math.min(this.decisions[t].SLL_MinLook, l);
                        if (l > this.decisions[t].SLL_MaxLook) {
                            this.decisions[t].SLL_MaxLook = l;
                            this.decisions[t].SLL_MaxLookEvent = new d.LookaheadEventInfo(t, undefined, i, e, this._startIndex, this._sllStopIndex, false)
                        }
                        if (this._llStopIndex >= 0) {
                            let r = this._llStopIndex - this._startIndex + 1;
                            this.decisions[t].LL_TotalLook += r;
                            this.decisions[t].LL_MinLook = this.decisions[t].LL_MinLook === 0 ? r : Math.min(this.decisions[t].LL_MinLook, r);
                            if (r > this.decisions[t].LL_MaxLook) {
                                this.decisions[t].LL_MaxLook = r;
                                this.decisions[t].LL_MaxLookEvent = new d.LookaheadEventInfo(t, undefined, i, e, this._startIndex, this._llStopIndex, true)
                            }
                        }
                        return i
                    } finally {
                        this._input = undefined;
                        this.currentDecision = -1
                    }
                }
                getStartState(e, t, r, n) {
                    let i = super.getStartState(e, t, r, n);
                    this.currentState = i;
                    return i
                }
                computeStartState(e, t, r) {
                    let n = super.computeStartState(e, t, r);
                    this.currentState = n;
                    return n
                }
                computeReachSet(e, t, r, n) {
                    if (this._input === undefined) {
                        throw new Error("Invalid state")
                    }
                    let i = super.computeReachSet(e, t, r, n);
                    if (i == null) {
                        this.decisions[this.currentDecision].errors.push(new u.ErrorInfo(this.currentDecision, t, this._input, this._startIndex, this._input.index))
                    }
                    this.currentState = i;
                    return i
                }
                getExistingTargetState(e, t) {
                    if (this.currentState === undefined || this._input === undefined) {
                        throw new Error("Invalid state")
                    }
                    if (this.currentState.useContext) {
                        this._llStopIndex = this._input.index
                    } else {
                        this._sllStopIndex = this._input.index
                    }
                    let r = super.getExistingTargetState(e, t);
                    if (r != null) {
                        this.currentState = new g.SimulatorState(this.currentState.outerContext, r, this.currentState.useContext, this.currentState.remainingOuterContext);
                        if (this.currentState.useContext) {
                            this.decisions[this.currentDecision].LL_DFATransitions++
                        } else {
                            this.decisions[this.currentDecision].SLL_DFATransitions++
                        }
                        if (r === a.ATNSimulator.ERROR) {
                            let t = new g.SimulatorState(this.currentState.outerContext, e, this.currentState.useContext, this.currentState.remainingOuterContext);
                            this.decisions[this.currentDecision].errors.push(new u.ErrorInfo(this.currentDecision, t, this._input, this._startIndex, this._input.index))
                        }
                    }
                    return r
                }
                computeTargetState(e, t, r, n, i, o) {
                    let s = super.computeTargetState(e, t, r, n, i, o);
                    if (i) {
                        this.decisions[this.currentDecision].LL_ATNTransitions++
                    } else {
                        this.decisions[this.currentDecision].SLL_ATNTransitions++
                    }
                    return s
                }
                evalSemanticContextImpl(e, t, r) {
                    if (this.currentState === undefined || this._input === undefined) {
                        throw new Error("Invalid state")
                    }
                    let n = super.evalSemanticContextImpl(e, t, r);
                    if (!(e instanceof h.SemanticContext.PrecedencePredicate)) {
                        let t = this._llStopIndex >= 0;
                        let i = t ? this._llStopIndex : this._sllStopIndex;
                        this.decisions[this.currentDecision].predicateEvals.push(new f.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, i, e, n, r))
                    }
                    return n
                }
                reportContextSensitivity(e, t, r, n, i) {
                    if (this._input === undefined) {
                        throw new Error("Invalid state")
                    }
                    if (t !== this.conflictingAltResolvedBySLL) {
                        this.decisions[this.currentDecision].contextSensitivities.push(new l.ContextSensitivityInfo(this.currentDecision, r, this._input, n, i))
                    }
                    super.reportContextSensitivity(e, t, r, n, i)
                }
                reportAttemptingFullContext(e, t, r, n, i) {
                    if (t != null) {
                        this.conflictingAltResolvedBySLL = t.nextSetBit(0)
                    } else {
                        this.conflictingAltResolvedBySLL = r.s0.configs.getRepresentedAlternatives().nextSetBit(0)
                    }
                    this.decisions[this.currentDecision].LL_Fallback++;
                    super.reportAttemptingFullContext(e, t, r, n, i)
                }
                reportAmbiguity(e, t, r, n, i, a, _) {
                    if (this.currentState === undefined || this._input === undefined) {
                        throw new Error("Invalid state")
                    }
                    let u;
                    if (a != null) {
                        u = a.nextSetBit(0)
                    } else {
                        u = _.getRepresentedAlternatives().nextSetBit(0)
                    }
                    if (this.conflictingAltResolvedBySLL !== s.ATN.INVALID_ALT_NUMBER && u !== this.conflictingAltResolvedBySLL) {
                        this.decisions[this.currentDecision].contextSensitivities.push(new l.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, r, n))
                    }
                    this.decisions[this.currentDecision].ambiguities.push(new o.AmbiguityInfo(this.currentDecision, this.currentState, a, this._input, r, n));
                    super.reportAmbiguity(e, t, r, n, i, a, _)
                }
                getDecisionInfo() {
                    return this.decisions
                }
                getCurrentState() {
                    return this.currentState
                }
            }
            n([c.Override, i(0, c.NotNull)], ProfilingATNSimulator.prototype, "adaptivePredict", null);
            n([c.Override], ProfilingATNSimulator.prototype, "getStartState", null);
            n([c.Override], ProfilingATNSimulator.prototype, "computeStartState", null);
            n([c.Override], ProfilingATNSimulator.prototype, "computeReachSet", null);
            n([c.Override], ProfilingATNSimulator.prototype, "getExistingTargetState", null);
            n([c.Override], ProfilingATNSimulator.prototype, "computeTargetState", null);
            n([c.Override], ProfilingATNSimulator.prototype, "evalSemanticContextImpl", null);
            n([c.Override], ProfilingATNSimulator.prototype, "reportContextSensitivity", null);
            n([c.Override], ProfilingATNSimulator.prototype, "reportAttemptingFullContext", null);
            n([c.Override, i(0, c.NotNull), i(5, c.NotNull), i(6, c.NotNull)], ProfilingATNSimulator.prototype, "reportAmbiguity", null);
            t.ProfilingATNSimulator = ProfilingATNSimulator
        },
        285: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RangeTransition = void 0;
            const o = r(7108);
            const s = r(6966);
            const a = r(9563);
            let l = class RangeTransition extends a.Transition {
                constructor(e, t, r) {
                    super(e);
                    this.from = t;
                    this.to = r
                }
                get serializationType() {
                    return 2
                }
                get label() {
                    return o.IntervalSet.of(this.from, this.to)
                }
                matches(e, t, r) {
                    return e >= this.from && e <= this.to
                }
                toString() {
                    return "'" + String.fromCodePoint(this.from) + "'..'" + String.fromCodePoint(this.to) + "'"
                }
            };
            n([s.Override], l.prototype, "serializationType", null);
            n([s.Override, s.NotNull], l.prototype, "label", null);
            n([s.Override], l.prototype, "matches", null);
            n([s.Override, s.NotNull], l.prototype, "toString", null);
            l = n([i(0, s.NotNull)], l);
            t.RangeTransition = l
        },
        612: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleStartState = void 0;
            const i = r(2210);
            const o = r(1765);
            const s = r(6966);
            class RuleStartState extends i.ATNState {
                constructor() {
                    super(...arguments);
                    this.isPrecedenceRule = false;
                    this.leftFactored = false
                }
                get stateType() {
                    return o.ATNStateType.RULE_START
                }
            }
            n([s.Override], RuleStartState.prototype, "stateType", null);
            t.RuleStartState = RuleStartState
        },
        8557: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleStopState = void 0;
            const i = r(2210);
            const o = r(1765);
            const s = r(6966);
            class RuleStopState extends i.ATNState {
                get nonStopStateNumber() {
                    return -1
                }
                get stateType() {
                    return o.ATNStateType.RULE_STOP
                }
            }
            n([s.Override], RuleStopState.prototype, "nonStopStateNumber", null);
            n([s.Override], RuleStopState.prototype, "stateType", null);
            t.RuleStopState = RuleStopState
        },
        7785: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleTransition = void 0;
            const o = r(6966);
            const s = r(9563);
            let a = class RuleTransition extends s.Transition {
                constructor(e, t, r, n) {
                    super(e);
                    this.tailCall = false;
                    this.optimizedTailCall = false;
                    this.ruleIndex = t;
                    this.precedence = r;
                    this.followState = n
                }
                get serializationType() {
                    return 3
                }
                get isEpsilon() {
                    return true
                }
                matches(e, t, r) {
                    return false
                }
            };
            n([o.NotNull], a.prototype, "followState", void 0);
            n([o.Override], a.prototype, "serializationType", null);
            n([o.Override], a.prototype, "isEpsilon", null);
            n([o.Override], a.prototype, "matches", null);
            a = n([i(0, o.NotNull), i(3, o.NotNull)], a);
            t.RuleTransition = a
        },
        4806: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SemanticContext = void 0;
            const o = r(112);
            const s = r(8069);
            const a = r(5032);
            const l = r(6966);
            const _ = r(4880);
            const u = r(2925);

            function max(e) {
                let t;
                for (let r of e) {
                    if (t === undefined) {
                        t = r;
                        continue
                    }
                    let e = t.compareTo(r);
                    if (e < 0) {
                        t = r
                    }
                }
                return t
            }

            function min(e) {
                let t;
                for (let r of e) {
                    if (t === undefined) {
                        t = r;
                        continue
                    }
                    let e = t.compareTo(r);
                    if (e > 0) {
                        t = r
                    }
                }
                return t
            }
            class SemanticContext {
                static get NONE() {
                    if (SemanticContext._NONE === undefined) {
                        SemanticContext._NONE = new SemanticContext.Predicate
                    }
                    return SemanticContext._NONE
                }
                evalPrecedence(e, t) {
                    return this
                }
                static and(e, t) {
                    if (!e || e === SemanticContext.NONE) {
                        return t
                    }
                    if (t === SemanticContext.NONE) {
                        return e
                    }
                    let r = new SemanticContext.AND(e, t);
                    if (r.opnds.length === 1) {
                        return r.opnds[0]
                    }
                    return r
                }
                static or(e, t) {
                    if (!e) {
                        return t
                    }
                    if (e === SemanticContext.NONE || t === SemanticContext.NONE) {
                        return SemanticContext.NONE
                    }
                    let r = new SemanticContext.OR(e, t);
                    if (r.opnds.length === 1) {
                        return r.opnds[0]
                    }
                    return r
                }
            }
            t.SemanticContext = SemanticContext;
            (function(e) {
                const t = 40363613;
                const r = 486279973;

                function filterPrecedencePredicates(t) {
                    let r = [];
                    for (let n = 0; n < t.length; n++) {
                        let i = t[n];
                        if (i instanceof e.PrecedencePredicate) {
                            r.push(i);
                            t.splice(n, 1);
                            n--
                        }
                    }
                    return r
                }
                class Predicate extends e {
                    constructor(e = -1, t = -1, r = false) {
                        super();
                        this.ruleIndex = e;
                        this.predIndex = t;
                        this.isCtxDependent = r
                    }
                    eval(e, t) {
                        let r = this.isCtxDependent ? t : undefined;
                        return e.sempred(r, this.ruleIndex, this.predIndex)
                    }
                    hashCode() {
                        let e = a.MurmurHash.initialize();
                        e = a.MurmurHash.update(e, this.ruleIndex);
                        e = a.MurmurHash.update(e, this.predIndex);
                        e = a.MurmurHash.update(e, this.isCtxDependent ? 1 : 0);
                        e = a.MurmurHash.finish(e, 3);
                        return e
                    }
                    equals(e) {
                        if (!(e instanceof Predicate)) {
                            return false
                        }
                        if (this === e) {
                            return true
                        }
                        return this.ruleIndex === e.ruleIndex && this.predIndex === e.predIndex && this.isCtxDependent === e.isCtxDependent
                    }
                    toString() {
                        return "{" + this.ruleIndex + ":" + this.predIndex + "}?"
                    }
                }
                n([l.Override], Predicate.prototype, "eval", null);
                n([l.Override], Predicate.prototype, "hashCode", null);
                n([l.Override], Predicate.prototype, "equals", null);
                n([l.Override], Predicate.prototype, "toString", null);
                e.Predicate = Predicate;
                class PrecedencePredicate extends e {
                    constructor(e) {
                        super();
                        this.precedence = e
                    }
                    eval(e, t) {
                        return e.precpred(t, this.precedence)
                    }
                    evalPrecedence(t, r) {
                        if (t.precpred(r, this.precedence)) {
                            return e.NONE
                        } else {
                            return undefined
                        }
                    }
                    compareTo(e) {
                        return this.precedence - e.precedence
                    }
                    hashCode() {
                        let e = 1;
                        e = 31 * e + this.precedence;
                        return e
                    }
                    equals(e) {
                        if (!(e instanceof PrecedencePredicate)) {
                            return false
                        }
                        if (this === e) {
                            return true
                        }
                        return this.precedence === e.precedence
                    }
                    toString() {
                        return "{" + this.precedence + ">=prec}?"
                    }
                }
                n([l.Override], PrecedencePredicate.prototype, "eval", null);
                n([l.Override], PrecedencePredicate.prototype, "evalPrecedence", null);
                n([l.Override], PrecedencePredicate.prototype, "compareTo", null);
                n([l.Override], PrecedencePredicate.prototype, "hashCode", null);
                n([l.Override], PrecedencePredicate.prototype, "equals", null);
                n([l.Override], PrecedencePredicate.prototype, "toString", null);
                e.PrecedencePredicate = PrecedencePredicate;
                class Operator extends e {}
                e.Operator = Operator;
                let c = class AND extends Operator {
                    constructor(e, t) {
                        super();
                        let r = new o.Array2DHashSet(_.ObjectEqualityComparator.INSTANCE);
                        if (e instanceof AND) {
                            r.addAll(e.opnds)
                        } else {
                            r.add(e)
                        }
                        if (t instanceof AND) {
                            r.addAll(t.opnds)
                        } else {
                            r.add(t)
                        }
                        this.opnds = r.toArray();
                        let n = filterPrecedencePredicates(this.opnds);
                        let i = min(n);
                        if (i) {
                            this.opnds.push(i)
                        }
                    }
                    get operands() {
                        return this.opnds
                    }
                    equals(e) {
                        if (this === e) {
                            return true
                        }
                        if (!(e instanceof AND)) {
                            return false
                        }
                        return s.ArrayEqualityComparator.INSTANCE.equals(this.opnds, e.opnds)
                    }
                    hashCode() {
                        return a.MurmurHash.hashCode(this.opnds, t)
                    }
                    eval(e, t) {
                        for (let r of this.opnds) {
                            if (!r.eval(e, t)) {
                                return false
                            }
                        }
                        return true
                    }
                    evalPrecedence(t, r) {
                        let n = false;
                        let i = [];
                        for (let o of this.opnds) {
                            let s = o.evalPrecedence(t, r);
                            n = n || s !== o;
                            if (s == null) {
                                return undefined
                            } else if (s !== e.NONE) {
                                i.push(s)
                            }
                        }
                        if (!n) {
                            return this
                        }
                        if (i.length === 0) {
                            return e.NONE
                        }
                        let o = i[0];
                        for (let t = 1; t < i.length; t++) {
                            o = e.and(o, i[t])
                        }
                        return o
                    }
                    toString() {
                        return u.join(this.opnds, "&&")
                    }
                };
                n([l.Override], c.prototype, "operands", null);
                n([l.Override], c.prototype, "equals", null);
                n([l.Override], c.prototype, "hashCode", null);
                n([l.Override], c.prototype, "eval", null);
                n([l.Override], c.prototype, "evalPrecedence", null);
                n([l.Override], c.prototype, "toString", null);
                c = n([i(0, l.NotNull), i(1, l.NotNull)], c);
                e.AND = c;
                let d = class OR extends Operator {
                    constructor(e, t) {
                        super();
                        let r = new o.Array2DHashSet(_.ObjectEqualityComparator.INSTANCE);
                        if (e instanceof OR) {
                            r.addAll(e.opnds)
                        } else {
                            r.add(e)
                        }
                        if (t instanceof OR) {
                            r.addAll(t.opnds)
                        } else {
                            r.add(t)
                        }
                        this.opnds = r.toArray();
                        let n = filterPrecedencePredicates(this.opnds);
                        let i = max(n);
                        if (i) {
                            this.opnds.push(i)
                        }
                    }
                    get operands() {
                        return this.opnds
                    }
                    equals(e) {
                        if (this === e) {
                            return true
                        }
                        if (!(e instanceof OR)) {
                            return false
                        }
                        return s.ArrayEqualityComparator.INSTANCE.equals(this.opnds, e.opnds)
                    }
                    hashCode() {
                        return a.MurmurHash.hashCode(this.opnds, r)
                    }
                    eval(e, t) {
                        for (let r of this.opnds) {
                            if (r.eval(e, t)) {
                                return true
                            }
                        }
                        return false
                    }
                    evalPrecedence(t, r) {
                        let n = false;
                        let i = [];
                        for (let o of this.opnds) {
                            let s = o.evalPrecedence(t, r);
                            n = n || s !== o;
                            if (s === e.NONE) {
                                return e.NONE
                            } else if (s) {
                                i.push(s)
                            }
                        }
                        if (!n) {
                            return this
                        }
                        if (i.length === 0) {
                            return undefined
                        }
                        let o = i[0];
                        for (let t = 1; t < i.length; t++) {
                            o = e.or(o, i[t])
                        }
                        return o
                    }
                    toString() {
                        return u.join(this.opnds, "||")
                    }
                };
                n([l.Override], d.prototype, "operands", null);
                n([l.Override], d.prototype, "equals", null);
                n([l.Override], d.prototype, "hashCode", null);
                n([l.Override], d.prototype, "eval", null);
                n([l.Override], d.prototype, "evalPrecedence", null);
                n([l.Override], d.prototype, "toString", null);
                d = n([i(0, l.NotNull), i(1, l.NotNull)], d);
                e.OR = d
            })(SemanticContext = t.SemanticContext || (t.SemanticContext = {}))
        },
        5864: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SetTransition = void 0;
            const o = r(7108);
            const s = r(6966);
            const a = r(7528);
            const l = r(9563);
            let _ = class SetTransition extends l.Transition {
                constructor(e, t) {
                    super(e);
                    if (t == null) {
                        t = o.IntervalSet.of(a.Token.INVALID_TYPE)
                    }
                    this.set = t
                }
                get serializationType() {
                    return 7
                }
                get label() {
                    return this.set
                }
                matches(e, t, r) {
                    return this.set.contains(e)
                }
                toString() {
                    return this.set.toString()
                }
            };
            n([s.NotNull], _.prototype, "set", void 0);
            n([s.Override], _.prototype, "serializationType", null);
            n([s.Override, s.NotNull], _.prototype, "label", null);
            n([s.Override], _.prototype, "matches", null);
            n([s.Override, s.NotNull], _.prototype, "toString", null);
            _ = n([i(0, s.NotNull), i(1, s.Nullable)], _);
            t.SetTransition = _
        },
        1533: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SimulatorState = void 0;
            const o = r(6966);
            const s = r(9562);
            let a = class SimulatorState {
                constructor(e, t, r, n) {
                    this.outerContext = e != null ? e : s.ParserRuleContext.emptyContext();
                    this.s0 = t;
                    this.useContext = r;
                    this.remainingOuterContext = n
                }
            };
            a = n([i(1, o.NotNull)], a);
            t.SimulatorState = a
        },
        7989: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.StarBlockStartState = void 0;
            const i = r(1765);
            const o = r(6039);
            const s = r(6966);
            class StarBlockStartState extends o.BlockStartState {
                get stateType() {
                    return i.ATNStateType.STAR_BLOCK_START
                }
            }
            n([s.Override], StarBlockStartState.prototype, "stateType", null);
            t.StarBlockStartState = StarBlockStartState
        },
        8734: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.StarLoopEntryState = void 0;
            const i = r(1765);
            const o = r(4980);
            const s = r(4402);
            const a = r(6966);
            class StarLoopEntryState extends s.DecisionState {
                constructor() {
                    super(...arguments);
                    this.precedenceRuleDecision = false;
                    this.precedenceLoopbackStates = new o.BitSet
                }
                get stateType() {
                    return i.ATNStateType.STAR_LOOP_ENTRY
                }
            }
            n([a.Override], StarLoopEntryState.prototype, "stateType", null);
            t.StarLoopEntryState = StarLoopEntryState
        },
        8146: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.StarLoopbackState = void 0;
            const i = r(2210);
            const o = r(1765);
            const s = r(6966);
            class StarLoopbackState extends i.ATNState {
                get loopEntryState() {
                    return this.transition(0).target
                }
                get stateType() {
                    return o.ATNStateType.STAR_LOOP_BACK
                }
            }
            n([s.Override], StarLoopbackState.prototype, "stateType", null);
            t.StarLoopbackState = StarLoopbackState
        },
        4562: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TokensStartState = void 0;
            const i = r(1765);
            const o = r(4402);
            const s = r(6966);
            class TokensStartState extends o.DecisionState {
                get stateType() {
                    return i.ATNStateType.TOKEN_START
                }
            }
            n([s.Override], TokensStartState.prototype, "stateType", null);
            t.TokensStartState = TokensStartState
        },
        9563: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Transition = void 0;
            const o = r(6966);
            let s = class Transition {
                constructor(e) {
                    if (e == null) {
                        throw new Error("target cannot be null.")
                    }
                    this.target = e
                }
                get isEpsilon() {
                    return false
                }
                get label() {
                    return undefined
                }
            };
            s.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"];
            n([o.NotNull], s.prototype, "target", void 0);
            s = n([i(0, o.NotNull)], s);
            t.Transition = s
        },
        884: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.WildcardTransition = void 0;
            const o = r(6966);
            const s = r(9563);
            let a = class WildcardTransition extends s.Transition {
                constructor(e) {
                    super(e)
                }
                get serializationType() {
                    return 9
                }
                matches(e, t, r) {
                    return e >= t && e <= r
                }
                toString() {
                    return "."
                }
            };
            n([o.Override], a.prototype, "serializationType", null);
            n([o.Override], a.prototype, "matches", null);
            n([o.Override, o.NotNull], a.prototype, "toString", null);
            a = n([i(0, o.NotNull)], a);
            t.WildcardTransition = a
        },
        1353: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.AcceptStateInfo = void 0;
            class AcceptStateInfo {
                constructor(e, t) {
                    this._prediction = e;
                    this._lexerActionExecutor = t
                }
                get prediction() {
                    return this._prediction
                }
                get lexerActionExecutor() {
                    return this._lexerActionExecutor
                }
            }
            t.AcceptStateInfo = AcceptStateInfo
        },
        8878: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DFA = void 0;
            const o = r(112);
            const s = r(9576);
            const a = r(2776);
            const l = r(5149);
            const _ = r(9566);
            const u = r(6966);
            const c = r(4880);
            const d = r(8734);
            const p = r(7847);
            let f = class DFA {
                constructor(e, t = 0) {
                    this.states = new o.Array2DHashSet(c.ObjectEqualityComparator.INSTANCE);
                    this.nextStateNumber = 0;
                    if (!e.atn) {
                        throw new Error("The ATNState must be associated with an ATN")
                    }
                    this.atnStartState = e;
                    this.atn = e.atn;
                    this.decision = t;
                    let r = false;
                    if (e instanceof d.StarLoopEntryState) {
                        if (e.precedenceRuleDecision) {
                            r = true;
                            this.s0 = new l.DFAState(new s.ATNConfigSet);
                            this.s0full = new l.DFAState(new s.ATNConfigSet)
                        }
                    }
                    this.precedenceDfa = r
                }
                get isPrecedenceDfa() {
                    return this.precedenceDfa
                }
                getPrecedenceStartState(e, t) {
                    if (!this.isPrecedenceDfa) {
                        throw new Error("Only precedence DFAs may contain a precedence start state.")
                    }
                    if (t) {
                        return this.s0full.getTarget(e)
                    } else {
                        return this.s0.getTarget(e)
                    }
                }
                setPrecedenceStartState(e, t, r) {
                    if (!this.isPrecedenceDfa) {
                        throw new Error("Only precedence DFAs may contain a precedence start state.")
                    }
                    if (e < 0) {
                        return
                    }
                    if (t) {
                        this.s0full.setTarget(e, r)
                    } else {
                        this.s0.setTarget(e, r)
                    }
                }
                get isEmpty() {
                    if (this.isPrecedenceDfa) {
                        return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0
                    }
                    return this.s0 == null && this.s0full == null
                }
                get isContextSensitive() {
                    if (this.isPrecedenceDfa) {
                        return this.s0full.getEdgeMap().size > 0
                    }
                    return this.s0full != null
                }
                addState(e) {
                    e.stateNumber = this.nextStateNumber++;
                    return this.states.getOrAdd(e)
                }
                toString(e, t) {
                    if (!e) {
                        e = p.VocabularyImpl.EMPTY_VOCABULARY
                    }
                    if (!this.s0) {
                        return ""
                    }
                    let r;
                    if (t) {
                        r = new a.DFASerializer(this, e, t, this.atnStartState.atn)
                    } else {
                        r = new a.DFASerializer(this, e)
                    }
                    return r.toString()
                }
                toLexerString() {
                    if (!this.s0) {
                        return ""
                    }
                    let e = new _.LexerDFASerializer(this);
                    return e.toString()
                }
            };
            n([u.NotNull], f.prototype, "states", void 0);
            n([u.NotNull], f.prototype, "atnStartState", void 0);
            n([u.NotNull], f.prototype, "atn", void 0);
            f = n([i(0, u.NotNull)], f);
            t.DFA = f
        },
        2776: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DFASerializer = void 0;
            const i = r(9336);
            const o = r(6966);
            const s = r(5047);
            const a = r(3602);
            const l = r(7847);
            class DFASerializer {
                constructor(e, t, r, n) {
                    if (t instanceof a.Recognizer) {
                        r = t.ruleNames;
                        n = t.atn;
                        t = t.vocabulary
                    } else if (!t) {
                        t = l.VocabularyImpl.EMPTY_VOCABULARY
                    }
                    this.dfa = e;
                    this.vocabulary = t;
                    this.ruleNames = r;
                    this.atn = n
                }
                toString() {
                    if (!this.dfa.s0) {
                        return ""
                    }
                    let e = "";
                    if (this.dfa.states) {
                        let t = new Array(...this.dfa.states.toArray());
                        t.sort(((e, t) => e.stateNumber - t.stateNumber));
                        for (let r of t) {
                            let t = r.getEdgeMap();
                            let n = [...t.keys()].sort(((e, t) => e - t));
                            let o = r.getContextEdgeMap();
                            let s = [...o.keys()].sort(((e, t) => e - t));
                            for (let o of n) {
                                let n = t.get(o);
                                if ((n == null || n === i.ATNSimulator.ERROR) && !r.isContextSymbol(o)) {
                                    continue
                                }
                                let s = false;
                                e += this.getStateString(r) + "-" + this.getEdgeLabel(o) + "->";
                                if (r.isContextSymbol(o)) {
                                    e += "!";
                                    s = true
                                }
                                let a = n;
                                if (a && a.stateNumber !== i.ATNSimulator.ERROR.stateNumber) {
                                    e += this.getStateString(a) + "\n"
                                } else if (s) {
                                    e += "ctx\n"
                                }
                            }
                            if (r.isContextSensitive) {
                                for (let t of s) {
                                    e += this.getStateString(r) + "-" + this.getContextLabel(t) + "->" + this.getStateString(o.get(t)) + "\n"
                                }
                            }
                        }
                    }
                    let t = e;
                    if (t.length === 0) {
                        return ""
                    }
                    return t
                }
                getContextLabel(e) {
                    if (e === s.PredictionContext.EMPTY_FULL_STATE_KEY) {
                        return "ctx:EMPTY_FULL"
                    } else if (e === s.PredictionContext.EMPTY_LOCAL_STATE_KEY) {
                        return "ctx:EMPTY_LOCAL"
                    }
                    if (this.atn && e > 0 && e <= this.atn.states.length) {
                        let t = this.atn.states[e];
                        let r = t.ruleIndex;
                        if (this.ruleNames && r >= 0 && r < this.ruleNames.length) {
                            return "ctx:" + String(e) + "(" + this.ruleNames[r] + ")"
                        }
                    }
                    return "ctx:" + String(e)
                }
                getEdgeLabel(e) {
                    return this.vocabulary.getDisplayName(e)
                }
                getStateString(e) {
                    if (e === i.ATNSimulator.ERROR) {
                        return "ERROR"
                    }
                    let t = e.stateNumber;
                    let r = "s" + t;
                    if (e.isAcceptState) {
                        if (e.predicates) {
                            r = ":s" + t + "=>" + e.predicates
                        } else {
                            r = ":s" + t + "=>" + e.prediction
                        }
                    }
                    if (e.isContextSensitive) {
                        r += "*";
                        for (let t of e.configs) {
                            if (t.reachesIntoOuterContext) {
                                r += "*";
                                break
                            }
                        }
                    }
                    return r
                }
            }
            n([o.NotNull], DFASerializer.prototype, "dfa", void 0);
            n([o.NotNull], DFASerializer.prototype, "vocabulary", void 0);
            n([o.Override], DFASerializer.prototype, "toString", null);
            t.DFASerializer = DFASerializer
        },
        5149: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DFAState = void 0;
            const o = r(7747);
            const s = r(4980);
            const a = r(5032);
            const l = r(6966);
            const _ = r(5047);
            const u = r(9491);
            class DFAState {
                constructor(e) {
                    this.stateNumber = -1;
                    this.configs = e;
                    this.edges = new Map;
                    this.contextEdges = new Map
                }
                get isContextSensitive() {
                    return !!this.contextSymbols
                }
                isContextSymbol(e) {
                    if (!this.isContextSensitive) {
                        return false
                    }
                    return this.contextSymbols.get(e)
                }
                setContextSymbol(e) {
                    u(this.isContextSensitive);
                    this.contextSymbols.set(e)
                }
                setContextSensitive(e) {
                    u(!this.configs.isOutermostConfigSet);
                    if (this.isContextSensitive) {
                        return
                    }
                    if (!this.contextSymbols) {
                        this.contextSymbols = new s.BitSet
                    }
                }
                get acceptStateInfo() {
                    return this._acceptStateInfo
                }
                set acceptStateInfo(e) {
                    this._acceptStateInfo = e
                }
                get isAcceptState() {
                    return !!this._acceptStateInfo
                }
                get prediction() {
                    if (!this._acceptStateInfo) {
                        return o.ATN.INVALID_ALT_NUMBER
                    }
                    return this._acceptStateInfo.prediction
                }
                get lexerActionExecutor() {
                    if (!this._acceptStateInfo) {
                        return undefined
                    }
                    return this._acceptStateInfo.lexerActionExecutor
                }
                getTarget(e) {
                    return this.edges.get(e)
                }
                setTarget(e, t) {
                    this.edges.set(e, t)
                }
                getEdgeMap() {
                    return this.edges
                }
                getContextTarget(e) {
                    if (e === _.PredictionContext.EMPTY_FULL_STATE_KEY) {
                        e = -1
                    }
                    return this.contextEdges.get(e)
                }
                setContextTarget(e, t) {
                    if (!this.isContextSensitive) {
                        throw new Error("The state is not context sensitive.")
                    }
                    if (e === _.PredictionContext.EMPTY_FULL_STATE_KEY) {
                        e = -1
                    }
                    this.contextEdges.set(e, t)
                }
                getContextEdgeMap() {
                    let e = new Map(this.contextEdges);
                    let t = e.get(-1);
                    if (t !== undefined) {
                        if (e.size === 1) {
                            let e = new Map;
                            e.set(_.PredictionContext.EMPTY_FULL_STATE_KEY, t);
                            return e
                        } else {
                            e.delete(-1);
                            e.set(_.PredictionContext.EMPTY_FULL_STATE_KEY, t)
                        }
                    }
                    return e
                }
                hashCode() {
                    let e = a.MurmurHash.initialize(7);
                    e = a.MurmurHash.update(e, this.configs.hashCode());
                    e = a.MurmurHash.finish(e, 1);
                    return e
                }
                equals(e) {
                    if (this === e) {
                        return true
                    }
                    if (!(e instanceof DFAState)) {
                        return false
                    }
                    let t = e;
                    let r = this.configs.equals(t.configs);
                    return r
                }
                toString() {
                    let e = "";
                    e += this.stateNumber + ":" + this.configs;
                    if (this.isAcceptState) {
                        e += "=>";
                        if (this.predicates) {
                            e += this.predicates
                        } else {
                            e += this.prediction
                        }
                    }
                    return e.toString()
                }
            }
            n([l.NotNull], DFAState.prototype, "configs", void 0);
            n([l.NotNull], DFAState.prototype, "edges", void 0);
            n([l.NotNull], DFAState.prototype, "contextEdges", void 0);
            n([l.Override], DFAState.prototype, "hashCode", null);
            n([l.Override], DFAState.prototype, "equals", null);
            n([l.Override], DFAState.prototype, "toString", null);
            t.DFAState = DFAState;
            (function(e) {
                let t = class PredPrediction {
                    constructor(e, t) {
                        this.alt = t;
                        this.pred = e
                    }
                    toString() {
                        return "(" + this.pred + ", " + this.alt + ")"
                    }
                };
                n([l.NotNull], t.prototype, "pred", void 0);
                n([l.Override], t.prototype, "toString", null);
                t = n([i(0, l.NotNull)], t);
                e.PredPrediction = t
            })(DFAState = t.DFAState || (t.DFAState = {}))
        },
        9566: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.LexerDFASerializer = void 0;
            const o = r(2776);
            const s = r(6966);
            const a = r(7847);
            let l = class LexerDFASerializer extends o.DFASerializer {
                constructor(e) {
                    super(e, a.VocabularyImpl.EMPTY_VOCABULARY)
                }
                getEdgeLabel(e) {
                    return "'" + String.fromCodePoint(e) + "'"
                }
            };
            n([s.Override, s.NotNull], l.prototype, "getEdgeLabel", null);
            l = n([i(0, s.NotNull)], l);
            t.LexerDFASerializer = l
        },
        1127: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
                if (n === undefined) n = r;
                Object.defineProperty(e, n, {
                    enumerable: true,
                    get: function() {
                        return t[r]
                    }
                })
            } : function(e, t, r, n) {
                if (n === undefined) n = r;
                e[n] = t[r]
            });
            var i = this && this.__exportStar || function(e, t) {
                for (var r in e)
                    if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r)
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            i(r(9629), t);
            i(r(8872), t);
            i(r(4108), t);
            i(r(4003), t);
            i(r(3810), t);
            i(r(7677), t);
            i(r(4904), t);
            i(r(1013), t);
            i(r(8951), t);
            i(r(3798), t);
            i(r(8001), t);
            i(r(2757), t);
            i(r(8125), t);
            i(r(488), t);
            i(r(3690), t);
            i(r(1666), t);
            i(r(5575), t);
            i(r(368), t);
            i(r(790), t);
            i(r(3828), t);
            i(r(1740), t);
            i(r(5828), t);
            i(r(3638), t);
            i(r(7715), t);
            i(r(1914), t);
            i(r(8871), t);
            i(r(708), t);
            i(r(18), t);
            i(r(9562), t);
            i(r(319), t);
            i(r(5932), t);
            i(r(8145), t);
            i(r(3602), t);
            i(r(8617), t);
            i(r(6218), t);
            i(r(85), t);
            i(r(9480), t);
            i(r(7528), t);
            i(r(9535), t);
            i(r(4416), t);
            i(r(9550), t);
            i(r(9427), t);
            i(r(8780), t);
            i(r(7847), t);
            i(r(7017), t)
        },
        9605: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Array2DHashMap = void 0;
            const n = r(112);
            class MapKeyEqualityComparator {
                constructor(e) {
                    this.keyComparator = e
                }
                hashCode(e) {
                    return this.keyComparator.hashCode(e.key)
                }
                equals(e, t) {
                    return this.keyComparator.equals(e.key, t.key)
                }
            }
            class Array2DHashMap {
                constructor(e) {
                    if (e instanceof Array2DHashMap) {
                        this.backingStore = new n.Array2DHashSet(e.backingStore)
                    } else {
                        this.backingStore = new n.Array2DHashSet(new MapKeyEqualityComparator(e))
                    }
                }
                clear() {
                    this.backingStore.clear()
                }
                containsKey(e) {
                    return this.backingStore.contains({
                        key: e
                    })
                }
                get(e) {
                    let t = this.backingStore.get({
                        key: e
                    });
                    if (!t) {
                        return undefined
                    }
                    return t.value
                }
                get isEmpty() {
                    return this.backingStore.isEmpty
                }
                put(e, t) {
                    let r = this.backingStore.get({
                        key: e,
                        value: t
                    });
                    let n;
                    if (!r) {
                        this.backingStore.add({
                            key: e,
                            value: t
                        })
                    } else {
                        n = r.value;
                        r.value = t
                    }
                    return n
                }
                putIfAbsent(e, t) {
                    let r = this.backingStore.get({
                        key: e,
                        value: t
                    });
                    let n;
                    if (!r) {
                        this.backingStore.add({
                            key: e,
                            value: t
                        })
                    } else {
                        n = r.value
                    }
                    return n
                }
                get size() {
                    return this.backingStore.size
                }
                hashCode() {
                    return this.backingStore.hashCode()
                }
                equals(e) {
                    if (!(e instanceof Array2DHashMap)) {
                        return false
                    }
                    return this.backingStore.equals(e.backingStore)
                }
            }
            t.Array2DHashMap = Array2DHashMap
        },
        112: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Array2DHashSet = void 0;
            const o = r(9491);
            const s = r(4210);
            const a = r(6966);
            const l = r(5032);
            const _ = 16;
            const u = .75;
            class Array2DHashSet {
                constructor(e, t = _) {
                    this.n = 0;
                    this.threshold = Math.floor(_ * u);
                    if (e instanceof Array2DHashSet) {
                        this.comparator = e.comparator;
                        this.buckets = e.buckets.slice(0);
                        for (let e = 0; e < this.buckets.length; e++) {
                            let t = this.buckets[e];
                            if (t) {
                                this.buckets[e] = t.slice(0)
                            }
                        }
                        this.n = e.n;
                        this.threshold = e.threshold
                    } else {
                        this.comparator = e || s.DefaultEqualityComparator.INSTANCE;
                        this.buckets = this.createBuckets(t)
                    }
                }
                getOrAdd(e) {
                    if (this.n > this.threshold) {
                        this.expand()
                    }
                    return this.getOrAddImpl(e)
                }
                getOrAddImpl(e) {
                    let t = this.getBucket(e);
                    let r = this.buckets[t];
                    if (!r) {
                        r = [e];
                        this.buckets[t] = r;
                        this.n++;
                        return e
                    }
                    for (let t of r) {
                        if (this.comparator.equals(t, e)) {
                            return t
                        }
                    }
                    r.push(e);
                    this.n++;
                    return e
                }
                get(e) {
                    if (e == null) {
                        return e
                    }
                    let t = this.getBucket(e);
                    let r = this.buckets[t];
                    if (!r) {
                        return undefined
                    }
                    for (let t of r) {
                        if (this.comparator.equals(t, e)) {
                            return t
                        }
                    }
                    return undefined
                }
                getBucket(e) {
                    let t = this.comparator.hashCode(e);
                    let r = t & this.buckets.length - 1;
                    return r
                }
                hashCode() {
                    let e = l.MurmurHash.initialize();
                    for (let t of this.buckets) {
                        if (t == null) {
                            continue
                        }
                        for (let r of t) {
                            if (r == null) {
                                break
                            }
                            e = l.MurmurHash.update(e, this.comparator.hashCode(r))
                        }
                    }
                    e = l.MurmurHash.finish(e, this.size);
                    return e
                }
                equals(e) {
                    if (e === this) {
                        return true
                    }
                    if (!(e instanceof Array2DHashSet)) {
                        return false
                    }
                    if (e.size !== this.size) {
                        return false
                    }
                    let t = this.containsAll(e);
                    return t
                }
                expand() {
                    let e = this.buckets;
                    let t = this.buckets.length * 2;
                    let r = this.createBuckets(t);
                    this.buckets = r;
                    this.threshold = Math.floor(t * u);
                    let n = this.size;
                    for (let t of e) {
                        if (!t) {
                            continue
                        }
                        for (let e of t) {
                            let t = this.getBucket(e);
                            let r = this.buckets[t];
                            if (!r) {
                                r = [];
                                this.buckets[t] = r
                            }
                            r.push(e)
                        }
                    }
                    o(this.n === n)
                }
                add(e) {
                    let t = this.getOrAdd(e);
                    return t === e
                }
                get size() {
                    return this.n
                }
                get isEmpty() {
                    return this.n === 0
                }
                contains(e) {
                    return this.containsFast(this.asElementType(e))
                }
                containsFast(e) {
                    if (e == null) {
                        return false
                    }
                    return this.get(e) != null
                }*[Symbol.iterator]() {
                    yield* this.toArray()
                }
                toArray() {
                    const e = new Array(this.size);
                    let t = 0;
                    for (let r of this.buckets) {
                        if (r == null) {
                            continue
                        }
                        for (let n of r) {
                            if (n == null) {
                                break
                            }
                            e[t++] = n
                        }
                    }
                    return e
                }
                containsAll(e) {
                    if (e instanceof Array2DHashSet) {
                        let t = e;
                        for (let e of t.buckets) {
                            if (e == null) {
                                continue
                            }
                            for (let t of e) {
                                if (t == null) {
                                    break
                                }
                                if (!this.containsFast(this.asElementType(t))) {
                                    return false
                                }
                            }
                        }
                    } else {
                        for (let t of e) {
                            if (!this.containsFast(this.asElementType(t))) {
                                return false
                            }
                        }
                    }
                    return true
                }
                addAll(e) {
                    let t = false;
                    for (let r of e) {
                        let e = this.getOrAdd(r);
                        if (e !== r) {
                            t = true
                        }
                    }
                    return t
                }
                clear() {
                    this.buckets = this.createBuckets(_);
                    this.n = 0;
                    this.threshold = Math.floor(_ * u)
                }
                toString() {
                    if (this.size === 0) {
                        return "{}"
                    }
                    let e = "{";
                    let t = true;
                    for (let r of this.buckets) {
                        if (r == null) {
                            continue
                        }
                        for (let n of r) {
                            if (n == null) {
                                break
                            }
                            if (t) {
                                t = false
                            } else {
                                e += ", "
                            }
                            e += n.toString()
                        }
                    }
                    e += "}";
                    return e
                }
                toTableString() {
                    let e = "";
                    for (let t of this.buckets) {
                        if (t == null) {
                            e += "null\n";
                            continue
                        }
                        e += "[";
                        let r = true;
                        for (let n of t) {
                            if (r) {
                                r = false
                            } else {
                                e += " "
                            }
                            if (n == null) {
                                e += "_"
                            } else {
                                e += n.toString()
                            }
                        }
                        e += "]\n"
                    }
                    return e
                }
                asElementType(e) {
                    return e
                }
                createBuckets(e) {
                    return new Array(e)
                }
            }
            n([a.NotNull], Array2DHashSet.prototype, "comparator", void 0);
            n([a.Override], Array2DHashSet.prototype, "hashCode", null);
            n([a.Override], Array2DHashSet.prototype, "equals", null);
            n([a.Override], Array2DHashSet.prototype, "add", null);
            n([a.Override], Array2DHashSet.prototype, "size", null);
            n([a.Override], Array2DHashSet.prototype, "isEmpty", null);
            n([a.Override], Array2DHashSet.prototype, "contains", null);
            n([i(0, a.Nullable)], Array2DHashSet.prototype, "containsFast", null);
            n([a.Override], Array2DHashSet.prototype, Symbol.iterator, null);
            n([a.Override], Array2DHashSet.prototype, "toArray", null);
            n([a.Override], Array2DHashSet.prototype, "containsAll", null);
            n([a.Override], Array2DHashSet.prototype, "addAll", null);
            n([a.Override], Array2DHashSet.prototype, "clear", null);
            n([a.Override], Array2DHashSet.prototype, "toString", null);
            n([a.SuppressWarnings("unchecked")], Array2DHashSet.prototype, "asElementType", null);
            n([a.SuppressWarnings("unchecked")], Array2DHashSet.prototype, "createBuckets", null);
            t.Array2DHashSet = Array2DHashSet
        },
        8069: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ArrayEqualityComparator = void 0;
            const i = r(6966);
            const o = r(5032);
            const s = r(4880);
            class ArrayEqualityComparator {
                hashCode(e) {
                    if (e == null) {
                        return 0
                    }
                    return o.MurmurHash.hashCode(e, 0)
                }
                equals(e, t) {
                    if (e == null) {
                        return t == null
                    } else if (t == null) {
                        return false
                    }
                    if (e.length !== t.length) {
                        return false
                    }
                    for (let r = 0; r < e.length; r++) {
                        if (!s.ObjectEqualityComparator.INSTANCE.equals(e[r], t[r])) {
                            return false
                        }
                    }
                    return true
                }
            }
            ArrayEqualityComparator.INSTANCE = new ArrayEqualityComparator;
            n([i.Override], ArrayEqualityComparator.prototype, "hashCode", null);
            n([i.Override], ArrayEqualityComparator.prototype, "equals", null);
            t.ArrayEqualityComparator = ArrayEqualityComparator
        },
        4797: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Arrays = void 0;
            var r;
            (function(e) {
                function binarySearch(e, t, r, n) {
                    return binarySearch0(e, r !== undefined ? r : 0, n !== undefined ? n : e.length, t)
                }
                e.binarySearch = binarySearch;

                function binarySearch0(e, t, r, n) {
                    let i = t;
                    let o = r - 1;
                    while (i <= o) {
                        let t = i + o >>> 1;
                        let r = e[t];
                        if (r < n) {
                            i = t + 1
                        } else if (r > n) {
                            o = t - 1
                        } else {
                            return t
                        }
                    }
                    return -(i + 1)
                }

                function toString(e) {
                    let t = "[";
                    let r = true;
                    for (let n of e) {
                        if (r) {
                            r = false
                        } else {
                            t += ", "
                        }
                        if (n === null) {
                            t += "null"
                        } else if (n === undefined) {
                            t += "undefined"
                        } else {
                            t += n
                        }
                    }
                    t += "]";
                    return t
                }
                e.toString = toString
            })(r = t.Arrays || (t.Arrays = {}))
        },
        4980: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BitSet = void 0;
            const n = r(3837);
            const i = r(5032);
            const o = new Uint16Array(0);

            function getIndex(e) {
                return e >>> 4
            }

            function unIndex(e) {
                return e * 16
            }

            function findLSBSet(e) {
                let t = 1;
                for (let r = 0; r < 16; r++) {
                    if ((e & t) !== 0) {
                        return r
                    }
                    t = t << 1 >>> 0
                }
                throw new RangeError("No specified bit found")
            }

            function findMSBSet(e) {
                let t = 1 << 15 >>> 0;
                for (let r = 15; r >= 0; r--) {
                    if ((e & t) !== 0) {
                        return r
                    }
                    t = t >>> 1
                }
                throw new RangeError("No specified bit found")
            }

            function bitsFor(e, t) {
                e &= 15;
                t &= 15;
                if (e === t) {
                    return 1 << e >>> 0
                }
                return 65535 >>> 15 - t ^ 65535 >>> 16 - e
            }
            const s = new Uint8Array(65536);
            for (let e = 0; e < 16; e++) {
                const t = 1 << e >>> 0;
                let r = 0;
                while (r < s.length) {
                    r += t;
                    for (let e = 0; e < t; e++) {
                        s[r]++;
                        r++
                    }
                }
            }
            class BitSet {
                constructor(e) {
                    if (!e) {
                        this.data = o
                    } else if (typeof e === "number") {
                        if (e < 0) {
                            throw new RangeError("nbits cannot be negative")
                        } else {
                            this.data = new Uint16Array(getIndex(e - 1) + 1)
                        }
                    } else {
                        if (e instanceof BitSet) {
                            this.data = e.data.slice(0)
                        } else {
                            let t = -1;
                            for (let r of e) {
                                if (t < r) {
                                    t = r
                                }
                            }
                            this.data = new Uint16Array(getIndex(t - 1) + 1);
                            for (let t of e) {
                                this.set(t)
                            }
                        }
                    }
                }
                and(e) {
                    const t = this.data;
                    const r = e.data;
                    const n = Math.min(t.length, r.length);
                    let i = -1;
                    for (let e = 0; e < n; e++) {
                        let n = t[e] &= r[e];
                        if (n !== 0) {
                            i = e
                        }
                    }
                    if (i === -1) {
                        this.data = o
                    }
                    if (i < t.length - 1) {
                        this.data = t.slice(0, i + 1)
                    }
                }
                andNot(e) {
                    const t = this.data;
                    const r = e.data;
                    const n = Math.min(t.length, r.length);
                    let i = -1;
                    for (let e = 0; e < n; e++) {
                        let n = t[e] &= r[e] ^ 65535;
                        if (n !== 0) {
                            i = e
                        }
                    }
                    if (i === -1) {
                        this.data = o
                    }
                    if (i < t.length - 1) {
                        this.data = t.slice(0, i + 1)
                    }
                }
                cardinality() {
                    if (this.isEmpty) {
                        return 0
                    }
                    const e = this.data;
                    const t = e.length;
                    let r = 0;
                    for (let n = 0; n < t; n++) {
                        r += s[e[n]]
                    }
                    return r
                }
                clear(e, t) {
                    if (e == null) {
                        this.data.fill(0)
                    } else if (t == null) {
                        this.set(e, false)
                    } else {
                        this.set(e, t, false)
                    }
                }
                flip(e, t) {
                    if (t == null) {
                        t = e
                    }
                    if (e < 0 || t < e) {
                        throw new RangeError
                    }
                    let r = getIndex(e);
                    const n = getIndex(t);
                    if (r === n) {
                        this.data[r] ^= bitsFor(e, t)
                    } else {
                        this.data[r++] ^= bitsFor(e, 15);
                        while (r < n) {
                            this.data[r++] ^= 65535
                        }
                        this.data[r++] ^= bitsFor(0, t)
                    }
                }
                get(e, t) {
                    if (t === undefined) {
                        return !!(this.data[getIndex(e)] & bitsFor(e, e))
                    } else {
                        let r = new BitSet(t + 1);
                        for (let n = e; n <= t; n++) {
                            r.set(n, this.get(n))
                        }
                        return r
                    }
                }
                intersects(e) {
                    let t = Math.min(this.length(), e.length());
                    if (t === 0) {
                        return false
                    }
                    let r = getIndex(t - 1);
                    for (let t = 0; t <= r; t++) {
                        if ((this.data[t] & e.data[t]) !== 0) {
                            return true
                        }
                    }
                    return false
                }
                get isEmpty() {
                    return this.length() === 0
                }
                length() {
                    if (!this.data.length) {
                        return 0
                    }
                    return this.previousSetBit(unIndex(this.data.length) - 1) + 1
                }
                nextClearBit(e) {
                    if (e < 0) {
                        throw new RangeError("fromIndex cannot be negative")
                    }
                    const t = this.data;
                    const r = t.length;
                    let n = getIndex(e);
                    if (n > r) {
                        return -1
                    }
                    let i = 65535 ^ bitsFor(e, 15);
                    if ((t[n] | i) === 65535) {
                        n++;
                        i = 0;
                        for (; n < r; n++) {
                            if (t[n] !== 65535) {
                                break
                            }
                        }
                        if (n === r) {
                            return -1
                        }
                    }
                    return unIndex(n) + findLSBSet((t[n] | i) ^ 65535)
                }
                nextSetBit(e) {
                    if (e < 0) {
                        throw new RangeError("fromIndex cannot be negative")
                    }
                    const t = this.data;
                    const r = t.length;
                    let n = getIndex(e);
                    if (n > r) {
                        return -1
                    }
                    let i = bitsFor(e, 15);
                    if ((t[n] & i) === 0) {
                        n++;
                        i = 65535;
                        for (; n < r; n++) {
                            if (t[n] !== 0) {
                                break
                            }
                        }
                        if (n >= r) {
                            return -1
                        }
                    }
                    return unIndex(n) + findLSBSet(t[n] & i)
                }
                or(e) {
                    const t = this.data;
                    const r = e.data;
                    const n = Math.min(t.length, r.length);
                    const i = Math.max(t.length, r.length);
                    const s = t.length === i ? t : new Uint16Array(i);
                    let a = -1;
                    for (let e = 0; e < n; e++) {
                        let n = s[e] = t[e] | r[e];
                        if (n !== 0) {
                            a = e
                        }
                    }
                    const l = t.length > r.length ? t : r;
                    for (let e = n; e < i; e++) {
                        let t = s[e] = l[e];
                        if (t !== 0) {
                            a = e
                        }
                    }
                    if (a === -1) {
                        this.data = o
                    } else if (s.length === a + 1) {
                        this.data = s
                    } else {
                        this.data = s.slice(0, a)
                    }
                }
                previousClearBit(e) {
                    if (e < 0) {
                        throw new RangeError("fromIndex cannot be negative")
                    }
                    const t = this.data;
                    const r = t.length;
                    let n = getIndex(e);
                    if (n >= r) {
                        n = r - 1
                    }
                    let i = 65535 ^ bitsFor(0, e);
                    if ((t[n] | i) === 65535) {
                        i = 0;
                        n--;
                        for (; n >= 0; n--) {
                            if (t[n] !== 65535) {
                                break
                            }
                        }
                        if (n < 0) {
                            return -1
                        }
                    }
                    return unIndex(n) + findMSBSet((t[n] | i) ^ 65535)
                }
                previousSetBit(e) {
                    if (e < 0) {
                        throw new RangeError("fromIndex cannot be negative")
                    }
                    const t = this.data;
                    const r = t.length;
                    let n = getIndex(e);
                    if (n >= r) {
                        n = r - 1
                    }
                    let i = bitsFor(0, e);
                    if ((t[n] & i) === 0) {
                        n--;
                        i = 65535;
                        for (; n >= 0; n--) {
                            if (t[n] !== 0) {
                                break
                            }
                        }
                        if (n < 0) {
                            return -1
                        }
                    }
                    return unIndex(n) + findMSBSet(t[n] & i)
                }
                set(e, t, r) {
                    if (t === undefined) {
                        t = e;
                        r = true
                    } else if (typeof t === "boolean") {
                        r = t;
                        t = e
                    }
                    if (r === undefined) {
                        r = true
                    }
                    if (e < 0 || e > t) {
                        throw new RangeError
                    }
                    let n = getIndex(e);
                    let i = getIndex(t);
                    if (r && i >= this.data.length) {
                        let e = new Uint16Array(i + 1);
                        this.data.forEach(((t, r) => e[r] = t));
                        this.data = e
                    } else if (!r) {
                        if (n >= this.data.length) {
                            return
                        }
                        if (i >= this.data.length) {
                            i = this.data.length - 1;
                            t = this.data.length * 16 - 1
                        }
                    }
                    if (n === i) {
                        this._setBits(n, r, bitsFor(e, t))
                    } else {
                        this._setBits(n++, r, bitsFor(e, 15));
                        while (n < i) {
                            this.data[n++] = r ? 65535 : 0
                        }
                        this._setBits(n, r, bitsFor(0, t))
                    }
                }
                _setBits(e, t, r) {
                    if (t) {
                        this.data[e] |= r
                    } else {
                        this.data[e] &= 65535 ^ r
                    }
                }
                get size() {
                    return this.data.byteLength * 8
                }
                hashCode() {
                    return i.MurmurHash.hashCode(this.data, 22)
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof BitSet)) {
                        return false
                    }
                    const t = this.length();
                    if (t !== e.length()) {
                        return false
                    }
                    if (t === 0) {
                        return true
                    }
                    let r = getIndex(t - 1);
                    for (let t = 0; t <= r; t++) {
                        if (this.data[t] !== e.data[t]) {
                            return false
                        }
                    }
                    return true
                }
                toString() {
                    let e = "{";
                    let t = true;
                    for (let r = this.nextSetBit(0); r >= 0; r = this.nextSetBit(r + 1)) {
                        if (t) {
                            t = false
                        } else {
                            e += ", "
                        }
                        e += r
                    }
                    e += "}";
                    return e
                }
                xor(e) {
                    const t = this.data;
                    const r = e.data;
                    const n = Math.min(t.length, r.length);
                    const i = Math.max(t.length, r.length);
                    const s = t.length === i ? t : new Uint16Array(i);
                    let a = -1;
                    for (let e = 0; e < n; e++) {
                        let n = s[e] = t[e] ^ r[e];
                        if (n !== 0) {
                            a = e
                        }
                    }
                    const l = t.length > r.length ? t : r;
                    for (let e = n; e < i; e++) {
                        let t = s[e] = l[e];
                        if (t !== 0) {
                            a = e
                        }
                    }
                    if (a === -1) {
                        this.data = o
                    } else if (s.length === a + 1) {
                        this.data = s
                    } else {
                        this.data = s.slice(0, a + 1)
                    }
                }
                clone() {
                    return new BitSet(this)
                } [Symbol.iterator]() {
                    return new BitSetIterator(this.data)
                } [n.inspect.custom]() {
                    return "BitSet " + this.toString()
                }
            }
            t.BitSet = BitSet;
            class BitSetIterator {
                constructor(e) {
                    this.data = e;
                    this.index = 0;
                    this.mask = 65535
                }
                next() {
                    while (this.index < this.data.length) {
                        const e = this.data[this.index] & this.mask;
                        if (e !== 0) {
                            const t = unIndex(this.index) + findLSBSet(e);
                            this.mask = bitsFor(t + 1, 15);
                            return {
                                done: false,
                                value: t
                            }
                        }
                        this.index++;
                        this.mask = 65535
                    }
                    return {
                        done: true,
                        value: -1
                    }
                } [Symbol.iterator]() {
                    return this
                }
            }
        },
        286: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.isSupplementaryCodePoint = t.isLowSurrogate = t.isHighSurrogate = void 0;

            function isHighSurrogate(e) {
                return e >= 55296 && e <= 56319
            }
            t.isHighSurrogate = isHighSurrogate;

            function isLowSurrogate(e) {
                return e >= 56320 && e <= 57343
            }
            t.isLowSurrogate = isLowSurrogate;

            function isSupplementaryCodePoint(e) {
                return e >= 65536
            }
            t.isSupplementaryCodePoint = isSupplementaryCodePoint
        },
        4210: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DefaultEqualityComparator = void 0;
            const i = r(6966);
            const o = r(5032);
            const s = r(4880);
            class DefaultEqualityComparator {
                hashCode(e) {
                    if (e == null) {
                        return 0
                    } else if (typeof e === "string" || typeof e === "number") {
                        return o.MurmurHash.hashCode([e])
                    } else {
                        return s.ObjectEqualityComparator.INSTANCE.hashCode(e)
                    }
                }
                equals(e, t) {
                    if (e == null) {
                        return t == null
                    } else if (typeof e === "string" || typeof e === "number") {
                        return e === t
                    } else {
                        return s.ObjectEqualityComparator.INSTANCE.equals(e, t)
                    }
                }
            }
            DefaultEqualityComparator.INSTANCE = new DefaultEqualityComparator;
            n([i.Override], DefaultEqualityComparator.prototype, "hashCode", null);
            n([i.Override], DefaultEqualityComparator.prototype, "equals", null);
            t.DefaultEqualityComparator = DefaultEqualityComparator
        },
        2446: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.IntegerList = void 0;
            const i = r(4797);
            const o = r(6966);
            const s = new Int32Array(0);
            const a = 4;
            const l = (1 << 31 >>> 0) - 1 - 8;
            class IntegerList {
                constructor(e) {
                    if (!e) {
                        this._data = s;
                        this._size = 0
                    } else if (e instanceof IntegerList) {
                        this._data = e._data.slice(0);
                        this._size = e._size
                    } else if (typeof e === "number") {
                        if (e === 0) {
                            this._data = s;
                            this._size = 0
                        } else {
                            this._data = new Int32Array(e);
                            this._size = 0
                        }
                    } else {
                        this._data = s;
                        this._size = 0;
                        for (let t of e) {
                            this.add(t)
                        }
                    }
                }
                add(e) {
                    if (this._data.length === this._size) {
                        this.ensureCapacity(this._size + 1)
                    }
                    this._data[this._size] = e;
                    this._size++
                }
                addAll(e) {
                    if (Array.isArray(e)) {
                        this.ensureCapacity(this._size + e.length);
                        this._data.subarray(this._size, this._size + e.length).set(e);
                        this._size += e.length
                    } else if (e instanceof IntegerList) {
                        this.ensureCapacity(this._size + e._size);
                        this._data.subarray(this._size, this._size + e.size).set(e._data);
                        this._size += e._size
                    } else {
                        this.ensureCapacity(this._size + e.size);
                        let t = 0;
                        for (let r of e) {
                            this._data[this._size + t] = r;
                            t++
                        }
                        this._size += e.size
                    }
                }
                get(e) {
                    if (e < 0 || e >= this._size) {
                        throw RangeError()
                    }
                    return this._data[e]
                }
                contains(e) {
                    for (let t = 0; t < this._size; t++) {
                        if (this._data[t] === e) {
                            return true
                        }
                    }
                    return false
                }
                set(e, t) {
                    if (e < 0 || e >= this._size) {
                        throw RangeError()
                    }
                    let r = this._data[e];
                    this._data[e] = t;
                    return r
                }
                removeAt(e) {
                    let t = this.get(e);
                    this._data.copyWithin(e, e + 1, this._size);
                    this._data[this._size - 1] = 0;
                    this._size--;
                    return t
                }
                removeRange(e, t) {
                    if (e < 0 || t < 0 || e > this._size || t > this._size) {
                        throw RangeError()
                    }
                    if (e > t) {
                        throw RangeError()
                    }
                    this._data.copyWithin(t, e, this._size);
                    this._data.fill(0, this._size - (t - e), this._size);
                    this._size -= t - e
                }
                get isEmpty() {
                    return this._size === 0
                }
                get size() {
                    return this._size
                }
                trimToSize() {
                    if (this._data.length === this._size) {
                        return
                    }
                    this._data = this._data.slice(0, this._size)
                }
                clear() {
                    this._data.fill(0, 0, this._size);
                    this._size = 0
                }
                toArray() {
                    if (this._size === 0) {
                        return []
                    }
                    return Array.from(this._data.subarray(0, this._size))
                }
                sort() {
                    this._data.subarray(0, this._size).sort()
                }
                equals(e) {
                    if (e === this) {
                        return true
                    }
                    if (!(e instanceof IntegerList)) {
                        return false
                    }
                    if (this._size !== e._size) {
                        return false
                    }
                    for (let t = 0; t < this._size; t++) {
                        if (this._data[t] !== e._data[t]) {
                            return false
                        }
                    }
                    return true
                }
                hashCode() {
                    let e = 1;
                    for (let t = 0; t < this._size; t++) {
                        e = 31 * e + this._data[t]
                    }
                    return e
                }
                toString() {
                    return this._data.toString()
                }
                binarySearch(e, t, r) {
                    if (t === undefined) {
                        t = 0
                    }
                    if (r === undefined) {
                        r = this._size
                    }
                    if (t < 0 || r < 0 || t > this._size || r > this._size) {
                        throw new RangeError
                    }
                    if (t > r) {
                        throw new RangeError
                    }
                    return i.Arrays.binarySearch(this._data, e, t, r)
                }
                ensureCapacity(e) {
                    if (e < 0 || e > l) {
                        throw new RangeError
                    }
                    let t;
                    if (this._data.length === 0) {
                        t = a
                    } else {
                        t = this._data.length
                    }
                    while (t < e) {
                        t = t * 2;
                        if (t < 0 || t > l) {
                            t = l
                        }
                    }
                    let r = new Int32Array(t);
                    r.set(this._data);
                    this._data = r
                }
                toCharArray() {
                    let e = new Uint16Array(this._size);
                    let t = 0;
                    let r = false;
                    for (let n = 0; n < this._size; n++) {
                        let i = this._data[n];
                        if (i >= 0 && i < 65536) {
                            e[t] = i;
                            t++;
                            continue
                        }
                        if (!r) {
                            let t = new Uint16Array(this.charArraySize());
                            t.set(e, 0);
                            e = t;
                            r = true
                        }
                        let o = String.fromCodePoint(i);
                        e[t] = o.charCodeAt(0);
                        e[t + 1] = o.charCodeAt(1);
                        t += 2
                    }
                    return e
                }
                charArraySize() {
                    let e = 0;
                    for (let t = 0; t < this._size; t++) {
                        e += this._data[t] >= 65536 ? 2 : 1
                    }
                    return e
                }
            }
            n([o.NotNull], IntegerList.prototype, "_data", void 0);
            n([o.Override], IntegerList.prototype, "equals", null);
            n([o.Override], IntegerList.prototype, "hashCode", null);
            n([o.Override], IntegerList.prototype, "toString", null);
            t.IntegerList = IntegerList
        },
        7356: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.IntegerStack = void 0;
            const n = r(2446);
            class IntegerStack extends n.IntegerList {
                constructor(e) {
                    super(e)
                }
                push(e) {
                    this.add(e)
                }
                pop() {
                    return this.removeAt(this.size - 1)
                }
                peek() {
                    return this.get(this.size - 1)
                }
            }
            t.IntegerStack = IntegerStack
        },
        6330: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Interval = void 0;
            const i = r(6966);
            const o = 1e3;
            class Interval {
                constructor(e, t) {
                    this.a = e;
                    this.b = t
                }
                static get INVALID() {
                    return Interval._INVALID
                }
                static of (e, t) {
                    if (e !== t || e < 0 || e > o) {
                        return new Interval(e, t)
                    }
                    if (Interval.cache[e] == null) {
                        Interval.cache[e] = new Interval(e, e)
                    }
                    return Interval.cache[e]
                }
                get length() {
                    if (this.b < this.a) {
                        return 0
                    }
                    return this.b - this.a + 1
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof Interval)) {
                        return false
                    }
                    return this.a === e.a && this.b === e.b
                }
                hashCode() {
                    let e = 23;
                    e = e * 31 + this.a;
                    e = e * 31 + this.b;
                    return e
                }
                startsBeforeDisjoint(e) {
                    return this.a < e.a && this.b < e.a
                }
                startsBeforeNonDisjoint(e) {
                    return this.a <= e.a && this.b >= e.a
                }
                startsAfter(e) {
                    return this.a > e.a
                }
                startsAfterDisjoint(e) {
                    return this.a > e.b
                }
                startsAfterNonDisjoint(e) {
                    return this.a > e.a && this.a <= e.b
                }
                disjoint(e) {
                    return this.startsBeforeDisjoint(e) || this.startsAfterDisjoint(e)
                }
                adjacent(e) {
                    return this.a === e.b + 1 || this.b === e.a - 1
                }
                properlyContains(e) {
                    return e.a >= this.a && e.b <= this.b
                }
                union(e) {
                    return Interval.of(Math.min(this.a, e.a), Math.max(this.b, e.b))
                }
                intersection(e) {
                    return Interval.of(Math.max(this.a, e.a), Math.min(this.b, e.b))
                }
                differenceNotProperlyContained(e) {
                    let t;
                    if (e.startsBeforeNonDisjoint(this)) {
                        t = Interval.of(Math.max(this.a, e.b + 1), this.b)
                    } else if (e.startsAfterNonDisjoint(this)) {
                        t = Interval.of(this.a, e.a - 1)
                    }
                    return t
                }
                toString() {
                    return this.a + ".." + this.b
                }
            }
            Interval._INVALID = new Interval(-1, -2);
            Interval.cache = new Array(o + 1);
            n([i.Override], Interval.prototype, "equals", null);
            n([i.Override], Interval.prototype, "hashCode", null);
            n([i.Override], Interval.prototype, "toString", null);
            t.Interval = Interval
        },
        7108: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.IntervalSet = void 0;
            const o = r(8069);
            const s = r(2446);
            const a = r(6330);
            const l = r(1740);
            const _ = r(5032);
            const u = r(6966);
            const c = r(7528);
            class IntervalSet {
                constructor(e) {
                    this.readonly = false;
                    if (e != null) {
                        this._intervals = e.slice(0)
                    } else {
                        this._intervals = []
                    }
                }
                static get COMPLETE_CHAR_SET() {
                    if (IntervalSet._COMPLETE_CHAR_SET === undefined) {
                        IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(l.Lexer.MIN_CHAR_VALUE, l.Lexer.MAX_CHAR_VALUE);
                        IntervalSet._COMPLETE_CHAR_SET.setReadonly(true)
                    }
                    return IntervalSet._COMPLETE_CHAR_SET
                }
                static get EMPTY_SET() {
                    if (IntervalSet._EMPTY_SET == null) {
                        IntervalSet._EMPTY_SET = new IntervalSet;
                        IntervalSet._EMPTY_SET.setReadonly(true)
                    }
                    return IntervalSet._EMPTY_SET
                }
                static of (e, t = e) {
                    let r = new IntervalSet;
                    r.add(e, t);
                    return r
                }
                clear() {
                    if (this.readonly) {
                        throw new Error("can't alter readonly IntervalSet")
                    }
                    this._intervals.length = 0
                }
                add(e, t = e) {
                    this.addRange(a.Interval.of(e, t))
                }
                addRange(e) {
                    if (this.readonly) {
                        throw new Error("can't alter readonly IntervalSet")
                    }
                    if (e.b < e.a) {
                        return
                    }
                    for (let t = 0; t < this._intervals.length; t++) {
                        let r = this._intervals[t];
                        if (e.equals(r)) {
                            return
                        }
                        if (e.adjacent(r) || !e.disjoint(r)) {
                            let n = e.union(r);
                            this._intervals[t] = n;
                            while (t < this._intervals.length - 1) {
                                t++;
                                let e = this._intervals[t];
                                if (!n.adjacent(e) && n.disjoint(e)) {
                                    break
                                }
                                this._intervals.splice(t, 1);
                                t--;
                                this._intervals[t] = n.union(e)
                            }
                            return
                        }
                        if (e.startsBeforeDisjoint(r)) {
                            this._intervals.splice(t, 0, e);
                            return
                        }
                    }
                    this._intervals.push(e)
                }
                static or(e) {
                    let t = new IntervalSet;
                    for (let r of e) {
                        t.addAll(r)
                    }
                    return t
                }
                addAll(e) {
                    if (e == null) {
                        return this
                    }
                    if (e instanceof IntervalSet) {
                        let t = e;
                        let r = t._intervals.length;
                        for (let e = 0; e < r; e++) {
                            let r = t._intervals[e];
                            this.add(r.a, r.b)
                        }
                    } else {
                        for (let t of e.toArray()) {
                            this.add(t)
                        }
                    }
                    return this
                }
                complementRange(e, t) {
                    return this.complement(IntervalSet.of(e, t))
                }
                complement(e) {
                    if (e.isNil) {
                        return IntervalSet.EMPTY_SET
                    }
                    let t;
                    if (e instanceof IntervalSet) {
                        t = e
                    } else {
                        t = new IntervalSet;
                        t.addAll(e)
                    }
                    return t.subtract(this)
                }
                subtract(e) {
                    if (e == null || e.isNil) {
                        return new IntervalSet(this._intervals)
                    }
                    if (e instanceof IntervalSet) {
                        return IntervalSet.subtract(this, e)
                    }
                    let t = new IntervalSet;
                    t.addAll(e);
                    return IntervalSet.subtract(this, t)
                }
                static subtract(e, t) {
                    if (e.isNil) {
                        return new IntervalSet
                    }
                    let r = new IntervalSet(e._intervals);
                    if (t.isNil) {
                        return r
                    }
                    let n = 0;
                    let i = 0;
                    while (n < r._intervals.length && i < t._intervals.length) {
                        let e = r._intervals[n];
                        let o = t._intervals[i];
                        if (o.b < e.a) {
                            i++;
                            continue
                        }
                        if (o.a > e.b) {
                            n++;
                            continue
                        }
                        let s;
                        let l;
                        if (o.a > e.a) {
                            s = new a.Interval(e.a, o.a - 1)
                        }
                        if (o.b < e.b) {
                            l = new a.Interval(o.b + 1, e.b)
                        }
                        if (s) {
                            if (l) {
                                r._intervals[n] = s;
                                r._intervals.splice(n + 1, 0, l);
                                n++;
                                i++;
                                continue
                            } else {
                                r._intervals[n] = s;
                                n++;
                                continue
                            }
                        } else {
                            if (l) {
                                r._intervals[n] = l;
                                i++;
                                continue
                            } else {
                                r._intervals.splice(n, 1);
                                continue
                            }
                        }
                    }
                    return r
                }
                or(e) {
                    let t = new IntervalSet;
                    t.addAll(this);
                    t.addAll(e);
                    return t
                }
                and(e) {
                    if (e.isNil) {
                        return new IntervalSet
                    }
                    let t = this._intervals;
                    let r = e._intervals;
                    let n;
                    let i = t.length;
                    let o = r.length;
                    let s = 0;
                    let a = 0;
                    while (s < i && a < o) {
                        let e = t[s];
                        let i = r[a];
                        if (e.startsBeforeDisjoint(i)) {
                            s++
                        } else if (i.startsBeforeDisjoint(e)) {
                            a++
                        } else if (e.properlyContains(i)) {
                            if (!n) {
                                n = new IntervalSet
                            }
                            n.addRange(e.intersection(i));
                            a++
                        } else if (i.properlyContains(e)) {
                            if (!n) {
                                n = new IntervalSet
                            }
                            n.addRange(e.intersection(i));
                            s++
                        } else if (!e.disjoint(i)) {
                            if (!n) {
                                n = new IntervalSet
                            }
                            n.addRange(e.intersection(i));
                            if (e.startsAfterNonDisjoint(i)) {
                                a++
                            } else if (i.startsAfterNonDisjoint(e)) {
                                s++
                            }
                        }
                    }
                    if (!n) {
                        return new IntervalSet
                    }
                    return n
                }
                contains(e) {
                    let t = this._intervals.length;
                    let r = 0;
                    let n = t - 1;
                    while (r <= n) {
                        let t = r + n >> 1;
                        let i = this._intervals[t];
                        let o = i.a;
                        let s = i.b;
                        if (s < e) {
                            r = t + 1
                        } else if (o > e) {
                            n = t - 1
                        } else {
                            return true
                        }
                    }
                    return false
                }
                get isNil() {
                    return this._intervals == null || this._intervals.length === 0
                }
                get maxElement() {
                    if (this.isNil) {
                        throw new RangeError("set is empty")
                    }
                    let e = this._intervals[this._intervals.length - 1];
                    return e.b
                }
                get minElement() {
                    if (this.isNil) {
                        throw new RangeError("set is empty")
                    }
                    return this._intervals[0].a
                }
                get intervals() {
                    return this._intervals
                }
                hashCode() {
                    let e = _.MurmurHash.initialize();
                    for (let t of this._intervals) {
                        e = _.MurmurHash.update(e, t.a);
                        e = _.MurmurHash.update(e, t.b)
                    }
                    e = _.MurmurHash.finish(e, this._intervals.length * 2);
                    return e
                }
                equals(e) {
                    if (e == null || !(e instanceof IntervalSet)) {
                        return false
                    }
                    return o.ArrayEqualityComparator.INSTANCE.equals(this._intervals, e._intervals)
                }
                toString(e = false) {
                    let t = "";
                    if (this._intervals == null || this._intervals.length === 0) {
                        return "{}"
                    }
                    if (this.size > 1) {
                        t += "{"
                    }
                    let r = true;
                    for (let n of this._intervals) {
                        if (r) {
                            r = false
                        } else {
                            t += ", "
                        }
                        let i = n.a;
                        let o = n.b;
                        if (i === o) {
                            if (i === c.Token.EOF) {
                                t += "<EOF>"
                            } else if (e) {
                                t += "'" + String.fromCodePoint(i) + "'"
                            } else {
                                t += i
                            }
                        } else {
                            if (e) {
                                t += "'" + String.fromCodePoint(i) + "'..'" + String.fromCodePoint(o) + "'"
                            } else {
                                t += i + ".." + o
                            }
                        }
                    }
                    if (this.size > 1) {
                        t += "}"
                    }
                    return t
                }
                toStringVocabulary(e) {
                    if (this._intervals == null || this._intervals.length === 0) {
                        return "{}"
                    }
                    let t = "";
                    if (this.size > 1) {
                        t += "{"
                    }
                    let r = true;
                    for (let n of this._intervals) {
                        if (r) {
                            r = false
                        } else {
                            t += ", "
                        }
                        let i = n.a;
                        let o = n.b;
                        if (i === o) {
                            t += this.elementName(e, i)
                        } else {
                            for (let r = i; r <= o; r++) {
                                if (r > i) {
                                    t += ", "
                                }
                                t += this.elementName(e, r)
                            }
                        }
                    }
                    if (this.size > 1) {
                        t += "}"
                    }
                    return t
                }
                elementName(e, t) {
                    if (t === c.Token.EOF) {
                        return "<EOF>"
                    } else if (t === c.Token.EPSILON) {
                        return "<EPSILON>"
                    } else {
                        return e.getDisplayName(t)
                    }
                }
                get size() {
                    let e = 0;
                    let t = this._intervals.length;
                    if (t === 1) {
                        let e = this._intervals[0];
                        return e.b - e.a + 1
                    }
                    for (let r = 0; r < t; r++) {
                        let t = this._intervals[r];
                        e += t.b - t.a + 1
                    }
                    return e
                }
                toIntegerList() {
                    let e = new s.IntegerList(this.size);
                    let t = this._intervals.length;
                    for (let r = 0; r < t; r++) {
                        let t = this._intervals[r];
                        let n = t.a;
                        let i = t.b;
                        for (let t = n; t <= i; t++) {
                            e.add(t)
                        }
                    }
                    return e
                }
                toSet() {
                    let e = new Set;
                    for (let t of this._intervals) {
                        let r = t.a;
                        let n = t.b;
                        for (let t = r; t <= n; t++) {
                            e.add(t)
                        }
                    }
                    return e
                }
                toArray() {
                    let e = new Array;
                    let t = this._intervals.length;
                    for (let r = 0; r < t; r++) {
                        let t = this._intervals[r];
                        let n = t.a;
                        let i = t.b;
                        for (let t = n; t <= i; t++) {
                            e.push(t)
                        }
                    }
                    return e
                }
                remove(e) {
                    if (this.readonly) {
                        throw new Error("can't alter readonly IntervalSet")
                    }
                    let t = this._intervals.length;
                    for (let r = 0; r < t; r++) {
                        let t = this._intervals[r];
                        let n = t.a;
                        let i = t.b;
                        if (e < n) {
                            break
                        }
                        if (e === n && e === i) {
                            this._intervals.splice(r, 1);
                            break
                        }
                        if (e === n) {
                            this._intervals[r] = a.Interval.of(t.a + 1, t.b);
                            break
                        }
                        if (e === i) {
                            this._intervals[r] = a.Interval.of(t.a, t.b - 1);
                            break
                        }
                        if (e > n && e < i) {
                            let n = t.b;
                            this._intervals[r] = a.Interval.of(t.a, e - 1);
                            this.add(e + 1, n)
                        }
                    }
                }
                get isReadonly() {
                    return this.readonly
                }
                setReadonly(e) {
                    if (this.readonly && !e) {
                        throw new Error("can't alter readonly IntervalSet")
                    }
                    this.readonly = e
                }
            }
            n([u.Override], IntervalSet.prototype, "addAll", null);
            n([u.Override], IntervalSet.prototype, "complement", null);
            n([u.Override], IntervalSet.prototype, "subtract", null);
            n([u.Override], IntervalSet.prototype, "or", null);
            n([u.Override], IntervalSet.prototype, "and", null);
            n([u.Override], IntervalSet.prototype, "contains", null);
            n([u.Override], IntervalSet.prototype, "isNil", null);
            n([u.Override], IntervalSet.prototype, "hashCode", null);
            n([u.Override], IntervalSet.prototype, "equals", null);
            n([i(0, u.NotNull)], IntervalSet.prototype, "toStringVocabulary", null);
            n([u.NotNull, i(0, u.NotNull)], IntervalSet.prototype, "elementName", null);
            n([u.Override], IntervalSet.prototype, "size", null);
            n([u.Override], IntervalSet.prototype, "remove", null);
            n([u.NotNull], IntervalSet, "of", null);
            n([u.NotNull], IntervalSet, "subtract", null);
            t.IntervalSet = IntervalSet
        },
        8870: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.MultiMap = void 0;
            class MultiMap extends Map {
                constructor() {
                    super()
                }
                map(e, t) {
                    let r = super.get(e);
                    if (!r) {
                        r = [];
                        super.set(e, r)
                    }
                    r.push(t)
                }
                getPairs() {
                    let e = [];
                    this.forEach(((t, r) => {
                        t.forEach((t => {
                            e.push([r, t])
                        }))
                    }));
                    return e
                }
            }
            t.MultiMap = MultiMap
        },
        5032: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.MurmurHash = void 0;
            var r;
            (function(e) {
                const t = 0;

                function initialize(e = t) {
                    return e
                }
                e.initialize = initialize;

                function update(e, t) {
                    const r = 3432918353;
                    const n = 461845907;
                    const i = 15;
                    const o = 13;
                    const s = 5;
                    const a = 3864292196;
                    if (t == null) {
                        t = 0
                    } else if (typeof t === "string") {
                        t = hashString(t)
                    } else if (typeof t === "object") {
                        t = t.hashCode()
                    }
                    let l = t;
                    l = Math.imul(l, r);
                    l = l << i | l >>> 32 - i;
                    l = Math.imul(l, n);
                    e = e ^ l;
                    e = e << o | e >>> 32 - o;
                    e = Math.imul(e, s) + a;
                    return e & 4294967295
                }
                e.update = update;

                function finish(e, t) {
                    e = e ^ t * 4;
                    e = e ^ e >>> 16;
                    e = Math.imul(e, 2246822507);
                    e = e ^ e >>> 13;
                    e = Math.imul(e, 3266489909);
                    e = e ^ e >>> 16;
                    return e
                }
                e.finish = finish;

                function hashCode(e, r = t) {
                    let n = initialize(r);
                    let i = 0;
                    for (let t of e) {
                        n = update(n, t);
                        i++
                    }
                    n = finish(n, i);
                    return n
                }
                e.hashCode = hashCode;

                function hashString(e) {
                    let t = e.length;
                    if (t === 0) {
                        return 0
                    }
                    let r = 0;
                    for (let n = 0; n < t; n++) {
                        let t = e.charCodeAt(n);
                        r = (r << 5 >>> 0) - r + t;
                        r |= 0
                    }
                    return r
                }
            })(r = t.MurmurHash || (t.MurmurHash = {}))
        },
        4880: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ObjectEqualityComparator = void 0;
            const i = r(6966);
            class ObjectEqualityComparator {
                hashCode(e) {
                    if (e == null) {
                        return 0
                    }
                    return e.hashCode()
                }
                equals(e, t) {
                    if (e == null) {
                        return t == null
                    }
                    return e.equals(t)
                }
            }
            ObjectEqualityComparator.INSTANCE = new ObjectEqualityComparator;
            n([i.Override], ObjectEqualityComparator.prototype, "hashCode", null);
            n([i.Override], ObjectEqualityComparator.prototype, "equals", null);
            t.ObjectEqualityComparator = ObjectEqualityComparator
        },
        8650: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ParseCancellationException = void 0;
            class ParseCancellationException extends Error {
                constructor(e) {
                    super(e.message);
                    this.cause = e;
                    this.stack = e.stack
                }
                getCause() {
                    return this.cause
                }
            }
            t.ParseCancellationException = ParseCancellationException
        },
        4316: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.UUID = void 0;
            const n = r(5032);
            class UUID {
                constructor(e, t, r, n) {
                    this.data = new Uint32Array(4);
                    this.data[0] = e;
                    this.data[1] = t;
                    this.data[2] = r;
                    this.data[3] = n
                }
                static fromString(e) {
                    if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(e)) {
                        throw new Error("Incorrectly formatted UUID")
                    }
                    let t = e.split("-");
                    let r = parseInt(t[0], 16);
                    let n = (parseInt(t[1], 16) << 16 >>> 0) + parseInt(t[2], 16);
                    let i = (parseInt(t[3], 16) << 16 >>> 0) + parseInt(t[4].substr(0, 4), 16);
                    let o = parseInt(t[4].substr(-8), 16);
                    return new UUID(r, n, i, o)
                }
                hashCode() {
                    return n.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]])
                }
                equals(e) {
                    if (e === this) {
                        return true
                    } else if (!(e instanceof UUID)) {
                        return false
                    }
                    return this.data[0] === e.data[0] && this.data[1] === e.data[1] && this.data[2] === e.data[2] && this.data[3] === e.data[3]
                }
                toString() {
                    return ("00000000" + this.data[0].toString(16)).substr(-8) + "-" + ("0000" + (this.data[1] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[1].toString(16)).substr(-4) + "-" + ("0000" + (this.data[2] >>> 16).toString(16)).substr(-4) + "-" + ("0000" + this.data[2].toString(16)).substr(-4) + ("00000000" + this.data[3].toString(16)).substr(-8)
                }
            }
            t.UUID = UUID
        },
        2925: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.toCharArray = t.toMap = t.equals = t.join = t.escapeWhitespace = void 0;

            function escapeWhitespace(e, t) {
                return t ? e.replace(/ /, "") : e.replace(/\t/, "\\t").replace(/\n/, "\\n").replace(/\r/, "\\r")
            }
            t.escapeWhitespace = escapeWhitespace;

            function join(e, t) {
                let r = "";
                let n = true;
                for (let i of e) {
                    if (n) {
                        n = false
                    } else {
                        r += t
                    }
                    r += i
                }
                return r
            }
            t.join = join;

            function equals(e, t) {
                if (e === t) {
                    return true
                }
                if (e === undefined || t === undefined) {
                    return false
                }
                return e.equals(t)
            }
            t.equals = equals;

            function toMap(e) {
                let t = new Map;
                for (let r = 0; r < e.length; r++) {
                    t.set(e[r], r)
                }
                return t
            }
            t.toMap = toMap;

            function toCharArray(e) {
                if (typeof e === "string") {
                    let t = new Uint16Array(e.length);
                    for (let r = 0; r < e.length; r++) {
                        t[r] = e.charCodeAt(r)
                    }
                    return t
                } else {
                    return e.toCharArray()
                }
            }
            t.toCharArray = toCharArray
        },
        8817: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ErrorNode = void 0;
            const i = r(6966);
            const o = r(4292);
            class ErrorNode extends o.TerminalNode {
                constructor(e) {
                    super(e)
                }
                accept(e) {
                    return e.visitErrorNode(this)
                }
            }
            n([i.Override], ErrorNode.prototype, "accept", null);
            t.ErrorNode = ErrorNode
        },
        2123: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleNode = void 0;
            class RuleNode {}
            t.RuleNode = RuleNode
        },
        4292: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TerminalNode = void 0;
            const i = r(6330);
            const o = r(6966);
            const s = r(7528);
            class TerminalNode {
                constructor(e) {
                    this._symbol = e
                }
                getChild(e) {
                    throw new RangeError("Terminal Node has no children.")
                }
                get symbol() {
                    return this._symbol
                }
                get parent() {
                    return this._parent
                }
                setParent(e) {
                    this._parent = e
                }
                get payload() {
                    return this._symbol
                }
                get sourceInterval() {
                    let e = this._symbol.tokenIndex;
                    return new i.Interval(e, e)
                }
                get childCount() {
                    return 0
                }
                accept(e) {
                    return e.visitTerminal(this)
                }
                get text() {
                    return this._symbol.text || ""
                }
                toStringTree(e) {
                    return this.toString()
                }
                toString() {
                    if (this._symbol.type === s.Token.EOF) {
                        return "<EOF>"
                    }
                    return this._symbol.text || ""
                }
            }
            n([o.Override], TerminalNode.prototype, "getChild", null);
            n([o.Override], TerminalNode.prototype, "parent", null);
            n([o.Override], TerminalNode.prototype, "setParent", null);
            n([o.Override], TerminalNode.prototype, "payload", null);
            n([o.Override], TerminalNode.prototype, "sourceInterval", null);
            n([o.Override], TerminalNode.prototype, "childCount", null);
            n([o.Override], TerminalNode.prototype, "accept", null);
            n([o.Override], TerminalNode.prototype, "text", null);
            n([o.Override], TerminalNode.prototype, "toStringTree", null);
            n([o.Override], TerminalNode.prototype, "toString", null);
            t.TerminalNode = TerminalNode
        },
        4569: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Trees = void 0;
            const o = r(7747);
            const s = r(3798);
            const a = r(8817);
            const l = r(6966);
            const _ = r(8871);
            const u = r(9562);
            const c = r(2123);
            const d = r(4292);
            const p = r(7528);
            const f = r(2925);
            class Trees {
                static toStringTree(e, t) {
                    let r;
                    if (t instanceof _.Parser) {
                        r = t.ruleNames
                    } else {
                        r = t
                    }
                    let n = f.escapeWhitespace(this.getNodeText(e, r), false);
                    if (e.childCount === 0) {
                        return n
                    }
                    let i = "";
                    i += "(";
                    n = f.escapeWhitespace(this.getNodeText(e, r), false);
                    i += n;
                    i += " ";
                    for (let t = 0; t < e.childCount; t++) {
                        if (t > 0) {
                            i += " "
                        }
                        i += this.toStringTree(e.getChild(t), r)
                    }
                    i += ")";
                    return i
                }
                static getNodeText(e, t) {
                    let r;
                    if (t instanceof _.Parser) {
                        r = t.ruleNames
                    } else if (t) {
                        r = t
                    } else {
                        let t = e.payload;
                        if (typeof t.text === "string") {
                            return t.text
                        }
                        return e.payload.toString()
                    }
                    if (e instanceof c.RuleNode) {
                        let t = e.ruleContext;
                        let n = t.ruleIndex;
                        let i = r[n];
                        let s = t.altNumber;
                        if (s !== o.ATN.INVALID_ALT_NUMBER) {
                            return i + ":" + s
                        }
                        return i
                    } else if (e instanceof a.ErrorNode) {
                        return e.toString()
                    } else if (e instanceof d.TerminalNode) {
                        let t = e.symbol;
                        return t.text || ""
                    }
                    throw new TypeError("Unexpected node type")
                }
                static getChildren(e) {
                    let t = [];
                    for (let r = 0; r < e.childCount; r++) {
                        t.push(e.getChild(r))
                    }
                    return t
                }
                static getAncestors(e) {
                    let t = [];
                    let r = e.parent;
                    while (r) {
                        t.unshift(r);
                        r = r.parent
                    }
                    return t
                }
                static isAncestorOf(e, t) {
                    if (!e || !t || !e.parent) {
                        return false
                    }
                    let r = t.parent;
                    while (r) {
                        if (e === r) {
                            return true
                        }
                        r = r.parent
                    }
                    return false
                }
                static findAllTokenNodes(e, t) {
                    return Trees.findAllNodes(e, t, true)
                }
                static findAllRuleNodes(e, t) {
                    return Trees.findAllNodes(e, t, false)
                }
                static findAllNodes(e, t, r) {
                    let n = [];
                    Trees._findAllNodes(e, t, r, n);
                    return n
                }
                static _findAllNodes(e, t, r, n) {
                    if (r && e instanceof d.TerminalNode) {
                        if (e.symbol.type === t) {
                            n.push(e)
                        }
                    } else if (!r && e instanceof u.ParserRuleContext) {
                        if (e.ruleIndex === t) {
                            n.push(e)
                        }
                    }
                    for (let i = 0; i < e.childCount; i++) {
                        Trees._findAllNodes(e.getChild(i), t, r, n)
                    }
                }
                static getDescendants(e) {
                    let t = [];

                    function recurse(e) {
                        t.push(e);
                        const r = e.childCount;
                        for (let t = 0; t < r; t++) {
                            recurse(e.getChild(t))
                        }
                    }
                    recurse(e);
                    return t
                }
                static getRootOfSubtreeEnclosingRegion(e, t, r) {
                    let n = e.childCount;
                    for (let i = 0; i < n; i++) {
                        let n = e.getChild(i);
                        let o = Trees.getRootOfSubtreeEnclosingRegion(n, t, r);
                        if (o) {
                            return o
                        }
                    }
                    if (e instanceof u.ParserRuleContext) {
                        let n = e.stop;
                        if (t >= e.start.tokenIndex && (n == null || r <= n.tokenIndex)) {
                            return e
                        }
                    }
                    return undefined
                }
                static stripChildrenOutOfRange(e, t, r, n) {
                    if (!e) {
                        return
                    }
                    let i = e.childCount;
                    for (let o = 0; o < i; o++) {
                        let i = e.getChild(o);
                        let a = i.sourceInterval;
                        if (i instanceof u.ParserRuleContext && (a.b < r || a.a > n)) {
                            if (Trees.isAncestorOf(i, t)) {
                                let t = new s.CommonToken(p.Token.INVALID_TYPE, "...");
                                e.children[o] = new d.TerminalNode(t)
                            }
                        }
                    }
                }
                static findNodeSuchThat(e, t) {
                    if (t(e)) {
                        return e
                    }
                    let r = e.childCount;
                    for (let n = 0; n < r; n++) {
                        let r = Trees.findNodeSuchThat(e.getChild(n), t);
                        if (r !== undefined) {
                            return r
                        }
                    }
                    return undefined
                }
            }
            n([i(0, l.NotNull)], Trees, "toStringTree", null);
            n([l.NotNull, i(0, l.NotNull)], Trees, "getAncestors", null);
            n([i(0, l.NotNull)], Trees, "getRootOfSubtreeEnclosingRegion", null);
            t.Trees = Trees
        },
        2191: (e, t) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Chunk = void 0;
            class Chunk {}
            t.Chunk = Chunk
        },
        451: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ParseTreeMatch = void 0;
            const o = r(6966);
            let s = class ParseTreeMatch {
                constructor(e, t, r, n) {
                    if (!e) {
                        throw new Error("tree cannot be null")
                    }
                    if (!t) {
                        throw new Error("pattern cannot be null")
                    }
                    if (!r) {
                        throw new Error("labels cannot be null")
                    }
                    this._tree = e;
                    this._pattern = t;
                    this._labels = r;
                    this._mismatchedNode = n
                }
                get(e) {
                    let t = this._labels.get(e);
                    if (!t || t.length === 0) {
                        return undefined
                    }
                    return t[t.length - 1]
                }
                getAll(e) {
                    const t = this._labels.get(e);
                    if (!t) {
                        return []
                    }
                    return t
                }
                get labels() {
                    return this._labels
                }
                get mismatchedNode() {
                    return this._mismatchedNode
                }
                get succeeded() {
                    return !this._mismatchedNode
                }
                get pattern() {
                    return this._pattern
                }
                get tree() {
                    return this._tree
                }
                toString() {
                    return `Match ${this.succeeded?"succeeded":"failed"}; found ${this.labels.size} labels`
                }
            };
            n([o.NotNull, i(0, o.NotNull)], s.prototype, "getAll", null);
            n([o.NotNull], s.prototype, "labels", null);
            n([o.NotNull], s.prototype, "pattern", null);
            n([o.NotNull], s.prototype, "tree", null);
            n([o.Override], s.prototype, "toString", null);
            s = n([i(0, o.NotNull), i(1, o.NotNull), i(2, o.NotNull)], s);
            t.ParseTreeMatch = s
        },
        3263: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ParseTreePattern = void 0;
            const o = r(6966);
            const s = r(5972);
            let a = class ParseTreePattern {
                constructor(e, t, r, n) {
                    this._matcher = e;
                    this._patternRuleIndex = r;
                    this._pattern = t;
                    this._patternTree = n
                }
                match(e) {
                    return this._matcher.match(e, this)
                }
                matches(e) {
                    return this._matcher.match(e, this).succeeded
                }
                findAll(e, t) {
                    let r = s.XPath.findAll(e, t, this._matcher.parser);
                    let n = [];
                    for (let e of r) {
                        let t = this.match(e);
                        if (t.succeeded) {
                            n.push(t)
                        }
                    }
                    return n
                }
                get matcher() {
                    return this._matcher
                }
                get pattern() {
                    return this._pattern
                }
                get patternRuleIndex() {
                    return this._patternRuleIndex
                }
                get patternTree() {
                    return this._patternTree
                }
            };
            n([o.NotNull], a.prototype, "_pattern", void 0);
            n([o.NotNull], a.prototype, "_patternTree", void 0);
            n([o.NotNull], a.prototype, "_matcher", void 0);
            n([o.NotNull, i(0, o.NotNull)], a.prototype, "match", null);
            n([i(0, o.NotNull)], a.prototype, "matches", null);
            n([o.NotNull, i(0, o.NotNull), i(1, o.NotNull)], a.prototype, "findAll", null);
            n([o.NotNull], a.prototype, "matcher", null);
            n([o.NotNull], a.prototype, "pattern", null);
            n([o.NotNull], a.prototype, "patternTree", null);
            a = n([i(0, o.NotNull), i(1, o.NotNull), i(3, o.NotNull)], a);
            t.ParseTreePattern = a
        },
        5497: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ParseTreePatternMatcher = void 0;
            const o = r(4003);
            const s = r(4904);
            const a = r(2757);
            const l = r(7715);
            const _ = r(8870);
            const u = r(6966);
            const c = r(8650);
            const d = r(18);
            const p = r(9562);
            const f = r(451);
            const h = r(3263);
            const g = r(8145);
            const m = r(2123);
            const y = r(617);
            const S = r(784);
            const T = r(4292);
            const x = r(3896);
            const C = r(7528);
            const N = r(1123);
            class ParseTreePatternMatcher {
                constructor(e, t) {
                    this.start = "<";
                    this.stop = ">";
                    this.escape = "\\";
                    this.escapeRE = /\\/g;
                    this._lexer = e;
                    this._parser = t
                }
                setDelimiters(e, t, r) {
                    if (!e) {
                        throw new Error("start cannot be null or empty")
                    }
                    if (!t) {
                        throw new Error("stop cannot be null or empty")
                    }
                    this.start = e;
                    this.stop = t;
                    this.escape = r;
                    this.escapeRE = new RegExp(r.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g")
                }
                matches(e, t, r = 0) {
                    if (typeof t === "string") {
                        let n = this.compile(t, r);
                        return this.matches(e, n)
                    } else {
                        let r = new _.MultiMap;
                        let n = this.matchImpl(e, t.patternTree, r);
                        return !n
                    }
                }
                match(e, t, r = 0) {
                    if (typeof t === "string") {
                        let n = this.compile(t, r);
                        return this.match(e, n)
                    } else {
                        let r = new _.MultiMap;
                        let n = this.matchImpl(e, t.patternTree, r);
                        return new f.ParseTreeMatch(e, t, r, n)
                    }
                }
                compile(e, t) {
                    let r = this.tokenize(e);
                    let n = new l.ListTokenSource(r);
                    let i = new a.CommonTokenStream(n);
                    const s = this._parser;
                    let _ = new d.ParserInterpreter(s.grammarFileName, s.vocabulary, s.ruleNames, s.getATNWithBypassAlts(), i);
                    let u;
                    try {
                        _.errorHandler = new o.BailErrorStrategy;
                        u = _.parse(t)
                    } catch (e) {
                        if (e instanceof c.ParseCancellationException) {
                            throw e.getCause()
                        } else if (e instanceof g.RecognitionException) {
                            throw e
                        } else if (e instanceof Error) {
                            throw new ParseTreePatternMatcher.CannotInvokeStartRule(e)
                        } else {
                            throw e
                        }
                    }
                    if (i.LA(1) !== C.Token.EOF) {
                        throw new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern
                    }
                    return new h.ParseTreePattern(this, e, t, u)
                }
                get lexer() {
                    return this._lexer
                }
                get parser() {
                    return this._parser
                }
                matchImpl(e, t, r) {
                    if (!e) {
                        throw new TypeError("tree cannot be null")
                    }
                    if (!t) {
                        throw new TypeError("patternTree cannot be null")
                    }
                    if (e instanceof T.TerminalNode && t instanceof T.TerminalNode) {
                        let n;
                        if (e.symbol.type === t.symbol.type) {
                            if (t.symbol instanceof N.TokenTagToken) {
                                let n = t.symbol;
                                r.map(n.tokenName, e);
                                const i = n.label;
                                if (i) {
                                    r.map(i, e)
                                }
                            } else if (e.text === t.text) {} else {
                                if (!n) {
                                    n = e
                                }
                            }
                        } else {
                            if (!n) {
                                n = e
                            }
                        }
                        return n
                    }
                    if (e instanceof p.ParserRuleContext && t instanceof p.ParserRuleContext) {
                        let n;
                        let i = this.getRuleTagToken(t);
                        if (i) {
                            let o;
                            if (e.ruleContext.ruleIndex === t.ruleContext.ruleIndex) {
                                r.map(i.ruleName, e);
                                const t = i.label;
                                if (t) {
                                    r.map(t, e)
                                }
                            } else {
                                if (!n) {
                                    n = e
                                }
                            }
                            return n
                        }
                        if (e.childCount !== t.childCount) {
                            if (!n) {
                                n = e
                            }
                            return n
                        }
                        let o = e.childCount;
                        for (let n = 0; n < o; n++) {
                            let i = this.matchImpl(e.getChild(n), t.getChild(n), r);
                            if (i) {
                                return i
                            }
                        }
                        return n
                    }
                    return e
                }
                getRuleTagToken(e) {
                    if (e instanceof m.RuleNode) {
                        if (e.childCount === 1 && e.getChild(0) instanceof T.TerminalNode) {
                            let t = e.getChild(0);
                            if (t.symbol instanceof y.RuleTagToken) {
                                return t.symbol
                            }
                        }
                    }
                    return undefined
                }
                tokenize(e) {
                    let t = this.split(e);
                    let r = [];
                    for (let n of t) {
                        if (n instanceof S.TagChunk) {
                            let t = n;
                            const i = t.tag.substr(0, 1);
                            if (i === i.toUpperCase()) {
                                let n = this._parser.getTokenType(t.tag);
                                if (n === C.Token.INVALID_TYPE) {
                                    throw new Error("Unknown token " + t.tag + " in pattern: " + e)
                                }
                                let i = new N.TokenTagToken(t.tag, n, t.label);
                                r.push(i)
                            } else if (i === i.toLowerCase()) {
                                let n = this._parser.getRuleIndex(t.tag);
                                if (n === -1) {
                                    throw new Error("Unknown rule " + t.tag + " in pattern: " + e)
                                }
                                let i = this._parser.getATNWithBypassAlts().ruleToTokenType[n];
                                r.push(new y.RuleTagToken(t.tag, i, t.label))
                            } else {
                                throw new Error("invalid tag: " + t.tag + " in pattern: " + e)
                            }
                        } else {
                            let e = n;
                            this._lexer.inputStream = s.CharStreams.fromString(e.text);
                            let t = this._lexer.nextToken();
                            while (t.type !== C.Token.EOF) {
                                r.push(t);
                                t = this._lexer.nextToken()
                            }
                        }
                    }
                    return r
                }
                split(e) {
                    let t = 0;
                    let r = e.length;
                    let n = [];
                    let i;
                    let o = [];
                    let s = [];
                    while (t < r) {
                        if (t === e.indexOf(this.escape + this.start, t)) {
                            t += this.escape.length + this.start.length
                        } else if (t === e.indexOf(this.escape + this.stop, t)) {
                            t += this.escape.length + this.stop.length
                        } else if (t === e.indexOf(this.start, t)) {
                            o.push(t);
                            t += this.start.length
                        } else if (t === e.indexOf(this.stop, t)) {
                            s.push(t);
                            t += this.stop.length
                        } else {
                            t++
                        }
                    }
                    if (o.length > s.length) {
                        throw new Error("unterminated tag in pattern: " + e)
                    }
                    if (o.length < s.length) {
                        throw new Error("missing start tag in pattern: " + e)
                    }
                    let a = o.length;
                    for (let t = 0; t < a; t++) {
                        if (o[t] >= s[t]) {
                            throw new Error("tag delimiters out of order in pattern: " + e)
                        }
                    }
                    if (a === 0) {
                        let t = e.substring(0, r);
                        n.push(new x.TextChunk(t))
                    }
                    if (a > 0 && o[0] > 0) {
                        let t = e.substring(0, o[0]);
                        n.push(new x.TextChunk(t))
                    }
                    for (let t = 0; t < a; t++) {
                        let r = e.substring(o[t] + this.start.length, s[t]);
                        let i = r;
                        let l;
                        let _ = r.indexOf(":");
                        if (_ >= 0) {
                            l = r.substring(0, _);
                            i = r.substring(_ + 1, r.length)
                        }
                        n.push(new S.TagChunk(i, l));
                        if (t + 1 < a) {
                            let r = e.substring(s[t] + this.stop.length, o[t + 1]);
                            n.push(new x.TextChunk(r))
                        }
                    }
                    if (a > 0) {
                        let t = s[a - 1] + this.stop.length;
                        if (t < r) {
                            let i = e.substring(t, r);
                            n.push(new x.TextChunk(i))
                        }
                    }
                    for (let e = 0; e < n.length; e++) {
                        let t = n[e];
                        if (t instanceof x.TextChunk) {
                            let r = t.text.replace(this.escapeRE, "");
                            if (r.length < t.text.length) {
                                n[e] = new x.TextChunk(r)
                            }
                        }
                    }
                    return n
                }
            }
            n([u.NotNull, i(1, u.NotNull)], ParseTreePatternMatcher.prototype, "match", null);
            n([u.NotNull], ParseTreePatternMatcher.prototype, "lexer", null);
            n([u.NotNull], ParseTreePatternMatcher.prototype, "parser", null);
            n([i(0, u.NotNull), i(1, u.NotNull), i(2, u.NotNull)], ParseTreePatternMatcher.prototype, "matchImpl", null);
            t.ParseTreePatternMatcher = ParseTreePatternMatcher;
            (function(e) {
                class CannotInvokeStartRule extends Error {
                    constructor(e) {
                        super(`CannotInvokeStartRule: ${e}`);
                        this.error = e
                    }
                }
                e.CannotInvokeStartRule = CannotInvokeStartRule;
                class StartRuleDoesNotConsumeFullPattern extends Error {
                    constructor() {
                        super("StartRuleDoesNotConsumeFullPattern")
                    }
                }
                e.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern
            })(ParseTreePatternMatcher = t.ParseTreePatternMatcher || (t.ParseTreePatternMatcher = {}))
        },
        617: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.RuleTagToken = void 0;
            const o = r(6966);
            const s = r(7528);
            let a = class RuleTagToken {
                constructor(e, t, r) {
                    if (e == null || e.length === 0) {
                        throw new Error("ruleName cannot be null or empty.")
                    }
                    this._ruleName = e;
                    this.bypassTokenType = t;
                    this._label = r
                }
                get ruleName() {
                    return this._ruleName
                }
                get label() {
                    return this._label
                }
                get channel() {
                    return s.Token.DEFAULT_CHANNEL
                }
                get text() {
                    if (this._label != null) {
                        return "<" + this._label + ":" + this._ruleName + ">"
                    }
                    return "<" + this._ruleName + ">"
                }
                get type() {
                    return this.bypassTokenType
                }
                get line() {
                    return 0
                }
                get charPositionInLine() {
                    return -1
                }
                get tokenIndex() {
                    return -1
                }
                get startIndex() {
                    return -1
                }
                get stopIndex() {
                    return -1
                }
                get tokenSource() {
                    return undefined
                }
                get inputStream() {
                    return undefined
                }
                toString() {
                    return this._ruleName + ":" + this.bypassTokenType
                }
            };
            n([o.NotNull], a.prototype, "ruleName", null);
            n([o.Override], a.prototype, "channel", null);
            n([o.Override], a.prototype, "text", null);
            n([o.Override], a.prototype, "type", null);
            n([o.Override], a.prototype, "line", null);
            n([o.Override], a.prototype, "charPositionInLine", null);
            n([o.Override], a.prototype, "tokenIndex", null);
            n([o.Override], a.prototype, "startIndex", null);
            n([o.Override], a.prototype, "stopIndex", null);
            n([o.Override], a.prototype, "tokenSource", null);
            n([o.Override], a.prototype, "inputStream", null);
            n([o.Override], a.prototype, "toString", null);
            a = n([i(0, o.NotNull)], a);
            t.RuleTagToken = a
        },
        784: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TagChunk = void 0;
            const i = r(2191);
            const o = r(6966);
            class TagChunk extends i.Chunk {
                constructor(e, t) {
                    super();
                    if (e == null || e.length === 0) {
                        throw new Error("tag cannot be null or empty")
                    }
                    this._tag = e;
                    this._label = t
                }
                get tag() {
                    return this._tag
                }
                get label() {
                    return this._label
                }
                toString() {
                    if (this._label != null) {
                        return this._label + ":" + this._tag
                    }
                    return this._tag
                }
            }
            n([o.NotNull], TagChunk.prototype, "tag", null);
            n([o.Override], TagChunk.prototype, "toString", null);
            t.TagChunk = TagChunk
        },
        3896: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TextChunk = void 0;
            const o = r(2191);
            const s = r(6966);
            let a = class TextChunk extends o.Chunk {
                constructor(e) {
                    super();
                    if (e == null) {
                        throw new Error("text cannot be null")
                    }
                    this._text = e
                }
                get text() {
                    return this._text
                }
                toString() {
                    return "'" + this._text + "'"
                }
            };
            n([s.NotNull], a.prototype, "_text", void 0);
            n([s.NotNull], a.prototype, "text", null);
            n([s.Override], a.prototype, "toString", null);
            a = n([i(0, s.NotNull)], a);
            t.TextChunk = a
        },
        1123: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            var i = this && this.__param || function(e, t) {
                return function(r, n) {
                    t(r, n, e)
                }
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TokenTagToken = void 0;
            const o = r(3798);
            const s = r(6966);
            let a = class TokenTagToken extends o.CommonToken {
                constructor(e, t, r) {
                    super(t);
                    this._tokenName = e;
                    this._label = r
                }
                get tokenName() {
                    return this._tokenName
                }
                get label() {
                    return this._label
                }
                get text() {
                    if (this._label != null) {
                        return "<" + this._label + ":" + this._tokenName + ">"
                    }
                    return "<" + this._tokenName + ">"
                }
                toString() {
                    return this._tokenName + ":" + this.type
                }
            };
            n([s.NotNull], a.prototype, "_tokenName", void 0);
            n([s.NotNull], a.prototype, "tokenName", null);
            n([s.Override], a.prototype, "text", null);
            n([s.Override], a.prototype, "toString", null);
            a = n([i(0, s.NotNull)], a);
            t.TokenTagToken = a
        },
        5972: (e, t, r) => {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPath = void 0;
            const n = r(4904);
            const i = r(2757);
            const o = r(3638);
            const s = r(9562);
            const a = r(7528);
            const l = r(4484);
            const _ = r(6308);
            const u = r(4334);
            const c = r(9093);
            const d = r(5772);
            const p = r(5912);
            const f = r(9915);
            const h = r(5206);
            class XPath {
                constructor(e, t) {
                    this.parser = e;
                    this.path = t;
                    this.elements = this.split(t)
                }
                split(e) {
                    let t = new l.XPathLexer(n.CharStreams.fromString(e));
                    t.recover = e => {
                        throw e
                    };
                    t.removeErrorListeners();
                    t.addErrorListener(new _.XPathLexerErrorListener);
                    let r = new i.CommonTokenStream(t);
                    try {
                        r.fill()
                    } catch (r) {
                        if (r instanceof o.LexerNoViableAltException) {
                            let n = t.charPositionInLine;
                            let i = "Invalid tokens or characters at index " + n + " in path '" + e + "' -- " + r.message;
                            throw new RangeError(i)
                        }
                        throw r
                    }
                    let s = r.getTokens();
                    let u = [];
                    let c = s.length;
                    let d = 0;
                    e: while (d < c) {
                        let e = s[d];
                        let t;
                        switch (e.type) {
                            case l.XPathLexer.ROOT:
                            case l.XPathLexer.ANYWHERE:
                                let r = e.type === l.XPathLexer.ANYWHERE;
                                d++;
                                t = s[d];
                                let n = t.type === l.XPathLexer.BANG;
                                if (n) {
                                    d++;
                                    t = s[d]
                                }
                                let i = this.getXPathElement(t, r);
                                i.invert = n;
                                u.push(i);
                                d++;
                                break;
                            case l.XPathLexer.TOKEN_REF:
                            case l.XPathLexer.RULE_REF:
                            case l.XPathLexer.WILDCARD:
                                u.push(this.getXPathElement(e, false));
                                d++;
                                break;
                            case a.Token.EOF:
                                break e;
                            default:
                                throw new Error("Unknowth path element " + e)
                        }
                    }
                    return u
                }
                getXPathElement(e, t) {
                    if (e.type === a.Token.EOF) {
                        throw new Error("Missing path element at end of path")
                    }
                    let r = e.text;
                    if (r == null) {
                        throw new Error("Expected wordToken to have text content.")
                    }
                    let n = this.parser.getTokenType(r);
                    let i = this.parser.getRuleIndex(r);
                    switch (e.type) {
                        case l.XPathLexer.WILDCARD:
                            return t ? new f.XPathWildcardAnywhereElement : new h.XPathWildcardElement;
                        case l.XPathLexer.TOKEN_REF:
                        case l.XPathLexer.STRING:
                            if (n === a.Token.INVALID_TYPE) {
                                throw new Error(r + " at index " + e.startIndex + " isn't a valid token name")
                            }
                            return t ? new d.XPathTokenAnywhereElement(r, n) : new p.XPathTokenElement(r, n);
                        default:
                            if (i === -1) {
                                throw new Error(r + " at index " + e.startIndex + " isn't a valid rule name")
                            }
                            return t ? new u.XPathRuleAnywhereElement(r, i) : new c.XPathRuleElement(r, i)
                    }
                }
                static findAll(e, t, r) {
                    let n = new XPath(r, t);
                    return n.evaluate(e)
                }
                evaluate(e) {
                    let t = new s.ParserRuleContext;
                    t.addChild(e);
                    let r = new Set([t]);
                    let n = 0;
                    while (n < this.elements.length) {
                        let e = new Set;
                        for (let t of r) {
                            if (t.childCount > 0) {
                                let r = this.elements[n].evaluate(t);
                                r.forEach(e.add, e)
                            }
                        }
                        n++;
                        r = e
                    }
                    return r
                }
            }
            t.XPath = XPath;
            XPath.WILDCARD = "*";
            XPath.NOT = "!"
        },
        7905: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathElement = void 0;
            const i = r(6966);
            class XPathElement {
                constructor(e) {
                    this.nodeName = e;
                    this.invert = false
                }
                toString() {
                    let e = this.invert ? "!" : "";
                    let t = Object.constructor.name;
                    return t + "[" + e + this.nodeName + "]"
                }
            }
            n([i.Override], XPathElement.prototype, "toString", null);
            t.XPathElement = XPathElement
        },
        4484: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathLexer = void 0;
            const n = r(6027);
            const i = r(1740);
            const o = r(3262);
            const s = r(7847);
            const a = r(2925);
            class XPathLexer extends i.Lexer {
                constructor(e) {
                    super(e);
                    this._interp = new o.LexerATNSimulator(XPathLexer._ATN, this)
                }
                get vocabulary() {
                    return XPathLexer.VOCABULARY
                }
                get grammarFileName() {
                    return "XPathLexer.g4"
                }
                get ruleNames() {
                    return XPathLexer.ruleNames
                }
                get serializedATN() {
                    return XPathLexer._serializedATN
                }
                get channelNames() {
                    return XPathLexer.channelNames
                }
                get modeNames() {
                    return XPathLexer.modeNames
                }
                action(e, t, r) {
                    switch (t) {
                        case 4:
                            this.ID_action(e, r);
                            break
                    }
                }
                ID_action(e, t) {
                    switch (t) {
                        case 0:
                            let e = this.text;
                            if (e.charAt(0) === e.charAt(0).toUpperCase()) {
                                this.type = XPathLexer.TOKEN_REF
                            } else {
                                this.type = XPathLexer.RULE_REF
                            }
                            break
                    }
                }
                static get _ATN() {
                    if (!XPathLexer.__ATN) {
                        XPathLexer.__ATN = (new n.ATNDeserializer).deserialize(a.toCharArray(XPathLexer._serializedATN))
                    }
                    return XPathLexer.__ATN
                }
            }
            t.XPathLexer = XPathLexer;
            XPathLexer.TOKEN_REF = 1;
            XPathLexer.RULE_REF = 2;
            XPathLexer.ANYWHERE = 3;
            XPathLexer.ROOT = 4;
            XPathLexer.WILDCARD = 5;
            XPathLexer.BANG = 6;
            XPathLexer.ID = 7;
            XPathLexer.STRING = 8;
            XPathLexer.channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
            XPathLexer.modeNames = ["DEFAULT_MODE"];
            XPathLexer.ruleNames = ["ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "NameChar", "NameStartChar", "STRING"];
            XPathLexer._LITERAL_NAMES = [undefined, undefined, undefined, "'//'", "'/'", "'*'", "'!'"];
            XPathLexer._SYMBOLIC_NAMES = [undefined, "TOKEN_REF", "RULE_REF", "ANYWHERE", "ROOT", "WILDCARD", "BANG", "ID", "STRING"];
            XPathLexer.VOCABULARY = new s.VocabularyImpl(XPathLexer._LITERAL_NAMES, XPathLexer._SYMBOLIC_NAMES, []);
            XPathLexer._serializedATNSegments = 2;
            XPathLexer._serializedATNSegment0 = "\n2\b" + "\t\t\t\t\t" + "\t\b\t\b\t\t\t" + "\n\f" + '"\v\b\b\t' + "\t\t,\n\t\f\t\t/\v\t\t\t-\n" + "\t\b\v\t\r\n" + "\n2;C\\" + "aac|" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "\r" + "(*<>?AOR_" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "\ud801" + "\uda02\uda38\uda3d\uda6e\uda77\uda77\uda86" + "\uda86\uda9d\udaa1\udaa3\udab1" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + '"' + "C\\c|" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "\r(*" + "<>?AOR_" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "";
            XPathLexer._serializedATNSegment1 = "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "" + "1" + "\t\v" + "" + "\t\v\r%" + "')1" + "11" + ",\b#" + "\n \b\r" + '"  !' + '!#" #$\b$\f' + "%&\t&'(\t(" + ")-)*,\v+*,/" + "-.-+.0/-" + "01)1 -" + "";
            XPathLexer._serializedATN = a.join([XPathLexer._serializedATNSegment0, XPathLexer._serializedATNSegment1], "")
        },
        6308: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathLexerErrorListener = void 0;
            const i = r(6966);
            class XPathLexerErrorListener {
                syntaxError(e, t, r, n, i, o) {}
            }
            n([i.Override], XPathLexerErrorListener.prototype, "syntaxError", null);
            t.XPathLexerErrorListener = XPathLexerErrorListener
        },
        4334: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathRuleAnywhereElement = void 0;
            const i = r(6966);
            const o = r(4569);
            const s = r(7905);
            class XPathRuleAnywhereElement extends s.XPathElement {
                constructor(e, t) {
                    super(e);
                    this.ruleIndex = t
                }
                evaluate(e) {
                    return o.Trees.findAllRuleNodes(e, this.ruleIndex)
                }
            }
            n([i.Override], XPathRuleAnywhereElement.prototype, "evaluate", null);
            t.XPathRuleAnywhereElement = XPathRuleAnywhereElement
        },
        9093: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathRuleElement = void 0;
            const i = r(9562);
            const o = r(6966);
            const s = r(4569);
            const a = r(7905);
            class XPathRuleElement extends a.XPathElement {
                constructor(e, t) {
                    super(e);
                    this.ruleIndex = t
                }
                evaluate(e) {
                    let t = [];
                    for (let r of s.Trees.getChildren(e)) {
                        if (r instanceof i.ParserRuleContext) {
                            if (r.ruleIndex === this.ruleIndex && !this.invert || r.ruleIndex !== this.ruleIndex && this.invert) {
                                t.push(r)
                            }
                        }
                    }
                    return t
                }
            }
            n([o.Override], XPathRuleElement.prototype, "evaluate", null);
            t.XPathRuleElement = XPathRuleElement
        },
        5772: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathTokenAnywhereElement = void 0;
            const i = r(6966);
            const o = r(4569);
            const s = r(7905);
            class XPathTokenAnywhereElement extends s.XPathElement {
                constructor(e, t) {
                    super(e);
                    this.tokenType = t
                }
                evaluate(e) {
                    return o.Trees.findAllTokenNodes(e, this.tokenType)
                }
            }
            n([i.Override], XPathTokenAnywhereElement.prototype, "evaluate", null);
            t.XPathTokenAnywhereElement = XPathTokenAnywhereElement
        },
        5912: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathTokenElement = void 0;
            const i = r(6966);
            const o = r(4292);
            const s = r(4569);
            const a = r(7905);
            class XPathTokenElement extends a.XPathElement {
                constructor(e, t) {
                    super(e);
                    this.tokenType = t
                }
                evaluate(e) {
                    let t = [];
                    for (let r of s.Trees.getChildren(e)) {
                        if (r instanceof o.TerminalNode) {
                            if (r.symbol.type === this.tokenType && !this.invert || r.symbol.type !== this.tokenType && this.invert) {
                                t.push(r)
                            }
                        }
                    }
                    return t
                }
            }
            n([i.Override], XPathTokenElement.prototype, "evaluate", null);
            t.XPathTokenElement = XPathTokenElement
        },
        9915: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathWildcardAnywhereElement = void 0;
            const i = r(6966);
            const o = r(4569);
            const s = r(5972);
            const a = r(7905);
            class XPathWildcardAnywhereElement extends a.XPathElement {
                constructor() {
                    super(s.XPath.WILDCARD)
                }
                evaluate(e) {
                    if (this.invert) {
                        return []
                    }
                    return o.Trees.getDescendants(e)
                }
            }
            n([i.Override], XPathWildcardAnywhereElement.prototype, "evaluate", null);
            t.XPathWildcardAnywhereElement = XPathWildcardAnywhereElement
        },
        5206: function(e, t, r) {
            /*!
             * Copyright 2016 The ANTLR Project. All rights reserved.
             * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.
             */
            var n = this && this.__decorate || function(e, t, r, n) {
                var i = arguments.length,
                    o = i < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n,
                    s;
                if (typeof Reflect === "object" && typeof Reflect.decorate === "function") o = Reflect.decorate(e, t, r, n);
                else
                    for (var a = e.length - 1; a >= 0; a--)
                        if (s = e[a]) o = (i < 3 ? s(o) : i > 3 ? s(t, r, o) : s(t, r)) || o;
                return i > 3 && o && Object.defineProperty(t, r, o), o
            };
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.XPathWildcardElement = void 0;
            const i = r(6966);
            const o = r(4569);
            const s = r(5972);
            const a = r(7905);
            class XPathWildcardElement extends a.XPathElement {
                constructor() {
                    super(s.XPath.WILDCARD)
                }
                evaluate(e) {
                    let t = [];
                    if (this.invert) {
                        return t
                    }
                    for (let r of o.Trees.getChildren(e)) {
                        t.push(r)
                    }
                    return t
                }
            }
            n([i.Override], XPathWildcardElement.prototype, "evaluate", null);
            t.XPathWildcardElement = XPathWildcardElement
        },
        1515: (e, t, r) => {
            const n = "==SUPPRESS==";
            const i = "?";
            const o = "*";
            const s = "+";
            const a = "A...";
            const l = "...";
            const _ = "_unrecognized_args";
            const u = r(9491);
            const c = r(3837);
            const d = r(7147);
            const p = r(9067);
            const f = r(1017);
            const h = c.inspect;

            function get_argv() {
                return process.argv.slice(1)
            }

            function get_terminal_size() {
                return {
                    columns: +process.env.COLUMNS || process.stdout.columns || 80
                }
            }

            function hasattr(e, t) {
                return Object.prototype.hasOwnProperty.call(e, t)
            }

            function getattr(e, t, r) {
                return hasattr(e, t) ? e[t] : r
            }

            function setattr(e, t, r) {
                e[t] = r
            }

            function setdefault(e, t, r) {
                if (!hasattr(e, t)) e[t] = r;
                return e[t]
            }

            function delattr(e, t) {
                delete e[t]
            }

            function range(e, t, r = 1) {
                if (arguments.length === 1)[t, e] = [e, 0];
                if (typeof e !== "number" || typeof t !== "number" || typeof r !== "number") {
                    throw new TypeError("argument cannot be interpreted as an integer")
                }
                if (r === 0) throw new TypeError("range() arg 3 must not be zero");
                let n = [];
                if (r > 0) {
                    for (let i = e; i < t; i += r) n.push(i)
                } else {
                    for (let i = e; i > t; i += r) n.push(i)
                }
                return n
            }

            function splitlines(e, t = false) {
                let r;
                if (!t) {
                    r = e.split(/\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029]/)
                } else {
                    r = [];
                    let t = e.split(/(\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029])/);
                    for (let e = 0; e < t.length; e += 2) {
                        r.push(t[e] + (e + 1 < t.length ? t[e + 1] : ""))
                    }
                }
                if (!r[r.length - 1]) r.pop();
                return r
            }

            function _string_lstrip(e, t) {
                let r = 0;
                while (r < e.length && t.includes(e[r])) r++;
                return r ? e.slice(r) : e
            }

            function _string_split(e, t, r) {
                let n = e.split(t);
                if (n.length > r) {
                    n = n.slice(0, r).concat([n.slice(r).join(t)])
                }
                return n
            }

            function _array_equal(e, t) {
                if (e.length !== t.length) return false;
                for (let r = 0; r < e.length; r++) {
                    if (e[r] !== t[r]) return false
                }
                return true
            }

            function _array_remove(e, t) {
                let r = e.indexOf(t);
                if (r === -1) throw new TypeError(p("%r not in list", t));
                e.splice(r, 1)
            }

            function _choices_to_array(e) {
                if (e === undefined) {
                    return []
                } else if (Array.isArray(e)) {
                    return e
                } else if (e !== null && typeof e[Symbol.iterator] === "function") {
                    return Array.from(e)
                } else if (typeof e === "object" && e !== null) {
                    return Object.keys(e)
                } else {
                    throw new Error(p("invalid choices value: %r", e))
                }
            }

            function _callable(e) {
                let t = {
                    [e.name]: function(...r) {
                        let n = new.target === t || !new.target;
                        return Reflect.construct(e, r, n ? e : new.target)
                    }
                };
                t[e.name].prototype = e.prototype;
                e.prototype[Symbol.toStringTag] = e.name;
                return t[e.name]
            }

            function _alias(e, t, r) {
                try {
                    let n = e.constructor.name;
                    Object.defineProperty(e, t, {
                        value: c.deprecate(e[r], p("%s.%s() is renamed to %s.%s()", n, t, n, r)),
                        enumerable: false
                    })
                } catch {}
            }

            function _camelcase_alias(e) {
                for (let t of Object.getOwnPropertyNames(e.prototype)) {
                    let r = t.replace(/\w_[a-z]/g, (e => e[0] + e[2].toUpperCase()));
                    if (r !== t) _alias(e.prototype, r, t)
                }
                return e
            }

            function _to_legacy_name(e) {
                e = e.replace(/\w_[a-z]/g, (e => e[0] + e[2].toUpperCase()));
                if (e === "default") e = "defaultValue";
                if (e === "const") e = "constant";
                return e
            }

            function _to_new_name(e) {
                if (e === "defaultValue") e = "default";
                if (e === "constant") e = "const";
                e = e.replace(/[A-Z]/g, (e => "_" + e.toLowerCase()));
                return e
            }
            let g = Symbol("no_default_value");

            function _parse_opts(e, t) {
                function get_name() {
                    let e = (new Error).stack.split("\n").map((e => e.match(/^    at (.*) \(.*\)$/))).filter(Boolean).map((e => e[1])).map((e => e.match(/[^ .]*$/)[0]));
                    if (e.length && e[0] === get_name.name) e.shift();
                    if (e.length && e[0] === _parse_opts.name) e.shift();
                    return e.length ? e[0] : ""
                }
                e = Array.from(e);
                let r = {};
                let n = [];
                let i = e.length && e[e.length - 1];
                if (typeof i === "object" && i !== null && !Array.isArray(i) && (!i.constructor || i.constructor.name === "Object")) {
                    r = Object.assign({}, e.pop())
                }
                let o = [];
                for (let e of Object.keys(t)) {
                    let t = _to_legacy_name(e);
                    if (t !== e && t in r) {
                        if (e in r) {} else {
                            r[e] = r[t]
                        }
                        o.push([t, e]);
                        delete r[t]
                    }
                }
                if (o.length) {
                    let e = get_name();
                    deprecate("camelcase_" + e, p("%s(): following options are renamed: %s", e, o.map((([e, t]) => p("%r -> %r", e, t)))))
                }
                let s = [];
                let a = e.length;
                for (let [i, o] of Object.entries(t)) {
                    if (i[0] === "*") {
                        if (i.length > 0 && i[1] === "*") {
                            let e = [];
                            for (let t of Object.keys(r)) {
                                let n = _to_new_name(t);
                                if (n !== t && t in r) {
                                    if (n in r) {} else {
                                        r[n] = r[t]
                                    }
                                    e.push([t, n]);
                                    delete r[t]
                                }
                            }
                            if (e.length) {
                                let t = get_name();
                                deprecate("camelcase_" + t, p("%s(): following options are renamed: %s", t, e.map((([e, t]) => p("%r -> %r", e, t)))))
                            }
                            n.push(r);
                            r = {}
                        } else {
                            n.push(e);
                            e = []
                        }
                    } else if (i in r && e.length > 0) {
                        throw new TypeError(p("%s() got multiple values for argument %r", get_name(), i))
                    } else if (i in r) {
                        n.push(r[i]);
                        delete r[i]
                    } else if (e.length > 0) {
                        n.push(e.shift())
                    } else if (o !== g) {
                        n.push(o)
                    } else {
                        s.push(i)
                    }
                }
                if (Object.keys(r).length) {
                    throw new TypeError(p("%s() got an unexpected keyword argument %r", get_name(), Object.keys(r)[0]))
                }
                if (e.length) {
                    let e = Object.entries(t).filter((([e, t]) => e[0] !== "*" && t !== g)).length;
                    let r = Object.entries(t).filter((([e]) => e[0] !== "*")).length;
                    throw new TypeError(p("%s() takes %s positional argument%s but %s %s given", get_name(), e === r ? p("from %s to %s", e, r) : r, e === r && r === 1 ? "" : "s", a, a === 1 ? "was" : "were"))
                }
                if (s.length) {
                    let e = s.map(h);
                    if (e.length > 1) e[e.length - 1] = "and " + e[e.length - 1];
                    let t = e.join(e.length === 2 ? "" : ", ");
                    throw new TypeError(p("%s() missing %i required positional argument%s: %s", get_name(), e.length, e.length === 1 ? "" : "s", t))
                }
                return n
            }
            let m = {};

            function deprecate(e, t) {
                m[e] = m[e] || c.deprecate((() => {}), t);
                m[e]()
            }

            function _AttributeHolder(e = Object) {
                return class _AttributeHolder extends e {
                    [c.inspect.custom]() {
                        let e = this.constructor.name;
                        let t = [];
                        let r = {};
                        for (let e of this._get_args()) {
                            t.push(h(e))
                        }
                        for (let [e, n] of this._get_kwargs()) {
                            if (/^[a-z_][a-z0-9_$]*$/i.test(e)) {
                                t.push(p("%s=%r", e, n))
                            } else {
                                r[e] = n
                            }
                        }
                        if (Object.keys(r).length) {
                            t.push(p("**%s", h(r)))
                        }
                        return p("%s(%s)", e, t.join(", "))
                    }
                    toString() {
                        return this[c.inspect.custom]()
                    }
                    _get_kwargs() {
                        return Object.entries(this)
                    }
                    _get_args() {
                        return []
                    }
                }
            }

            function _copy_items(e) {
                if (e === undefined) {
                    return []
                }
                return e.slice(0)
            }
            const y = _camelcase_alias(_callable(class HelpFormatter {
                constructor() {
                    let [e, t, r, n] = _parse_opts(arguments, {
                        prog: g,
                        indent_increment: 2,
                        max_help_position: 24,
                        width: undefined
                    });
                    if (n === undefined) {
                        n = get_terminal_size().columns;
                        n -= 2
                    }
                    this._prog = e;
                    this._indent_increment = t;
                    this._max_help_position = Math.min(r, Math.max(n - 20, t * 2));
                    this._width = n;
                    this._current_indent = 0;
                    this._level = 0;
                    this._action_max_length = 0;
                    this._root_section = this._Section(this, undefined);
                    this._current_section = this._root_section;
                    this._whitespace_matcher = /[ \t\n\r\f\v]+/g;
                    this._long_break_matcher = /\n\n\n+/g
                }
                _indent() {
                    this._current_indent += this._indent_increment;
                    this._level += 1
                }
                _dedent() {
                    this._current_indent -= this._indent_increment;
                    u(this._current_indent >= 0, "Indent decreased below 0.");
                    this._level -= 1
                }
                _add_item(e, t) {
                    this._current_section.items.push([e, t])
                }
                start_section(e) {
                    this._indent();
                    let t = this._Section(this, this._current_section, e);
                    this._add_item(t.format_help.bind(t), []);
                    this._current_section = t
                }
                end_section() {
                    this._current_section = this._current_section.parent;
                    this._dedent()
                }
                add_text(e) {
                    if (e !== n && e !== undefined) {
                        this._add_item(this._format_text.bind(this), [e])
                    }
                }
                add_usage(e, t, r, i = undefined) {
                    if (e !== n) {
                        let n = [e, t, r, i];
                        this._add_item(this._format_usage.bind(this), n)
                    }
                }
                add_argument(e) {
                    if (e.help !== n) {
                        let t = [this._format_action_invocation(e)];
                        for (let r of this._iter_indented_subactions(e)) {
                            t.push(this._format_action_invocation(r))
                        }
                        let r = Math.max(...t.map((e => e.length)));
                        let n = r + this._current_indent;
                        this._action_max_length = Math.max(this._action_max_length, n);
                        this._add_item(this._format_action.bind(this), [e])
                    }
                }
                add_arguments(e) {
                    for (let t of e) {
                        this.add_argument(t)
                    }
                }
                format_help() {
                    let e = this._root_section.format_help();
                    if (e) {
                        e = e.replace(this._long_break_matcher, "\n\n");
                        e = e.replace(/^\n+|\n+$/g, "") + "\n"
                    }
                    return e
                }
                _join_parts(e) {
                    return e.filter((e => e && e !== n)).join("")
                }
                _format_usage(e, t, r, n) {
                    if (n === undefined) {
                        n = "usage: "
                    }
                    if (e !== undefined) {
                        e = p(e, {
                            prog: this._prog
                        })
                    } else if (e === undefined && !t.length) {
                        e = p("%(prog)s", {
                            prog: this._prog
                        })
                    } else if (e === undefined) {
                        let i = p("%(prog)s", {
                            prog: this._prog
                        });
                        let o = [];
                        let s = [];
                        for (let e of t) {
                            if (e.option_strings.length) {
                                o.push(e)
                            } else {
                                s.push(e)
                            }
                        }
                        let a = this._format_actions_usage([].concat(o).concat(s), r);
                        e = [i, a].map(String).join(" ");
                        let l = this._width - this._current_indent;
                        if (n.length + e.length > l) {
                            let t = /\(.*?\)+(?=\s|$)|\[.*?\]+(?=\s|$)|\S+/g;
                            let a = this._format_actions_usage(o, r);
                            let _ = this._format_actions_usage(s, r);
                            let c = a.match(t) || [];
                            let d = _.match(t) || [];
                            u(c.join(" ") === a);
                            u(d.join(" ") === _);
                            let get_lines = (e, t, r = undefined) => {
                                let n = [];
                                let i = [];
                                let o;
                                if (r !== undefined) {
                                    o = r.length - 1
                                } else {
                                    o = t.length - 1
                                }
                                for (let r of e) {
                                    if (o + 1 + r.length > l && i) {
                                        n.push(t + i.join(" "));
                                        i = [];
                                        o = t.length - 1
                                    }
                                    i.push(r);
                                    o += r.length + 1
                                }
                                if (i.length) {
                                    n.push(t + i.join(" "))
                                }
                                if (r !== undefined) {
                                    n[0] = n[0].slice(t.length)
                                }
                                return n
                            };
                            let p;
                            if (n.length + i.length <= .75 * l) {
                                let e = " ".repeat(n.length + i.length + 1);
                                if (c.length) {
                                    p = get_lines([i].concat(c), e, n);
                                    p = p.concat(get_lines(d, e))
                                } else if (d.length) {
                                    p = get_lines([i].concat(d), e, n)
                                } else {
                                    p = [i]
                                }
                            } else {
                                let e = " ".repeat(n.length);
                                let t = [].concat(c).concat(d);
                                p = get_lines(t, e);
                                if (p.length > 1) {
                                    p = [];
                                    p = p.concat(get_lines(c, e));
                                    p = p.concat(get_lines(d, e))
                                }
                                p = [i].concat(p)
                            }
                            e = p.join("\n")
                        }
                    }
                    return p("%s%s\n\n", n, e)
                }
                _format_actions_usage(e, t) {
                    let r = new Set;
                    let i = {};
                    for (let n of t) {
                        let t = e.indexOf(n._group_actions[0]);
                        if (t === -1) {
                            continue
                        } else {
                            let o = t + n._group_actions.length;
                            if (_array_equal(e.slice(t, o), n._group_actions)) {
                                for (let e of n._group_actions) {
                                    r.add(e)
                                }
                                if (!n.required) {
                                    if (t in i) {
                                        i[t] += " ["
                                    } else {
                                        i[t] = "["
                                    }
                                    if (o in i) {
                                        i[o] += "]"
                                    } else {
                                        i[o] = "]"
                                    }
                                } else {
                                    if (t in i) {
                                        i[t] += " ("
                                    } else {
                                        i[t] = "("
                                    }
                                    if (o in i) {
                                        i[o] += ")"
                                    } else {
                                        i[o] = ")"
                                    }
                                }
                                for (let e of range(t + 1, o)) {
                                    i[e] = "|"
                                }
                            }
                        }
                    }
                    let o = [];
                    for (let [t, s] of Object.entries(e)) {
                        if (s.help === n) {
                            o.push(undefined);
                            if (i[+t] === "|") {
                                delete i[+t]
                            } else if (i[+t + 1] === "|") {
                                delete i[+t + 1]
                            }
                        } else if (!s.option_strings.length) {
                            let e = this._get_default_metavar_for_positional(s);
                            let t = this._format_args(s, e);
                            if (r.has(s)) {
                                if (t[0] === "[" && t[t.length - 1] === "]") {
                                    t = t.slice(1, -1)
                                }
                            }
                            o.push(t)
                        } else {
                            let e = s.option_strings[0];
                            let t;
                            if (s.nargs === 0) {
                                t = s.format_usage()
                            } else {
                                let r = this._get_default_metavar_for_optional(s);
                                let n = this._format_args(s, r);
                                t = p("%s %s", e, n)
                            }
                            if (!s.required && !r.has(s)) {
                                t = p("[%s]", t)
                            }
                            o.push(t)
                        }
                    }
                    for (let e of Object.keys(i).map(Number).sort(((e, t) => t - e))) {
                        o.splice(+e, 0, i[+e])
                    }
                    let s = o.filter(Boolean).join(" ");
                    s = s.replace(/([\[(]) /g, "$1");
                    s = s.replace(/ ([\])])/g, "$1");
                    s = s.replace(/[\[(] *[\])]/g, "");
                    s = s.replace(/\(([^|]*)\)/g, "$1", s);
                    s = s.trim();
                    return s
                }
                _format_text(e) {
                    if (e.includes("%(prog)")) {
                        e = p(e, {
                            prog: this._prog
                        })
                    }
                    let t = Math.max(this._width - this._current_indent, 11);
                    let r = " ".repeat(this._current_indent);
                    return this._fill_text(e, t, r) + "\n\n"
                }
                _format_action(e) {
                    let t = Math.min(this._action_max_length + 2, this._max_help_position);
                    let r = Math.max(this._width - t, 11);
                    let n = t - this._current_indent - 2;
                    let i = this._format_action_invocation(e);
                    let o;
                    if (!e.help) {
                        let e = [this._current_indent, "", i];
                        i = p("%*s%s\n", ...e)
                    } else if (i.length <= n) {
                        let e = [this._current_indent, "", n, i];
                        i = p("%*s%-*s  ", ...e);
                        o = 0
                    } else {
                        let e = [this._current_indent, "", i];
                        i = p("%*s%s\n", ...e);
                        o = t
                    }
                    let s = [i];
                    if (e.help) {
                        let n = this._expand_help(e);
                        let i = this._split_lines(n, r);
                        s.push(p("%*s%s\n", o, "", i[0]));
                        for (let e of i.slice(1)) {
                            s.push(p("%*s%s\n", t, "", e))
                        }
                    } else if (!i.endsWith("\n")) {
                        s.push("\n")
                    }
                    for (let t of this._iter_indented_subactions(e)) {
                        s.push(this._format_action(t))
                    }
                    return this._join_parts(s)
                }
                _format_action_invocation(e) {
                    if (!e.option_strings.length) {
                        let t = this._get_default_metavar_for_positional(e);
                        let r = this._metavar_formatter(e, t)(1)[0];
                        return r
                    } else {
                        let t = [];
                        if (e.nargs === 0) {
                            t = t.concat(e.option_strings)
                        } else {
                            let r = this._get_default_metavar_for_optional(e);
                            let n = this._format_args(e, r);
                            for (let r of e.option_strings) {
                                t.push(p("%s %s", r, n))
                            }
                        }
                        return t.join(", ")
                    }
                }
                _metavar_formatter(e, t) {
                    let r;
                    if (e.metavar !== undefined) {
                        r = e.metavar
                    } else if (e.choices !== undefined) {
                        let t = _choices_to_array(e.choices).map(String);
                        r = p("{%s}", t.join(","))
                    } else {
                        r = t
                    }

                    function format(e) {
                        if (Array.isArray(r)) {
                            return r
                        } else {
                            return Array(e).fill(r)
                        }
                    }
                    return format
                }
                _format_args(e, t) {
                    let r = this._metavar_formatter(e, t);
                    let _;
                    if (e.nargs === undefined) {
                        _ = p("%s", ...r(1))
                    } else if (e.nargs === i) {
                        _ = p("[%s]", ...r(1))
                    } else if (e.nargs === o) {
                        let e = r(1);
                        if (e.length === 2) {
                            _ = p("[%s [%s ...]]", ...e)
                        } else {
                            _ = p("[%s ...]", ...e)
                        }
                    } else if (e.nargs === s) {
                        _ = p("%s [%s ...]", ...r(2))
                    } else if (e.nargs === l) {
                        _ = "..."
                    } else if (e.nargs === a) {
                        _ = p("%s ...", ...r(1))
                    } else if (e.nargs === n) {
                        _ = ""
                    } else {
                        let t;
                        try {
                            t = range(e.nargs).map((() => "%s"))
                        } catch (e) {
                            throw new TypeError("invalid nargs value")
                        }
                        _ = p(t.join(" "), ...r(e.nargs))
                    }
                    return _
                }
                _expand_help(e) {
                    let t = Object.assign({
                        prog: this._prog
                    }, e);
                    for (let e of Object.keys(t)) {
                        if (t[e] === n) {
                            delete t[e]
                        }
                    }
                    for (let e of Object.keys(t)) {
                        if (t[e] && t[e].name) {
                            t[e] = t[e].name
                        }
                    }
                    if (t.choices !== undefined) {
                        let e = _choices_to_array(t.choices).map(String).join(", ");
                        t.choices = e
                    }
                    for (let e of Object.keys(t)) {
                        let r = _to_legacy_name(e);
                        if (r !== e) {
                            t[r] = t[e]
                        }
                    }
                    return p(this._get_help_string(e), t)
                }* _iter_indented_subactions(e) {
                    if (typeof e._get_subactions === "function") {
                        this._indent();
                        yield* e._get_subactions();
                        this._dedent()
                    }
                }
                _split_lines(e, t) {
                    e = e.replace(this._whitespace_matcher, " ").trim();
                    let n = r(4604);
                    return n.wrap(e, {
                        width: t
                    })
                }
                _fill_text(e, t, n) {
                    e = e.replace(this._whitespace_matcher, " ").trim();
                    let i = r(4604);
                    return i.fill(e, {
                        width: t,
                        initial_indent: n,
                        subsequent_indent: n
                    })
                }
                _get_help_string(e) {
                    return e.help
                }
                _get_default_metavar_for_optional(e) {
                    return e.dest.toUpperCase()
                }
                _get_default_metavar_for_positional(e) {
                    return e.dest
                }
            }));
            y.prototype._Section = _callable(class _Section {
                constructor(e, t, r = undefined) {
                    this.formatter = e;
                    this.parent = t;
                    this.heading = r;
                    this.items = []
                }
                format_help() {
                    if (this.parent !== undefined) {
                        this.formatter._indent()
                    }
                    let e = this.formatter._join_parts(this.items.map((([e, t]) => e.apply(null, t))));
                    if (this.parent !== undefined) {
                        this.formatter._dedent()
                    }
                    if (!e) {
                        return ""
                    }
                    let t;
                    if (this.heading !== n && this.heading !== undefined) {
                        let e = this.formatter._current_indent;
                        t = p("%*s%s:\n", e, "", this.heading)
                    } else {
                        t = ""
                    }
                    return this.formatter._join_parts(["\n", t, e, "\n"])
                }
            });
            const S = _camelcase_alias(_callable(class RawDescriptionHelpFormatter extends y {
                _fill_text(e, t, r) {
                    return splitlines(e, true).map((e => r + e)).join("")
                }
            }));
            const T = _camelcase_alias(_callable(class RawTextHelpFormatter extends S {
                _split_lines(e) {
                    return splitlines(e)
                }
            }));
            const x = _camelcase_alias(_callable(class ArgumentDefaultsHelpFormatter extends y {
                _get_help_string(e) {
                    let t = e.help;
                    if (!e.help.includes("%(default)") && !e.help.includes("%(defaultValue)")) {
                        if (e.default !== n) {
                            let r = [i, o];
                            if (e.option_strings.length || r.includes(e.nargs)) {
                                t += " (default: %(default)s)"
                            }
                        }
                    }
                    return t
                }
            }));
            const C = _camelcase_alias(_callable(class MetavarTypeHelpFormatter extends y {
                _get_default_metavar_for_optional(e) {
                    return typeof e.type === "function" ? e.type.name : e.type
                }
                _get_default_metavar_for_positional(e) {
                    return typeof e.type === "function" ? e.type.name : e.type
                }
            }));

            function _get_action_name(e) {
                if (e === undefined) {
                    return undefined
                } else if (e.option_strings.length) {
                    return e.option_strings.join("/")
                } else if (![undefined, n].includes(e.metavar)) {
                    return e.metavar
                } else if (![undefined, n].includes(e.dest)) {
                    return e.dest
                } else {
                    return undefined
                }
            }
            const N = _callable(class ArgumentError extends Error {
                constructor(e, t) {
                    super();
                    this.name = "ArgumentError";
                    this._argument_name = _get_action_name(e);
                    this._message = t;
                    this.message = this.str()
                }
                str() {
                    let e;
                    if (this._argument_name === undefined) {
                        e = "%(message)s"
                    } else {
                        e = "argument %(argument_name)s: %(message)s"
                    }
                    return p(e, {
                        message: this._message,
                        argument_name: this._argument_name
                    })
                }
            });
            const A = _callable(class ArgumentTypeError extends Error {
                constructor(e) {
                    super(e);
                    this.name = "ArgumentTypeError"
                }
            });
            const E = _camelcase_alias(_callable(class Action extends(_AttributeHolder(Function)) {
                constructor() {
                    let [e, t, r, n, i, o, s, a, l, _] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        nargs: undefined,
                        const: undefined,
                        default: undefined,
                        type: undefined,
                        choices: undefined,
                        required: false,
                        help: undefined,
                        metavar: undefined
                    });
                    super("return arguments.callee.call.apply(arguments.callee, arguments)");
                    this.option_strings = e;
                    this.dest = t;
                    this.nargs = r;
                    this.const = n;
                    this.default = i;
                    this.type = o;
                    this.choices = s;
                    this.required = a;
                    this.help = l;
                    this.metavar = _
                }
                _get_kwargs() {
                    let e = ["option_strings", "dest", "nargs", "const", "default", "type", "choices", "help", "metavar"];
                    return e.map((e => [e, getattr(this, e)]))
                }
                format_usage() {
                    return this.option_strings[0]
                }
                call() {
                    throw new Error(".call() not defined")
                }
            }));
            const v = _camelcase_alias(_callable(class BooleanOptionalAction extends E {
                constructor() {
                    let [e, t, r, n, i, o, s, a] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        default: undefined,
                        type: undefined,
                        choices: undefined,
                        required: false,
                        help: undefined,
                        metavar: undefined
                    });
                    let l = [];
                    for (let t of e) {
                        l.push(t);
                        if (t.startsWith("--")) {
                            t = "--no-" + t.slice(2);
                            l.push(t)
                        }
                    }
                    if (s !== undefined && r !== undefined) {
                        s += ` (default: ${r})`
                    }
                    super({
                        option_strings: l,
                        dest: t,
                        nargs: 0,
                        default: r,
                        type: n,
                        choices: i,
                        required: o,
                        help: s,
                        metavar: a
                    })
                }
                call(e, t, r, n = undefined) {
                    if (this.option_strings.includes(n)) {
                        setattr(t, this.dest, !n.startsWith("--no-"))
                    }
                }
                format_usage() {
                    return this.option_strings.join(" | ")
                }
            }));
            const M = _callable(class _StoreAction extends E {
                constructor() {
                    let [e, t, r, n, o, s, a, l, _, u] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        nargs: undefined,
                        const: undefined,
                        default: undefined,
                        type: undefined,
                        choices: undefined,
                        required: false,
                        help: undefined,
                        metavar: undefined
                    });
                    if (r === 0) {
                        throw new TypeError("nargs for store actions must be != 0; if you " + "have nothing to store, actions such as store " + "true or store const may be more appropriate")
                    }
                    if (n !== undefined && r !== i) {
                        throw new TypeError(p("nargs must be %r to supply const", i))
                    }
                    super({
                        option_strings: e,
                        dest: t,
                        nargs: r,
                        const: n,
                        default: o,
                        type: s,
                        choices: a,
                        required: l,
                        help: _,
                        metavar: u
                    })
                }
                call(e, t, r) {
                    setattr(t, this.dest, r)
                }
            });
            const w = _callable(class _StoreConstAction extends E {
                constructor() {
                    let [e, t, r, n, i, o] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        const: g,
                        default: undefined,
                        required: false,
                        help: undefined,
                        metavar: undefined
                    });
                    super({
                        option_strings: e,
                        dest: t,
                        nargs: 0,
                        const: r,
                        default: n,
                        required: i,
                        help: o
                    })
                }
                call(e, t) {
                    setattr(t, this.dest, this.const)
                }
            });
            const b = _callable(class _StoreTrueAction extends w {
                constructor() {
                    let [e, t, r, n, i] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        default: false,
                        required: false,
                        help: undefined
                    });
                    super({
                        option_strings: e,
                        dest: t,
                        const: true,
                        default: r,
                        required: n,
                        help: i
                    })
                }
            });
            const F = _callable(class _StoreFalseAction extends w {
                constructor() {
                    let [e, t, r, n, i] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        default: true,
                        required: false,
                        help: undefined
                    });
                    super({
                        option_strings: e,
                        dest: t,
                        const: false,
                        default: r,
                        required: n,
                        help: i
                    })
                }
            });
            const B = _callable(class _AppendAction extends E {
                constructor() {
                    let [e, t, r, n, o, s, a, l, _, u] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        nargs: undefined,
                        const: undefined,
                        default: undefined,
                        type: undefined,
                        choices: undefined,
                        required: false,
                        help: undefined,
                        metavar: undefined
                    });
                    if (r === 0) {
                        throw new TypeError("nargs for append actions must be != 0; if arg " + "strings are not supplying the value to append, " + "the append const action may be more appropriate")
                    }
                    if (n !== undefined && r !== i) {
                        throw new TypeError(p("nargs must be %r to supply const", i))
                    }
                    super({
                        option_strings: e,
                        dest: t,
                        nargs: r,
                        const: n,
                        default: o,
                        type: s,
                        choices: a,
                        required: l,
                        help: _,
                        metavar: u
                    })
                }
                call(e, t, r) {
                    let n = getattr(t, this.dest, undefined);
                    n = _copy_items(n);
                    n.push(r);
                    setattr(t, this.dest, n)
                }
            });
            const I = _callable(class _AppendConstAction extends E {
                constructor() {
                    let [e, t, r, n, i, o, s] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        const: g,
                        default: undefined,
                        required: false,
                        help: undefined,
                        metavar: undefined
                    });
                    super({
                        option_strings: e,
                        dest: t,
                        nargs: 0,
                        const: r,
                        default: n,
                        required: i,
                        help: o,
                        metavar: s
                    })
                }
                call(e, t) {
                    let r = getattr(t, this.dest, undefined);
                    r = _copy_items(r);
                    r.push(this.const);
                    setattr(t, this.dest, r)
                }
            });
            const L = _callable(class _CountAction extends E {
                constructor() {
                    let [e, t, r, n, i] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: g,
                        default: undefined,
                        required: false,
                        help: undefined
                    });
                    super({
                        option_strings: e,
                        dest: t,
                        nargs: 0,
                        default: r,
                        required: n,
                        help: i
                    })
                }
                call(e, t) {
                    let r = getattr(t, this.dest, undefined);
                    if (r === undefined) {
                        r = 0
                    }
                    setattr(t, this.dest, r + 1)
                }
            });
            const P = _callable(class _HelpAction extends E {
                constructor() {
                    let [e, t, r, i] = _parse_opts(arguments, {
                        option_strings: g,
                        dest: n,
                        default: n,
                        help: undefined
                    });
                    super({
                        option_strings: e,
                        dest: t,
                        default: r,
                        nargs: 0,
                        help: i
                    })
                }
                call(e) {
                    e.print_help();
                    e.exit()
                }
            });
            const O = _callable(class _VersionAction extends E {
                constructor() {
                    let [e, t, r, i, o] = _parse_opts(arguments, {
                        option_strings: g,
                        version: undefined,
                        dest: n,
                        default: n,
                        help: "show program's version number and exit"
                    });
                    super({
                        option_strings: e,
                        dest: r,
                        default: i,
                        nargs: 0,
                        help: o
                    });
                    this.version = t
                }
                call(e) {
                    let t = this.version;
                    if (t === undefined) {
                        t = e.version
                    }
                    let r = e._get_formatter();
                    r.add_text(t);
                    e._print_message(r.format_help(), process.stdout);
                    e.exit()
                }
            });
            const R = _camelcase_alias(_callable(class _SubParsersAction extends E {
                constructor() {
                    let [e, t, r, i, o, s, l] = _parse_opts(arguments, {
                        option_strings: g,
                        prog: g,
                        parser_class: g,
                        dest: n,
                        required: false,
                        help: undefined,
                        metavar: undefined
                    });
                    let _ = {};
                    super({
                        option_strings: e,
                        dest: i,
                        nargs: a,
                        choices: _,
                        required: o,
                        help: s,
                        metavar: l
                    });
                    this._prog_prefix = t;
                    this._parser_class = r;
                    this._name_parser_map = _;
                    this._choices_actions = []
                }
                add_parser() {
                    let [e, t] = _parse_opts(arguments, {
                        name: g,
                        "**kwargs": g
                    });
                    if (t.prog === undefined) {
                        t.prog = p("%s %s", this._prog_prefix, e)
                    }
                    let r = getattr(t, "aliases", []);
                    delete t.aliases;
                    if ("help" in t) {
                        let n = t.help;
                        delete t.help;
                        let i = this._ChoicesPseudoAction(e, r, n);
                        this._choices_actions.push(i)
                    }
                    let n = new this._parser_class(t);
                    this._name_parser_map[e] = n;
                    for (let e of r) {
                        this._name_parser_map[e] = n
                    }
                    return n
                }
                _get_subactions() {
                    return this._choices_actions
                }
                call(e, t, r) {
                    let i = r[0];
                    let o = r.slice(1);
                    if (this.dest !== n) {
                        setattr(t, this.dest, i)
                    }
                    if (hasattr(this._name_parser_map, i)) {
                        e = this._name_parser_map[i]
                    } else {
                        let e = {
                            parser_name: i,
                            choices: this._name_parser_map.join(", ")
                        };
                        let t = p("unknown parser %(parser_name)r (choices: %(choices)s)", e);
                        throw new N(this, t)
                    }
                    let s;
                    [s, o] = e.parse_known_args(o, undefined);
                    for (let [e, r] of Object.entries(s)) {
                        setattr(t, e, r)
                    }
                    if (o.length) {
                        setdefault(t, _, []);
                        getattr(t, _).push(...o)
                    }
                }
            }));
            R.prototype._ChoicesPseudoAction = _callable(class _ChoicesPseudoAction extends E {
                constructor(e, t, r) {
                    let n = e,
                        i = e;
                    if (t.length) {
                        n += p(" (%s)", t.join(", "))
                    }
                    super({
                        option_strings: [],
                        dest: i,
                        help: r,
                        metavar: n
                    })
                }
            });
            const D = _callable(class _ExtendAction extends B {
                call(e, t, r) {
                    let n = getattr(t, this.dest, undefined);
                    n = _copy_items(n);
                    n = n.concat(r);
                    setattr(t, this.dest, n)
                }
            });
            const k = _callable(class FileType extends Function {
                constructor() {
                    let [e, t, r, n, i, o, s, a, l] = _parse_opts(arguments, {
                        flags: "r",
                        encoding: undefined,
                        mode: undefined,
                        autoClose: undefined,
                        emitClose: undefined,
                        start: undefined,
                        end: undefined,
                        highWaterMark: undefined,
                        fs: undefined
                    });
                    super("return arguments.callee.call.apply(arguments.callee, arguments)");
                    Object.defineProperty(this, "name", {
                        get() {
                            return p("FileType(%r)", e)
                        }
                    });
                    this._flags = e;
                    this._options = {};
                    if (t !== undefined) this._options.encoding = t;
                    if (r !== undefined) this._options.mode = r;
                    if (n !== undefined) this._options.autoClose = n;
                    if (i !== undefined) this._options.emitClose = i;
                    if (o !== undefined) this._options.start = o;
                    if (s !== undefined) this._options.end = s;
                    if (a !== undefined) this._options.highWaterMark = a;
                    if (l !== undefined) this._options.fs = l
                }
                call(e) {
                    if (e === "-") {
                        if (this._flags.includes("r")) {
                            return process.stdin
                        } else if (this._flags.includes("w")) {
                            return process.stdout
                        } else {
                            let e = p('argument "-" with mode %r', this._flags);
                            throw new TypeError(e)
                        }
                    }
                    let t;
                    try {
                        t = d.openSync(e, this._flags, this._options.mode)
                    } catch (t) {
                        let r = {
                            filename: e,
                            error: t.message
                        };
                        let n = "can't open '%(filename)s': %(error)s";
                        throw new A(p(n, r))
                    }
                    let r = Object.assign({
                        fd: t,
                        flags: this._flags
                    }, this._options);
                    if (this._flags.includes("r")) {
                        return d.createReadStream(undefined, r)
                    } else if (this._flags.includes("w")) {
                        return d.createWriteStream(undefined, r)
                    } else {
                        let t = p('argument "%s" with mode %r', e, this._flags);
                        throw new TypeError(t)
                    }
                } [c.inspect.custom]() {
                    let e = [this._flags];
                    let t = Object.entries(this._options).map((([e, t]) => {
                        if (e === "mode") t = {
                            value: t,
                            [c.inspect.custom]() {
                                return "0o" + this.value.toString(8)
                            }
                        };
                        return [e, t]
                    }));
                    let r = [].concat(e.filter((e => e !== -1)).map(h)).concat(t.filter((([, e]) => e !== undefined)).map((([e, t]) => p("%s=%r", e, t)))).join(", ");
                    return p("%s(%s)", this.constructor.name, r)
                }
                toString() {
                    return this[c.inspect.custom]()
                }
            });
            const $ = _callable(class Namespace extends(_AttributeHolder()) {
                constructor(e = {}) {
                    super();
                    Object.assign(this, e)
                }
            });
            $.prototype[Symbol.toStringTag] = undefined;
            const j = _camelcase_alias(_callable(class _ActionsContainer {
                constructor() {
                    let [e, t, r, n] = _parse_opts(arguments, {
                        description: g,
                        prefix_chars: g,
                        argument_default: g,
                        conflict_handler: g
                    });
                    this.description = e;
                    this.argument_default = r;
                    this.prefix_chars = t;
                    this.conflict_handler = n;
                    this._registries = {};
                    this.register("action", undefined, M);
                    this.register("action", "store", M);
                    this.register("action", "store_const", w);
                    this.register("action", "store_true", b);
                    this.register("action", "store_false", F);
                    this.register("action", "append", B);
                    this.register("action", "append_const", I);
                    this.register("action", "count", L);
                    this.register("action", "help", P);
                    this.register("action", "version", O);
                    this.register("action", "parsers", R);
                    this.register("action", "extend", D);
                    ["storeConst", "storeTrue", "storeFalse", "appendConst"].forEach((e => {
                        let t = _to_new_name(e);
                        this.register("action", e, c.deprecate(this._registry_get("action", t), p('{action: "%s"} is renamed to {action: "%s"}', e, t)))
                    }));
                    this._get_handler();
                    this._actions = [];
                    this._option_string_actions = {};
                    this._action_groups = [];
                    this._mutually_exclusive_groups = [];
                    this._defaults = {};
                    this._negative_number_matcher = /^-\d+$|^-\d*\.\d+$/;
                    this._has_negative_number_optionals = []
                }
                register(e, t, r) {
                    let n = setdefault(this._registries, e, {});
                    n[t] = r
                }
                _registry_get(e, t, r = undefined) {
                    return getattr(this._registries[e], t, r)
                }
                set_defaults(e) {
                    Object.assign(this._defaults, e);
                    for (let t of this._actions) {
                        if (t.dest in e) {
                            t.default = e[t.dest]
                        }
                    }
                }
                get_default(e) {
                    for (let t of this._actions) {
                        if (t.dest === e && t.default !== undefined) {
                            return t.default
                        }
                    }
                    return this._defaults[e]
                }
                add_argument() {
                    let [e, t] = _parse_opts(arguments, {
                        "*args": g,
                        "**kwargs": g
                    });
                    if (e.length === 1 && Array.isArray(e[0])) {
                        e = e[0];
                        deprecate("argument-array", p("use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })", {
                            args: e.map(h).join(", ")
                        }))
                    }
                    let r = this.prefix_chars;
                    if (!e.length || e.length === 1 && !r.includes(e[0][0])) {
                        if (e.length && "dest" in t) {
                            throw new TypeError("dest supplied twice for positional argument")
                        }
                        t = this._get_positional_kwargs(...e, t)
                    } else {
                        t = this._get_optional_kwargs(...e, t)
                    }
                    if (!("default" in t)) {
                        let e = t.dest;
                        if (e in this._defaults) {
                            t.default = this._defaults[e]
                        } else if (this.argument_default !== undefined) {
                            t.default = this.argument_default
                        }
                    }
                    let n = this._pop_action_class(t);
                    if (typeof n !== "function") {
                        throw new TypeError(p('unknown action "%s"', n))
                    }
                    let i = new n(t);
                    let o = this._registry_get("type", i.type, i.type);
                    if (typeof o !== "function") {
                        throw new TypeError(p("%r is not callable", o))
                    }
                    if (o === k) {
                        throw new TypeError(p("%r is a FileType class object, instance of it" + " must be passed", o))
                    }
                    if ("_get_formatter" in this) {
                        try {
                            this._get_formatter()._format_args(i, undefined)
                        } catch (e) {
                            if (e instanceof TypeError && e.message !== "invalid nargs value") {
                                throw new TypeError("length of metavar tuple does not match nargs")
                            } else {
                                throw e
                            }
                        }
                    }
                    return this._add_action(i)
                }
                add_argument_group() {
                    let e = U(this, ...arguments);
                    this._action_groups.push(e);
                    return e
                }
                add_mutually_exclusive_group() {
                    let e = Z(this, ...arguments);
                    this._mutually_exclusive_groups.push(e);
                    return e
                }
                _add_action(e) {
                    this._check_conflict(e);
                    this._actions.push(e);
                    e.container = this;
                    for (let t of e.option_strings) {
                        this._option_string_actions[t] = e
                    }
                    for (let t of e.option_strings) {
                        if (this._negative_number_matcher.test(t)) {
                            if (!this._has_negative_number_optionals.length) {
                                this._has_negative_number_optionals.push(true)
                            }
                        }
                    }
                    return e
                }
                _remove_action(e) {
                    _array_remove(this._actions, e)
                }
                _add_container_actions(e) {
                    let t = {};
                    for (let e of this._action_groups) {
                        if (e.title in t) {
                            let t = "cannot merge actions - two groups are named %r";
                            throw new TypeError(p(t, e.title))
                        }
                        t[e.title] = e
                    }
                    let r = new Map;
                    for (let n of e._action_groups) {
                        if (!(n.title in t)) {
                            t[n.title] = this.add_argument_group({
                                title: n.title,
                                description: n.description,
                                conflict_handler: n.conflict_handler
                            })
                        }
                        for (let e of n._group_actions) {
                            r.set(e, t[n.title])
                        }
                    }
                    for (let t of e._mutually_exclusive_groups) {
                        let e = this.add_mutually_exclusive_group({
                            required: t.required
                        });
                        for (let n of t._group_actions) {
                            r.set(n, e)
                        }
                    }
                    for (let t of e._actions) {
                        r.get(t)._add_action(t)
                    }
                }
                _get_positional_kwargs() {
                    let [e, t] = _parse_opts(arguments, {
                        dest: g,
                        "**kwargs": g
                    });
                    if ("required" in t) {
                        let e = "'required' is an invalid argument for positionals";
                        throw new TypeError(e)
                    }
                    if (![i, o].includes(t.nargs)) {
                        t.required = true
                    }
                    if (t.nargs === o && !("default" in t)) {
                        t.required = true
                    }
                    return Object.assign(t, {
                        dest: e,
                        option_strings: []
                    })
                }
                _get_optional_kwargs() {
                    let [e, t] = _parse_opts(arguments, {
                        "*args": g,
                        "**kwargs": g
                    });
                    let r = [];
                    let n = [];
                    let i;
                    for (i of e) {
                        if (!this.prefix_chars.includes(i[0])) {
                            let e = {
                                option: i,
                                prefix_chars: this.prefix_chars
                            };
                            let t = "invalid option string %(option)r: " + "must start with a character %(prefix_chars)r";
                            throw new TypeError(p(t, e))
                        }
                        r.push(i);
                        if (i.length > 1 && this.prefix_chars.includes(i[1])) {
                            n.push(i)
                        }
                    }
                    let o = t.dest;
                    delete t.dest;
                    if (o === undefined) {
                        let e;
                        if (n.length) {
                            e = n[0]
                        } else {
                            e = r[0]
                        }
                        o = _string_lstrip(e, this.prefix_chars);
                        if (!o) {
                            let e = "dest= is required for options like %r";
                            throw new TypeError(p(e, i))
                        }
                        o = o.replace(/-/g, "_")
                    }
                    return Object.assign(t, {
                        dest: o,
                        option_strings: r
                    })
                }
                _pop_action_class(e, t = undefined) {
                    let r = getattr(e, "action", t);
                    delete e.action;
                    return this._registry_get("action", r, r)
                }
                _get_handler() {
                    let e = p("_handle_conflict_%s", this.conflict_handler);
                    if (typeof this[e] === "function") {
                        return this[e]
                    } else {
                        let e = "invalid conflict_resolution value: %r";
                        throw new TypeError(p(e, this.conflict_handler))
                    }
                }
                _check_conflict(e) {
                    let t = [];
                    for (let r of e.option_strings) {
                        if (hasattr(this._option_string_actions, r)) {
                            let e = this._option_string_actions[r];
                            t.push([r, e])
                        }
                    }
                    if (t.length) {
                        let r = this._get_handler();
                        r.call(this, e, t)
                    }
                }
                _handle_conflict_error(e, t) {
                    let r = t.length === 1 ? "conflicting option string: %s" : "conflicting option strings: %s";
                    let n = t.map((([e]) => e)).join(", ");
                    throw new N(e, p(r, n))
                }
                _handle_conflict_resolve(e, t) {
                    for (let [e, r] of t) {
                        _array_remove(r.option_strings, e);
                        delete this._option_string_actions[e];
                        if (!r.option_strings.length) {
                            r.container._remove_action(r)
                        }
                    }
                }
            }));
            const U = _callable(class _ArgumentGroup extends j {
                constructor() {
                    let [e, t, r, n] = _parse_opts(arguments, {
                        container: g,
                        title: undefined,
                        description: undefined,
                        "**kwargs": g
                    });
                    setdefault(n, "conflict_handler", e.conflict_handler);
                    setdefault(n, "prefix_chars", e.prefix_chars);
                    setdefault(n, "argument_default", e.argument_default);
                    super(Object.assign({
                        description: r
                    }, n));
                    this.title = t;
                    this._group_actions = [];
                    this._registries = e._registries;
                    this._actions = e._actions;
                    this._option_string_actions = e._option_string_actions;
                    this._defaults = e._defaults;
                    this._has_negative_number_optionals = e._has_negative_number_optionals;
                    this._mutually_exclusive_groups = e._mutually_exclusive_groups
                }
                _add_action(e) {
                    e = super._add_action(e);
                    this._group_actions.push(e);
                    return e
                }
                _remove_action(e) {
                    super._remove_action(e);
                    _array_remove(this._group_actions, e)
                }
            });
            const Z = _callable(class _MutuallyExclusiveGroup extends U {
                constructor() {
                    let [e, t] = _parse_opts(arguments, {
                        container: g,
                        required: false
                    });
                    super(e);
                    this.required = t;
                    this._container = e
                }
                _add_action(e) {
                    if (e.required) {
                        let e = "mutually exclusive arguments must be optional";
                        throw new TypeError(e)
                    }
                    e = this._container._add_action(e);
                    this._group_actions.push(e);
                    return e
                }
                _remove_action(e) {
                    this._container._remove_action(e);
                    _array_remove(this._group_actions, e)
                }
            });
            const q = _camelcase_alias(_callable(class ArgumentParser extends(_AttributeHolder(j)) {
                constructor() {
                    let [e, t, r, i, o, s, a, l, _, u, d, h, g, m, S] = _parse_opts(arguments, {
                        prog: undefined,
                        usage: undefined,
                        description: undefined,
                        epilog: undefined,
                        parents: [],
                        formatter_class: y,
                        prefix_chars: "-",
                        fromfile_prefix_chars: undefined,
                        argument_default: undefined,
                        conflict_handler: "error",
                        add_help: true,
                        allow_abbrev: true,
                        exit_on_error: true,
                        debug: undefined,
                        version: undefined
                    });
                    if (m !== undefined) {
                        deprecate("debug", 'The "debug" argument to ArgumentParser is deprecated. Please ' + "override ArgumentParser.exit function instead.")
                    }
                    if (S !== undefined) {
                        deprecate("version", 'The "version" argument to ArgumentParser is deprecated. Please use ' + "add_argument(..., { action: 'version', version: 'N', ... }) instead.")
                    }
                    super({
                        description: r,
                        prefix_chars: a,
                        argument_default: _,
                        conflict_handler: u
                    });
                    if (e === undefined) {
                        e = f.basename(get_argv()[0] || "")
                    }
                    this.prog = e;
                    this.usage = t;
                    this.epilog = i;
                    this.formatter_class = s;
                    this.fromfile_prefix_chars = l;
                    this.add_help = d;
                    this.allow_abbrev = h;
                    this.exit_on_error = g;
                    this.debug = m;
                    this._positionals = this.add_argument_group("positional arguments");
                    this._optionals = this.add_argument_group("optional arguments");
                    this._subparsers = undefined;

                    function identity(e) {
                        return e
                    }
                    this.register("type", undefined, identity);
                    this.register("type", null, identity);
                    this.register("type", "auto", identity);
                    this.register("type", "int", (function(e) {
                        let t = Number(e);
                        if (!Number.isInteger(t)) {
                            throw new TypeError(p("could not convert string to int: %r", e))
                        }
                        return t
                    }));
                    this.register("type", "float", (function(e) {
                        let t = Number(e);
                        if (isNaN(t)) {
                            throw new TypeError(p("could not convert string to float: %r", e))
                        }
                        return t
                    }));
                    this.register("type", "str", String);
                    this.register("type", "string", c.deprecate(String, 'use {type:"str"} or {type:String} instead of {type:"string"}'));
                    let T = a.includes("-") ? "-" : a[0];
                    if (this.add_help) {
                        this.add_argument(T + "h", T.repeat(2) + "help", {
                            action: "help",
                            default: n,
                            help: "show this help message and exit"
                        })
                    }
                    if (S) {
                        this.add_argument(T + "v", T.repeat(2) + "version", {
                            action: "version",
                            default: n,
                            version: this.version,
                            help: "show program's version number and exit"
                        })
                    }
                    for (let e of o) {
                        this._add_container_actions(e);
                        Object.assign(this._defaults, e._defaults)
                    }
                }
                _get_kwargs() {
                    let e = ["prog", "usage", "description", "formatter_class", "conflict_handler", "add_help"];
                    return e.map((e => [e, getattr(this, e)]))
                }
                add_subparsers() {
                    let [e] = _parse_opts(arguments, {
                        "**kwargs": g
                    });
                    if (this._subparsers !== undefined) {
                        this.error("cannot have multiple subparser arguments")
                    }
                    setdefault(e, "parser_class", this.constructor);
                    if ("title" in e || "description" in e) {
                        let t = getattr(e, "title", "subcommands");
                        let r = getattr(e, "description", undefined);
                        delete e.title;
                        delete e.description;
                        this._subparsers = this.add_argument_group(t, r)
                    } else {
                        this._subparsers = this._positionals
                    }
                    if (e.prog === undefined) {
                        let t = this._get_formatter();
                        let r = this._get_positional_actions();
                        let n = this._mutually_exclusive_groups;
                        t.add_usage(this.usage, r, n, "");
                        e.prog = t.format_help().trim()
                    }
                    let t = this._pop_action_class(e, "parsers");
                    let r = new t(Object.assign({
                        option_strings: []
                    }, e));
                    this._subparsers._add_action(r);
                    return r
                }
                _add_action(e) {
                    if (e.option_strings.length) {
                        this._optionals._add_action(e)
                    } else {
                        this._positionals._add_action(e)
                    }
                    return e
                }
                _get_optional_actions() {
                    return this._actions.filter((e => e.option_strings.length))
                }
                _get_positional_actions() {
                    return this._actions.filter((e => !e.option_strings.length))
                }
                parse_args(e = undefined, t = undefined) {
                    let r;
                    [e, r] = this.parse_known_args(e, t);
                    if (r && r.length > 0) {
                        let e = "unrecognized arguments: %s";
                        this.error(p(e, r.join(" ")))
                    }
                    return e
                }
                parse_known_args(e = undefined, t = undefined) {
                    if (e === undefined) {
                        e = get_argv().slice(1)
                    }
                    if (t === undefined) {
                        t = new $
                    }
                    for (let e of this._actions) {
                        if (e.dest !== n) {
                            if (!hasattr(t, e.dest)) {
                                if (e.default !== n) {
                                    setattr(t, e.dest, e.default)
                                }
                            }
                        }
                    }
                    for (let e of Object.keys(this._defaults)) {
                        if (!hasattr(t, e)) {
                            setattr(t, e, this._defaults[e])
                        }
                    }
                    if (this.exit_on_error) {
                        try {
                            [t, e] = this._parse_known_args(e, t)
                        } catch (e) {
                            if (e instanceof N) {
                                this.error(e.message)
                            } else {
                                throw e
                            }
                        }
                    } else {
                        [t, e] = this._parse_known_args(e, t)
                    }
                    if (hasattr(t, _)) {
                        e = e.concat(getattr(t, _));
                        delattr(t, _)
                    }
                    return [t, e]
                }
                _parse_known_args(e, t) {
                    if (this.fromfile_prefix_chars !== undefined) {
                        e = this._read_args_from_files(e)
                    }
                    let r = new Map;
                    for (let e of this._mutually_exclusive_groups) {
                        let t = e._group_actions;
                        for (let [n, i] of Object.entries(e._group_actions)) {
                            let e = r.get(i) || [];
                            e = e.concat(t.slice(0, +n));
                            e = e.concat(t.slice(+n + 1));
                            r.set(i, e)
                        }
                    }
                    let i = {};
                    let o = [];
                    let s = Object.entries(e)[Symbol.iterator]();
                    for (let [e, t] of s) {
                        if (t === "--") {
                            o.push("-");
                            for ([e, t] of s) {
                                o.push("A")
                            }
                        } else {
                            let r = this._parse_optional(t);
                            let n;
                            if (r === undefined) {
                                n = "A"
                            } else {
                                i[e] = r;
                                n = "O"
                            }
                            o.push(n)
                        }
                    }
                    let a = o.join("");
                    let l = new Set;
                    let _ = new Set;
                    let c;
                    let take_action = (e, i, o = undefined) => {
                        l.add(e);
                        let s = this._get_values(e, i);
                        if (s !== e.default) {
                            _.add(e);
                            for (let t of r.get(e) || []) {
                                if (_.has(t)) {
                                    let r = "not allowed with argument %s";
                                    let n = _get_action_name(t);
                                    throw new N(e, p(r, n))
                                }
                            }
                        }
                        if (s !== n) {
                            e(this, t, s, o)
                        }
                    };
                    let consume_optional = t => {
                        let r = i[t];
                        let [n, o, s] = r;
                        let l = [];
                        let _;
                        for (;;) {
                            if (n === undefined) {
                                c.push(e[t]);
                                return t + 1
                            }
                            if (s !== undefined) {
                                let e = this._match_argument(n, "A");
                                let r = this.prefix_chars;
                                if (e === 0 && !r.includes(o[1])) {
                                    l.push([n, [], o]);
                                    let e = o[0];
                                    o = e + s[0];
                                    let t = s.slice(1) || undefined;
                                    let r = this._option_string_actions;
                                    if (hasattr(r, o)) {
                                        n = r[o];
                                        s = t
                                    } else {
                                        let e = "ignored explicit argument %r";
                                        throw new N(n, p(e, s))
                                    }
                                } else if (e === 1) {
                                    _ = t + 1;
                                    let e = [s];
                                    l.push([n, e, o]);
                                    break
                                } else {
                                    let e = "ignored explicit argument %r";
                                    throw new N(n, p(e, s))
                                }
                            } else {
                                let r = t + 1;
                                let i = a.slice(r);
                                let s = this._match_argument(n, i);
                                _ = r + s;
                                let u = e.slice(r, _);
                                l.push([n, u, o]);
                                break
                            }
                        }
                        u(l.length);
                        for (let [e, t, r] of l) {
                            take_action(e, t, r)
                        }
                        return _
                    };
                    let d = this._get_positional_actions();
                    let consume_positionals = t => {
                        let r = a.slice(t);
                        let n = this._match_arguments_partial(d, r);
                        for (let r = 0; r < d.length && r < n.length; r++) {
                            let i = d[r];
                            let o = n[r];
                            let s = e.slice(t, t + o);
                            t += o;
                            take_action(i, s)
                        }
                        d = d.slice(n.length);
                        return t
                    };
                    c = [];
                    let f = 0;
                    let h = Math.max(-1, ...Object.keys(i).map(Number));
                    while (f <= h) {
                        let t = Math.min(...Object.keys(i).map(Number).filter((e => e >= f)));
                        if (f !== t) {
                            let e = consume_positionals(f);
                            if (e > f) {
                                f = e;
                                continue
                            } else {
                                f = e
                            }
                        }
                        if (!(f in i)) {
                            let r = e.slice(f, t);
                            c = c.concat(r);
                            f = t
                        }
                        f = consume_optional(f)
                    }
                    let g = consume_positionals(f);
                    c = c.concat(e.slice(g));
                    let m = [];
                    for (let e of this._actions) {
                        if (!l.has(e)) {
                            if (e.required) {
                                m.push(_get_action_name(e))
                            } else {
                                if (e.default !== undefined && typeof e.default === "string" && hasattr(t, e.dest) && e.default === getattr(t, e.dest)) {
                                    setattr(t, e.dest, this._get_value(e, e.default))
                                }
                            }
                        }
                    }
                    if (m.length) {
                        this.error(p("the following arguments are required: %s", m.join(", ")))
                    }
                    for (let e of this._mutually_exclusive_groups) {
                        if (e.required) {
                            let t = true;
                            for (let r of e._group_actions) {
                                if (_.has(r)) {
                                    t = false;
                                    break
                                }
                            }
                            if (t) {
                                let t = e._group_actions.filter((e => e.help !== n)).map((e => _get_action_name(e)));
                                let r = "one of the arguments %s is required";
                                this.error(p(r, t.join(" ")))
                            }
                        }
                    }
                    return [t, c]
                }
                _read_args_from_files(e) {
                    let t = [];
                    for (let r of e) {
                        if (!r || !this.fromfile_prefix_chars.includes(r[0])) {
                            t.push(r)
                        } else {
                            try {
                                let e = d.readFileSync(r.slice(1), "utf8");
                                let n = [];
                                for (let t of splitlines(e)) {
                                    for (let e of this.convert_arg_line_to_args(t)) {
                                        n.push(e)
                                    }
                                }
                                n = this._read_args_from_files(n);
                                t = t.concat(n)
                            } catch (e) {
                                this.error(e.message)
                            }
                        }
                    }
                    return t
                }
                convert_arg_line_to_args(e) {
                    return [e]
                }
                _match_argument(e, t) {
                    let r = this._get_nargs_pattern(e);
                    let n = t.match(new RegExp("^" + r));
                    if (n === null) {
                        let t = {
                            undefined: "expected one argument",
                            [i]: "expected at most one argument",
                            [s]: "expected at least one argument"
                        };
                        let r = t[e.nargs];
                        if (r === undefined) {
                            r = p(e.nargs === 1 ? "expected %s argument" : "expected %s arguments", e.nargs)
                        }
                        throw new N(e, r)
                    }
                    return n[1].length
                }
                _match_arguments_partial(e, t) {
                    let r = [];
                    for (let n of range(e.length, 0, -1)) {
                        let i = e.slice(0, n);
                        let o = i.map((e => this._get_nargs_pattern(e))).join("");
                        let s = t.match(new RegExp("^" + o));
                        if (s !== null) {
                            r = r.concat(s.slice(1).map((e => e.length)));
                            break
                        }
                    }
                    return r
                }
                _parse_optional(e) {
                    if (!e) {
                        return undefined
                    }
                    if (!this.prefix_chars.includes(e[0])) {
                        return undefined
                    }
                    if (e in this._option_string_actions) {
                        let t = this._option_string_actions[e];
                        return [t, e, undefined]
                    }
                    if (e.length === 1) {
                        return undefined
                    }
                    if (e.includes("=")) {
                        let [t, r] = _string_split(e, "=", 1);
                        if (t in this._option_string_actions) {
                            let e = this._option_string_actions[t];
                            return [e, t, r]
                        }
                    }
                    let t = this._get_option_tuples(e);
                    if (t.length > 1) {
                        let r = t.map((([, e]) => e)).join(", ");
                        let n = {
                            option: e,
                            matches: r
                        };
                        let i = "ambiguous option: %(option)s could match %(matches)s";
                        this.error(p(i, n))
                    } else if (t.length === 1) {
                        let [e] = t;
                        return e
                    }
                    if (this._negative_number_matcher.test(e)) {
                        if (!this._has_negative_number_optionals.length) {
                            return undefined
                        }
                    }
                    if (e.includes(" ")) {
                        return undefined
                    }
                    return [undefined, e, undefined]
                }
                _get_option_tuples(e) {
                    let t = [];
                    let r = this.prefix_chars;
                    if (r.includes(e[0]) && r.includes(e[1])) {
                        if (this.allow_abbrev) {
                            let r, n;
                            if (e.includes("=")) {
                                [r, n] = _string_split(e, "=", 1)
                            } else {
                                r = e;
                                n = undefined
                            }
                            for (let e of Object.keys(this._option_string_actions)) {
                                if (e.startsWith(r)) {
                                    let r = this._option_string_actions[e];
                                    let i = [r, e, n];
                                    t.push(i)
                                }
                            }
                        }
                    } else if (r.includes(e[0]) && !r.includes(e[1])) {
                        let r = e;
                        let n = undefined;
                        let i = e.slice(0, 2);
                        let o = e.slice(2);
                        for (let e of Object.keys(this._option_string_actions)) {
                            if (e === i) {
                                let r = this._option_string_actions[e];
                                let n = [r, e, o];
                                t.push(n)
                            } else if (e.startsWith(r)) {
                                let r = this._option_string_actions[e];
                                let i = [r, e, n];
                                t.push(i)
                            }
                        }
                    } else {
                        this.error(p("unexpected option string: %s", e))
                    }
                    return t
                }
                _get_nargs_pattern(e) {
                    let t = e.nargs;
                    let r;
                    if (t === undefined) {
                        r = "(-*A-*)"
                    } else if (t === i) {
                        r = "(-*A?-*)"
                    } else if (t === o) {
                        r = "(-*[A-]*)"
                    } else if (t === s) {
                        r = "(-*A[A-]*)"
                    } else if (t === l) {
                        r = "([-AO]*)"
                    } else if (t === a) {
                        r = "(-*A[-AO]*)"
                    } else if (t === n) {
                        r = "(-*-*)"
                    } else {
                        r = p("(-*%s-*)", "A".repeat(t).split("").join("-*"))
                    }
                    if (e.option_strings.length) {
                        r = r.replace(/-\*/g, "");
                        r = r.replace(/-/g, "")
                    }
                    return r
                }
                parse_intermixed_args(e = undefined, t = undefined) {
                    let r;
                    [e, r] = this.parse_known_intermixed_args(e, t);
                    if (r.length) {
                        let e = "unrecognized arguments: %s";
                        this.error(p(e, r.join(" ")))
                    }
                    return e
                }
                parse_known_intermixed_args(e = undefined, t = undefined) {
                    let r;
                    let i = this._get_positional_actions();
                    let o = i.filter((e => [a, l].includes(e.nargs)));
                    if (o.length) {
                        throw new TypeError(p("parse_intermixed_args: positional arg" + " with nargs=%s", o[0].nargs))
                    }
                    for (let e of this._mutually_exclusive_groups) {
                        for (let t of e._group_actions) {
                            if (i.includes(t)) {
                                throw new TypeError("parse_intermixed_args: positional in" + " mutuallyExclusiveGroup")
                            }
                        }
                    }
                    let s;
                    try {
                        s = this.usage;
                        let o;
                        try {
                            if (this.usage === undefined) {
                                this.usage = this.format_usage().slice(7)
                            }
                            for (let e of i) {
                                e.save_nargs = e.nargs;
                                e.nargs = n;
                                e.save_default = e.default;
                                e.default = n
                            } [t, o] = this.parse_known_args(e, t);
                            for (let e of i) {
                                let r = getattr(t, e.dest);
                                if (Array.isArray(r) && r.length === 0) {
                                    console.warn(p("Do not expect %s in %s", e.dest, t));
                                    delattr(t, e.dest)
                                }
                            }
                        } finally {
                            for (let e of i) {
                                e.nargs = e.save_nargs;
                                e.default = e.save_default
                            }
                        }
                        let a = this._get_optional_actions();
                        try {
                            for (let e of a) {
                                e.save_required = e.required;
                                e.required = false
                            }
                            for (let e of this._mutually_exclusive_groups) {
                                e.save_required = e.required;
                                e.required = false
                            } [t, r] = this.parse_known_args(o, t)
                        } finally {
                            for (let e of a) {
                                e.required = e.save_required
                            }
                            for (let e of this._mutually_exclusive_groups) {
                                e.required = e.save_required
                            }
                        }
                    } finally {
                        this.usage = s
                    }
                    return [t, r]
                }
                _get_values(e, t) {
                    if (![a, l].includes(e.nargs)) {
                        try {
                            _array_remove(t, "--")
                        } catch (e) {}
                    }
                    let r;
                    if (!t.length && e.nargs === i) {
                        if (e.option_strings.length) {
                            r = e.const
                        } else {
                            r = e.default
                        }
                        if (typeof r === "string") {
                            r = this._get_value(e, r);
                            this._check_value(e, r)
                        }
                    } else if (!t.length && e.nargs === o && !e.option_strings.length) {
                        if (e.default !== undefined) {
                            r = e.default
                        } else {
                            r = t
                        }
                        this._check_value(e, r)
                    } else if (t.length === 1 && [undefined, i].includes(e.nargs)) {
                        let n = t[0];
                        r = this._get_value(e, n);
                        this._check_value(e, r)
                    } else if (e.nargs === l) {
                        r = t.map((t => this._get_value(e, t)))
                    } else if (e.nargs === a) {
                        r = t.map((t => this._get_value(e, t)));
                        this._check_value(e, r[0])
                    } else if (e.nargs === n) {
                        r = n
                    } else {
                        r = t.map((t => this._get_value(e, t)));
                        for (let t of r) {
                            this._check_value(e, t)
                        }
                    }
                    return r
                }
                _get_value(e, t) {
                    let r = this._registry_get("type", e.type, e.type);
                    if (typeof r !== "function") {
                        let t = "%r is not callable";
                        throw new N(e, p(t, r))
                    }
                    let n;
                    try {
                        try {
                            n = r(t)
                        } catch (e) {
                            if (e instanceof TypeError && /Class constructor .* cannot be invoked without 'new'/.test(e.message)) {
                                n = new r(t)
                            } else {
                                throw e
                            }
                        }
                    } catch (r) {
                        if (r instanceof A) {
                            let t = r.message;
                            throw new N(e, t)
                        } else if (r instanceof TypeError) {
                            let r = getattr(e.type, "name", h(e.type));
                            let n = {
                                type: r,
                                value: t
                            };
                            let i = "invalid %(type)s value: %(value)r";
                            throw new N(e, p(i, n))
                        } else {
                            throw r
                        }
                    }
                    return n
                }
                _check_value(e, t) {
                    if (e.choices !== undefined && !_choices_to_array(e.choices).includes(t)) {
                        let r = {
                            value: t,
                            choices: _choices_to_array(e.choices).map(h).join(", ")
                        };
                        let n = "invalid choice: %(value)r (choose from %(choices)s)";
                        throw new N(e, p(n, r))
                    }
                }
                format_usage() {
                    let e = this._get_formatter();
                    e.add_usage(this.usage, this._actions, this._mutually_exclusive_groups);
                    return e.format_help()
                }
                format_help() {
                    let e = this._get_formatter();
                    e.add_usage(this.usage, this._actions, this._mutually_exclusive_groups);
                    e.add_text(this.description);
                    for (let t of this._action_groups) {
                        e.start_section(t.title);
                        e.add_text(t.description);
                        e.add_arguments(t._group_actions);
                        e.end_section()
                    }
                    e.add_text(this.epilog);
                    return e.format_help()
                }
                _get_formatter() {
                    return new this.formatter_class({
                        prog: this.prog
                    })
                }
                print_usage(e = undefined) {
                    if (e === undefined) e = process.stdout;
                    this._print_message(this.format_usage(), e)
                }
                print_help(e = undefined) {
                    if (e === undefined) e = process.stdout;
                    this._print_message(this.format_help(), e)
                }
                _print_message(e, t = undefined) {
                    if (e) {
                        if (t === undefined) t = process.stderr;
                        t.write(e)
                    }
                }
                exit(e = 0, t = undefined) {
                    if (t) {
                        this._print_message(t, process.stderr)
                    }
                    process.exit(e)
                }
                error(e) {
                    if (this.debug === true) throw new Error(e);
                    this.print_usage(process.stderr);
                    let t = {
                        prog: this.prog,
                        message: e
                    };
                    this.exit(2, p("%(prog)s: error: %(message)s\n", t))
                }
            }));
            e.exports = {
                ArgumentParser: q,
                ArgumentError: N,
                ArgumentTypeError: A,
                BooleanOptionalAction: v,
                FileType: k,
                HelpFormatter: y,
                ArgumentDefaultsHelpFormatter: x,
                RawDescriptionHelpFormatter: S,
                RawTextHelpFormatter: T,
                MetavarTypeHelpFormatter: C,
                Namespace: $,
                Action: E,
                ONE_OR_MORE: s,
                OPTIONAL: i,
                PARSER: a,
                REMAINDER: l,
                SUPPRESS: n,
                ZERO_OR_MORE: o
            };
            Object.defineProperty(e.exports, "Const", {
                get() {
                    let e = {};
                    Object.entries({
                        ONE_OR_MORE: s,
                        OPTIONAL: i,
                        PARSER: a,
                        REMAINDER: l,
                        SUPPRESS: n,
                        ZERO_OR_MORE: o
                    }).forEach((([t, r]) => {
                        Object.defineProperty(e, t, {
                            get() {
                                deprecate(t, p("use argparse.%s instead of argparse.Const.%s", t, t));
                                return r
                            }
                        })
                    }));
                    Object.entries({
                        _UNRECOGNIZED_ARGS_ATTR: _
                    }).forEach((([t, r]) => {
                        Object.defineProperty(e, t, {
                            get() {
                                deprecate(t, p("argparse.Const.%s is an internal symbol and will no longer be available", t));
                                return r
                            }
                        })
                    }));
                    return e
                },
                enumerable: false
            })
        },
        9067: (e, t, r) => {
            const {
                inspect: n
            } = r(3837);
            e.exports = function sub(e, ...t) {
                let r = /%(?:(%)|(-)?(\*)?(?:\((\w+)\))?([A-Za-z]))/g;
                let i = e.replace(r, (function(e, r, i, o, s, a) {
                    if (r) return "%";
                    let l = 0;
                    if (o) {
                        if (t.length === 0) throw new TypeError("not enough arguments for format string");
                        l = t.shift();
                        if (!Number.isInteger(l)) throw new TypeError("* wants int")
                    }
                    let _;
                    if (s !== undefined) {
                        let e = t[0];
                        if (typeof e !== "object" || e === null) throw new TypeError("format requires a mapping");
                        if (!(s in e)) throw new TypeError(`no such key: '${s}'`);
                        _ = e[s]
                    } else {
                        if (t.length === 0) throw new TypeError("not enough arguments for format string");
                        _ = t.shift()
                    }
                    switch (a) {
                        case "s":
                            _ = String(_);
                            break;
                        case "r":
                            _ = n(_);
                            break;
                        case "d":
                        case "i":
                            if (typeof _ !== "number") {
                                throw new TypeError(`%${a} format: a number is required, not ${typeof _}`)
                            }
                            _ = String(_.toFixed(0));
                            break;
                        default:
                            throw new TypeError(`unsupported format character '${a}'`)
                    }
                    if (l > 0) {
                        return i ? _.padEnd(l) : _.padStart(l)
                    } else {
                        return _
                    }
                }));
                if (t.length) {
                    if (t.length === 1 && typeof t[0] === "object" && t[0] !== null) {} else {
                        throw new TypeError("not all arguments converted during string formatting")
                    }
                }
                return i
            }
        },
        4604: e => {
            const t = /([\t\n\x0b\x0c\r ]+)/;
            class TextWrapper {
                constructor(e = {}) {
                    let {
                        width: t = 70,
                        initial_indent: r = "",
                        subsequent_indent: n = "",
                        expand_tabs: i = true,
                        replace_whitespace: o = true,
                        fix_sentence_endings: s = false,
                        break_long_words: a = true,
                        drop_whitespace: l = true,
                        break_on_hyphens: _ = true,
                        tabsize: u = 8,
                        max_lines: c = undefined,
                        placeholder: d = " [...]"
                    } = e;
                    this.width = t;
                    this.initial_indent = r;
                    this.subsequent_indent = n;
                    this.expand_tabs = i;
                    this.replace_whitespace = o;
                    this.fix_sentence_endings = s;
                    this.break_long_words = a;
                    this.drop_whitespace = l;
                    this.break_on_hyphens = _;
                    this.tabsize = u;
                    this.max_lines = c;
                    this.placeholder = d
                }
                _munge_whitespace(e) {
                    if (this.expand_tabs) {
                        e = e.replace(/\t/g, " ".repeat(this.tabsize))
                    }
                    if (this.replace_whitespace) {
                        e = e.replace(/[\t\n\x0b\x0c\r]/g, " ")
                    }
                    return e
                }
                _split(e) {
                    let r = e.split(t);
                    r = r.filter(Boolean);
                    return r
                }
                _handle_long_word(e, t, r, n) {
                    let i;
                    if (n < 1) {
                        i = 1
                    } else {
                        i = n - r
                    }
                    if (this.break_long_words) {
                        t.push(e[e.length - 1].slice(0, i));
                        e[e.length - 1] = e[e.length - 1].slice(i)
                    } else if (!t) {
                        t.push(...e.pop())
                    }
                }
                _wrap_chunks(e) {
                    let t = [];
                    let r;
                    if (this.width <= 0) {
                        throw Error(`invalid width ${this.width} (must be > 0)`)
                    }
                    if (this.max_lines !== undefined) {
                        if (this.max_lines > 1) {
                            r = this.subsequent_indent
                        } else {
                            r = this.initial_indent
                        }
                        if (r.length + this.placeholder.trimStart().length > this.width) {
                            throw Error("placeholder too large for max width")
                        }
                    }
                    e = e.reverse();
                    while (e.length > 0) {
                        let r = [];
                        let n = 0;
                        let i;
                        if (t) {
                            i = this.subsequent_indent
                        } else {
                            i = this.initial_indent
                        }
                        let o = this.width - i.length;
                        if (this.drop_whitespace && e[e.length - 1].trim() === "" && t.length > 0) {
                            e.pop()
                        }
                        while (e.length > 0) {
                            let t = e[e.length - 1].length;
                            if (n + t <= o) {
                                r.push(e.pop());
                                n += t
                            } else {
                                break
                            }
                        }
                        if (e.length && e[e.length - 1].length > o) {
                            this._handle_long_word(e, r, n, o);
                            n = r.map((e => e.length)).reduce(((e, t) => e + t), 0)
                        }
                        if (this.drop_whitespace && r.length > 0 && r[r.length - 1].trim() === "") {
                            n -= r[r.length - 1].length;
                            r.pop()
                        }
                        if (r) {
                            if (this.max_lines === undefined || t.length + 1 < this.max_lines || (e.length === 0 || this.drop_whitespace && e.length === 1 && !e[0].trim()) && n <= o) {
                                t.push(i + r.join(""))
                            } else {
                                let e = false;
                                while (r) {
                                    if (r[r.length - 1].trim() && n + this.placeholder.length <= o) {
                                        r.push(this.placeholder);
                                        t.push(i + r.join(""));
                                        e = true;
                                        break
                                    }
                                    n -= r[-1].length;
                                    r.pop()
                                }
                                if (!e) {
                                    if (t) {
                                        let e = t[t.length - 1].trimEnd();
                                        if (e.length + this.placeholder.length <= this.width) {
                                            t[t.length - 1] = e + this.placeholder;
                                            break
                                        }
                                    }
                                    t.push(i + this.placeholder.lstrip())
                                }
                                break
                            }
                        }
                    }
                    return t
                }
                _split_chunks(e) {
                    e = this._munge_whitespace(e);
                    return this._split(e)
                }
                wrap(e) {
                    let t = this._split_chunks(e);
                    return this._wrap_chunks(t)
                }
                fill(e) {
                    return this.wrap(e).join("\n")
                }
            }

            function wrap(e, t = {}) {
                let {
                    width: r = 70,
                    ...n
                } = t;
                let i = new TextWrapper(Object.assign({
                    width: r
                }, n));
                return i.wrap(e)
            }

            function fill(e, t = {}) {
                let {
                    width: r = 70,
                    ...n
                } = t;
                let i = new TextWrapper(Object.assign({
                    width: r
                }, n));
                return i.fill(e)
            }
            let r = /^[ \t]+$/gm;
            let n = /(^[ \t]*)(?:[^ \t\n])/gm;

            function dedent(e) {
                let t = undefined;
                e = e.replace(r, "");
                let i = e.match(n) || [];
                for (let e of i) {
                    e = e.slice(0, -1);
                    if (t === undefined) {
                        t = e
                    } else if (e.startsWith(t)) {} else if (t.startsWith(e)) {
                        t = e
                    } else {
                        for (let r = 0; r < t.length && r < e.length; r++) {
                            if (t[r] !== e[r]) {
                                t = t.slice(0, r);
                                break
                            }
                        }
                    }
                }
                if (t) {
                    e = e.replace(new RegExp("^" + t, "mg"), "")
                }
                return e
            }
            e.exports = {
                wrap: wrap,
                fill: fill,
                dedent: dedent
            }
        },
        9491: e => {
            e.exports = require("assert")
        },
        7147: e => {
            e.exports = require("fs")
        },
        1017: e => {
            e.exports = require("path")
        },
        3837: e => {
            e.exports = require("util")
        },
        8203: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.codegen_python = codegen_python;
            var n = r(5466);
            var i = r(9937);
            var o = r(5359);
            var s = r(9386);
            var a = r(4222);
            var l = r(2078);
            var _ = r(9054);

            function codegen_python(e, t) {
                let r = (0, n.empty)();
                let u = 0;
                let c = 0;
                let d = 0;
                const new_rnd_name = () => {
                    d = d + 1 | 0;
                    const e = d | 0;
                    return (0, i.toText)((0, i.printf)("_sedlex_rnd_%d"))(e)
                };
                let p = (0, n.empty)();
                let f = (0, o.empty)();
                let h = (0, o.empty)();
                const push_toplevel = e => {
                    f = (0, o.ofArrayWithTail)([e, s.empty], f)
                };
                const push_later_toplevel = e => {
                    h = (0, o.ofArrayWithTail)([e, s.empty], h)
                };
                const st_func_name = e => (0, i.toText)((0, i.printf)("_sedlex_st_%d"))(e);
                const _cg_decision_func = e => {
                    switch (e.tag) {
                        case 2: {
                            return (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("return"), (0, s.word)((0, a.int32ToString)(e.fields[0])))
                        }
                        case 1: {
                            let t;
                            const r = e.fields[1];
                            const _ = (0, n.tryFind)(r, p);
                            if (_ == null) {
                                let e;
                                const _ = (0, o.ofSeq)((0, l.map)((e => (0, s.word)((0, a.int32ToString)(e))), r));
                                e = (0, s.seplist)((0, s.word)(", "), _);
                                let c;
                                u = u + 1 | 0;
                                const d = u | 0;
                                c = (0, i.toText)((0, i.printf)("_sedlex_DT_table_%d"))(d);
                                push_later_toplevel((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)(c), (0, s.word)("=")), (0, s.bracket)(e)));
                                p = (0, n.add)(r, c, p);
                                t = c
                            } else {
                                t = _
                            }
                            return (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("return"), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)(t), (0, s.word)("[")), (0, s.word)("c"))), (0, s.word)("-")), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.pretty)(e.fields[0]), (0, s.word)("]"))), (0, s.word)("-")), (0, s.pretty)(1))
                        }
                        default: {
                            const t = _cg_decision_func(e.fields[1]);
                            const r = _cg_decision_func(e.fields[2]);
                            return (0, s.vsep)((0, o.ofArray)([(0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("if"), (0, s.word)("c")), (0, s.word)("<=")), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)((0, a.int32ToString)(e.fields[0])), (0, s.word)(":"))), (0, s.Doc_op_RightShift_2AAA0F3C)(t, 4), (0, s.word)("else:"), (0, s.Doc_op_RightShift_2AAA0F3C)(r, 4)]))
                        }
                    }
                };
                const cg_decision_func = e => {
                    const t = (0, n.tryFind)(e, r);
                    if (t == null) {
                        let t;
                        c = c + 1 | 0;
                        const a = c | 0;
                        t = (0, i.toText)((0, i.printf)("_sedlex_decide_%d"))(a);
                        push_toplevel((0, s.vsep)((0, o.ofArray)([(0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("def"), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)(t), (0, s.parens)((0, s.word)("c: int"))), (0, s.word)(":"))), (0, s.Doc_op_RightShift_2AAA0F3C)(_cg_decision_func(e), 4)])));
                        r = (0, n.add)(e, t, r);
                        return t
                    } else {
                        return t
                    }
                };
                const _cg_state_func = e => {
                    let t;
                    switch (e.tag) {
                        case 3: {
                            return (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("result"), (0, s.word)("=")), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)(st_func_name(e.fields[0])), (0, s.parens)((0, s.word)("lexerbuf"))))
                        }
                        case 4: {
                            return (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("result"), (0, s.word)("=")), (0, s.pretty)(e.fields[0]))
                        }
                        case 2: {
                            return (0, s.vsep)((0, o.ofArray)([(0, s.word)((0, i.toText)((0, i.printf)("mark(lexerbuf, %d)"))(e.fields[0])), _cg_state_func(e.fields[1])]))
                        }
                        case 0: {
                            const r = e.fields[1];
                            let n = (0, o.empty)();
                            for (let e = 0; e <= r.length - 1; e++) {
                                const t = _cg_state_func(r[e]);
                                const i = new_rnd_name();
                                push_toplevel((0, s.vsep)((0, o.ofArray)([(0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("def"), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)(i), (0, s.parens)((0, s.word)("lexerbuf: lexbuf"))), (0, s.word)(":"))), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.ofArray)([(0, s.word)("result = -1"), t, (0, s.word)("return result")])), 4)])));
                                n = (0, o.cons)(i, n)
                            }
                            const a = (0, o.reverse)(n);
                            const l = new_rnd_name();
                            push_later_toplevel((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)(l), (0, s.word)("=")), (0, s.bracket)((t = (0, o.map)(s.word, a), (0, s.seplist)((0, s.word)(", "), t)))));
                            const _ = _cg_state_func(e.fields[2]);
                            const u = (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)(cg_decision_func(e.fields[0])), (0, s.parens)((0, s.word)("public_next_int(lexerbuf)")));
                            return (0, s.vsep)((0, o.ofArray)([(0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("state_id"), (0, s.word)("=")), u), (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("if"), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)((0, i.toText)((0, i.printf)("state_id >= 0"))), (0, s.word)(":"))), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.singleton)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("result"), (0, s.word)("=")), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)((0, i.toText)((0, i.printf)("%s[state_id]"))(l)), (0, s.parens)((0, s.word)("lexerbuf")))))), 4), (0, s.word)("else:"), (0, s.Doc_op_RightShift_2AAA0F3C)(_, 4)]))
                        }
                        default: {
                            return (0, s.word)("result = backtrack(lexerbuf)")
                        }
                    }
                };
                const g = (0, a.getEnumerator)(t.states);
                try {
                    while (g["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = g["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        push_toplevel((0, s.vsep)((0, o.ofArray)([(0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("def"), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)(st_func_name(e[0])), (0, s.parens)((0, s.word)("lexerbuf: lexbuf"))), (0, s.word)(":"))), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.ofArray)([(0, s.word)("result = -1"), _cg_state_func(e[1]), (0, s.word)("return result")])), 4)])))
                    }
                } finally {
                    (0, a.disposeSafe)(g)
                }
                const m = (0, a.getEnumerator)(t.referenced_decision_trees);
                try {
                    while (m["System.Collections.IEnumerator.MoveNext"]()) {
                        cg_decision_func(m["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    }
                } finally {
                    (0, a.disposeSafe)(m)
                }
                let y;
                const S = t.lex_code;
                const T = '"' + (0, i.replace)(S[1], '"', '\\"') + '"';
                const x = st_func_name(0);
                const C = (0, o.ofArray)((0, _.map)((e => e.tag === 1 ? (0, s.pretty)(e.fields[0]) : (0, s.word)("None")), S[0]));
                const N = (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("["), (0, s.seplist)((0, s.word)(", "), C)), (0, s.word)("]")), (0, s.word)(" # token_ids"));
                const A = new_rnd_name();
                push_toplevel((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)(A), (0, s.word)("=")), N));
                y = (0, s.vsep)((0, o.ofArray)([s.empty, (0, s.word)("@dataclasses.dataclass"), (0, s.word)("class Token:"), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.ofArray)([(0, s.word)("token_id: int"), (0, s.word)("lexeme : str"), (0, s.word)("line: int"), (0, s.word)("col: int"), (0, s.word)("span: int"), (0, s.word)("offset: int"), (0, s.word)("file: str")])), 4), s.empty, (0, s.word)('_Token = typing.TypeVar("_Token")'), s.empty, (0, s.word)("class TokenConstructor(typing_extensions.Protocol[_Token]):"), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.singleton)((0, s.word)("def __call__(self, token_id: int, lexeme: str, line: int, col: int, span: int, offset: int, file: str) -> _Token: ..."))), 4), s.empty, (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("def"), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)("lex"), (0, s.parens)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("lexerbuf: lexbuf"), (0, s.word)(", ")), (0, s.word)("construct_token: TokenConstructor[_Token]=Token")))), (0, s.word)(":"))), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.ofArray)([(0, s.word)("start(lexerbuf)"), (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("case_id"), (0, s.word)("=")), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)(x), (0, s.parens)((0, s.word)("lexerbuf")))), (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("if case_id < 0:"), (0, s.word)("raise")), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)("Exception"), (0, s.parens)((0, s.word)(T)))), (0, s.Doc_op_Addition_Z7CFFAC00)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("token_id"), (0, s.word)("=")), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)(A), (0, s.word)("[")), (0, s.word)("case_id")), (0, s.word)("]"))), (0, s.word)("if token_id is not None:"), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.singleton)((0, s.Doc_op_Addition_Z7CFFAC00)((0, s.word)("return"), (0, s.Doc_op_Multiply_Z7CFFAC00)((0, s.word)("construct_token"), (0, s.parens)((0, s.seplist)((0, s.word)(", "), (0, o.ofArray)([(0, s.word)("token_id"), (0, s.word)("lexeme(lexerbuf)"), (0, s.word)("lexerbuf.start_line"), (0, s.word)("lexerbuf.pos - lexerbuf.curr_bol"), (0, s.word)("lexerbuf.pos - lexerbuf.start_pos"), (0, s.word)("lexerbuf.start_pos"), (0, s.word)("lexerbuf.filename")]))))))), 4), (0, s.word)("return None")])), 4), (0, s.word)("def lexall(buf: lexbuf, construct: TokenConstructor[_Token], is_eof: Callable[[_Token], bool]):"), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.ofArray)([(0, s.word)("while True:"), (0, s.Doc_op_RightShift_2AAA0F3C)((0, s.vsep)((0, o.ofArray)([(0, s.word)("token = lex(buf, construct)"), (0, s.word)("if token is None: continue"), (0, s.word)("if is_eof(token): break"), (0, s.word)("yield token")])), 4)])), 4)]));
                return (0, s.vsep)((0, o.append)((0, o.singleton)((0, s.vsep)((0, o.ofArray)([(0, s.word)(`from ${e}.sedlex import *`), (0, s.word)("import typing"), (0, s.word)("import typing_extensions"), (0, s.word)("import dataclasses")]))), (0, o.append)(f, (0, o.append)((0, o.singleton)(y), h))))
            }
        },
        9386: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Array_drop = Array_drop;
            t.Doc = void 0;
            t.Doc$reflection = Doc$reflection;
            t.DocPrimitive = void 0;
            t.DocPrimitive$reflection = DocPrimitive$reflection;
            t.Doc_op_Addition_Z7CFFAC00 = Doc_op_Addition_Z7CFFAC00;
            t.Doc_op_Multiply_Z7CFFAC00 = Doc_op_Multiply_Z7CFFAC00;
            t.Doc_op_RightShift_2AAA0F3C = Doc_op_RightShift_2AAA0F3C;
            t.Stack$1 = void 0;
            t.Stack$1$reflection = Stack$1$reflection;
            t.Stack$1_$ctor_2605DBCF = Stack$1_$ctor_2605DBCF;
            t.Stack$1__Pop = Stack$1__Pop;
            t.Stack$1__Push_2B595 = Stack$1__Push_2B595;
            t.Stack$1__get_Last = Stack$1__get_Last;
            t.align = align;
            t.bracket = bracket;
            t.compileToPrims = compileToPrims;
            t.concat = concat;
            t.empty = void 0;
            t.genDoc = genDoc;
            t.indent = indent;
            t.listof = listof;
            t.parens = parens;
            t.pretty = pretty;
            t.render = render;
            t.seplist = seplist;
            t.showDoc = showDoc;
            t.vsep = vsep;
            t.word = word;
            var n = r(6638);
            var i = r(6356);
            var o = r(9054);
            var s = r(2078);
            var a = r(5359);
            var l = r(9937);
            var _ = r(4222);
            var u = r(8443);
            class Doc extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["Concat", "VSep", "Align", "Indent", "Word"]
                }
            }
            t.Doc = Doc;

            function Doc$reflection() {
                return (0, i.union_type)("Fable.CodeGen.Doc", [], Doc, (() => [
                    [
                        ["Item1", Doc$reflection()],
                        ["Item2", Doc$reflection()]
                    ],
                    [
                        ["Item", (0, i.list_type)(Doc$reflection())]
                    ],
                    [
                        ["Item", Doc$reflection()]
                    ],
                    [
                        ["Item1", i.int32_type],
                        ["Item2", Doc$reflection()]
                    ],
                    [
                        ["Item", i.string_type]
                    ]
                ]))
            }

            function Doc_op_Multiply_Z7CFFAC00(e, t) {
                return new Doc(0, e, t)
            }

            function Doc_op_Addition_Z7CFFAC00(e, t) {
                return Doc_op_Multiply_Z7CFFAC00(Doc_op_Multiply_Z7CFFAC00(e, new Doc(4, " ")), t)
            }

            function Doc_op_RightShift_2AAA0F3C(e, t) {
                return new Doc(3, t, e)
            }
            class DocPrimitive extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["DP_PopIndent", "DP_PushCurrentIndent", "DP_PushIndent", "DP_Word"]
                }
            }
            t.DocPrimitive = DocPrimitive;

            function DocPrimitive$reflection() {
                return (0, i.union_type)("Fable.CodeGen.DocPrimitive", [], DocPrimitive, (() => [
                    [],
                    [],
                    [
                        ["Item", i.int32_type]
                    ],
                    [
                        ["Item", i.string_type]
                    ]
                ]))
            }

            function Array_drop(e, t) {
                return (0, o.take)(t.length - e, t)
            }

            function compileToPrims(e) {
                switch (e.tag) {
                    case 2: {
                        const t = compileToPrims(e.fields[0]);
                        if (t.length === 0) {
                            return t
                        } else {
                            t[0] = (0, o.append)([new DocPrimitive(1)], t[0]);
                            t[t.length - 1] = (0, o.append)(t[t.length - 1], [new DocPrimitive(0)]);
                            return t
                        }
                    }
                    case 3: {
                        const t = [new DocPrimitive(2, e.fields[0])];
                        const r = compileToPrims(e.fields[1]);
                        if (r.length === 0) {
                            return r
                        } else {
                            r[0] = (0, o.append)(t, r[0]);
                            r[r.length - 1] = (0, o.append)(r[r.length - 1], [new DocPrimitive(0)]);
                            return r
                        }
                    }
                    case 1: {
                        return (0, o.concat)((0, s.map)(compileToPrims, e.fields[0]))
                    }
                    case 4: {
                        return [
                            [new DocPrimitive(3, e.fields[0])]
                        ]
                    }
                    default: {
                        const t = compileToPrims(e.fields[0]);
                        const r = compileToPrims(e.fields[1]);
                        if (t.length === 0) {
                            return r
                        } else if (r.length === 0) {
                            return t
                        } else {
                            return (0, o.concat)([Array_drop(1, t), [(0, o.append)((0, o.last)(t), (0, o.head)(r))], (0, o.skip)(1, r)])
                        }
                    }
                }
            }
            class Stack$1 {
                constructor(e) {
                    this._content = e != null ? (0, s.toList)(e) : (0, a.empty)()
                }
            }
            t.Stack$1 = Stack$1;

            function Stack$1$reflection(e) {
                return (0, i.class_type)("Fable.CodeGen.Stack`1", [e], Stack$1)
            }

            function Stack$1_$ctor_2605DBCF(e) {
                return new Stack$1(e)
            }

            function Stack$1__Push_2B595(e, t) {
                e._content = (0, a.cons)(t, e._content)
            }

            function Stack$1__Pop(e) {
                const t = e._content;
                if (!(0, a.isEmpty)(t)) {
                    e._content = (0, a.tail)(t);
                    return (0, a.head)(t)
                } else {
                    const e = new Error("negative stacksize");
                    throw e
                }
            }

            function Stack$1__get_Last(e) {
                const t = e._content;
                if (!(0, a.isEmpty)(t)) {
                    return (0, a.head)(t)
                } else {
                    const e = new Error("negative stacksize");
                    throw e
                }
            }

            function render(e, t) {
                const r = Stack$1_$ctor_2605DBCF([0]);
                if (e.length === 0) {} else {
                    for (let n = 0; n <= e.length - 1; n++) {
                        const i = e[n];
                        let o = 0;
                        let s = false;
                        for (let e = 0; e <= i.length - 1; e++) {
                            const n = i[e];
                            switch (n.tag) {
                                case 1: {
                                    Stack$1__Push_2B595(r, o);
                                    break
                                }
                                case 0: {
                                    Stack$1__Pop(r);
                                    break
                                }
                                case 2: {
                                    Stack$1__Push_2B595(r, Stack$1__get_Last(r) + n.fields[0]);
                                    break
                                }
                                default: {
                                    const e = n.fields[0];
                                    if (!s) {
                                        o = Stack$1__get_Last(r) + o | 0;
                                        t((0, l.replicate)(o, " "));
                                        s = true
                                    }
                                    t(e);
                                    o = o + e.length | 0
                                }
                            }
                        }
                        t("\n")
                    }
                }
            }

            function pretty(e) {
                let t;
                return new Doc(4, (t = e, (0, n.toString)(t)))
            }

            function word(e) {
                return new Doc(4, e)
            }

            function vsep(e) {
                return new Doc(1, e)
            }

            function align(e) {
                return new Doc(2, e)
            }

            function indent(e, t) {
                return new Doc(3, e, t)
            }

            function concat(e, t) {
                return new Doc(0, e, t)
            }
            const c = word("");
            t.empty = c;

            function parens(e) {
                return Doc_op_Multiply_Z7CFFAC00(Doc_op_Multiply_Z7CFFAC00(word("("), e), word(")"))
            }

            function bracket(e) {
                return Doc_op_Multiply_Z7CFFAC00(Doc_op_Multiply_Z7CFFAC00(word("["), e), word("]"))
            }

            function listof(e) {
                if (!(0, a.isEmpty)(e)) {
                    let t = (0, a.head)(e);
                    const r = (0, _.getEnumerator)((0, a.tail)(e));
                    try {
                        while (r["System.Collections.IEnumerator.MoveNext"]()) {
                            const e = r["System.Collections.Generic.IEnumerator`1.get_Current"]();
                            t = Doc_op_Multiply_Z7CFFAC00(t, e)
                        }
                    } finally {
                        (0, _.disposeSafe)(r)
                    }
                    return t
                } else {
                    return c
                }
            }

            function seplist(e, t) {
                if (!(0, a.isEmpty)(t)) {
                    let r = (0, a.head)(t);
                    const n = (0, _.getEnumerator)((0, a.tail)(t));
                    try {
                        while (n["System.Collections.IEnumerator.MoveNext"]()) {
                            const t = n["System.Collections.Generic.IEnumerator`1.get_Current"]();
                            r = Doc_op_Multiply_Z7CFFAC00(Doc_op_Multiply_Z7CFFAC00(r, e), t)
                        }
                    } finally {
                        (0, _.disposeSafe)(n)
                    }
                    return r
                } else {
                    return c
                }
            }

            function showDoc(e) {
                const t = (0, u.StringBuilder_$ctor)();
                render(compileToPrims(e), (e => {
                    (0, u.StringBuilder__Append_Z721C83C5)(t, e)
                }));
                return (0, n.toString)(t)
            }

            function genDoc(e, t) {
                render(compileToPrims(e), t)
            }
        },
        417: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Automata_add_node = Automata_add_node;
            t.Automata_add_nodes = Automata_add_nodes;
            t.Automata_alt = Automata_alt;
            t.Automata_char_pair_op = Automata_char_pair_op;
            t.Automata_chars = Automata_chars;
            t.Automata_compile = Automata_compile;
            t.Automata_compile_re = Automata_compile_re;
            t.Automata_compl = Automata_compl;
            t.Automata_cur_id = void 0;
            t.Automata_decision = Automata_decision;
            t.Automata_decision_table = Automata_decision_table;
            t.Automata_decision_tree = void 0;
            t.Automata_decision_tree$reflection = Automata_decision_tree$reflection;
            t.Automata_eps = Automata_eps;
            t.Automata_intersection = void 0;
            t.Automata_is_chars = Automata_is_chars;
            t.Automata_limit = void 0;
            t.Automata_new_node = Automata_new_node;
            t.Automata_node = void 0;
            t.Automata_node$reflection = Automata_node$reflection;
            t.Automata_old_decision_table = Automata_old_decision_table;
            t.Automata_pair_op = Automata_pair_op;
            t.Automata_plus = Automata_plus;
            t.Automata_rep = Automata_rep;
            t.Automata_repeat = Automata_repeat;
            t.Automata_segments_of_partition = Automata_segments_of_partition;
            t.Automata_seq = Automata_seq;
            t.Automata_simplify = Automata_simplify;
            t.Automata_simplify_decision_tree = Automata_simplify_decision_tree;
            t.Automata_subtract = void 0;
            t.Automata_transition = Automata_transition;
            t.Cset_any = void 0;
            t.Cset_complement = Cset_complement;
            t.Cset_difference = Cset_difference;
            t.Cset_empty = Cset_empty;
            t.Cset_eof = void 0;
            t.Cset_intersection = Cset_intersection;
            t.Cset_interval = Cset_interval;
            t.Cset_is_empty = Cset_is_empty;
            t.Cset_min_code = t.Cset_max_code = void 0;
            t.Cset_singleton = Cset_singleton;
            t.Cset_union = Cset_union;
            t.Lexer_discard = void 0;
            t.Lexer_tokenize = Lexer_tokenize;
            t.Utf8_from_ustring = void 0;
            t.Utf8_lexeme = Utf8_lexeme;
            t.Utf8_lexeme_char = Utf8_lexeme_char;
            t.Utf8_sub_lexeme = Utf8_sub_lexeme;
            t.backtrack = backtrack;
            t.build = build;
            t.compiled_unit = t.chunk_size = void 0;
            t.compiled_unit$reflection = compiled_unit$reflection;
            t.empty_lexbuf = void 0;
            t.from_ustring = from_ustring;
            t.incr = incr;
            t.inline_thread = inline_thread;
            t.keep_token = void 0;
            t.keep_token$reflection = keep_token$reflection;
            t.lang = void 0;
            t.lang$reflection = lang$reflection;
            t.lexbuf = void 0;
            t.lexbuf$reflection = lexbuf$reflection;
            t.lexeme = lexeme;
            t.lexeme_char = lexeme_char;
            t.lexeme_end = lexeme_end;
            t.lexeme_start = lexeme_start;
            t.lexing_positions = lexing_positions;
            t.mark = mark;
            t.new_line = new_line;
            t.pany = void 0;
            t.pchar = pchar;
            t.pchars = pchars;
            t.pcompl = pcompl;
            t.peof = void 0;
            t.pintersct = pintersct;
            t.pinterval = pinterval;
            t.popt = popt;
            t.por = por;
            t.position = void 0;
            t.position$reflection = position$reflection;
            t.pplus = pplus;
            t.prep = prep;
            t.pseq = pseq;
            t.pstar = pstar;
            t.pstring = pstring;
            t.psub = psub;
            t.public_next_int = public_next_int;
            t.regexp_for_char = regexp_for_char;
            t.regexp_for_string = regexp_for_string;
            t.start = start;
            t.with_tokenizer = with_tokenizer;
            var n = r(5359);
            var i = r(4222);
            var o = r(6638);
            var s = r(6356);
            var a = r(9054);
            var l = r(5466);
            var _ = r(6256);
            var u = r(1337);

            function incr(e) {
                e.contents = e.contents + 1 | 0
            }

            function Cset_union(e, t) {
                e: while (true) {
                    const r = e,
                        i = t;
                    const o = [r, i];
                    if (!(0, n.isEmpty)(o[0])) {
                        if (!(0, n.isEmpty)(o[1])) {
                            if ((0, n.head)(o[0])[0] <= (0, n.head)(o[1])[0]) {
                                if ((0, n.head)(o[0])[1] + 1 < (0, n.head)(o[1])[0]) {
                                    return (0, n.cons)((0, n.head)(o[0]), Cset_union((0, n.tail)(o[0]), i))
                                } else if ((0, n.head)(o[0])[1] < (0, n.head)(o[1])[1]) {
                                    e = (0, n.tail)(o[0]);
                                    t = (0, n.cons)([(0, n.head)(o[0])[0], (0, n.head)(o[1])[1]], (0, n.tail)(o[1]));
                                    continue e
                                } else {
                                    e = r;
                                    t = (0, n.tail)(o[1]);
                                    continue e
                                }
                            } else {
                                e = i;
                                t = r;
                                continue e
                            }
                        } else {
                            return r
                        }
                    } else {
                        return i
                    }
                    break
                }
            }
            const c = 1114111;
            t.Cset_max_code = c;
            const d = -1;
            t.Cset_min_code = d;

            function Cset_empty() {
                return (0, n.empty)()
            }

            function Cset_singleton(e) {
                return (0, n.singleton)([e, e])
            }

            function Cset_is_empty(e) {
                if ((0, n.isEmpty)(e)) {
                    return true
                } else {
                    return false
                }
            }

            function Cset_interval(e, t) {
                if ((0, i.compare)(e, t) <= 0) {
                    return (0, n.singleton)([e, t])
                } else {
                    return (0, n.singleton)([t, e])
                }
            }
            const p = Cset_singleton(-1);
            t.Cset_eof = p;
            const f = Cset_interval(0, c);
            t.Cset_any = f;

            function Cset_complement(e) {
                const aux = (e, t) => {
                    if (!(0, n.isEmpty)(t)) {
                        return (0, n.cons)([e, (0, n.head)(t)[0] - 1], aux((0, n.head)(t)[1] + 1, (0, n.tail)(t)))
                    } else if (e <= c) {
                        return (0, n.singleton)([e, c])
                    } else {
                        return (0, n.empty)()
                    }
                };
                let t, r, i, o;
                if (!(0, n.isEmpty)(e)) {
                    if ((0, n.head)(e)[0] === -1) {
                        t = 0;
                        r = (0, n.head)(e)[1];
                        i = (0, n.tail)(e)
                    } else {
                        t = 1;
                        o = e
                    }
                } else {
                    t = 1;
                    o = e
                }
                switch (t) {
                    case 0: {
                        return aux(r + 1, i)
                    }
                    case 1: {
                        return aux(-1, o)
                    }
                }
            }

            function Cset_intersection(e, t) {
                return Cset_complement(Cset_union(Cset_complement(e), Cset_complement(t)))
            }

            function Cset_difference(e, t) {
                return Cset_complement(Cset_union(Cset_complement(e), t))
            }
            class Automata_node extends o.Record {
                constructor(e, t, r) {
                    super();
                    this.id = e | 0;
                    this.eps = t;
                    this.trans = r
                }
            }
            t.Automata_node = Automata_node;

            function Automata_node$reflection() {
                return (0, s.record_type)("Fable.Sedlex.Compiler.Automata.node", [], Automata_node, (() => [
                    ["id", s.int32_type],
                    ["eps", (0, s.list_type)(Automata_node$reflection())],
                    ["trans", (0, s.list_type)((0, s.tuple_type)((0, s.list_type)((0, s.tuple_type)(s.int32_type, s.int32_type)), Automata_node$reflection()))]
                ]))
            }
            const h = new o.FSharpRef(0);
            t.Automata_cur_id = h;

            function Automata_new_node() {
                incr(h);
                return new Automata_node(h.contents, (0, n.empty)(), (0, n.empty)())
            }

            function Automata_seq(e, t, r) {
                return e(t(r))
            }

            function Automata_is_chars(e, t) {
                let r, i;
                let o, s, a;
                if ((0, n.isEmpty)(t.eps)) {
                    if (!(0, n.isEmpty)(t.trans)) {
                        if ((0, n.isEmpty)((0, n.tail)(t.trans))) {
                            if (r = (0, n.head)(t.trans)[1], i = (0, n.head)(t.trans)[0], r === e) {
                                o = 0;
                                s = (0, n.head)(t.trans)[0];
                                a = (0, n.head)(t.trans)[1]
                            } else {
                                o = 1
                            }
                        } else {
                            o = 1
                        }
                    } else {
                        o = 1
                    }
                } else {
                    o = 1
                }
                switch (o) {
                    case 0: {
                        return s
                    }
                    case 1: {
                        return void 0
                    }
                }
            }

            function Automata_chars(e, t) {
                const r = Automata_new_node();
                r.trans = (0, n.singleton)([e, t]);
                return r
            }

            function Automata_alt(e, t, r) {
                const i = e(r);
                const o = t(r);
                const s = [Automata_is_chars(r, i), Automata_is_chars(r, o)];
                let a, l, _;
                if (s[0] != null) {
                    if (s[1] != null) {
                        a = 0;
                        l = s[0];
                        _ = s[1]
                    } else {
                        a = 1
                    }
                } else {
                    a = 1
                }
                switch (a) {
                    case 0: {
                        return Automata_chars(Cset_union(l, _), r)
                    }
                    case 1: {
                        const e = Automata_new_node();
                        e.eps = (0, n.ofArray)([i, o]);
                        return e
                    }
                }
            }

            function Automata_rep(e, t) {
                const r = Automata_new_node();
                r.eps = (0, n.ofArray)([e(r), t]);
                return r
            }

            function Automata_plus(e, t) {
                const r = Automata_new_node();
                const i = e(r);
                r.eps = (0, n.ofArray)([i, t]);
                return i
            }

            function Automata_eps(e) {
                return e
            }

            function Automata_compl(e) {
                let t;
                const r = Automata_new_node();
                const n = Automata_is_chars(r, e(r));
                if (n != null) {
                    return t = Cset_difference(f, n), e => Automata_chars(t, e)
                } else {
                    return void 0
                }
            }

            function Automata_pair_op(e, t, r) {
                let n;
                const i = Automata_new_node();
                const to_chars = e => Automata_is_chars(i, e(i));
                const o = [to_chars(t), to_chars(r)];
                let s, a, l;
                if (o[0] != null) {
                    if (o[1] != null) {
                        s = 0;
                        a = o[0];
                        l = o[1]
                    } else {
                        s = 1
                    }
                } else {
                    s = 1
                }
                switch (s) {
                    case 0: {
                        return n = e(a, l), e => Automata_chars(n, e)
                    }
                    case 1: {
                        return void 0
                    }
                }
            }
            const Automata_subtract = e => t => Automata_pair_op(Cset_difference, e, t);
            t.Automata_subtract = Automata_subtract;
            const Automata_intersection = e => t => Automata_pair_op(Cset_intersection, e, t);
            t.Automata_intersection = Automata_intersection;

            function Automata_compile_re(e) {
                const t = Automata_new_node();
                return [e(t), t]
            }

            function Automata_add_node(e, t) {
                if ((0, n.exists)((e => t === e), e)) {
                    return e
                } else {
                    return Automata_add_nodes((0, n.cons)(t, e), t.eps)
                }
            }

            function Automata_add_nodes(e, t) {
                return (0, n.fold)(Automata_add_node, e, t)
            }

            function Automata_transition(e) {
                const norm = e => {
                    e: while (true) {
                        const t = e;
                        let r, i, o, s, a, l, _, u;
                        if (!(0, n.isEmpty)(t)) {
                            if (!(0, n.isEmpty)((0, n.tail)(t))) {
                                r = 0;
                                i = (0, n.head)(t)[0];
                                o = (0, n.head)((0, n.tail)(t))[0];
                                s = (0, n.tail)(t);
                                a = (0, n.head)(t)[1];
                                l = (0, n.head)((0, n.tail)(t))[1];
                                _ = (0, n.tail)((0, n.tail)(t))
                            } else {
                                r = 1;
                                u = t
                            }
                        } else {
                            r = 1;
                            u = t
                        }
                        switch (r) {
                            case 0: {
                                if (a === l) {
                                    e = (0, n.cons)([Cset_union(i, o), a], _);
                                    continue e
                                } else {
                                    return (0, n.cons)([i, a], norm(s))
                                }
                            }
                            case 1: {
                                return u
                            }
                        }
                        break
                    }
                };
                const t = norm((0, n.sortWith)(((e, t) => e[1].id - t[1].id), (0, n.concat)((0, n.map)((e => e.trans), e))));
                const r = (0, n.toArray)((0, n.map)((e => [e[0], Automata_add_nodes((0, n.empty)(), e[1])]), (0, n.fold)((0, i.uncurry)(2, (e => {
                    const t = e[0];
                    const r = e[1];
                    return e => {
                        const i = e[0];
                        const o = e[1];
                        const s = (0, n.append)((0, n.cons)([Cset_difference(i, t), (0, n.singleton)(o)], (0, n.map)((e => [Cset_intersection(e[0], i), (0, n.cons)(o, e[1])]), r)), (0, n.map)((e => [Cset_difference(e[0], i), e[1]]), r));
                        return [Cset_union(t, i), (0, n.filter)((e => !Cset_is_empty(e[0])), s)]
                    }
                })), [Cset_empty(), (0, n.empty)()], t)[1]));
                r.sort(((e, t) => (0, i.compare)(e[0], t[0])));
                return r
            }

            function Automata_compile(e) {
                const t = (0, a.map)(Automata_compile_re, e);
                const r = new o.FSharpRef(0);
                let i = (0, l.empty)();
                let s = (0, l.empty)();
                const aux = e => {
                    const o = (0, l.tryFind)(e, i);
                    if (o == null) {
                        const o = r.contents | 0;
                        incr(r);
                        i = (0, l.add)(e, o, i);
                        const _ = (0, a.map)((e => [e[0], aux(e[1])]), Automata_transition(e));
                        const u = (0, a.map)((t => (0, n.exists)((e => t[1] === e), e)), t);
                        s = (0, l.add)(o, [_, u], s);
                        return o | 0
                    } else {
                        return o | 0
                    }
                };
                const _ = new o.FSharpRef((0, n.empty)());
                t.forEach((e => {
                    _.contents = Automata_add_node(_.contents, e[0])
                }));
                const u = aux(_.contents) | 0;
                return (0, a.initialize)(r.contents, (e => (0, l.find)(e, s)))
            }
            class Automata_decision_tree extends o.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["Lte", "Table", "Return"]
                }
            }
            t.Automata_decision_tree = Automata_decision_tree;

            function Automata_decision_tree$reflection() {
                return (0, s.union_type)("Fable.Sedlex.Compiler.Automata.decision_tree", [], Automata_decision_tree, (() => [
                    [
                        ["Item1", s.int32_type],
                        ["Item2", Automata_decision_tree$reflection()],
                        ["Item3", Automata_decision_tree$reflection()]
                    ],
                    [
                        ["Item1", s.int32_type],
                        ["Item2", (0, s.array_type)(s.int32_type)]
                    ],
                    [
                        ["Item", s.int32_type]
                    ]
                ]))
            }

            function Automata_simplify_decision_tree(e) {
                let t, r, n, i;
                if (e.tag === 2) {
                    t = 0
                } else if (e.tag === 0) {
                    if (e.fields[1].tag === 2) {
                        if (e.fields[2].tag === 2) {
                            if (e.fields[1].fields[0] === e.fields[2].fields[0]) {
                                t = 1;
                                r = e.fields[1].fields[0];
                                n = e.fields[2].fields[0];
                                i = e.fields[1]
                            } else {
                                t = 2
                            }
                        } else {
                            t = 2
                        }
                    } else {
                        t = 2
                    }
                } else {
                    t = 0
                }
                switch (t) {
                    case 0: {
                        return e
                    }
                    case 1: {
                        return i
                    }
                    case 2: {
                        if (e.tag === 0) {
                            const t = Automata_simplify_decision_tree(e.fields[1]);
                            const r = Automata_simplify_decision_tree(e.fields[2]);
                            const n = [t, r];
                            let i;
                            if (n[0].tag === 2) {
                                if (n[1].tag === 2) {
                                    if (n[0].fields[0] === n[1].fields[0]) {
                                        i = 0
                                    } else {
                                        i = 1
                                    }
                                } else {
                                    i = 1
                                }
                            } else {
                                i = 1
                            }
                            switch (i) {
                                case 0: {
                                    return t
                                }
                                case 1: {
                                    return new Automata_decision_tree(0, e.fields[0], t, r)
                                }
                            }
                        } else {
                            throw new Error("Match failure")
                        }
                    }
                }
            }

            function Automata_decision(e) {
                const merge2 = e => {
                    let t, r, i, o, s, a, l, _, u;
                    if (!(0, n.isEmpty)(e)) {
                        if (!(0, n.isEmpty)((0, n.tail)(e))) {
                            t = 0;
                            r = (0, n.head)(e)[0];
                            i = (0, n.head)((0, n.tail)(e))[0];
                            o = (0, n.head)(e)[1];
                            s = (0, n.head)((0, n.tail)(e))[1];
                            a = (0, n.head)(e)[2];
                            l = (0, n.head)((0, n.tail)(e))[2];
                            _ = (0, n.tail)((0, n.tail)(e))
                        } else {
                            t = 1;
                            u = e
                        }
                    } else {
                        t = 1;
                        u = e
                    }
                    switch (t) {
                        case 0: {
                            return (0, n.cons)([r, s, new Automata_decision_tree(0, o, a, o + 1 === i ? l : new Automata_decision_tree(0, i - 1, new Automata_decision_tree(2, -1), l))], merge2(_))
                        }
                        case 1: {
                            return u
                        }
                    }
                };
                const aux = e => {
                    e: while (true) {
                        const t = e;
                        if ((0, n.isEmpty)(t)) {
                            return new Automata_decision_tree(2, -1)
                        } else if ((0, n.isEmpty)((0, n.tail)(t))) {
                            return new Automata_decision_tree(0, (0, n.head)(t)[0] - 1, new Automata_decision_tree(2, -1), new Automata_decision_tree(0, (0, n.head)(t)[1], (0, n.head)(t)[2], new Automata_decision_tree(2, -1)))
                        } else {
                            e = merge2(t);
                            continue e
                        }
                        break
                    }
                };
                return aux((0, n.map)((e => [e[0], e[1], new Automata_decision_tree(2, e[2])]), e))
            }
            const g = 8192;
            t.Automata_limit = g;

            function Automata_old_decision_table(e) {
                const aux = (e, t, r) => {
                    e: while (true) {
                        const o = e,
                            s = t,
                            a = r;
                        let l, _, u, c, d, p;
                        if (!(0, n.isEmpty)(a)) {
                            if ((0, n.head)(a)[1] < g && (0, n.head)(a)[2] < 255) {
                                l = 0;
                                _ = (0, n.head)(a)[0];
                                u = (0, n.head)(a)[1];
                                c = (0, n.head)(a)[2];
                                d = (0, n.tail)(a);
                                p = (0, n.head)(a)
                            } else {
                                l = 1
                            }
                        } else {
                            l = 1
                        }
                        switch (l) {
                            case 0: {
                                e = (0, i.min)(i.compare, _, o);
                                t = (0, n.cons)(p, s);
                                r = d;
                                continue e
                            }
                            case 1: {
                                return [o, s, a]
                            }
                        }
                        break
                    }
                };
                const t = aux(2147483647, (0, n.empty)(), e);
                const r = t[1];
                const o = t[2];
                const s = t[0] | 0;
                if (!(0, n.isEmpty)(r)) {
                    if ((0, n.isEmpty)((0, n.tail)(r))) {
                        return new Automata_decision_tree(0, (0, n.head)(r)[0] - 1, new Automata_decision_tree(2, -1), new Automata_decision_tree(0, (0, n.head)(r)[1], new Automata_decision_tree(2, (0, n.head)(r)[2]), Automata_decision(o)))
                    } else {
                        const e = (0, a.fill)(new Array((0, n.head)(r)[1] - s + 1), 0, (0, n.head)(r)[1] - s + 1, 0);
                        (0, n.iterate)((t => {
                            for (let r = t[0]; r <= t[1]; r++) {
                                e[r - s] = t[2] + 1 | 0
                            }
                        }), r);
                        return new Automata_decision_tree(0, s - 1, new Automata_decision_tree(2, -1), new Automata_decision_tree(0, (0, n.head)(r)[1], new Automata_decision_tree(1, s, e), Automata_decision(o)))
                    }
                } else {
                    return Automata_decision(e)
                }
            }

            function Automata_simplify(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o.tag === 0) {
                        const s = o.fields[1];
                        const a = o.fields[2];
                        const l = o.fields[0] | 0;
                        if (l >= i) {
                            e = n;
                            t = i;
                            r = s;
                            continue e
                        } else if (l < n) {
                            e = n;
                            t = i;
                            r = a;
                            continue e
                        } else {
                            return new Automata_decision_tree(0, l, Automata_simplify(n, l, s), Automata_simplify(l + 1, i, a))
                        }
                    } else {
                        return o
                    }
                    break
                }
            }

            function Automata_segments_of_partition(e) {
                const t = new o.FSharpRef((0, n.empty)());
                (0, a.iterateIndexed)(((e, r) => {
                    (0, n.iterate)((r => {
                        t.contents = (0, n.cons)([r[0], r[1], e], t.contents)
                    }), r)
                }), e);
                return (0, n.sortWith)(((e, t) => (0, i.compare)(e[0], t[0])), t.contents)
            }

            function Automata_decision_table(e) {
                return Automata_simplify(-1, c, Automata_old_decision_table(Automata_segments_of_partition(e)))
            }

            function Automata_char_pair_op(e, t, r, n) {
                const i = e(r, n);
                if (i == null) {
                    throw new Error(`the ${t} operator can only applied to single-character length regexps`)
                } else {
                    return (0, _.value)(i)
                }
            }

            function Automata_repeat(e, t, r) {
                const n = [t, r];
                if (n[0] === 0) {
                    if (n[1] === 0) {
                        return Automata_eps
                    } else {
                        let t;
                        const r = Automata_repeat(e, 0, n[1] - 1);
                        t = t => Automata_seq(e, r, t);
                        return e => Automata_alt(Automata_eps, t, e)
                    }
                } else {
                    const t = Automata_repeat(e, n[0] - 1, n[1] - 1);
                    return r => Automata_seq(e, t, r)
                }
            }
            class keep_token extends o.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["Discard", "Tokenize"]
                }
            }
            t.keep_token = keep_token;

            function keep_token$reflection() {
                return (0, s.union_type)("Fable.Sedlex.Compiler.keep_token", [], keep_token, (() => [
                    [],
                    [
                        ["Item", s.int32_type]
                    ]
                ]))
            }
            class lang extends o.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["Lang_match_i", "Lang_backtrace", "Lang_mark", "Lang_callst", "Lang_int"]
                }
            }
            t.lang = lang;

            function lang$reflection() {
                return (0, s.union_type)("Fable.Sedlex.Compiler.lang", [], lang, (() => [
                    [
                        ["Item1", Automata_decision_tree$reflection()],
                        ["Item2", (0, s.array_type)(lang$reflection())],
                        ["Item3", lang$reflection()]
                    ],
                    [],
                    [
                        ["Item1", s.int32_type],
                        ["Item2", lang$reflection()]
                    ],
                    [
                        ["Item", s.int32_type]
                    ],
                    [
                        ["Item", s.int32_type]
                    ]
                ]))
            }
            class compiled_unit extends o.Record {
                constructor(e, t, r) {
                    super();
                    this.states = e;
                    this.lex_code = t;
                    this.referenced_decision_trees = r
                }
            }
            t.compiled_unit = compiled_unit;

            function compiled_unit$reflection() {
                return (0, s.record_type)("Fable.Sedlex.Compiler.compiled_unit", [], compiled_unit, (() => [
                    ["states", (0, s.class_type)("Microsoft.FSharp.Collections.FSharpMap`2", [s.int32_type, lang$reflection()])],
                    ["lex_code", (0, s.tuple_type)((0, s.array_type)(keep_token$reflection()), s.string_type)],
                    ["referenced_decision_trees", (0, s.class_type)("Microsoft.FSharp.Collections.FSharpSet`1", [Automata_decision_tree$reflection()])]
                ]))
            }

            function build(e, t) {
                let r = (0, l.empty)();
                const n = new o.FSharpRef(0);
                let s = (0, l.empty)();
                let _ = (0, u.empty)({
                    Compare: i.compare
                });
                const best_final = e => {
                    const t = new o.FSharpRef(void 0);
                    for (let r = e.length - 1; r >= 0; r--) {
                        if (e[r]) {
                            t.contents = r
                        }
                    }
                    return t.contents
                };
                const gen_definition = e => t => {
                    const r = e;
                    const n = Automata_compile((0, a.map)((e => e[0]), r));
                    const o = (0, a.map)((e => e[1]), r);
                    return new compiled_unit((0, l.ofArray)((0, a.choose)((e => e), (0, a.mapIndexed)((0, i.uncurry)(2, gen_state(n)), n))), [o, t], _)
                };
                const call_state = e => t => {
                    const r = e[t];
                    if (r[0].length === 0) {
                        const e = best_final(r[1]);
                        if (e == null) {
                            throw new Error("cannot found best final")
                        } else {
                            return new lang(4, e)
                        }
                    } else {
                        return new lang(3, t)
                    }
                };
                const gen_state = e => t => r => {
                    const n = r[0];
                    const i = (0, a.map)((e => e[0]), n);
                    const o = (0, a.map)((t => call_state(e)(t[1])), n);
                    const body = () => {
                        let e, t, r;
                        return new lang(0, (e = i, t = (0, l.tryFind)(e, s), t != null ? t : (r = Automata_simplify_decision_tree(Automata_decision_table(e)), _ = (0, u.add)(r, _), s = (0, l.add)(e, r, s), r)), o, new lang(1))
                    };
                    const c = best_final(r[1]);
                    if (c != null) {
                        if (n.length === 0) {
                            return void 0
                        } else if (c != null) {
                            return [t, new lang(2, c, body())]
                        } else {
                            throw new Error("Match failure")
                        }
                    } else {
                        return [t, body()]
                    }
                };
                return gen_definition(e)(t)
            }
            class lexbuf extends o.Record {
                constructor(e, t, r, n, i, o, s, a, l, _, u, c, d, p, f, h, g) {
                    super();
                    this.refill = e;
                    this.buf = t;
                    this.src = r;
                    this.len = n | 0;
                    this.offset = i | 0;
                    this.pos = o | 0;
                    this.curr_bol = s | 0;
                    this.curr_line = a | 0;
                    this.start_pos = l | 0;
                    this.start_bol = _ | 0;
                    this.start_line = u | 0;
                    this.marked_pos = c | 0;
                    this.marked_bol = d | 0;
                    this.marked_line = p | 0;
                    this.marked_val = f | 0;
                    this.filename = h;
                    this.finished = g
                }
            }
            t.lexbuf = lexbuf;

            function lexbuf$reflection() {
                return (0, s.record_type)("Fable.Sedlex.Compiler.lexbuf", [], lexbuf, (() => [
                    ["refill", (0, s.lambda_type)(s.string_type, (0, s.lambda_type)(s.int32_type, (0, s.lambda_type)(s.int32_type, s.int32_type)))],
                    ["buf", (0, s.array_type)(s.int32_type)],
                    ["src", s.string_type],
                    ["len", s.int32_type],
                    ["offset", s.int32_type],
                    ["pos", s.int32_type],
                    ["curr_bol", s.int32_type],
                    ["curr_line", s.int32_type],
                    ["start_pos", s.int32_type],
                    ["start_bol", s.int32_type],
                    ["start_line", s.int32_type],
                    ["marked_pos", s.int32_type],
                    ["marked_bol", s.int32_type],
                    ["marked_line", s.int32_type],
                    ["marked_val", s.int32_type],
                    ["filename", s.string_type],
                    ["finished", s.bool_type]
                ]))
            }
            const m = new lexbuf(((e, t, r) => {
                throw new Error("invalid")
            }), [], "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "", false);
            t.empty_lexbuf = m;

            function from_ustring(e) {
                const t = e.length | 0;
                const r = [];
                const n = (0, i.getEnumerator)(e.split(""));
                try {
                    while (n["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = n["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        void r.push(e.charCodeAt(0))
                    }
                } finally {
                    (0, i.disposeSafe)(n)
                }
                return new lexbuf(m.refill, r, e, t, m.offset, m.pos, m.curr_bol, m.curr_line, m.start_pos, m.start_bol, m.start_line, m.marked_pos, m.marked_bol, m.marked_line, m.marked_val, m.filename, true)
            }
            const y = 512;
            t.chunk_size = y;

            function new_line(e) {
                e.curr_line = e.curr_line + 1 | 0;
                e.curr_bol = e.pos + e.offset | 0
            }

            function public_next_int(e) {
                if (e.pos === e.len && e.finished) {
                    return -1
                } else {
                    const t = e.buf[e.pos] | 0;
                    e.pos = e.pos + 1 | 0;
                    if (t === 10) {
                        new_line(e)
                    }
                    return t | 0
                }
            }

            function mark(e, t) {
                e.marked_pos = e.pos | 0;
                e.marked_bol = e.curr_bol | 0;
                e.marked_line = e.curr_line | 0;
                e.marked_val = t | 0
            }

            function start(e) {
                e.start_pos = e.pos | 0;
                e.start_bol = e.curr_bol | 0;
                e.start_line = e.curr_line | 0;
                mark(e, -1)
            }

            function backtrack(e) {
                e.pos = e.marked_pos | 0;
                e.curr_bol = e.marked_bol | 0;
                e.curr_line = e.marked_line | 0;
                return e.marked_val | 0
            }

            function lexeme_start(e) {
                return e.start_pos + e.offset
            }

            function lexeme_end(e) {
                return e.pos + e.offset
            }

            function lexeme(e) {
                return e.src.slice(e.start_pos, e.pos - 1 + 1)
            }

            function lexeme_char(e, t) {
                return e.src[e.start_pos + t]
            }
            class position extends o.Record {
                constructor(e, t, r, n) {
                    super();
                    this.pos_fname = e;
                    this.pos_lnum = t | 0;
                    this.pos_cnum = r | 0;
                    this.pos_bol = n | 0
                }
            }
            t.position = position;

            function position$reflection() {
                return (0, s.record_type)("Fable.Sedlex.Compiler.position", [], position, (() => [
                    ["pos_fname", s.string_type],
                    ["pos_lnum", s.int32_type],
                    ["pos_cnum", s.int32_type],
                    ["pos_bol", s.int32_type]
                ]))
            }

            function lexing_positions(e) {
                return [new position(e.filename, e.start_line, e.start_pos + e.offset, e.start_bol), new position(e.filename, e.curr_line, e.pos + e.offset, e.curr_bol)]
            }

            function with_tokenizer(e, t) {
                return () => {
                    const r = e(t);
                    const n = lexing_positions(t);
                    return [r, n[0], n[1]]
                }
            }
            const S = from_ustring;
            t.Utf8_from_ustring = S;

            function Utf8_lexeme_char(e, t) {
                return lexeme_char(e, t)
            }

            function Utf8_sub_lexeme(e, t, r) {
                return e.src.slice(e.start_pos + t, e.start_pos + t + r - 1 + 1)
            }

            function Utf8_lexeme(e) {
                return e.src.slice(e.start_pos, e.pos - 1 + 1)
            }

            function inline_thread(e, t) {
                let r = (0, l.empty)();
                let n = (0, l.empty)();
                const evaluate_decision_func = e => {
                    const t = (0, l.tryFind)(e, r);
                    if (t == null) {
                        let t;
                        switch (e.tag) {
                            case 2: {
                                t = t => e.fields[0];
                                break
                            }
                            case 1: {
                                t = t => e.fields[1][t - e.fields[0]] - 1;
                                break
                            }
                            default: {
                                const r = evaluate_decision_func(e.fields[1]);
                                const n = evaluate_decision_func(e.fields[2]);
                                t = t => t <= e.fields[0] ? r(t) : n(t)
                            }
                        }
                        r = (0, l.add)(e, t, r);
                        return t
                    } else {
                        return t
                    }
                };
                const evaluate_state_func = e => {
                    switch (e.tag) {
                        case 3: {
                            const t = (0, l.find)(e.fields[0], n);
                            return e => t.contents(e)
                        }
                        case 4: {
                            return t => e.fields[0]
                        }
                        case 2: {
                            const t = evaluate_state_func(e.fields[1]);
                            return r => {
                                mark(r, e.fields[0]);
                                return t(r) | 0
                            }
                        }
                        case 0: {
                            const t = (0, a.map)(evaluate_state_func, e.fields[1]);
                            const r = evaluate_state_func(e.fields[2]);
                            const n = evaluate_decision_func(e.fields[0]);
                            return e => {
                                const i = (0, a.tryItem)(n(public_next_int(e)), t);
                                return (i != null ? i(e) : r(e)) | 0
                            }
                        }
                        default: {
                            return backtrack
                        }
                    }
                };
                n = (0, l.map)(((e, t) => new o.FSharpRef(null)), e.states);
                const s = (0, i.getEnumerator)(e.states);
                try {
                    while (s["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = s["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        (0, l.FSharpMap__get_Item)(n, e[0]).contents = evaluate_state_func(e[1])
                    }
                } finally {
                    (0, i.disposeSafe)(s)
                }
                const _ = (0, i.getEnumerator)(e.referenced_decision_trees);
                try {
                    while (_["System.Collections.IEnumerator.MoveNext"]()) {
                        evaluate_decision_func(_["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    }
                } finally {
                    (0, i.disposeSafe)(_)
                }
                const u = e.lex_code;
                const c = (0, l.find)(0, n).contents;
                return e => {
                    start(e);
                    const r = (0, a.tryItem)(c(e), u[0]);
                    if (r == null) {
                        throw new Error(u[1])
                    } else if (r.tag === 1) {
                        const n = r.fields[0] | 0;
                        let i;
                        const o = e;
                        i = [o.start_line, o.pos - o.curr_bol, o.pos - o.start_pos];
                        return t([n, lexeme(e), i[0], i[1], i[2], e.start_pos, e.filename])
                    } else {
                        return void 0
                    }
                }
            }
            const T = new keep_token(0);
            t.Lexer_discard = T;

            function Lexer_tokenize(e) {
                return new keep_token(1, e)
            }

            function por(e, t) {
                return r => Automata_alt(e, t, r)
            }

            function pseq(e) {
                const t = (0, n.ofArray)(e);
                if (!(0, n.isEmpty)(t)) {
                    return (0, n.fold)(((e, t) => r => Automata_seq(e, t, r)), (0, n.head)(t), (0, n.tail)(t))
                } else {
                    throw new Error("empty sequence")
                }
            }

            function pstar(e) {
                return t => Automata_rep(e, t)
            }

            function pplus(e) {
                return t => Automata_plus(e, t)
            }

            function prep(e, t, r) {
                if (0 <= t && t <= r) {
                    return Automata_repeat(e, t, r)
                } else {
                    throw new Error(`repeat operator requires 0 <= ${t} <= ${r}`)
                }
            }

            function popt(e) {
                return t => Automata_alt(Automata_eps, e, t)
            }

            function pcompl(e) {
                const t = Automata_compl(e);
                if (t == null) {
                    throw new Error("the Compl operator can only applied to a single-character length regexp")
                } else {
                    return t
                }
            }

            function psub(e) {
                return t => Automata_char_pair_op((0, i.uncurry)(2, Automata_subtract), "sub", e, t)
            }

            function pintersct(e) {
                return t => Automata_char_pair_op((0, i.uncurry)(2, Automata_intersection), "intersect", e, t)
            }

            function pchars(e) {
                const t = (0, n.ofArray)(e);
                let r;
                let o = Cset_empty();
                const s = (0, i.getEnumerator)(t);
                try {
                    while (s["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = s["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        const t = e.charCodeAt(0) | 0;
                        o = Cset_union(o, Cset_singleton(t))
                    }
                } finally {
                    (0, i.disposeSafe)(s)
                }
                r = e => Automata_chars(o, e);
                return r
            }

            function pinterval(e, t) {
                const r = Cset_interval(e, t);
                return e => Automata_chars(r, e)
            }

            function regexp_for_char(e) {
                const t = Cset_singleton(e.charCodeAt(0));
                return e => Automata_chars(t, e)
            }

            function regexp_for_string(e) {
                const aux = t => {
                    if (t === e.length) {
                        return Automata_eps
                    } else {
                        const r = regexp_for_char(e[t]);
                        const n = aux(t + 1);
                        return e => Automata_seq(r, n, e)
                    }
                };
                return aux(0)
            }

            function pstring(e) {
                return regexp_for_string(e)
            }

            function pchar(e) {
                return regexp_for_char(e)
            }
            const x = pinterval(0, c);
            t.pany = x;
            const C = (() => {
                const e = Cset_singleton(-1);
                return t => Automata_chars(e, t)
            })();
            t.peof = C
        },
        7688: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.parse_tbnf = parse_tbnf;
            var n = _interopRequireWildcard(r(2004));
            var i = _interopRequireWildcard(r(9271));
            var o = _interopRequireWildcard(r(668));
            var s = _interopRequireWildcard(r(1127));

            function _getRequireWildcardCache(e) {
                if (typeof WeakMap !== "function") return null;
                var t = new WeakMap;
                var r = new WeakMap;
                return (_getRequireWildcardCache = function(e) {
                    return e ? r : t
                })(e)
            }

            function _interopRequireWildcard(e, t) {
                if (!t && e && e.__esModule) {
                    return e
                }
                if (e === null || typeof e !== "object" && typeof e !== "function") {
                    return {
                        default: e
                    }
                }
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e)) {
                    return r.get(e)
                }
                var n = {};
                var i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in e) {
                    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
                        var s = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                        if (s && (s.get || s.set)) {
                            Object.defineProperty(n, o, s)
                        } else {
                            n[o] = e[o]
                        }
                    }
                }
                n.default = e;
                if (r) {
                    r.set(e, n)
                }
                return n
            }
            class ExcErrorListener {
                syntaxError(e, t, r, n, i, o) {
                    throw new SyntaxError("Syntax error at line " + r + ":" + n + ": " + i)
                }
            }

            function parse_tbnf(e, t) {
                var r = n.getfilename();
                try {
                    n.setfilename(t);
                    const l = s.CharStreams.fromString(e);
                    const _ = new i.TypedBNFLexer(l);
                    _.removeErrorListeners();
                    _.addErrorListener(new ExcErrorListener);
                    const u = new s.CommonTokenStream(_);
                    const c = new o.TypedBNFParser(u);
                    c.removeErrorListeners();
                    c.addErrorListener(new ExcErrorListener);
                    var a = c.start();
                    return a.result
                } finally {
                    n.setfilename(r)
                }
            }
        },
        9271: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TypedBNFLexer = void 0;
            var n = r(6027);
            var i = r(1740);
            var o = r(3262);
            var s = r(7847);
            var a = _interopRequireWildcard(r(2925));

            function _getRequireWildcardCache(e) {
                if (typeof WeakMap !== "function") return null;
                var t = new WeakMap;
                var r = new WeakMap;
                return (_getRequireWildcardCache = function(e) {
                    return e ? r : t
                })(e)
            }

            function _interopRequireWildcard(e, t) {
                if (!t && e && e.__esModule) {
                    return e
                }
                if (e === null || typeof e !== "object" && typeof e !== "function") {
                    return {
                        default: e
                    }
                }
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e)) {
                    return r.get(e)
                }
                var n = {};
                var i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in e) {
                    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
                        var s = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                        if (s && (s.get || s.set)) {
                            Object.defineProperty(n, o, s)
                        } else {
                            n[o] = e[o]
                        }
                    }
                }
                n.default = e;
                if (r) {
                    r.set(e, n)
                }
                return n
            }
            class TypedBNFLexer extends i.Lexer {
                constructor(e) {
                    super(e);
                    this._interp = new o.LexerATNSimulator(TypedBNFLexer._ATN, this)
                }
                get vocabulary() {
                    return TypedBNFLexer.VOCABULARY
                }
                get grammarFileName() {
                    return "TypedBNF.g4"
                }
                get ruleNames() {
                    return TypedBNFLexer.ruleNames
                }
                get serializedATN() {
                    return TypedBNFLexer._serializedATN
                }
                get channelNames() {
                    return TypedBNFLexer.channelNames
                }
                get modeNames() {
                    return TypedBNFLexer.modeNames
                }
                static get _ATN() {
                    if (!TypedBNFLexer.__ATN) {
                        TypedBNFLexer.__ATN = (new n.ATNDeserializer).deserialize(a.toCharArray(TypedBNFLexer._serializedATN))
                    }
                    return TypedBNFLexer.__ATN
                }
            }
            t.TypedBNFLexer = TypedBNFLexer;
            TypedBNFLexer.T__0 = 1;
            TypedBNFLexer.T__1 = 2;
            TypedBNFLexer.T__2 = 3;
            TypedBNFLexer.T__3 = 4;
            TypedBNFLexer.T__4 = 5;
            TypedBNFLexer.T__5 = 6;
            TypedBNFLexer.T__6 = 7;
            TypedBNFLexer.T__7 = 8;
            TypedBNFLexer.T__8 = 9;
            TypedBNFLexer.T__9 = 10;
            TypedBNFLexer.T__10 = 11;
            TypedBNFLexer.T__11 = 12;
            TypedBNFLexer.T__12 = 13;
            TypedBNFLexer.T__13 = 14;
            TypedBNFLexer.T__14 = 15;
            TypedBNFLexer.T__15 = 16;
            TypedBNFLexer.T__16 = 17;
            TypedBNFLexer.T__17 = 18;
            TypedBNFLexer.T__18 = 19;
            TypedBNFLexer.T__19 = 20;
            TypedBNFLexer.T__20 = 21;
            TypedBNFLexer.T__21 = 22;
            TypedBNFLexer.T__22 = 23;
            TypedBNFLexer.T__23 = 24;
            TypedBNFLexer.T__24 = 25;
            TypedBNFLexer.T__25 = 26;
            TypedBNFLexer.T__26 = 27;
            TypedBNFLexer.T__27 = 28;
            TypedBNFLexer.T__28 = 29;
            TypedBNFLexer.T__29 = 30;
            TypedBNFLexer.T__30 = 31;
            TypedBNFLexer.T__31 = 32;
            TypedBNFLexer.T__32 = 33;
            TypedBNFLexer.UNICODE_RANGE = 34;
            TypedBNFLexer.RANGE = 35;
            TypedBNFLexer.CNAMEPLUS = 36;
            TypedBNFLexer.INT = 37;
            TypedBNFLexer.WS = 38;
            TypedBNFLexer.FLOAT = 39;
            TypedBNFLexer.ESCAPED_STRING = 40;
            TypedBNFLexer.CPP_COMMENT = 41;
            TypedBNFLexer.C_COMMENT = 42;
            TypedBNFLexer.channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
            TypedBNFLexer.modeNames = ["DEFAULT_MODE"];
            TypedBNFLexer.ruleNames = ["T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", "T__7", "T__8", "T__9", "T__10", "T__11", "T__12", "T__13", "T__14", "T__15", "T__16", "T__17", "T__18", "T__19", "T__20", "T__21", "T__22", "T__23", "T__24", "T__25", "T__26", "T__27", "T__28", "T__29", "T__30", "T__31", "T__32", "UCODE", "UNICODE", "UNICODE_RANGE", "RANGE", "LCASE_LETTER", "UCASE_LETTER", "LETTER", "WORD", "CNAMEPLUS", "INT", "DIGIT", "WS", "FLOAT", "ESC", "ESCAPED_STRING", "CPP_COMMENT", "C_COMMENT"];
            TypedBNFLexer._LITERAL_NAMES = [undefined, "','", "'->'", "'('", "')'", "'<'", "'>'", "'*'", "'''", "':'", "'extern'", "'var'", "'case'", "'type'", "'ignore'", "'|'", "'{'", "'}'", "'let'", "'='", "'in'", "'fun'", "';'", "'$'", "'['", "']'", "'.'", "'true'", "'false'", "'+'", "'?'", "'!'", "'\\'", "'_'"];
            TypedBNFLexer._SYMBOLIC_NAMES = [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "UNICODE_RANGE", "RANGE", "CNAMEPLUS", "INT", "WS", "FLOAT", "ESCAPED_STRING", "CPP_COMMENT", "C_COMMENT"];
            TypedBNFLexer.VOCABULARY = new s.VocabularyImpl(TypedBNFLexer._LITERAL_NAMES, TypedBNFLexer._SYMBOLIC_NAMES, []);
            TypedBNFLexer._serializedATN = ",\b" + "\t\t\t\t\t" + "\t\b\t\b\t\t\t\n\t\n\v\t\v\f\t\f\r" + "\t\r\t\t\t\t\t" + "\t\t\t\t\t" + "\t\t\t\t\t" + '\t\t\t \t !\t!"\t' + "\"#\t#$\t$%\t%&\t&'\t'(\t()\t)*\t*" + "+\t+,\t,-\t-.\t./\t/0\t01\t12\t23\t3" + "" + "\b\b\t\t\n\n\v" + "\v\v\v\v\v\v\f\f\f\f\r" + "\r\r\r\r" + "" + "" + "" + "" + "" + '  !!!"' + '"###\n#$$$$$$$%%' + "%%%%&&&&&&''(" + "()))\n)**\n*\r**+++" + "\n+++++\n+\f++\v+,,\n,\r," + ",--....////\n//" + "//\n/0011111\n1\f1" + "1\v11122222\n2\f22\v" + "22222233333\n3\f33" + "\v3334\t" + "\v\r\b\t\n\v\f" + "\r!#" + "%')+-/13" + '579;= ?!A"C#E' + "GI$K%MOQSU&W" + "'Y[(])_a*c+e,\fC" + 'Hchc|C\\//aa2;\v\f""' + "GGgg\b$$^^cdppttvv$$^^\f\f" + "\t" + "\v\r" + "" + "" + "!" + "#%'" + ")+-" + "/135" + "79;" + "=?AC" + "IKU" + "W[]" + "aceg" + "il\tn" + "\vp\rrtv" + "xz" + "" + "!#" + "%')+" + "-/1" + "357" + "9;=?" + "ACE" + "GIKM" + "OQS" + "UWY" + "[]_" + "ace" + "gh.hij/jk@k" + "lm*m\bno+o\n" + "pq>q\frs@s" + "tu,uvw)w" + "xy<yz{g{|" + "z|}v}~g~t" + "pxc" + "te" + "cug" + "v{" + "rgk" + "ipq" + "tg" + '~ }"' + "$n" + "gv&" + "?(k" + "p*hw" + "p,=." + "&0]" + "2_4" + "06v" + "twg8" + "hcn" + "ug:-" + "<A>" + "#@^" + "fBaD" + "Y-\t" + "F^" + "wE#E#E#" + "E#H]G$" + "/G$_J" + "]\v/" + "\v_L" + "\tN\tP" + "O(M'" + "RQ)" + "" + "Ta" + "Q)" + "\tQ)Y-" + "" + "" + "VY-" + "" + "X\tZ" + "\t" + "\b.\\W," + "0W," + "\t\b" + "W," + "^\t\t`" + "$^" + "_0\n\n" + "" + "" + "$b" + "1," + "\v" + "" + "," + "1\b2" + "d11" + "\n\v" + "" + "" + "\b3f" + "" + ""
        },
        668: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TypedBNFParser = t.Type_productContext = t.Type_paramsContext = t.TypContext = t.Typ2Context = t.Tvar_strContext = t.TvarContext = t.ToplevelContext = t.Top_typContext = t.Start__y_Context = t.StartContext = t.Slist_o__i__u__i__s_lexer_and_p_Context = t.Slist_o__i__s__i__s_typ_p_Context = t.Slist_o__i__s__i__s_tvar_str_p_Context = t.Slist_o__i__s__i__s_psym_p_Context = t.Slist_o__i__s__i__s_param_type_p_Context = t.Slist_o__i__s__i__s_identstr_p_Context = t.Slist_o__i__s__i__s_field_ann_p_Context = t.Slist_o__i__s__i__s_expr_p_Context = t.Slist_o__i__s__i__s_ann_p_Context = t.PsymContext = t.ProductionsContext = t.ProductionContext = t.Param_typeContext = t.List_o_toplevel_p_Context = t.List_o_psym_p_Context = t.List_o_lexer_atomexpr_p_Context = t.LexerdefContext = t.Lexer_atomexprContext = t.Lexer_atomContext = t.Lexer_andContext = t.Lexer__y_Context = t.IdentstrContext = t.Func_parametersContext = t.Field_annsContext = t.Field_annContext = t.ExprContext = t.Eslist_o__i__s__i__s_param_type_p_Context = t.Eslist_o__i__s__i__s_field_ann_p_Context = t.Eslist_o__i__s__i__s_expr_p_Context = t.Eslist_o__i__s__i__s_ann_p_Context = t.Empty_o_slist_o__i__s__i__s_param_type_p__p_Context = t.Empty_o_slist_o__i__s__i__s_field_ann_p__p_Context = t.Empty_o_slist_o__i__s__i__s_expr_p__p_Context = t.Empty_o_slist_o__i__s__i__s_ann_p__p_Context = t.Empty_o_list_o_psym_p__p_Context = t.Elist_o_psym_p_Context = t.DefContext = t.DeclContext = t.CallContext = t.AtomexpContext = t.Arrow_typContext = t.AnnContext = void 0;
            var n = r(2004);
            var i = r(7747);
            var o = r(6027);
            var s = r(5575);
            var a = r(1914);
            var l = r(8871);
            var _ = r(9562);
            var u = r(9851);
            var c = r(8145);
            var d = r(7847);
            var p = _interopRequireWildcard(r(2925));

            function _getRequireWildcardCache(e) {
                if (typeof WeakMap !== "function") return null;
                var t = new WeakMap;
                var r = new WeakMap;
                return (_getRequireWildcardCache = function(e) {
                    return e ? r : t
                })(e)
            }

            function _interopRequireWildcard(e, t) {
                if (!t && e && e.__esModule) {
                    return e
                }
                if (e === null || typeof e !== "object" && typeof e !== "function") {
                    return {
                        default: e
                    }
                }
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e)) {
                    return r.get(e)
                }
                var n = {};
                var i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in e) {
                    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
                        var s = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                        if (s && (s.get || s.set)) {
                            Object.defineProperty(n, o, s)
                        } else {
                            n[o] = e[o]
                        }
                    }
                }
                n.default = e;
                if (r) {
                    r.set(e, n)
                }
                return n
            }
            class TypedBNFParser extends l.Parser {
                constructor(e) {
                    super(e);
                    this._interp = new u.ParserATNSimulator(TypedBNFParser._ATN, this)
                }
                get vocabulary() {
                    return TypedBNFParser.VOCABULARY
                }
                get grammarFileName() {
                    return "TypedBNF.g4"
                }
                get ruleNames() {
                    return TypedBNFParser.ruleNames
                }
                get serializedATN() {
                    return TypedBNFParser._serializedATN
                }
                createFailedPredicateException(e, t) {
                    return new s.FailedPredicateException(this, e, t)
                }
                start() {
                    let e = new StartContext(this._ctx, this.state);
                    this.enterRule(e, 0, TypedBNFParser.RULE_start);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 104;
                            e._v = this.start__y_();
                            this.state = 105;
                            this.match(TypedBNFParser.EOF);
                            e.result = e._v.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                list_o_toplevel_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new List_o_toplevel_p_Context(this._ctx, r);
                    let s = o;
                    let a = 2;
                    this.enterRecursionRule(o, 2, TypedBNFParser.RULE_list_o_toplevel_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 109;
                                o._list_o_toplevel_p__0__1 = this.toplevel();
                                o.result = [o._list_o_toplevel_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 118;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 0, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new List_o_toplevel_p_Context(t, r);
                                            o._list_o_toplevel_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_list_o_toplevel_p_);
                                            this.state = 112;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 113;
                                            o._list_o_toplevel_p__1__2 = this.toplevel();
                                            o.result = (0, n.addList)(o._list_o_toplevel_p__1__1.result, o._list_o_toplevel_p__1__2.result)
                                        }
                                    }
                                }
                                this.state = 120;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 0, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                start__y_() {
                    let e = new Start__y_Context(this._ctx, this.state);
                    this.enterRule(e, 4, TypedBNFParser.RULE_start__y_);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 121;
                            e._start__y__0__1 = this.list_o_toplevel_p_(0);
                            e.result = e._start__y__0__1.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                identstr() {
                    let e = new IdentstrContext(this._ctx, this.state);
                    this.enterRule(e, 6, TypedBNFParser.RULE_identstr);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 124;
                            e._identstr_0__1 = this.match(TypedBNFParser.CNAMEPLUS);
                            e.result = (0, n.str)(e._identstr_0__1)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                typ() {
                    let e = new TypContext(this._ctx, this.state);
                    this.enterRule(e, 8, TypedBNFParser.RULE_typ);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 127;
                            e._typ_0__1 = this.arrow_typ();
                            e.result = e._typ_0__1.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                slist_o__i__s__i__s_param_type_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__s__i__s_param_type_p_Context(this._ctx, r);
                    let s = o;
                    let a = 10;
                    this.enterRecursionRule(o, 10, TypedBNFParser.RULE_slist_o__i__s__i__s_param_type_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 131;
                                o._slist_o__i__s__i__s_param_type_p__0__1 = this.param_type();
                                o.result = [o._slist_o__i__s__i__s_param_type_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 141;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 1, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__s__i__s_param_type_p_Context(t, r);
                                            o._slist_o__i__s__i__s_param_type_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__s__i__s_param_type_p_);
                                            this.state = 134;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 135;
                                            this.match(TypedBNFParser.T__0);
                                            this.state = 136;
                                            o._slist_o__i__s__i__s_param_type_p__1__3 = this.param_type();
                                            o.result = (0, n.addList)(o._slist_o__i__s__i__s_param_type_p__1__1.result, o._slist_o__i__s__i__s_param_type_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 143;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 1, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                empty_o_slist_o__i__s__i__s_param_type_p__p_() {
                    let e = new Empty_o_slist_o__i__s__i__s_param_type_p__p_Context(this._ctx, this.state);
                    this.enterRule(e, 12, TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_param_type_p__p_);
                    try {
                        this.state = 148;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                            case TypedBNFParser.T__3:
                                this.enterOuterAlt(e, 1); {
                                    e.result = []
                                }
                                break;
                            case TypedBNFParser.T__2:
                            case TypedBNFParser.T__7:
                            case TypedBNFParser.CNAMEPLUS:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 145;
                                    e._empty_o_slist_o__i__s__i__s_param_type_p__p__1__1 = this.slist_o__i__s__i__s_param_type_p_(0);
                                    e.result = e._empty_o_slist_o__i__s__i__s_param_type_p__p__1__1.result
                                }
                                break;
                            default:
                                throw new a.NoViableAltException(this)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                eslist_o__i__s__i__s_param_type_p_() {
                    let e = new Eslist_o__i__s__i__s_param_type_p_Context(this._ctx, this.state);
                    this.enterRule(e, 14, TypedBNFParser.RULE_eslist_o__i__s__i__s_param_type_p_);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 150;
                            e._eslist_o__i__s__i__s_param_type_p__0__1 = this.empty_o_slist_o__i__s__i__s_param_type_p__p_();
                            e.result = e._eslist_o__i__s__i__s_param_type_p__0__1.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                arrow_typ() {
                    let e = new Arrow_typContext(this._ctx, this.state);
                    this.enterRule(e, 16, TypedBNFParser.RULE_arrow_typ);
                    try {
                        this.state = 168;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 3, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 153;
                                    e._arrow_typ_0__1 = this.typ2(0);
                                    this.state = 154;
                                    this.match(TypedBNFParser.T__1);
                                    this.state = 155;
                                    e._arrow_typ_0__3 = this.arrow_typ();
                                    e.result = (0, n.MK_TFun)([
                                        ["value", e._arrow_typ_0__1.result]
                                    ], e._arrow_typ_0__3.result)
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 158;
                                    this.match(TypedBNFParser.T__2);
                                    this.state = 159;
                                    e._arrow_typ_1__2 = this.eslist_o__i__s__i__s_param_type_p_();
                                    this.state = 160;
                                    this.match(TypedBNFParser.T__3);
                                    this.state = 161;
                                    this.match(TypedBNFParser.T__1);
                                    this.state = 162;
                                    e._arrow_typ_1__5 = this.arrow_typ();
                                    e.result = (0, n.MK_TFun)((0, n.process_tparam)(e._arrow_typ_1__2.result), e._arrow_typ_1__5.result)
                                }
                                break;
                            case 3:
                                this.enterOuterAlt(e, 3); {
                                    this.state = 165;
                                    e._arrow_typ_2__1 = this.type_product(0);
                                    e.result = (0, n.MK_TTuple)(e._arrow_typ_2__1.result)
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                slist_o__i__s__i__s_typ_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__s__i__s_typ_p_Context(this._ctx, r);
                    let s = o;
                    let a = 18;
                    this.enterRecursionRule(o, 18, TypedBNFParser.RULE_slist_o__i__s__i__s_typ_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 171;
                                o._slist_o__i__s__i__s_typ_p__0__1 = this.typ();
                                o.result = [o._slist_o__i__s__i__s_typ_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 181;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 4, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__s__i__s_typ_p_Context(t, r);
                                            o._slist_o__i__s__i__s_typ_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__s__i__s_typ_p_);
                                            this.state = 174;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 175;
                                            this.match(TypedBNFParser.T__0);
                                            this.state = 176;
                                            o._slist_o__i__s__i__s_typ_p__1__3 = this.typ();
                                            o.result = (0, n.addList)(o._slist_o__i__s__i__s_typ_p__1__1.result, o._slist_o__i__s__i__s_typ_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 183;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 4, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                typ2(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Typ2Context(this._ctx, r);
                    let s = o;
                    let l = 20;
                    this.enterRecursionRule(o, 20, TypedBNFParser.RULE_typ2, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            this.state = 190;
                            this._errHandler.sync(this);
                            switch (this._input.LA(1)) {
                                case TypedBNFParser.CNAMEPLUS: {
                                    this.state = 185;
                                    o._typ2_0__1 = this.match(TypedBNFParser.CNAMEPLUS);
                                    o.result = (0, n.MK_TConst)((0, n.str)(o._typ2_0__1))
                                }
                                break;
                            case TypedBNFParser.T__7: {
                                this.state = 187;
                                o._typ2_1__1 = this.tvar();
                                o.result = o._typ2_1__1.result
                            }
                            break;
                            default:
                                throw new a.NoViableAltException(this)
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 200;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 6, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Typ2Context(t, r);
                                            o._typ2_2__1 = s;
                                            this.pushNewRecursionContext(o, l, TypedBNFParser.RULE_typ2);
                                            this.state = 192;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 193;
                                            this.match(TypedBNFParser.T__4);
                                            this.state = 194;
                                            o._typ2_2__3 = this.slist_o__i__s__i__s_typ_p_(0);
                                            this.state = 195;
                                            this.match(TypedBNFParser.T__5);
                                            o.result = (0, n.MK_TApp)(o._typ2_2__1.result, o._typ2_2__3.result)
                                        }
                                    }
                                }
                                this.state = 202;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 6, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                type_product(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Type_productContext(this._ctx, r);
                    let s = o;
                    let a = 22;
                    this.enterRecursionRule(o, 22, TypedBNFParser.RULE_type_product, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 204;
                                o._type_product_1__1 = this.typ2(0);
                                o.result = [o._type_product_1__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 214;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 7, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Type_productContext(t, r);
                                            o._type_product_0__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_type_product);
                                            this.state = 207;
                                            if (!this.precpred(this._ctx, 2)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 2)")
                                            }
                                            this.state = 208;
                                            this.match(TypedBNFParser.T__6);
                                            this.state = 209;
                                            o._type_product_0__3 = this.typ2(0);
                                            o.result = (0, n.addList)(o._type_product_0__1.result, o._type_product_0__3.result)
                                        }
                                    }
                                }
                                this.state = 216;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 7, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                top_typ() {
                    let e = new Top_typContext(this._ctx, this.state);
                    this.enterRule(e, 24, TypedBNFParser.RULE_top_typ);
                    try {
                        this.state = 226;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                            case TypedBNFParser.T__4:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 217;
                                    this.match(TypedBNFParser.T__4);
                                    this.state = 218;
                                    e._top_typ_0__2 = this.slist_o__i__s__i__s_tvar_str_p_(0);
                                    this.state = 219;
                                    this.match(TypedBNFParser.T__5);
                                    this.state = 220;
                                    e._top_typ_0__4 = this.typ();
                                    e.result = (0, n.MK_Poly)(e._top_typ_0__2.result, e._top_typ_0__4.result)
                                }
                                break;
                            case TypedBNFParser.T__2:
                            case TypedBNFParser.T__7:
                            case TypedBNFParser.CNAMEPLUS:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 223;
                                    e._top_typ_1__1 = this.typ();
                                    e.result = (0, n.MK_Mono)(e._top_typ_1__1.result)
                                }
                                break;
                            default:
                                throw new a.NoViableAltException(this)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                tvar() {
                    let e = new TvarContext(this._ctx, this.state);
                    this.enterRule(e, 26, TypedBNFParser.RULE_tvar);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 228;
                            this.match(TypedBNFParser.T__7);
                            this.state = 229;
                            e._tvar_0__2 = this.match(TypedBNFParser.CNAMEPLUS);
                            e.result = (0, n.MK_TVar)((0, n.str)(e._tvar_0__2))
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                tvar_str() {
                    let e = new Tvar_strContext(this._ctx, this.state);
                    this.enterRule(e, 28, TypedBNFParser.RULE_tvar_str);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 232;
                            this.match(TypedBNFParser.T__7);
                            this.state = 233;
                            e._tvar_str_0__2 = this.match(TypedBNFParser.CNAMEPLUS);
                            e.result = (0, n.str)(e._tvar_str_0__2)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                param_type() {
                    let e = new Param_typeContext(this._ctx, this.state);
                    this.enterRule(e, 30, TypedBNFParser.RULE_param_type);
                    try {
                        this.state = 244;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 9, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 236;
                                    e._param_type_0__1 = this.match(TypedBNFParser.CNAMEPLUS);
                                    this.state = 237;
                                    this.match(TypedBNFParser.T__8);
                                    this.state = 238;
                                    e._param_type_0__3 = this.typ();
                                    e.result = [(0, n.str)(e._param_type_0__1), e._param_type_0__3.result]
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 241;
                                    e._param_type_1__1 = this.typ();
                                    e.result = ["_", e._param_type_1__1.result]
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                slist_o__i__s__i__s_tvar_str_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__s__i__s_tvar_str_p_Context(this._ctx, r);
                    let s = o;
                    let a = 32;
                    this.enterRecursionRule(o, 32, TypedBNFParser.RULE_slist_o__i__s__i__s_tvar_str_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 247;
                                o._slist_o__i__s__i__s_tvar_str_p__0__1 = this.tvar_str();
                                o.result = [o._slist_o__i__s__i__s_tvar_str_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 257;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 10, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__s__i__s_tvar_str_p_Context(t, r);
                                            o._slist_o__i__s__i__s_tvar_str_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__s__i__s_tvar_str_p_);
                                            this.state = 250;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 251;
                                            this.match(TypedBNFParser.T__0);
                                            this.state = 252;
                                            o._slist_o__i__s__i__s_tvar_str_p__1__3 = this.tvar_str();
                                            o.result = (0, n.addList)(o._slist_o__i__s__i__s_tvar_str_p__1__1.result, o._slist_o__i__s__i__s_tvar_str_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 259;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 10, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                type_params() {
                    let e = new Type_paramsContext(this._ctx, this.state);
                    this.enterRule(e, 34, TypedBNFParser.RULE_type_params);
                    try {
                        this.state = 266;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 11, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 260;
                                    this.match(TypedBNFParser.T__4);
                                    this.state = 261;
                                    e._type_params_0__2 = this.slist_o__i__s__i__s_tvar_str_p_(0);
                                    this.state = 262;
                                    this.match(TypedBNFParser.T__5);
                                    e.result = e._type_params_0__2.result
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    e.result = []
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                field_ann() {
                    let e = new Field_annContext(this._ctx, this.state);
                    this.enterRule(e, 36, TypedBNFParser.RULE_field_ann);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 268;
                            e._field_ann_0__1 = this.match(TypedBNFParser.CNAMEPLUS);
                            this.state = 269;
                            this.match(TypedBNFParser.T__8);
                            this.state = 270;
                            e._field_ann_0__3 = this.typ();
                            e.result = [(0, n.str)(e._field_ann_0__1), e._field_ann_0__3.result, (0, n.mkpos)(e._field_ann_0__1)]
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                slist_o__i__s__i__s_field_ann_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__s__i__s_field_ann_p_Context(this._ctx, r);
                    let s = o;
                    let a = 38;
                    this.enterRecursionRule(o, 38, TypedBNFParser.RULE_slist_o__i__s__i__s_field_ann_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 274;
                                o._slist_o__i__s__i__s_field_ann_p__0__1 = this.field_ann();
                                o.result = [o._slist_o__i__s__i__s_field_ann_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 284;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 12, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__s__i__s_field_ann_p_Context(t, r);
                                            o._slist_o__i__s__i__s_field_ann_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__s__i__s_field_ann_p_);
                                            this.state = 277;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 278;
                                            this.match(TypedBNFParser.T__0);
                                            this.state = 279;
                                            o._slist_o__i__s__i__s_field_ann_p__1__3 = this.field_ann();
                                            o.result = (0, n.addList)(o._slist_o__i__s__i__s_field_ann_p__1__1.result, o._slist_o__i__s__i__s_field_ann_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 286;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 12, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                empty_o_slist_o__i__s__i__s_field_ann_p__p_() {
                    let e = new Empty_o_slist_o__i__s__i__s_field_ann_p__p_Context(this._ctx, this.state);
                    this.enterRule(e, 40, TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_field_ann_p__p_);
                    try {
                        this.state = 291;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                            case TypedBNFParser.T__3:
                                this.enterOuterAlt(e, 1); {
                                    e.result = []
                                }
                                break;
                            case TypedBNFParser.CNAMEPLUS:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 288;
                                    e._empty_o_slist_o__i__s__i__s_field_ann_p__p__1__1 = this.slist_o__i__s__i__s_field_ann_p_(0);
                                    e.result = e._empty_o_slist_o__i__s__i__s_field_ann_p__p__1__1.result
                                }
                                break;
                            default:
                                throw new a.NoViableAltException(this)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                eslist_o__i__s__i__s_field_ann_p_() {
                    let e = new Eslist_o__i__s__i__s_field_ann_p_Context(this._ctx, this.state);
                    this.enterRule(e, 42, TypedBNFParser.RULE_eslist_o__i__s__i__s_field_ann_p_);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 293;
                            e._eslist_o__i__s__i__s_field_ann_p__0__1 = this.empty_o_slist_o__i__s__i__s_field_ann_p__p_();
                            e.result = e._eslist_o__i__s__i__s_field_ann_p__0__1.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                field_anns() {
                    let e = new Field_annsContext(this._ctx, this.state);
                    this.enterRule(e, 44, TypedBNFParser.RULE_field_anns);
                    try {
                        this.state = 302;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 14, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 296;
                                    this.match(TypedBNFParser.T__2);
                                    this.state = 297;
                                    e._field_anns_0__2 = this.eslist_o__i__s__i__s_field_ann_p_();
                                    this.state = 298;
                                    this.match(TypedBNFParser.T__3);
                                    e.result = [true, e._field_anns_0__2.result]
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    e.result = [false, []]
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                decl() {
                    let e = new DeclContext(this._ctx, this.state);
                    this.enterRule(e, 46, TypedBNFParser.RULE_decl);
                    try {
                        this.state = 330;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 15, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 304;
                                    this.match(TypedBNFParser.T__9);
                                    this.state = 305;
                                    e._decl_0__2 = this.match(TypedBNFParser.T__10);
                                    this.state = 306;
                                    e._decl_0__3 = this.identstr();
                                    this.state = 307;
                                    this.match(TypedBNFParser.T__8);
                                    this.state = 308;
                                    e._decl_0__5 = this.top_typ();
                                    e.result = (0, n.MK_Declvar)(e._decl_0__3.result, e._decl_0__5.result, (0, n.mkpos)(e._decl_0__2))
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 311;
                                    e._decl_1__1 = this.match(TypedBNFParser.T__11);
                                    this.state = 312;
                                    e._decl_1__2 = this.identstr();
                                    this.state = 313;
                                    this.match(TypedBNFParser.T__8);
                                    this.state = 314;
                                    e._decl_1__4 = this.typ();
                                    e.result = (0, n.MK_Declctor)(e._decl_1__2.result, e._decl_1__4.result, (0, n.mkpos)(e._decl_1__1))
                                }
                                break;
                            case 3:
                                this.enterOuterAlt(e, 3); {
                                    this.state = 317;
                                    e._decl_2__1 = this.match(TypedBNFParser.T__9);
                                    this.state = 318;
                                    this.match(TypedBNFParser.T__12);
                                    this.state = 319;
                                    e._decl_2__3 = this.identstr();
                                    this.state = 320;
                                    e._decl_2__4 = this.type_params();
                                    this.state = 321;
                                    e._decl_2__5 = this.field_anns();
                                    e.result = (0, n.MK_Decltype)(true, (0, n.fst)(e._decl_2__5.result), e._decl_2__3.result, e._decl_2__4.result, (0, n.snd)(e._decl_2__5.result), (0, n.mkpos)(e._decl_2__1))
                                }
                                break;
                            case 4:
                                this.enterOuterAlt(e, 4); {
                                    this.state = 324;
                                    e._decl_3__1 = this.match(TypedBNFParser.T__12);
                                    this.state = 325;
                                    e._decl_3__2 = this.identstr();
                                    this.state = 326;
                                    e._decl_3__3 = this.type_params();
                                    this.state = 327;
                                    e._decl_3__4 = this.field_anns();
                                    e.result = (0, n.MK_Decltype)(false, (0, n.fst)(e._decl_3__4.result), e._decl_3__2.result, e._decl_3__3.result, (0, n.snd)(e._decl_3__4.result), (0, n.mkpos)(e._decl_3__1))
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                toplevel() {
                    let e = new ToplevelContext(this._ctx, this.state);
                    this.enterRule(e, 48, TypedBNFParser.RULE_toplevel);
                    try {
                        this.state = 345;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 16, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 332;
                                    e._toplevel_0__1 = this.def();
                                    e.result = e._toplevel_0__1.result
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 335;
                                    e._toplevel_1__1 = this.decl();
                                    e.result = e._toplevel_1__1.result
                                }
                                break;
                            case 3:
                                this.enterOuterAlt(e, 3); {
                                    this.state = 338;
                                    e._toplevel_2__1 = this.lexerdef();
                                    e.result = e._toplevel_2__1.result
                                }
                                break;
                            case 4:
                                this.enterOuterAlt(e, 4); {
                                    this.state = 341;
                                    e._toplevel_3__1 = this.match(TypedBNFParser.T__13);
                                    this.state = 342;
                                    e._toplevel_3__2 = this.slist_o__i__s__i__s_identstr_p_(0);
                                    e.result = (0, n.MK_Defignore)(e._toplevel_3__2.result, (0, n.mkpos)(e._toplevel_3__1))
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                slist_o__i__s__i__s_identstr_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__s__i__s_identstr_p_Context(this._ctx, r);
                    let s = o;
                    let a = 50;
                    this.enterRecursionRule(o, 50, TypedBNFParser.RULE_slist_o__i__s__i__s_identstr_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 348;
                                o._slist_o__i__s__i__s_identstr_p__0__1 = this.identstr();
                                o.result = [o._slist_o__i__s__i__s_identstr_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 358;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 17, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__s__i__s_identstr_p_Context(t, r);
                                            o._slist_o__i__s__i__s_identstr_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__s__i__s_identstr_p_);
                                            this.state = 351;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 352;
                                            this.match(TypedBNFParser.T__0);
                                            this.state = 353;
                                            o._slist_o__i__s__i__s_identstr_p__1__3 = this.identstr();
                                            o.result = (0, n.addList)(o._slist_o__i__s__i__s_identstr_p__1__1.result, o._slist_o__i__s__i__s_identstr_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 360;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 17, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                def() {
                    let e = new DefContext(this._ctx, this.state);
                    this.enterRule(e, 52, TypedBNFParser.RULE_def);
                    try {
                        this.state = 372;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 18, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 361;
                                    e._def_0__1 = this.match(TypedBNFParser.CNAMEPLUS);
                                    this.state = 362;
                                    this.match(TypedBNFParser.T__2);
                                    this.state = 363;
                                    e._def_0__3 = this.slist_o__i__s__i__s_identstr_p_(0);
                                    this.state = 364;
                                    this.match(TypedBNFParser.T__3);
                                    this.state = 365;
                                    e._def_0__5 = this.productions(0);
                                    e.result = (0, n.MK_Defmacro)((0, n.str)(e._def_0__1), e._def_0__3.result, e._def_0__5.result, (0, n.mkpos)(e._def_0__1))
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 368;
                                    e._def_1__1 = this.match(TypedBNFParser.CNAMEPLUS);
                                    this.state = 369;
                                    e._def_1__2 = this.productions(0);
                                    e.result = (0, n.MK_Defrule)((0, n.str)(e._def_1__1), e._def_1__2.result, (0, n.mkpos)(e._def_1__1))
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                productions(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new ProductionsContext(this._ctx, r);
                    let s = o;
                    let a = 54;
                    this.enterRecursionRule(o, 54, TypedBNFParser.RULE_productions, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 375;
                                o._productions_0__1 = this.match(TypedBNFParser.T__8);
                                this.state = 376;
                                o._productions_0__2 = this.production();
                                o.result = [
                                    [(0, n.mkpos)(o._productions_0__1), o._productions_0__2.result]
                                ]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 386;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 19, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new ProductionsContext(t, r);
                                            o._productions_1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_productions);
                                            this.state = 379;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 380;
                                            o._productions_1__2 = this.match(TypedBNFParser.T__14);
                                            this.state = 381;
                                            o._productions_1__3 = this.production();
                                            o.result = (0, n.addList)(o._productions_1__1.result, [(0, n.mkpos)(o._productions_1__2), o._productions_1__3.result])
                                        }
                                    }
                                }
                                this.state = 388;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 19, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                list_o_psym_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new List_o_psym_p_Context(this._ctx, r);
                    let s = o;
                    let a = 56;
                    this.enterRecursionRule(o, 56, TypedBNFParser.RULE_list_o_psym_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 390;
                                o._list_o_psym_p__0__1 = this.psym();
                                o.result = [o._list_o_psym_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 399;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 20, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new List_o_psym_p_Context(t, r);
                                            o._list_o_psym_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_list_o_psym_p_);
                                            this.state = 393;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 394;
                                            o._list_o_psym_p__1__2 = this.psym();
                                            o.result = (0, n.addList)(o._list_o_psym_p__1__1.result, o._list_o_psym_p__1__2.result)
                                        }
                                    }
                                }
                                this.state = 401;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 20, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                empty_o_list_o_psym_p__p_() {
                    let e = new Empty_o_list_o_psym_p__p_Context(this._ctx, this.state);
                    this.enterRule(e, 58, TypedBNFParser.RULE_empty_o_list_o_psym_p__p_);
                    try {
                        this.state = 406;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                            case TypedBNFParser.T__15:
                                this.enterOuterAlt(e, 1); {
                                    e.result = []
                                }
                                break;
                            case TypedBNFParser.T__4:
                            case TypedBNFParser.CNAMEPLUS:
                            case TypedBNFParser.ESCAPED_STRING:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 403;
                                    e._empty_o_list_o_psym_p__p__1__1 = this.list_o_psym_p_(0);
                                    e.result = e._empty_o_list_o_psym_p__p__1__1.result
                                }
                                break;
                            default:
                                throw new a.NoViableAltException(this)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                elist_o_psym_p_() {
                    let e = new Elist_o_psym_p_Context(this._ctx, this.state);
                    this.enterRule(e, 60, TypedBNFParser.RULE_elist_o_psym_p_);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 408;
                            e._elist_o_psym_p__0__1 = this.empty_o_list_o_psym_p__p_();
                            e.result = e._elist_o_psym_p__0__1.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                production() {
                    let e = new ProductionContext(this._ctx, this.state);
                    this.enterRule(e, 62, TypedBNFParser.RULE_production);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 411;
                            e._production_0__1 = this.elist_o_psym_p_();
                            this.state = 412;
                            this.match(TypedBNFParser.T__15);
                            this.state = 413;
                            e._production_0__3 = this.expr();
                            this.state = 414;
                            this.match(TypedBNFParser.T__16);
                            e.result = (0, n.MK_production)(e._production_0__1.result, e._production_0__3.result)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                slist_o__i__s__i__s_psym_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__s__i__s_psym_p_Context(this._ctx, r);
                    let s = o;
                    let a = 64;
                    this.enterRecursionRule(o, 64, TypedBNFParser.RULE_slist_o__i__s__i__s_psym_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 418;
                                o._slist_o__i__s__i__s_psym_p__0__1 = this.psym();
                                o.result = [o._slist_o__i__s__i__s_psym_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 428;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 22, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__s__i__s_psym_p_Context(t, r);
                                            o._slist_o__i__s__i__s_psym_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__s__i__s_psym_p_);
                                            this.state = 421;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 422;
                                            this.match(TypedBNFParser.T__0);
                                            this.state = 423;
                                            o._slist_o__i__s__i__s_psym_p__1__3 = this.psym();
                                            o.result = (0, n.addList)(o._slist_o__i__s__i__s_psym_p__1__1.result, o._slist_o__i__s__i__s_psym_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 430;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 22, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                psym() {
                    let e = new PsymContext(this._ctx, this.state);
                    this.enterRule(e, 66, TypedBNFParser.RULE_psym);
                    try {
                        this.state = 447;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 23, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 431;
                                    this.match(TypedBNFParser.T__4);
                                    this.state = 432;
                                    e._psym_0__2 = this.identstr();
                                    this.state = 433;
                                    this.match(TypedBNFParser.T__5);
                                    e.result = (0, n.MK_Term)(e._psym_0__2.result, false)
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 436;
                                    e._psym_1__1 = this.match(TypedBNFParser.ESCAPED_STRING);
                                    e.result = (0, n.MK_Term)((0, n.unescape)((0, n.str)(e._psym_1__1)), true)
                                }
                                break;
                            case 3:
                                this.enterOuterAlt(e, 3); {
                                    this.state = 438;
                                    e._psym_2__1 = this.identstr();
                                    e.result = (0, n.MK_Nonterm)(e._psym_2__1.result)
                                }
                                break;
                            case 4:
                                this.enterOuterAlt(e, 4); {
                                    this.state = 441;
                                    e._psym_3__1 = this.match(TypedBNFParser.CNAMEPLUS);
                                    this.state = 442;
                                    this.match(TypedBNFParser.T__2);
                                    this.state = 443;
                                    e._psym_3__3 = this.slist_o__i__s__i__s_psym_p_(0);
                                    this.state = 444;
                                    this.match(TypedBNFParser.T__3);
                                    e.result = (0, n.MK_Macrocall)((0, n.str)(e._psym_3__1), e._psym_3__3.result, (0, n.mkpos)(e._psym_3__1))
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                ann() {
                    let e = new AnnContext(this._ctx, this.state);
                    this.enterRule(e, 68, TypedBNFParser.RULE_ann);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 449;
                            e._ann_0__1 = this.identstr();
                            this.state = 450;
                            this.match(TypedBNFParser.T__8);
                            this.state = 451;
                            e._ann_0__3 = this.typ();
                            e.result = [e._ann_0__1.result, e._ann_0__3.result]
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                slist_o__i__s__i__s_ann_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__s__i__s_ann_p_Context(this._ctx, r);
                    let s = o;
                    let a = 70;
                    this.enterRecursionRule(o, 70, TypedBNFParser.RULE_slist_o__i__s__i__s_ann_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 455;
                                o._slist_o__i__s__i__s_ann_p__0__1 = this.ann();
                                o.result = [o._slist_o__i__s__i__s_ann_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 465;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 24, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__s__i__s_ann_p_Context(t, r);
                                            o._slist_o__i__s__i__s_ann_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__s__i__s_ann_p_);
                                            this.state = 458;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 459;
                                            this.match(TypedBNFParser.T__0);
                                            this.state = 460;
                                            o._slist_o__i__s__i__s_ann_p__1__3 = this.ann();
                                            o.result = (0, n.addList)(o._slist_o__i__s__i__s_ann_p__1__1.result, o._slist_o__i__s__i__s_ann_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 467;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 24, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                empty_o_slist_o__i__s__i__s_ann_p__p_() {
                    let e = new Empty_o_slist_o__i__s__i__s_ann_p__p_Context(this._ctx, this.state);
                    this.enterRule(e, 72, TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_ann_p__p_);
                    try {
                        this.state = 472;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                            case TypedBNFParser.T__3:
                                this.enterOuterAlt(e, 1); {
                                    e.result = []
                                }
                                break;
                            case TypedBNFParser.CNAMEPLUS:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 469;
                                    e._empty_o_slist_o__i__s__i__s_ann_p__p__1__1 = this.slist_o__i__s__i__s_ann_p_(0);
                                    e.result = e._empty_o_slist_o__i__s__i__s_ann_p__p__1__1.result
                                }
                                break;
                            default:
                                throw new a.NoViableAltException(this)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                eslist_o__i__s__i__s_ann_p_() {
                    let e = new Eslist_o__i__s__i__s_ann_p_Context(this._ctx, this.state);
                    this.enterRule(e, 74, TypedBNFParser.RULE_eslist_o__i__s__i__s_ann_p_);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 474;
                            e._eslist_o__i__s__i__s_ann_p__0__1 = this.empty_o_slist_o__i__s__i__s_ann_p__p_();
                            e.result = e._eslist_o__i__s__i__s_ann_p__0__1.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                func_parameters() {
                    let e = new Func_parametersContext(this._ctx, this.state);
                    this.enterRule(e, 76, TypedBNFParser.RULE_func_parameters);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 477;
                            this.match(TypedBNFParser.T__2);
                            this.state = 478;
                            e._func_parameters_0__2 = this.eslist_o__i__s__i__s_ann_p_();
                            this.state = 479;
                            this.match(TypedBNFParser.T__3);
                            e.result = e._func_parameters_0__2.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                expr() {
                    let e = new ExprContext(this._ctx, this.state);
                    this.enterRule(e, 78, TypedBNFParser.RULE_expr);
                    try {
                        this.state = 504;
                        this._errHandler.sync(this);
                        switch (this.interpreter.adaptivePredict(this._input, 26, this._ctx)) {
                            case 1:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 482;
                                    e._expr_0__1 = this.match(TypedBNFParser.T__17);
                                    this.state = 483;
                                    e._expr_0__2 = this.identstr();
                                    this.state = 484;
                                    this.match(TypedBNFParser.T__18);
                                    this.state = 485;
                                    e._expr_0__4 = this.expr();
                                    this.state = 486;
                                    this.match(TypedBNFParser.T__19);
                                    this.state = 487;
                                    e._expr_0__6 = this.expr();
                                    e.result = (0, n.MK_Expr)((0, n.MK_ELet)(e._expr_0__2.result, e._expr_0__4.result, e._expr_0__6.result), (0, n.mkpos)(e._expr_0__1))
                                }
                                break;
                            case 2:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 490;
                                    e._expr_1__1 = this.match(TypedBNFParser.T__20);
                                    this.state = 491;
                                    e._expr_1__2 = this.func_parameters();
                                    this.state = 492;
                                    this.match(TypedBNFParser.T__1);
                                    this.state = 493;
                                    e._expr_1__4 = this.expr();
                                    e.result = (0, n.MK_Expr)((0, n.MK_EFun)(e._expr_1__2.result, e._expr_1__4.result), (0, n.mkpos)(e._expr_1__1))
                                }
                                break;
                            case 3:
                                this.enterOuterAlt(e, 3); {
                                    this.state = 496;
                                    e._expr_2__1 = this.call(0);
                                    e.result = e._expr_2__1.result
                                }
                                break;
                            case 4:
                                this.enterOuterAlt(e, 4); {
                                    this.state = 499;
                                    e._expr_3__1 = this.call(0);
                                    this.state = 500;
                                    this.match(TypedBNFParser.T__21);
                                    this.state = 501;
                                    e._expr_3__3 = this.expr();
                                    e.result = (0, n.MK_Expr)((0, n.MK_ELet)("_", e._expr_3__1.result, e._expr_3__3.result), (0, n.getpos)(e._expr_3__1.result))
                                }
                                break
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                call(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new CallContext(this._ctx, r);
                    let s = o;
                    let a = 80;
                    this.enterRecursionRule(o, 80, TypedBNFParser.RULE_call, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 507;
                                o._call_1__1 = this.atomexp(0);
                                o.result = o._call_1__1.result
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 518;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 27, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new CallContext(t, r);
                                            o._call_0__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_call);
                                            this.state = 510;
                                            if (!this.precpred(this._ctx, 2)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 2)")
                                            }
                                            this.state = 511;
                                            this.match(TypedBNFParser.T__2);
                                            this.state = 512;
                                            o._call_0__3 = this.eslist_o__i__s__i__s_expr_p_();
                                            this.state = 513;
                                            this.match(TypedBNFParser.T__3);
                                            o.result = (0, n.MK_Expr)((0, n.MK_EApp)(o._call_0__1.result, o._call_0__3.result), (0, n.getpos)(o._call_0__1.result))
                                        }
                                    }
                                }
                                this.state = 520;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 27, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                empty_o_slist_o__i__s__i__s_expr_p__p_() {
                    let e = new Empty_o_slist_o__i__s__i__s_expr_p__p_Context(this._ctx, this.state);
                    this.enterRule(e, 82, TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_expr_p__p_);
                    try {
                        this.state = 525;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                            case TypedBNFParser.T__3:
                            case TypedBNFParser.T__24:
                                this.enterOuterAlt(e, 1); {
                                    e.result = []
                                }
                                break;
                            case TypedBNFParser.T__2:
                            case TypedBNFParser.T__17:
                            case TypedBNFParser.T__20:
                            case TypedBNFParser.T__22:
                            case TypedBNFParser.T__23:
                            case TypedBNFParser.T__26:
                            case TypedBNFParser.T__27:
                            case TypedBNFParser.CNAMEPLUS:
                            case TypedBNFParser.INT:
                            case TypedBNFParser.FLOAT:
                            case TypedBNFParser.ESCAPED_STRING:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 522;
                                    e._empty_o_slist_o__i__s__i__s_expr_p__p__1__1 = this.slist_o__i__s__i__s_expr_p_(0);
                                    e.result = e._empty_o_slist_o__i__s__i__s_expr_p__p__1__1.result
                                }
                                break;
                            default:
                                throw new a.NoViableAltException(this)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                eslist_o__i__s__i__s_expr_p_() {
                    let e = new Eslist_o__i__s__i__s_expr_p_Context(this._ctx, this.state);
                    this.enterRule(e, 84, TypedBNFParser.RULE_eslist_o__i__s__i__s_expr_p_);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 527;
                            e._eslist_o__i__s__i__s_expr_p__0__1 = this.empty_o_slist_o__i__s__i__s_expr_p__p_();
                            e.result = e._eslist_o__i__s__i__s_expr_p__0__1.result
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                slist_o__i__s__i__s_expr_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__s__i__s_expr_p_Context(this._ctx, r);
                    let s = o;
                    let a = 86;
                    this.enterRecursionRule(o, 86, TypedBNFParser.RULE_slist_o__i__s__i__s_expr_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 531;
                                o._slist_o__i__s__i__s_expr_p__0__1 = this.expr();
                                o.result = [o._slist_o__i__s__i__s_expr_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 541;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 29, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__s__i__s_expr_p_Context(t, r);
                                            o._slist_o__i__s__i__s_expr_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__s__i__s_expr_p_);
                                            this.state = 534;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 535;
                                            this.match(TypedBNFParser.T__0);
                                            this.state = 536;
                                            o._slist_o__i__s__i__s_expr_p__1__3 = this.expr();
                                            o.result = (0, n.addList)(o._slist_o__i__s__i__s_expr_p__1__1.result, o._slist_o__i__s__i__s_expr_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 543;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 29, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                atomexp(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new AtomexpContext(this._ctx, r);
                    let s = o;
                    let a = 88;
                    this.enterRecursionRule(o, 88, TypedBNFParser.RULE_atomexp, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            this.state = 573;
                            this._errHandler.sync(this);
                            switch (this.interpreter.adaptivePredict(this._input, 30, this._ctx)) {
                                case 1: {
                                    this.state = 545;
                                    o._atomexp_0__1 = this.match(TypedBNFParser.INT);
                                    o.result = (0, n.MK_Expr)((0, n.MK_EInt)((0, n.toint)(o._atomexp_0__1)), (0, n.mkpos)(o._atomexp_0__1))
                                }
                                break;
                            case 2: {
                                this.state = 547;
                                o._atomexp_1__1 = this.match(TypedBNFParser.FLOAT);
                                o.result = (0, n.MK_Expr)((0, n.MK_EFlt)((0, n.tofloat)(o._atomexp_1__1)), (0, n.mkpos)(o._atomexp_1__1))
                            }
                            break;
                            case 3: {
                                this.state = 549;
                                o._atomexp_2__1 = this.match(TypedBNFParser.ESCAPED_STRING);
                                o.result = (0, n.MK_Expr)((0, n.MK_EStr)((0, n.unescape)((0, n.str)(o._atomexp_2__1))), (0, n.mkpos)(o._atomexp_2__1))
                            }
                            break;
                            case 4: {
                                this.state = 551;
                                o._atomexp_3__1 = this.match(TypedBNFParser.T__22);
                                this.state = 552;
                                o._atomexp_3__2 = this.match(TypedBNFParser.INT);
                                o.result = (0, n.MK_Expr)((0, n.MK_ESlot)((0, n.toint)(o._atomexp_3__2)), (0, n.mkpos)(o._atomexp_3__1))
                            }
                            break;
                            case 5: {
                                this.state = 554;
                                o._atomexp_4__1 = this.match(TypedBNFParser.T__23);
                                this.state = 555;
                                o._atomexp_4__2 = this.eslist_o__i__s__i__s_expr_p_();
                                this.state = 556;
                                this.match(TypedBNFParser.T__24);
                                o.result = (0, n.MK_Expr)((0, n.MK_EList)(o._atomexp_4__2.result), (0, n.mkpos)(o._atomexp_4__1))
                            }
                            break;
                            case 6: {
                                this.state = 559;
                                o._atomexp_5__1 = this.match(TypedBNFParser.T__2);
                                this.state = 560;
                                this.match(TypedBNFParser.T__3);
                                o.result = (0, n.MK_Expr)((0, n.MK_ETuple)([]), (0, n.mkpos)(o._atomexp_5__1))
                            }
                            break;
                            case 7: {
                                this.state = 562;
                                o._atomexp_6__1 = this.match(TypedBNFParser.T__2);
                                this.state = 563;
                                o._atomexp_6__2 = this.slist_o__i__s__i__s_expr_p_(0);
                                this.state = 564;
                                this.match(TypedBNFParser.T__3);
                                o.result = (0, n.MK_Expr)((0, n.MK_ETuple)(o._atomexp_6__2.result), (0, n.mkpos)(o._atomexp_6__1))
                            }
                            break;
                            case 8: {
                                this.state = 567;
                                o._atomexp_7__1 = this.match(TypedBNFParser.CNAMEPLUS);
                                o.result = (0, n.MK_Expr)((0, n.MK_EVar)((0, n.str)(o._atomexp_7__1)), (0, n.mkpos)(o._atomexp_7__1))
                            }
                            break;
                            case 9: {
                                this.state = 569;
                                o._atomexp_9__1 = this.match(TypedBNFParser.T__26);
                                o.result = (0, n.MK_Expr)((0, n.MK_EBool)(true), (0, n.mkpos)(o._atomexp_9__1))
                            }
                            break;
                            case 10: {
                                this.state = 571;
                                o._atomexp_10__1 = this.match(TypedBNFParser.T__27);
                                o.result = (0, n.MK_Expr)((0, n.MK_EBool)(false), (0, n.mkpos)(o._atomexp_10__1))
                            }
                            break
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 581;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 31, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new AtomexpContext(t, r);
                                            o._atomexp_8__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_atomexp);
                                            this.state = 575;
                                            if (!this.precpred(this._ctx, 3)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 3)")
                                            }
                                            this.state = 576;
                                            this.match(TypedBNFParser.T__25);
                                            this.state = 577;
                                            o._atomexp_8__3 = this.match(TypedBNFParser.CNAMEPLUS);
                                            o.result = (0, n.MK_Expr)((0, n.MK_EField)(o._atomexp_8__1.result, (0, n.str)(o._atomexp_8__3)), (0, n.getpos)(o._atomexp_8__1.result))
                                        }
                                    }
                                }
                                this.state = 583;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 31, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                slist_o__i__u__i__s_lexer_and_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Slist_o__i__u__i__s_lexer_and_p_Context(this._ctx, r);
                    let s = o;
                    let a = 90;
                    this.enterRecursionRule(o, 90, TypedBNFParser.RULE_slist_o__i__u__i__s_lexer_and_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 585;
                                o._slist_o__i__u__i__s_lexer_and_p__0__1 = this.lexer_and();
                                o.result = [o._slist_o__i__u__i__s_lexer_and_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 595;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 32, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new Slist_o__i__u__i__s_lexer_and_p_Context(t, r);
                                            o._slist_o__i__u__i__s_lexer_and_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_slist_o__i__u__i__s_lexer_and_p_);
                                            this.state = 588;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 589;
                                            this.match(TypedBNFParser.T__14);
                                            this.state = 590;
                                            o._slist_o__i__u__i__s_lexer_and_p__1__3 = this.lexer_and();
                                            o.result = (0, n.addList)(o._slist_o__i__u__i__s_lexer_and_p__1__1.result, o._slist_o__i__u__i__s_lexer_and_p__1__3.result)
                                        }
                                    }
                                }
                                this.state = 597;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 32, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                lexer__y_() {
                    let e = new Lexer__y_Context(this._ctx, this.state);
                    this.enterRule(e, 92, TypedBNFParser.RULE_lexer__y_);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 598;
                            e._lexer__y__0__1 = this.slist_o__i__u__i__s_lexer_and_p_(0);
                            e.result = (0, n.MK_LOr)(e._lexer__y__0__1.result)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                list_o_lexer_atomexpr_p_(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new List_o_lexer_atomexpr_p_Context(this._ctx, r);
                    let s = o;
                    let a = 94;
                    this.enterRecursionRule(o, 94, TypedBNFParser.RULE_list_o_lexer_atomexpr_p_, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 602;
                                o._list_o_lexer_atomexpr_p__0__1 = this.lexer_atomexpr(0);
                                o.result = [o._list_o_lexer_atomexpr_p__0__1.result]
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 611;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 33, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        {
                                            o = new List_o_lexer_atomexpr_p_Context(t, r);
                                            o._list_o_lexer_atomexpr_p__1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_list_o_lexer_atomexpr_p_);
                                            this.state = 605;
                                            if (!this.precpred(this._ctx, 1)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 1)")
                                            }
                                            this.state = 606;
                                            o._list_o_lexer_atomexpr_p__1__2 = this.lexer_atomexpr(0);
                                            o.result = (0, n.addList)(o._list_o_lexer_atomexpr_p__1__1.result, o._list_o_lexer_atomexpr_p__1__2.result)
                                        }
                                    }
                                }
                                this.state = 613;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 33, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                lexer_and() {
                    let e = new Lexer_andContext(this._ctx, this.state);
                    this.enterRule(e, 96, TypedBNFParser.RULE_lexer_and);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 614;
                            e._lexer_and_0__1 = this.list_o_lexer_atomexpr_p_(0);
                            e.result = (0, n.MK_LSeq)(e._lexer_and_0__1.result)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                lexer_atomexpr(e) {
                    if (e === undefined) {
                        e = 0
                    }
                    let t = this._ctx;
                    let r = this.state;
                    let o = new Lexer_atomexprContext(this._ctx, r);
                    let s = o;
                    let a = 98;
                    this.enterRecursionRule(o, 98, TypedBNFParser.RULE_lexer_atomexpr, e);
                    try {
                        let e;
                        this.enterOuterAlt(o, 1); {
                            {
                                this.state = 618;
                                o._lexer_atomexpr_3__1 = this.lexer_atom();
                                o.result = o._lexer_atomexpr_3__1.result
                            }
                            this._ctx._stop = this._input.tryLT(-1);
                            this.state = 632;
                            this._errHandler.sync(this);
                            e = this.interpreter.adaptivePredict(this._input, 35, this._ctx);
                            while (e !== 2 && e !== i.ATN.INVALID_ALT_NUMBER) {
                                if (e === 1) {
                                    if (this._parseListeners != null) {
                                        this.triggerExitRuleEvent()
                                    }
                                    s = o; {
                                        this.state = 630;
                                        this._errHandler.sync(this);
                                        switch (this.interpreter.adaptivePredict(this._input, 34, this._ctx)) {
                                            case 1: {
                                                o = new Lexer_atomexprContext(t, r);
                                                o._lexer_atomexpr_0__1 = s;
                                                this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_lexer_atomexpr);
                                                this.state = 621;
                                                if (!this.precpred(this._ctx, 4)) {
                                                    throw this.createFailedPredicateException("this.precpred(this._ctx, 4)")
                                                }
                                                this.state = 622;
                                                this.match(TypedBNFParser.T__28);
                                                o.result = (0, n.MK_LPlus)(o._lexer_atomexpr_0__1.result)
                                            }
                                            break;
                                        case 2: {
                                            o = new Lexer_atomexprContext(t, r);
                                            o._lexer_atomexpr_1__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_lexer_atomexpr);
                                            this.state = 624;
                                            if (!this.precpred(this._ctx, 3)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 3)")
                                            }
                                            this.state = 625;
                                            this.match(TypedBNFParser.T__6);
                                            o.result = (0, n.MK_LStar)(o._lexer_atomexpr_1__1.result)
                                        }
                                        break;
                                        case 3: {
                                            o = new Lexer_atomexprContext(t, r);
                                            o._lexer_atomexpr_2__1 = s;
                                            this.pushNewRecursionContext(o, a, TypedBNFParser.RULE_lexer_atomexpr);
                                            this.state = 627;
                                            if (!this.precpred(this._ctx, 2)) {
                                                throw this.createFailedPredicateException("this.precpred(this._ctx, 2)")
                                            }
                                            this.state = 628;
                                            this.match(TypedBNFParser.T__29);
                                            o.result = (0, n.MK_LOptional)(o._lexer_atomexpr_2__1.result)
                                        }
                                        break
                                        }
                                    }
                                }
                                this.state = 634;
                                this._errHandler.sync(this);
                                e = this.interpreter.adaptivePredict(this._input, 35, this._ctx)
                            }
                        }
                    } catch (e) {
                        if (e instanceof c.RecognitionException) {
                            o.exception = e;
                            this._errHandler.reportError(this, e);
                            this._errHandler.recover(this, e)
                        } else {
                            throw e
                        }
                    } finally {
                        this.unrollRecursionContexts(t)
                    }
                    return o
                }
                lexer_atom() {
                    let e = new Lexer_atomContext(this._ctx, this.state);
                    this.enterRule(e, 100, TypedBNFParser.RULE_lexer_atom);
                    try {
                        this.state = 658;
                        this._errHandler.sync(this);
                        switch (this._input.LA(1)) {
                            case TypedBNFParser.ESCAPED_STRING:
                                this.enterOuterAlt(e, 1); {
                                    this.state = 635;
                                    e._lexer_atom_0__1 = this.match(TypedBNFParser.ESCAPED_STRING);
                                    e.result = (0, n.MK_LStr)((0, n.unescape)((0, n.str)(e._lexer_atom_0__1)))
                                }
                                break;
                            case TypedBNFParser.T__30:
                                this.enterOuterAlt(e, 2); {
                                    this.state = 637;
                                    this.match(TypedBNFParser.T__30);
                                    this.state = 638;
                                    e._lexer_atom_1__2 = this.lexer_atom();
                                    e.result = (0, n.MK_LNot)(e._lexer_atom_1__2.result)
                                }
                                break;
                            case TypedBNFParser.T__2:
                                this.enterOuterAlt(e, 3); {
                                    this.state = 641;
                                    this.match(TypedBNFParser.T__2);
                                    this.state = 642;
                                    e._lexer_atom_2__2 = this.lexer__y_();
                                    this.state = 643;
                                    this.match(TypedBNFParser.T__3);
                                    e.result = (0, n.MK_LGroup)(e._lexer_atom_2__2.result)
                                }
                                break;
                            case TypedBNFParser.T__31:
                                this.enterOuterAlt(e, 4); {
                                    this.state = 646;
                                    this.match(TypedBNFParser.T__31);
                                    e.result = n.MK_LNumber
                                }
                                break;
                            case TypedBNFParser.RANGE:
                                this.enterOuterAlt(e, 5); {
                                    this.state = 648;
                                    e._lexer_atom_4__1 = this.match(TypedBNFParser.RANGE);
                                    e.result = (0, n.getrange)((0, n.str)(e._lexer_atom_4__1))
                                }
                                break;
                            case TypedBNFParser.UNICODE_RANGE:
                                this.enterOuterAlt(e, 6); {
                                    this.state = 650;
                                    e._lexer_atom_5__1 = this.match(TypedBNFParser.UNICODE_RANGE);
                                    e.result = (0, n.getunicoderange)((0, n.str)(e._lexer_atom_5__1))
                                }
                                break;
                            case TypedBNFParser.T__32:
                                this.enterOuterAlt(e, 7); {
                                    this.state = 652;
                                    this.match(TypedBNFParser.T__32);
                                    e.result = n.MK_LWildcard
                                }
                                break;
                            case TypedBNFParser.T__25:
                                this.enterOuterAlt(e, 8); {
                                    this.state = 654;
                                    this.match(TypedBNFParser.T__25);
                                    e.result = n.MK_LWildcard
                                }
                                break;
                            case TypedBNFParser.CNAMEPLUS:
                                this.enterOuterAlt(e, 9); {
                                    this.state = 656;
                                    e._lexer_atom_8__1 = this.match(TypedBNFParser.CNAMEPLUS);
                                    e.result = (0, n.MK_LRef)((0, n.str)(e._lexer_atom_8__1))
                                }
                                break;
                            default:
                                throw new a.NoViableAltException(this)
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                lexerdef() {
                    let e = new LexerdefContext(this._ctx, this.state);
                    this.enterRule(e, 102, TypedBNFParser.RULE_lexerdef);
                    try {
                        this.enterOuterAlt(e, 1); {
                            this.state = 660;
                            e._lexerdef_0__1 = this.match(TypedBNFParser.CNAMEPLUS);
                            this.state = 661;
                            this.match(TypedBNFParser.T__18);
                            this.state = 662;
                            e._lexerdef_0__3 = this.lexer__y_();
                            this.state = 663;
                            this.match(TypedBNFParser.T__21);
                            e.result = (0, n.MK_Deflexer)((0, n.str)(e._lexerdef_0__1), e._lexerdef_0__3.result, (0, n.mkpos)(e._lexerdef_0__1))
                        }
                    } catch (t) {
                        if (t instanceof c.RecognitionException) {
                            e.exception = t;
                            this._errHandler.reportError(this, t);
                            this._errHandler.recover(this, t)
                        } else {
                            throw t
                        }
                    } finally {
                        this.exitRule()
                    }
                    return e
                }
                sempred(e, t, r) {
                    switch (t) {
                        case 1:
                            return this.list_o_toplevel_p__sempred(e, r);
                        case 5:
                            return this.slist_o__i__s__i__s_param_type_p__sempred(e, r);
                        case 9:
                            return this.slist_o__i__s__i__s_typ_p__sempred(e, r);
                        case 10:
                            return this.typ2_sempred(e, r);
                        case 11:
                            return this.type_product_sempred(e, r);
                        case 16:
                            return this.slist_o__i__s__i__s_tvar_str_p__sempred(e, r);
                        case 19:
                            return this.slist_o__i__s__i__s_field_ann_p__sempred(e, r);
                        case 25:
                            return this.slist_o__i__s__i__s_identstr_p__sempred(e, r);
                        case 27:
                            return this.productions_sempred(e, r);
                        case 28:
                            return this.list_o_psym_p__sempred(e, r);
                        case 32:
                            return this.slist_o__i__s__i__s_psym_p__sempred(e, r);
                        case 35:
                            return this.slist_o__i__s__i__s_ann_p__sempred(e, r);
                        case 40:
                            return this.call_sempred(e, r);
                        case 43:
                            return this.slist_o__i__s__i__s_expr_p__sempred(e, r);
                        case 44:
                            return this.atomexp_sempred(e, r);
                        case 45:
                            return this.slist_o__i__u__i__s_lexer_and_p__sempred(e, r);
                        case 47:
                            return this.list_o_lexer_atomexpr_p__sempred(e, r);
                        case 49:
                            return this.lexer_atomexpr_sempred(e, r)
                    }
                    return true
                }
                list_o_toplevel_p__sempred(e, t) {
                    switch (t) {
                        case 0:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                slist_o__i__s__i__s_param_type_p__sempred(e, t) {
                    switch (t) {
                        case 1:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                slist_o__i__s__i__s_typ_p__sempred(e, t) {
                    switch (t) {
                        case 2:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                typ2_sempred(e, t) {
                    switch (t) {
                        case 3:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                type_product_sempred(e, t) {
                    switch (t) {
                        case 4:
                            return this.precpred(this._ctx, 2)
                    }
                    return true
                }
                slist_o__i__s__i__s_tvar_str_p__sempred(e, t) {
                    switch (t) {
                        case 5:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                slist_o__i__s__i__s_field_ann_p__sempred(e, t) {
                    switch (t) {
                        case 6:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                slist_o__i__s__i__s_identstr_p__sempred(e, t) {
                    switch (t) {
                        case 7:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                productions_sempred(e, t) {
                    switch (t) {
                        case 8:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                list_o_psym_p__sempred(e, t) {
                    switch (t) {
                        case 9:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                slist_o__i__s__i__s_psym_p__sempred(e, t) {
                    switch (t) {
                        case 10:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                slist_o__i__s__i__s_ann_p__sempred(e, t) {
                    switch (t) {
                        case 11:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                call_sempred(e, t) {
                    switch (t) {
                        case 12:
                            return this.precpred(this._ctx, 2)
                    }
                    return true
                }
                slist_o__i__s__i__s_expr_p__sempred(e, t) {
                    switch (t) {
                        case 13:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                atomexp_sempred(e, t) {
                    switch (t) {
                        case 14:
                            return this.precpred(this._ctx, 3)
                    }
                    return true
                }
                slist_o__i__u__i__s_lexer_and_p__sempred(e, t) {
                    switch (t) {
                        case 15:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                list_o_lexer_atomexpr_p__sempred(e, t) {
                    switch (t) {
                        case 16:
                            return this.precpred(this._ctx, 1)
                    }
                    return true
                }
                lexer_atomexpr_sempred(e, t) {
                    switch (t) {
                        case 17:
                            return this.precpred(this._ctx, 4);
                        case 18:
                            return this.precpred(this._ctx, 3);
                        case 19:
                            return this.precpred(this._ctx, 2)
                    }
                    return true
                }
                static get _ATN() {
                    if (!TypedBNFParser.__ATN) {
                        TypedBNFParser.__ATN = (new o.ATNDeserializer).deserialize(p.toCharArray(TypedBNFParser._serializedATN))
                    }
                    return TypedBNFParser.__ATN
                }
            }
            t.TypedBNFParser = TypedBNFParser;
            TypedBNFParser.T__0 = 1;
            TypedBNFParser.T__1 = 2;
            TypedBNFParser.T__2 = 3;
            TypedBNFParser.T__3 = 4;
            TypedBNFParser.T__4 = 5;
            TypedBNFParser.T__5 = 6;
            TypedBNFParser.T__6 = 7;
            TypedBNFParser.T__7 = 8;
            TypedBNFParser.T__8 = 9;
            TypedBNFParser.T__9 = 10;
            TypedBNFParser.T__10 = 11;
            TypedBNFParser.T__11 = 12;
            TypedBNFParser.T__12 = 13;
            TypedBNFParser.T__13 = 14;
            TypedBNFParser.T__14 = 15;
            TypedBNFParser.T__15 = 16;
            TypedBNFParser.T__16 = 17;
            TypedBNFParser.T__17 = 18;
            TypedBNFParser.T__18 = 19;
            TypedBNFParser.T__19 = 20;
            TypedBNFParser.T__20 = 21;
            TypedBNFParser.T__21 = 22;
            TypedBNFParser.T__22 = 23;
            TypedBNFParser.T__23 = 24;
            TypedBNFParser.T__24 = 25;
            TypedBNFParser.T__25 = 26;
            TypedBNFParser.T__26 = 27;
            TypedBNFParser.T__27 = 28;
            TypedBNFParser.T__28 = 29;
            TypedBNFParser.T__29 = 30;
            TypedBNFParser.T__30 = 31;
            TypedBNFParser.T__31 = 32;
            TypedBNFParser.T__32 = 33;
            TypedBNFParser.UNICODE_RANGE = 34;
            TypedBNFParser.RANGE = 35;
            TypedBNFParser.CNAMEPLUS = 36;
            TypedBNFParser.INT = 37;
            TypedBNFParser.WS = 38;
            TypedBNFParser.FLOAT = 39;
            TypedBNFParser.ESCAPED_STRING = 40;
            TypedBNFParser.CPP_COMMENT = 41;
            TypedBNFParser.C_COMMENT = 42;
            TypedBNFParser.RULE_start = 0;
            TypedBNFParser.RULE_list_o_toplevel_p_ = 1;
            TypedBNFParser.RULE_start__y_ = 2;
            TypedBNFParser.RULE_identstr = 3;
            TypedBNFParser.RULE_typ = 4;
            TypedBNFParser.RULE_slist_o__i__s__i__s_param_type_p_ = 5;
            TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_param_type_p__p_ = 6;
            TypedBNFParser.RULE_eslist_o__i__s__i__s_param_type_p_ = 7;
            TypedBNFParser.RULE_arrow_typ = 8;
            TypedBNFParser.RULE_slist_o__i__s__i__s_typ_p_ = 9;
            TypedBNFParser.RULE_typ2 = 10;
            TypedBNFParser.RULE_type_product = 11;
            TypedBNFParser.RULE_top_typ = 12;
            TypedBNFParser.RULE_tvar = 13;
            TypedBNFParser.RULE_tvar_str = 14;
            TypedBNFParser.RULE_param_type = 15;
            TypedBNFParser.RULE_slist_o__i__s__i__s_tvar_str_p_ = 16;
            TypedBNFParser.RULE_type_params = 17;
            TypedBNFParser.RULE_field_ann = 18;
            TypedBNFParser.RULE_slist_o__i__s__i__s_field_ann_p_ = 19;
            TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_field_ann_p__p_ = 20;
            TypedBNFParser.RULE_eslist_o__i__s__i__s_field_ann_p_ = 21;
            TypedBNFParser.RULE_field_anns = 22;
            TypedBNFParser.RULE_decl = 23;
            TypedBNFParser.RULE_toplevel = 24;
            TypedBNFParser.RULE_slist_o__i__s__i__s_identstr_p_ = 25;
            TypedBNFParser.RULE_def = 26;
            TypedBNFParser.RULE_productions = 27;
            TypedBNFParser.RULE_list_o_psym_p_ = 28;
            TypedBNFParser.RULE_empty_o_list_o_psym_p__p_ = 29;
            TypedBNFParser.RULE_elist_o_psym_p_ = 30;
            TypedBNFParser.RULE_production = 31;
            TypedBNFParser.RULE_slist_o__i__s__i__s_psym_p_ = 32;
            TypedBNFParser.RULE_psym = 33;
            TypedBNFParser.RULE_ann = 34;
            TypedBNFParser.RULE_slist_o__i__s__i__s_ann_p_ = 35;
            TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_ann_p__p_ = 36;
            TypedBNFParser.RULE_eslist_o__i__s__i__s_ann_p_ = 37;
            TypedBNFParser.RULE_func_parameters = 38;
            TypedBNFParser.RULE_expr = 39;
            TypedBNFParser.RULE_call = 40;
            TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_expr_p__p_ = 41;
            TypedBNFParser.RULE_eslist_o__i__s__i__s_expr_p_ = 42;
            TypedBNFParser.RULE_slist_o__i__s__i__s_expr_p_ = 43;
            TypedBNFParser.RULE_atomexp = 44;
            TypedBNFParser.RULE_slist_o__i__u__i__s_lexer_and_p_ = 45;
            TypedBNFParser.RULE_lexer__y_ = 46;
            TypedBNFParser.RULE_list_o_lexer_atomexpr_p_ = 47;
            TypedBNFParser.RULE_lexer_and = 48;
            TypedBNFParser.RULE_lexer_atomexpr = 49;
            TypedBNFParser.RULE_lexer_atom = 50;
            TypedBNFParser.RULE_lexerdef = 51;
            TypedBNFParser.ruleNames = ["start", "list_o_toplevel_p_", "start__y_", "identstr", "typ", "slist_o__i__s__i__s_param_type_p_", "empty_o_slist_o__i__s__i__s_param_type_p__p_", "eslist_o__i__s__i__s_param_type_p_", "arrow_typ", "slist_o__i__s__i__s_typ_p_", "typ2", "type_product", "top_typ", "tvar", "tvar_str", "param_type", "slist_o__i__s__i__s_tvar_str_p_", "type_params", "field_ann", "slist_o__i__s__i__s_field_ann_p_", "empty_o_slist_o__i__s__i__s_field_ann_p__p_", "eslist_o__i__s__i__s_field_ann_p_", "field_anns", "decl", "toplevel", "slist_o__i__s__i__s_identstr_p_", "def", "productions", "list_o_psym_p_", "empty_o_list_o_psym_p__p_", "elist_o_psym_p_", "production", "slist_o__i__s__i__s_psym_p_", "psym", "ann", "slist_o__i__s__i__s_ann_p_", "empty_o_slist_o__i__s__i__s_ann_p__p_", "eslist_o__i__s__i__s_ann_p_", "func_parameters", "expr", "call", "empty_o_slist_o__i__s__i__s_expr_p__p_", "eslist_o__i__s__i__s_expr_p_", "slist_o__i__s__i__s_expr_p_", "atomexp", "slist_o__i__u__i__s_lexer_and_p_", "lexer__y_", "list_o_lexer_atomexpr_p_", "lexer_and", "lexer_atomexpr", "lexer_atom", "lexerdef"];
            TypedBNFParser._LITERAL_NAMES = [undefined, "','", "'->'", "'('", "')'", "'<'", "'>'", "'*'", "'''", "':'", "'extern'", "'var'", "'case'", "'type'", "'ignore'", "'|'", "'{'", "'}'", "'let'", "'='", "'in'", "'fun'", "';'", "'$'", "'['", "']'", "'.'", "'true'", "'false'", "'+'", "'?'", "'!'", "'\\'", "'_'"];
            TypedBNFParser._SYMBOLIC_NAMES = [undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, "UNICODE_RANGE", "RANGE", "CNAMEPLUS", "INT", "WS", "FLOAT", "ESCAPED_STRING", "CPP_COMMENT", "C_COMMENT"];
            TypedBNFParser.VOCABULARY = new d.VocabularyImpl(TypedBNFParser._LITERAL_NAMES, TypedBNFParser._SYMBOLIC_NAMES, []);
            TypedBNFParser._serializedATNSegments = 2;
            TypedBNFParser._serializedATNSegment0 = "," + "\t\t\t\t\t" + "\t\b\t\b\t\t\t\n\t\n\v\t\v\f\t\f\r\t\r" + "\t\t\t\t\t" + "\t\t\t\t\t" + "\t\t\t\t\t" + '\t\t\t \t !\t!"\t"#' + "\t#$\t$%\t%&\t&'\t'(\t()\t)*\t*+\t+" + ",\t,-\t-.\t./\t/0\t01\t12\t23\t34" + "\t45\t5" + "w\n\fz\v" + "" + "" + "\n\f\v\b\b\b\b" + "\b\n\b\t\t\t\n\n\n\n\n\n\n" + "\n\n\n\n\n\n\n\n\n\n\n\v" + "\v\v\v\v\v\v\v\v\v\n\v\f\v\v" + "\v\v\f\f\f\f\f\f\f\n\f\f\f" + "\f\f\f\f\f\n\f\f\f\f\v\f\r\r\r" + "\r\r\r\r\r\r\r\n\r\f\r\r\v\r" + "" + "\n" + "" + "\n" + "\n\f\v" + "\n" + "" + "\n\f" + "\v\n" + "" + "\n" + "" + "" + "\n" + "\n" + "" + "\n\f\v" + "" + "\n" + "\n\f\v" + "" + "\n\f\v" + '\n   !!!!!!""' + '""""""""\n"\f""' + '\v"#############' + "####\n#$$$$$%%%" + "%%%%%%%\n%\f%%\v%&" + "&&&&\n&'''(((((" + "))))))))))))))" + ")))))))))\n)***" + "********\n*\f**\v*+" + "++++\n+,,,-----" + "-----\n-\f--\v-...." + ".............." + "............\n." + ".....\n.\f..\v.////" + "//////\n/\f//\v/000" + "111111111\n1\f11\v1" + "22233333333333" + "333\n3\f33\v3444444" + "44444444444444" + "4444\n45555555" + '\f"(48:BHRXZ\\`d6\b\n' + "\f" + ' "$&(*,.0246' + "8:<>@BDFHJLNPR" + "TVXZ\\^`bdfh" + "jn{\b~" + "\n\f" + "" + "" + " " + '"$&' + "(*," + ".02" + "468" + ":<>" + "@BD" + "FHJ" + "LNP" + "RTV" + "XZ\\" + "^`b" + "dfh" + "jkkllm\bm" + "no\bop2pq\bqx" + "rs\fst2tu\buw" + "vrwzxvxy" + "yzx{||}\b" + "}~&\b" + "\t\n\b\v" + "\b \b" + "\f" + " \b" + "" + "\r" + "\b\b\f\b\b" + "" + "\b\b\t" + "\f" + "\n\b\n" + "\t" + "\n\b\n" + "\r\b\n" + "" + "\b\v\n" + "\b\v\f" + "\n\b\v" + "" + "" + "\b\f&\b\f" + "\b\f" + "" + "\f\v" + "\b\b\f" + "" + "" + "\b\r\f\b\r" + "\f\t" + "\f\b\r" + "" + "" + '"\b\n' + "\b\n" + "\b" + "\n" + "&\b" + "\n&\b" + "&\v\n" + "\b\n" + "\b" + "!\b" + "\b" + "\f" + "\b" + "" + "#" + '"' + "\b\b" + "\b" + "%&\v" + "\n\b'" + "\b&" + "\b\f" + "&" + "\b" + "" + ")" + "\b(\b" + "" + "+*" + "\b-" + ",\b" + "\b" + "/" + "\f\r\b" + "\v\b" + "" + "\b\v\n" + "\b" + "\f\b" + "$.\b" + "" + "\b$." + "\b" + "" + "16" + "\b0" + "\bh5" + "\b" + "4\b" + "" + "" + "3\b\b" + "\b\f" + "\b" + "\b" + "" + "5" + "&4" + "8\b" + "&" + "8\b" + "7" + "\b\v" + "@!\b" + "\f@!" + "\b" + "" + "9" + "\bD#\b" + "\fD#" + "\b" + "" + ";" + "\b:\b" + "" + "=<" + "\b ?> " + "P)" + '\b!A\b"' + 'D#\b"' + "\f" + 'D#\b"' + "" + "C" + "\b" + "\b\b#" + "*\b#\b" + "\b#&" + 'B"' + "\b#" + "" + "E\b" + "\v\n" + "\b$G\b%" + "F$\b%" + "\fF$" + "\b%" + "" + "I" + "\b&H%\b&" + "" + "KJ&\b'" + "ML'" + "\b(O" + "\b" + "P)" + "P)\b)" + "N(" + "P)\b)" + "R*\b)" + "R*" + "P)\b)" + "" + "Q\b*" + "Z.\b*" + "\f" + "V,\b*" + "" + "S" + "\b+" + "X-\b+" + "U" + "T+\b,W" + "\b-P)\b-" + "\f" + "P)\b-" + "" + "Y" + "\b.'" + "\b.)\b." + "*\b." + "'\b." + "V," + "\b." + "\b." + "X-\b." + "&" + "\b.\b." + "\b." + "" + "" + "" + "" + "\f&" + "\b." + "";
            TypedBNFParser._serializedATNSegment1 = "[" + "\b/b2\b/" + "\f" + "b2\b/" + "" + "]" + "\\/\b0" + "_\b1d3" + "\b1\f" + "d3\b1" + "" + "a" + "`1\b2c" + "\b3f4" + "\b3\f" + "\b3\f" + "\t\b3\f" + " \b3" + "" + "" + "e" + "*\b4!" + "f4\b4" + "^0" + '\b4"' + "\b4%\b4" + "$\b4#" + "\b4\b" + "4&\b4" + "" + "" + "" + "g&" + "^0" + "\b5i'x" + "" + "" + "";
            TypedBNFParser._serializedATN = p.join([TypedBNFParser._serializedATNSegment0, TypedBNFParser._serializedATNSegment1], "");
            class StartContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                EOF() {
                    return this.getToken(TypedBNFParser.EOF, 0)
                }
                start__y_() {
                    return this.getRuleContext(0, Start__y_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_start
                }
                enterRule(e) {
                    if (e.enterStart) {
                        e.enterStart(this)
                    }
                }
                exitRule(e) {
                    if (e.exitStart) {
                        e.exitStart(this)
                    }
                }
            }
            t.StartContext = StartContext;
            class List_o_toplevel_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                toplevel() {
                    return this.getRuleContext(0, ToplevelContext)
                }
                list_o_toplevel_p_() {
                    return this.tryGetRuleContext(0, List_o_toplevel_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_list_o_toplevel_p_
                }
                enterRule(e) {
                    if (e.enterList_o_toplevel_p_) {
                        e.enterList_o_toplevel_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitList_o_toplevel_p_) {
                        e.exitList_o_toplevel_p_(this)
                    }
                }
            }
            t.List_o_toplevel_p_Context = List_o_toplevel_p_Context;
            class Start__y_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                list_o_toplevel_p_() {
                    return this.getRuleContext(0, List_o_toplevel_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_start__y_
                }
                enterRule(e) {
                    if (e.enterStart__y_) {
                        e.enterStart__y_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitStart__y_) {
                        e.exitStart__y_(this)
                    }
                }
            }
            t.Start__y_Context = Start__y_Context;
            class IdentstrContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                CNAMEPLUS() {
                    return this.getToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_identstr
                }
                enterRule(e) {
                    if (e.enterIdentstr) {
                        e.enterIdentstr(this)
                    }
                }
                exitRule(e) {
                    if (e.exitIdentstr) {
                        e.exitIdentstr(this)
                    }
                }
            }
            t.IdentstrContext = IdentstrContext;
            class TypContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                arrow_typ() {
                    return this.getRuleContext(0, Arrow_typContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_typ
                }
                enterRule(e) {
                    if (e.enterTyp) {
                        e.enterTyp(this)
                    }
                }
                exitRule(e) {
                    if (e.exitTyp) {
                        e.exitTyp(this)
                    }
                }
            }
            t.TypContext = TypContext;
            class Slist_o__i__s__i__s_param_type_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                param_type() {
                    return this.getRuleContext(0, Param_typeContext)
                }
                slist_o__i__s__i__s_param_type_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_param_type_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__s__i__s_param_type_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__s__i__s_param_type_p_) {
                        e.enterSlist_o__i__s__i__s_param_type_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__s__i__s_param_type_p_) {
                        e.exitSlist_o__i__s__i__s_param_type_p_(this)
                    }
                }
            }
            t.Slist_o__i__s__i__s_param_type_p_Context = Slist_o__i__s__i__s_param_type_p_Context;
            class Empty_o_slist_o__i__s__i__s_param_type_p__p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                slist_o__i__s__i__s_param_type_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_param_type_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_param_type_p__p_
                }
                enterRule(e) {
                    if (e.enterEmpty_o_slist_o__i__s__i__s_param_type_p__p_) {
                        e.enterEmpty_o_slist_o__i__s__i__s_param_type_p__p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEmpty_o_slist_o__i__s__i__s_param_type_p__p_) {
                        e.exitEmpty_o_slist_o__i__s__i__s_param_type_p__p_(this)
                    }
                }
            }
            t.Empty_o_slist_o__i__s__i__s_param_type_p__p_Context = Empty_o_slist_o__i__s__i__s_param_type_p__p_Context;
            class Eslist_o__i__s__i__s_param_type_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                empty_o_slist_o__i__s__i__s_param_type_p__p_() {
                    return this.getRuleContext(0, Empty_o_slist_o__i__s__i__s_param_type_p__p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_eslist_o__i__s__i__s_param_type_p_
                }
                enterRule(e) {
                    if (e.enterEslist_o__i__s__i__s_param_type_p_) {
                        e.enterEslist_o__i__s__i__s_param_type_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEslist_o__i__s__i__s_param_type_p_) {
                        e.exitEslist_o__i__s__i__s_param_type_p_(this)
                    }
                }
            }
            t.Eslist_o__i__s__i__s_param_type_p_Context = Eslist_o__i__s__i__s_param_type_p_Context;
            class Arrow_typContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                typ2() {
                    return this.tryGetRuleContext(0, Typ2Context)
                }
                arrow_typ() {
                    return this.tryGetRuleContext(0, Arrow_typContext)
                }
                eslist_o__i__s__i__s_param_type_p_() {
                    return this.tryGetRuleContext(0, Eslist_o__i__s__i__s_param_type_p_Context)
                }
                type_product() {
                    return this.tryGetRuleContext(0, Type_productContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_arrow_typ
                }
                enterRule(e) {
                    if (e.enterArrow_typ) {
                        e.enterArrow_typ(this)
                    }
                }
                exitRule(e) {
                    if (e.exitArrow_typ) {
                        e.exitArrow_typ(this)
                    }
                }
            }
            t.Arrow_typContext = Arrow_typContext;
            class Slist_o__i__s__i__s_typ_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                typ() {
                    return this.getRuleContext(0, TypContext)
                }
                slist_o__i__s__i__s_typ_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_typ_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__s__i__s_typ_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__s__i__s_typ_p_) {
                        e.enterSlist_o__i__s__i__s_typ_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__s__i__s_typ_p_) {
                        e.exitSlist_o__i__s__i__s_typ_p_(this)
                    }
                }
            }
            t.Slist_o__i__s__i__s_typ_p_Context = Slist_o__i__s__i__s_typ_p_Context;
            class Typ2Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                CNAMEPLUS() {
                    return this.tryGetToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                tvar() {
                    return this.tryGetRuleContext(0, TvarContext)
                }
                typ2() {
                    return this.tryGetRuleContext(0, Typ2Context)
                }
                slist_o__i__s__i__s_typ_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_typ_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_typ2
                }
                enterRule(e) {
                    if (e.enterTyp2) {
                        e.enterTyp2(this)
                    }
                }
                exitRule(e) {
                    if (e.exitTyp2) {
                        e.exitTyp2(this)
                    }
                }
            }
            t.Typ2Context = Typ2Context;
            class Type_productContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                type_product() {
                    return this.tryGetRuleContext(0, Type_productContext)
                }
                typ2() {
                    return this.getRuleContext(0, Typ2Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_type_product
                }
                enterRule(e) {
                    if (e.enterType_product) {
                        e.enterType_product(this)
                    }
                }
                exitRule(e) {
                    if (e.exitType_product) {
                        e.exitType_product(this)
                    }
                }
            }
            t.Type_productContext = Type_productContext;
            class Top_typContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                slist_o__i__s__i__s_tvar_str_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_tvar_str_p_Context)
                }
                typ() {
                    return this.getRuleContext(0, TypContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_top_typ
                }
                enterRule(e) {
                    if (e.enterTop_typ) {
                        e.enterTop_typ(this)
                    }
                }
                exitRule(e) {
                    if (e.exitTop_typ) {
                        e.exitTop_typ(this)
                    }
                }
            }
            t.Top_typContext = Top_typContext;
            class TvarContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                CNAMEPLUS() {
                    return this.getToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_tvar
                }
                enterRule(e) {
                    if (e.enterTvar) {
                        e.enterTvar(this)
                    }
                }
                exitRule(e) {
                    if (e.exitTvar) {
                        e.exitTvar(this)
                    }
                }
            }
            t.TvarContext = TvarContext;
            class Tvar_strContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                CNAMEPLUS() {
                    return this.getToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_tvar_str
                }
                enterRule(e) {
                    if (e.enterTvar_str) {
                        e.enterTvar_str(this)
                    }
                }
                exitRule(e) {
                    if (e.exitTvar_str) {
                        e.exitTvar_str(this)
                    }
                }
            }
            t.Tvar_strContext = Tvar_strContext;
            class Param_typeContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                CNAMEPLUS() {
                    return this.tryGetToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                typ() {
                    return this.getRuleContext(0, TypContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_param_type
                }
                enterRule(e) {
                    if (e.enterParam_type) {
                        e.enterParam_type(this)
                    }
                }
                exitRule(e) {
                    if (e.exitParam_type) {
                        e.exitParam_type(this)
                    }
                }
            }
            t.Param_typeContext = Param_typeContext;
            class Slist_o__i__s__i__s_tvar_str_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                tvar_str() {
                    return this.getRuleContext(0, Tvar_strContext)
                }
                slist_o__i__s__i__s_tvar_str_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_tvar_str_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__s__i__s_tvar_str_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__s__i__s_tvar_str_p_) {
                        e.enterSlist_o__i__s__i__s_tvar_str_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__s__i__s_tvar_str_p_) {
                        e.exitSlist_o__i__s__i__s_tvar_str_p_(this)
                    }
                }
            }
            t.Slist_o__i__s__i__s_tvar_str_p_Context = Slist_o__i__s__i__s_tvar_str_p_Context;
            class Type_paramsContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                slist_o__i__s__i__s_tvar_str_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_tvar_str_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_type_params
                }
                enterRule(e) {
                    if (e.enterType_params) {
                        e.enterType_params(this)
                    }
                }
                exitRule(e) {
                    if (e.exitType_params) {
                        e.exitType_params(this)
                    }
                }
            }
            t.Type_paramsContext = Type_paramsContext;
            class Field_annContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                CNAMEPLUS() {
                    return this.getToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                typ() {
                    return this.getRuleContext(0, TypContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_field_ann
                }
                enterRule(e) {
                    if (e.enterField_ann) {
                        e.enterField_ann(this)
                    }
                }
                exitRule(e) {
                    if (e.exitField_ann) {
                        e.exitField_ann(this)
                    }
                }
            }
            t.Field_annContext = Field_annContext;
            class Slist_o__i__s__i__s_field_ann_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                field_ann() {
                    return this.getRuleContext(0, Field_annContext)
                }
                slist_o__i__s__i__s_field_ann_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_field_ann_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__s__i__s_field_ann_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__s__i__s_field_ann_p_) {
                        e.enterSlist_o__i__s__i__s_field_ann_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__s__i__s_field_ann_p_) {
                        e.exitSlist_o__i__s__i__s_field_ann_p_(this)
                    }
                }
            }
            t.Slist_o__i__s__i__s_field_ann_p_Context = Slist_o__i__s__i__s_field_ann_p_Context;
            class Empty_o_slist_o__i__s__i__s_field_ann_p__p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                slist_o__i__s__i__s_field_ann_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_field_ann_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_field_ann_p__p_
                }
                enterRule(e) {
                    if (e.enterEmpty_o_slist_o__i__s__i__s_field_ann_p__p_) {
                        e.enterEmpty_o_slist_o__i__s__i__s_field_ann_p__p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEmpty_o_slist_o__i__s__i__s_field_ann_p__p_) {
                        e.exitEmpty_o_slist_o__i__s__i__s_field_ann_p__p_(this)
                    }
                }
            }
            t.Empty_o_slist_o__i__s__i__s_field_ann_p__p_Context = Empty_o_slist_o__i__s__i__s_field_ann_p__p_Context;
            class Eslist_o__i__s__i__s_field_ann_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                empty_o_slist_o__i__s__i__s_field_ann_p__p_() {
                    return this.getRuleContext(0, Empty_o_slist_o__i__s__i__s_field_ann_p__p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_eslist_o__i__s__i__s_field_ann_p_
                }
                enterRule(e) {
                    if (e.enterEslist_o__i__s__i__s_field_ann_p_) {
                        e.enterEslist_o__i__s__i__s_field_ann_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEslist_o__i__s__i__s_field_ann_p_) {
                        e.exitEslist_o__i__s__i__s_field_ann_p_(this)
                    }
                }
            }
            t.Eslist_o__i__s__i__s_field_ann_p_Context = Eslist_o__i__s__i__s_field_ann_p_Context;
            class Field_annsContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                eslist_o__i__s__i__s_field_ann_p_() {
                    return this.tryGetRuleContext(0, Eslist_o__i__s__i__s_field_ann_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_field_anns
                }
                enterRule(e) {
                    if (e.enterField_anns) {
                        e.enterField_anns(this)
                    }
                }
                exitRule(e) {
                    if (e.exitField_anns) {
                        e.exitField_anns(this)
                    }
                }
            }
            t.Field_annsContext = Field_annsContext;
            class DeclContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                identstr() {
                    return this.getRuleContext(0, IdentstrContext)
                }
                top_typ() {
                    return this.tryGetRuleContext(0, Top_typContext)
                }
                typ() {
                    return this.tryGetRuleContext(0, TypContext)
                }
                type_params() {
                    return this.tryGetRuleContext(0, Type_paramsContext)
                }
                field_anns() {
                    return this.tryGetRuleContext(0, Field_annsContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_decl
                }
                enterRule(e) {
                    if (e.enterDecl) {
                        e.enterDecl(this)
                    }
                }
                exitRule(e) {
                    if (e.exitDecl) {
                        e.exitDecl(this)
                    }
                }
            }
            t.DeclContext = DeclContext;
            class ToplevelContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                def() {
                    return this.tryGetRuleContext(0, DefContext)
                }
                decl() {
                    return this.tryGetRuleContext(0, DeclContext)
                }
                lexerdef() {
                    return this.tryGetRuleContext(0, LexerdefContext)
                }
                slist_o__i__s__i__s_identstr_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_identstr_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_toplevel
                }
                enterRule(e) {
                    if (e.enterToplevel) {
                        e.enterToplevel(this)
                    }
                }
                exitRule(e) {
                    if (e.exitToplevel) {
                        e.exitToplevel(this)
                    }
                }
            }
            t.ToplevelContext = ToplevelContext;
            class Slist_o__i__s__i__s_identstr_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                identstr() {
                    return this.getRuleContext(0, IdentstrContext)
                }
                slist_o__i__s__i__s_identstr_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_identstr_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__s__i__s_identstr_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__s__i__s_identstr_p_) {
                        e.enterSlist_o__i__s__i__s_identstr_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__s__i__s_identstr_p_) {
                        e.exitSlist_o__i__s__i__s_identstr_p_(this)
                    }
                }
            }
            t.Slist_o__i__s__i__s_identstr_p_Context = Slist_o__i__s__i__s_identstr_p_Context;
            class DefContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                CNAMEPLUS() {
                    return this.getToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                slist_o__i__s__i__s_identstr_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_identstr_p_Context)
                }
                productions() {
                    return this.getRuleContext(0, ProductionsContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_def
                }
                enterRule(e) {
                    if (e.enterDef) {
                        e.enterDef(this)
                    }
                }
                exitRule(e) {
                    if (e.exitDef) {
                        e.exitDef(this)
                    }
                }
            }
            t.DefContext = DefContext;
            class ProductionsContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                production() {
                    return this.getRuleContext(0, ProductionContext)
                }
                productions() {
                    return this.tryGetRuleContext(0, ProductionsContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_productions
                }
                enterRule(e) {
                    if (e.enterProductions) {
                        e.enterProductions(this)
                    }
                }
                exitRule(e) {
                    if (e.exitProductions) {
                        e.exitProductions(this)
                    }
                }
            }
            t.ProductionsContext = ProductionsContext;
            class List_o_psym_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                psym() {
                    return this.getRuleContext(0, PsymContext)
                }
                list_o_psym_p_() {
                    return this.tryGetRuleContext(0, List_o_psym_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_list_o_psym_p_
                }
                enterRule(e) {
                    if (e.enterList_o_psym_p_) {
                        e.enterList_o_psym_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitList_o_psym_p_) {
                        e.exitList_o_psym_p_(this)
                    }
                }
            }
            t.List_o_psym_p_Context = List_o_psym_p_Context;
            class Empty_o_list_o_psym_p__p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                list_o_psym_p_() {
                    return this.tryGetRuleContext(0, List_o_psym_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_empty_o_list_o_psym_p__p_
                }
                enterRule(e) {
                    if (e.enterEmpty_o_list_o_psym_p__p_) {
                        e.enterEmpty_o_list_o_psym_p__p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEmpty_o_list_o_psym_p__p_) {
                        e.exitEmpty_o_list_o_psym_p__p_(this)
                    }
                }
            }
            t.Empty_o_list_o_psym_p__p_Context = Empty_o_list_o_psym_p__p_Context;
            class Elist_o_psym_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                empty_o_list_o_psym_p__p_() {
                    return this.getRuleContext(0, Empty_o_list_o_psym_p__p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_elist_o_psym_p_
                }
                enterRule(e) {
                    if (e.enterElist_o_psym_p_) {
                        e.enterElist_o_psym_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitElist_o_psym_p_) {
                        e.exitElist_o_psym_p_(this)
                    }
                }
            }
            t.Elist_o_psym_p_Context = Elist_o_psym_p_Context;
            class ProductionContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                elist_o_psym_p_() {
                    return this.getRuleContext(0, Elist_o_psym_p_Context)
                }
                expr() {
                    return this.getRuleContext(0, ExprContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_production
                }
                enterRule(e) {
                    if (e.enterProduction) {
                        e.enterProduction(this)
                    }
                }
                exitRule(e) {
                    if (e.exitProduction) {
                        e.exitProduction(this)
                    }
                }
            }
            t.ProductionContext = ProductionContext;
            class Slist_o__i__s__i__s_psym_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                psym() {
                    return this.getRuleContext(0, PsymContext)
                }
                slist_o__i__s__i__s_psym_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_psym_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__s__i__s_psym_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__s__i__s_psym_p_) {
                        e.enterSlist_o__i__s__i__s_psym_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__s__i__s_psym_p_) {
                        e.exitSlist_o__i__s__i__s_psym_p_(this)
                    }
                }
            }
            t.Slist_o__i__s__i__s_psym_p_Context = Slist_o__i__s__i__s_psym_p_Context;
            class PsymContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                identstr() {
                    return this.tryGetRuleContext(0, IdentstrContext)
                }
                ESCAPED_STRING() {
                    return this.tryGetToken(TypedBNFParser.ESCAPED_STRING, 0)
                }
                CNAMEPLUS() {
                    return this.tryGetToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                slist_o__i__s__i__s_psym_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_psym_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_psym
                }
                enterRule(e) {
                    if (e.enterPsym) {
                        e.enterPsym(this)
                    }
                }
                exitRule(e) {
                    if (e.exitPsym) {
                        e.exitPsym(this)
                    }
                }
            }
            t.PsymContext = PsymContext;
            class AnnContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                identstr() {
                    return this.getRuleContext(0, IdentstrContext)
                }
                typ() {
                    return this.getRuleContext(0, TypContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_ann
                }
                enterRule(e) {
                    if (e.enterAnn) {
                        e.enterAnn(this)
                    }
                }
                exitRule(e) {
                    if (e.exitAnn) {
                        e.exitAnn(this)
                    }
                }
            }
            t.AnnContext = AnnContext;
            class Slist_o__i__s__i__s_ann_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                ann() {
                    return this.getRuleContext(0, AnnContext)
                }
                slist_o__i__s__i__s_ann_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_ann_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__s__i__s_ann_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__s__i__s_ann_p_) {
                        e.enterSlist_o__i__s__i__s_ann_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__s__i__s_ann_p_) {
                        e.exitSlist_o__i__s__i__s_ann_p_(this)
                    }
                }
            }
            t.Slist_o__i__s__i__s_ann_p_Context = Slist_o__i__s__i__s_ann_p_Context;
            class Empty_o_slist_o__i__s__i__s_ann_p__p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                slist_o__i__s__i__s_ann_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_ann_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_ann_p__p_
                }
                enterRule(e) {
                    if (e.enterEmpty_o_slist_o__i__s__i__s_ann_p__p_) {
                        e.enterEmpty_o_slist_o__i__s__i__s_ann_p__p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEmpty_o_slist_o__i__s__i__s_ann_p__p_) {
                        e.exitEmpty_o_slist_o__i__s__i__s_ann_p__p_(this)
                    }
                }
            }
            t.Empty_o_slist_o__i__s__i__s_ann_p__p_Context = Empty_o_slist_o__i__s__i__s_ann_p__p_Context;
            class Eslist_o__i__s__i__s_ann_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                empty_o_slist_o__i__s__i__s_ann_p__p_() {
                    return this.getRuleContext(0, Empty_o_slist_o__i__s__i__s_ann_p__p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_eslist_o__i__s__i__s_ann_p_
                }
                enterRule(e) {
                    if (e.enterEslist_o__i__s__i__s_ann_p_) {
                        e.enterEslist_o__i__s__i__s_ann_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEslist_o__i__s__i__s_ann_p_) {
                        e.exitEslist_o__i__s__i__s_ann_p_(this)
                    }
                }
            }
            t.Eslist_o__i__s__i__s_ann_p_Context = Eslist_o__i__s__i__s_ann_p_Context;
            class Func_parametersContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                eslist_o__i__s__i__s_ann_p_() {
                    return this.getRuleContext(0, Eslist_o__i__s__i__s_ann_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_func_parameters
                }
                enterRule(e) {
                    if (e.enterFunc_parameters) {
                        e.enterFunc_parameters(this)
                    }
                }
                exitRule(e) {
                    if (e.exitFunc_parameters) {
                        e.exitFunc_parameters(this)
                    }
                }
            }
            t.Func_parametersContext = Func_parametersContext;
            class ExprContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                identstr() {
                    return this.tryGetRuleContext(0, IdentstrContext)
                }
                expr(e) {
                    if (e === undefined) {
                        return this.getRuleContexts(ExprContext)
                    } else {
                        return this.getRuleContext(e, ExprContext)
                    }
                }
                func_parameters() {
                    return this.tryGetRuleContext(0, Func_parametersContext)
                }
                call() {
                    return this.tryGetRuleContext(0, CallContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_expr
                }
                enterRule(e) {
                    if (e.enterExpr) {
                        e.enterExpr(this)
                    }
                }
                exitRule(e) {
                    if (e.exitExpr) {
                        e.exitExpr(this)
                    }
                }
            }
            t.ExprContext = ExprContext;
            class CallContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                call() {
                    return this.tryGetRuleContext(0, CallContext)
                }
                eslist_o__i__s__i__s_expr_p_() {
                    return this.tryGetRuleContext(0, Eslist_o__i__s__i__s_expr_p_Context)
                }
                atomexp() {
                    return this.tryGetRuleContext(0, AtomexpContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_call
                }
                enterRule(e) {
                    if (e.enterCall) {
                        e.enterCall(this)
                    }
                }
                exitRule(e) {
                    if (e.exitCall) {
                        e.exitCall(this)
                    }
                }
            }
            t.CallContext = CallContext;
            class Empty_o_slist_o__i__s__i__s_expr_p__p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                slist_o__i__s__i__s_expr_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_expr_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_empty_o_slist_o__i__s__i__s_expr_p__p_
                }
                enterRule(e) {
                    if (e.enterEmpty_o_slist_o__i__s__i__s_expr_p__p_) {
                        e.enterEmpty_o_slist_o__i__s__i__s_expr_p__p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEmpty_o_slist_o__i__s__i__s_expr_p__p_) {
                        e.exitEmpty_o_slist_o__i__s__i__s_expr_p__p_(this)
                    }
                }
            }
            t.Empty_o_slist_o__i__s__i__s_expr_p__p_Context = Empty_o_slist_o__i__s__i__s_expr_p__p_Context;
            class Eslist_o__i__s__i__s_expr_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                empty_o_slist_o__i__s__i__s_expr_p__p_() {
                    return this.getRuleContext(0, Empty_o_slist_o__i__s__i__s_expr_p__p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_eslist_o__i__s__i__s_expr_p_
                }
                enterRule(e) {
                    if (e.enterEslist_o__i__s__i__s_expr_p_) {
                        e.enterEslist_o__i__s__i__s_expr_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitEslist_o__i__s__i__s_expr_p_) {
                        e.exitEslist_o__i__s__i__s_expr_p_(this)
                    }
                }
            }
            t.Eslist_o__i__s__i__s_expr_p_Context = Eslist_o__i__s__i__s_expr_p_Context;
            class Slist_o__i__s__i__s_expr_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                expr() {
                    return this.getRuleContext(0, ExprContext)
                }
                slist_o__i__s__i__s_expr_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_expr_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__s__i__s_expr_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__s__i__s_expr_p_) {
                        e.enterSlist_o__i__s__i__s_expr_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__s__i__s_expr_p_) {
                        e.exitSlist_o__i__s__i__s_expr_p_(this)
                    }
                }
            }
            t.Slist_o__i__s__i__s_expr_p_Context = Slist_o__i__s__i__s_expr_p_Context;
            class AtomexpContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                INT() {
                    return this.tryGetToken(TypedBNFParser.INT, 0)
                }
                FLOAT() {
                    return this.tryGetToken(TypedBNFParser.FLOAT, 0)
                }
                ESCAPED_STRING() {
                    return this.tryGetToken(TypedBNFParser.ESCAPED_STRING, 0)
                }
                eslist_o__i__s__i__s_expr_p_() {
                    return this.tryGetRuleContext(0, Eslist_o__i__s__i__s_expr_p_Context)
                }
                slist_o__i__s__i__s_expr_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__s__i__s_expr_p_Context)
                }
                CNAMEPLUS() {
                    return this.tryGetToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                atomexp() {
                    return this.tryGetRuleContext(0, AtomexpContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_atomexp
                }
                enterRule(e) {
                    if (e.enterAtomexp) {
                        e.enterAtomexp(this)
                    }
                }
                exitRule(e) {
                    if (e.exitAtomexp) {
                        e.exitAtomexp(this)
                    }
                }
            }
            t.AtomexpContext = AtomexpContext;
            class Slist_o__i__u__i__s_lexer_and_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                lexer_and() {
                    return this.getRuleContext(0, Lexer_andContext)
                }
                slist_o__i__u__i__s_lexer_and_p_() {
                    return this.tryGetRuleContext(0, Slist_o__i__u__i__s_lexer_and_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_slist_o__i__u__i__s_lexer_and_p_
                }
                enterRule(e) {
                    if (e.enterSlist_o__i__u__i__s_lexer_and_p_) {
                        e.enterSlist_o__i__u__i__s_lexer_and_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitSlist_o__i__u__i__s_lexer_and_p_) {
                        e.exitSlist_o__i__u__i__s_lexer_and_p_(this)
                    }
                }
            }
            t.Slist_o__i__u__i__s_lexer_and_p_Context = Slist_o__i__u__i__s_lexer_and_p_Context;
            class Lexer__y_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                slist_o__i__u__i__s_lexer_and_p_() {
                    return this.getRuleContext(0, Slist_o__i__u__i__s_lexer_and_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_lexer__y_
                }
                enterRule(e) {
                    if (e.enterLexer__y_) {
                        e.enterLexer__y_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitLexer__y_) {
                        e.exitLexer__y_(this)
                    }
                }
            }
            t.Lexer__y_Context = Lexer__y_Context;
            class List_o_lexer_atomexpr_p_Context extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                lexer_atomexpr() {
                    return this.getRuleContext(0, Lexer_atomexprContext)
                }
                list_o_lexer_atomexpr_p_() {
                    return this.tryGetRuleContext(0, List_o_lexer_atomexpr_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_list_o_lexer_atomexpr_p_
                }
                enterRule(e) {
                    if (e.enterList_o_lexer_atomexpr_p_) {
                        e.enterList_o_lexer_atomexpr_p_(this)
                    }
                }
                exitRule(e) {
                    if (e.exitList_o_lexer_atomexpr_p_) {
                        e.exitList_o_lexer_atomexpr_p_(this)
                    }
                }
            }
            t.List_o_lexer_atomexpr_p_Context = List_o_lexer_atomexpr_p_Context;
            class Lexer_andContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                list_o_lexer_atomexpr_p_() {
                    return this.getRuleContext(0, List_o_lexer_atomexpr_p_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_lexer_and
                }
                enterRule(e) {
                    if (e.enterLexer_and) {
                        e.enterLexer_and(this)
                    }
                }
                exitRule(e) {
                    if (e.exitLexer_and) {
                        e.exitLexer_and(this)
                    }
                }
            }
            t.Lexer_andContext = Lexer_andContext;
            class Lexer_atomexprContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                lexer_atomexpr() {
                    return this.tryGetRuleContext(0, Lexer_atomexprContext)
                }
                lexer_atom() {
                    return this.tryGetRuleContext(0, Lexer_atomContext)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_lexer_atomexpr
                }
                enterRule(e) {
                    if (e.enterLexer_atomexpr) {
                        e.enterLexer_atomexpr(this)
                    }
                }
                exitRule(e) {
                    if (e.exitLexer_atomexpr) {
                        e.exitLexer_atomexpr(this)
                    }
                }
            }
            t.Lexer_atomexprContext = Lexer_atomexprContext;
            class Lexer_atomContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                ESCAPED_STRING() {
                    return this.tryGetToken(TypedBNFParser.ESCAPED_STRING, 0)
                }
                lexer_atom() {
                    return this.tryGetRuleContext(0, Lexer_atomContext)
                }
                lexer__y_() {
                    return this.tryGetRuleContext(0, Lexer__y_Context)
                }
                RANGE() {
                    return this.tryGetToken(TypedBNFParser.RANGE, 0)
                }
                UNICODE_RANGE() {
                    return this.tryGetToken(TypedBNFParser.UNICODE_RANGE, 0)
                }
                CNAMEPLUS() {
                    return this.tryGetToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_lexer_atom
                }
                enterRule(e) {
                    if (e.enterLexer_atom) {
                        e.enterLexer_atom(this)
                    }
                }
                exitRule(e) {
                    if (e.exitLexer_atom) {
                        e.exitLexer_atom(this)
                    }
                }
            }
            t.Lexer_atomContext = Lexer_atomContext;
            class LexerdefContext extends _.ParserRuleContext {
                constructor(e, t) {
                    super(e, t)
                }
                CNAMEPLUS() {
                    return this.getToken(TypedBNFParser.CNAMEPLUS, 0)
                }
                lexer__y_() {
                    return this.getRuleContext(0, Lexer__y_Context)
                }
                get ruleIndex() {
                    return TypedBNFParser.RULE_lexerdef
                }
                enterRule(e) {
                    if (e.enterLexerdef) {
                        e.enterLexerdef(this)
                    }
                }
                exitRule(e) {
                    if (e.exitLexerdef) {
                        e.exitLexerdef(this)
                    }
                }
            }
            t.LexerdefContext = LexerdefContext
        },
        2004: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            Object.defineProperty(t, "MK_Declctor", {
                enumerable: true,
                get: function() {
                    return n.MK_Declctor
                }
            });
            Object.defineProperty(t, "MK_Decltype", {
                enumerable: true,
                get: function() {
                    return n.MK_Decltype
                }
            });
            Object.defineProperty(t, "MK_Declvar", {
                enumerable: true,
                get: function() {
                    return n.MK_Declvar
                }
            });
            Object.defineProperty(t, "MK_Defignore", {
                enumerable: true,
                get: function() {
                    return n.MK_Defignore
                }
            });
            Object.defineProperty(t, "MK_Deflexer", {
                enumerable: true,
                get: function() {
                    return n.MK_Deflexer
                }
            });
            Object.defineProperty(t, "MK_Defmacro", {
                enumerable: true,
                get: function() {
                    return n.MK_Defmacro
                }
            });
            Object.defineProperty(t, "MK_Defrule", {
                enumerable: true,
                get: function() {
                    return n.MK_Defrule
                }
            });
            Object.defineProperty(t, "MK_EApp", {
                enumerable: true,
                get: function() {
                    return n.MK_EApp
                }
            });
            Object.defineProperty(t, "MK_EBool", {
                enumerable: true,
                get: function() {
                    return n.MK_EBool
                }
            });
            Object.defineProperty(t, "MK_EField", {
                enumerable: true,
                get: function() {
                    return n.MK_EField
                }
            });
            Object.defineProperty(t, "MK_EFlt", {
                enumerable: true,
                get: function() {
                    return n.MK_EFlt
                }
            });
            Object.defineProperty(t, "MK_EFun", {
                enumerable: true,
                get: function() {
                    return n.MK_EFun
                }
            });
            Object.defineProperty(t, "MK_EInt", {
                enumerable: true,
                get: function() {
                    return n.MK_EInt
                }
            });
            Object.defineProperty(t, "MK_ELet", {
                enumerable: true,
                get: function() {
                    return n.MK_ELet
                }
            });
            Object.defineProperty(t, "MK_EList", {
                enumerable: true,
                get: function() {
                    return n.MK_EList
                }
            });
            Object.defineProperty(t, "MK_ESlot", {
                enumerable: true,
                get: function() {
                    return n.MK_ESlot
                }
            });
            Object.defineProperty(t, "MK_EStr", {
                enumerable: true,
                get: function() {
                    return n.MK_EStr
                }
            });
            Object.defineProperty(t, "MK_ETuple", {
                enumerable: true,
                get: function() {
                    return n.MK_ETuple
                }
            });
            Object.defineProperty(t, "MK_EVar", {
                enumerable: true,
                get: function() {
                    return n.MK_EVar
                }
            });
            t.MK_Expr = void 0;
            Object.defineProperty(t, "MK_LGroup", {
                enumerable: true,
                get: function() {
                    return n.MK_LGroup
                }
            });
            Object.defineProperty(t, "MK_LNot", {
                enumerable: true,
                get: function() {
                    return n.MK_LNot
                }
            });
            Object.defineProperty(t, "MK_LNumber", {
                enumerable: true,
                get: function() {
                    return n.MK_LNumber
                }
            });
            Object.defineProperty(t, "MK_LOptional", {
                enumerable: true,
                get: function() {
                    return n.MK_LOptional
                }
            });
            Object.defineProperty(t, "MK_LOr", {
                enumerable: true,
                get: function() {
                    return n.MK_LOr
                }
            });
            Object.defineProperty(t, "MK_LPlus", {
                enumerable: true,
                get: function() {
                    return n.MK_LPlus
                }
            });
            Object.defineProperty(t, "MK_LRange", {
                enumerable: true,
                get: function() {
                    return n.MK_LRange
                }
            });
            Object.defineProperty(t, "MK_LRef", {
                enumerable: true,
                get: function() {
                    return n.MK_LRef
                }
            });
            Object.defineProperty(t, "MK_LSeq", {
                enumerable: true,
                get: function() {
                    return n.MK_LSeq
                }
            });
            Object.defineProperty(t, "MK_LStar", {
                enumerable: true,
                get: function() {
                    return n.MK_LStar
                }
            });
            Object.defineProperty(t, "MK_LStr", {
                enumerable: true,
                get: function() {
                    return n.MK_LStr
                }
            });
            Object.defineProperty(t, "MK_LWildcard", {
                enumerable: true,
                get: function() {
                    return n.MK_LWildcard
                }
            });
            Object.defineProperty(t, "MK_Macrocall", {
                enumerable: true,
                get: function() {
                    return n.MK_Macrocall
                }
            });
            Object.defineProperty(t, "MK_Mono", {
                enumerable: true,
                get: function() {
                    return n.MK_Mono
                }
            });
            Object.defineProperty(t, "MK_Nonterm", {
                enumerable: true,
                get: function() {
                    return n.MK_Nonterm
                }
            });
            Object.defineProperty(t, "MK_Poly", {
                enumerable: true,
                get: function() {
                    return n.MK_Poly
                }
            });
            Object.defineProperty(t, "MK_TApp", {
                enumerable: true,
                get: function() {
                    return n.MK_TApp
                }
            });
            Object.defineProperty(t, "MK_TConst", {
                enumerable: true,
                get: function() {
                    return n.MK_TConst
                }
            });
            Object.defineProperty(t, "MK_TFun", {
                enumerable: true,
                get: function() {
                    return n.MK_TFun
                }
            });
            Object.defineProperty(t, "MK_TList", {
                enumerable: true,
                get: function() {
                    return n.MK_TList
                }
            });
            Object.defineProperty(t, "MK_TTuple", {
                enumerable: true,
                get: function() {
                    return n.MK_TTuple
                }
            });
            Object.defineProperty(t, "MK_TVar", {
                enumerable: true,
                get: function() {
                    return n.MK_TVar
                }
            });
            Object.defineProperty(t, "MK_Term", {
                enumerable: true,
                get: function() {
                    return n.MK_Term
                }
            });
            Object.defineProperty(t, "MK_expr", {
                enumerable: true,
                get: function() {
                    return n.MK_expr
                }
            });
            Object.defineProperty(t, "MK_production", {
                enumerable: true,
                get: function() {
                    return n.MK_production
                }
            });
            Object.defineProperty(t, "Token", {
                enumerable: true,
                get: function() {
                    return o.Token
                }
            });
            t.addList = addList;
            Object.defineProperty(t, "definition", {
                enumerable: true,
                get: function() {
                    return i.definition
                }
            });
            Object.defineProperty(t, "expr", {
                enumerable: true,
                get: function() {
                    return i.expr
                }
            });
            t.fst = fst;
            t.getfilename = getfilename;
            t.getpos = getpos;
            t.getrange = getrange;
            t.getunicoderange = getunicoderange;
            Object.defineProperty(t, "lexerule", {
                enumerable: true,
                get: function() {
                    return i.lexerule
                }
            });
            t.list_index = list_index;
            t.mkpos = mkpos;
            Object.defineProperty(t, "monot", {
                enumerable: true,
                get: function() {
                    return i.monot
                }
            });
            Object.defineProperty(t, "node", {
                enumerable: true,
                get: function() {
                    return i.node
                }
            });
            Object.defineProperty(t, "polyt", {
                enumerable: true,
                get: function() {
                    return i.polyt
                }
            });
            Object.defineProperty(t, "position", {
                enumerable: true,
                get: function() {
                    return i.position
                }
            });
            t.process_tparam = process_tparam;
            Object.defineProperty(t, "production", {
                enumerable: true,
                get: function() {
                    return i.production
                }
            });
            t.setfilename = setfilename;
            t.snd = snd;
            t.str = str;
            Object.defineProperty(t, "symbol", {
                enumerable: true,
                get: function() {
                    return i.symbol
                }
            });
            t.tofloat = tofloat;
            t.toint = toint;
            t.unescape = unescape;
            var n = r(3776);
            var i = r(3833);
            var o = r(1127);

            function fst(e) {
                return e[0]
            }

            function snd(e) {
                return e[1]
            }

            function list_index(e, t) {
                return e[t]
            }
            let s = n.MK_expr;
            t.MK_Expr = s;

            function addList(e, t) {
                e.push(t);
                return e
            }

            function unescape(e) {
                let t = "";
                let r = 1;
                let n = e.length - 1;
                while (r < n) {
                    if (e[r] == "\\") {
                        r++;
                        switch (e[r]) {
                            case "b":
                                t += "\b";
                                break;
                            case "t":
                                t += "\t";
                                break;
                            case "n":
                                t += "\n";
                                break;
                            case "f":
                                t += "\f";
                                break;
                            case "r":
                                t += "\r";
                                break;
                            case "\\":
                                t += "\\";
                                break;
                            case '"':
                                t += '"';
                                break;
                            case "'":
                                t += "'";
                                break;
                            default:
                                t += e[r];
                                break
                        }
                    } else {
                        t += e[r]
                    }
                    r++
                }
                return t
            }
            let a = "<no file>";

            function setfilename(e) {
                a = e
            }

            function getfilename() {
                return a
            }

            function mkpos(e) {
                return new i.position(e.line, e.charPositionInLine, getfilename())
            }

            function getpos(e) {
                return e.pos
            }

            function process_tparam(e) {
                let t = [];
                for (let r = 0; r < e.length; r++) {
                    if (e[r][0] == "_") {
                        t.push(["value" + r, e[r][1]])
                    } else {
                        t.push(e[r])
                    }
                }
                return t
            }

            function str(e) {
                return e.text
            }

            function toint(e) {
                if (e.text == undefined) throw new Error("toint: undefined token");
                return parseInt(e.text)
            }

            function tofloat(e) {
                if (e.text == undefined) throw new Error("tofloat: undefined token");
                return parseFloat(e.text)
            }

            function getunicoderange(e) {
                let [t, r] = e.substring(1, e.length - 1).split("-");
                return (0, n.MK_LRange)(parseInt(t.substring(2), 16), parseInt(r.substring(2), 16))
            }

            function getrange(e) {
                let [t, r] = e.substring(1, e.length - 1).split("-");
                return (0, n.MK_LRange)(t.codePointAt(0), r.codePointAt(0))
            }
        },
        9054: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Helpers_allocateArrayFromCons = Helpers_allocateArrayFromCons;
            t.addInPlace = addInPlace;
            t.addRangeInPlace = addRangeInPlace;
            t.allPairs = allPairs;
            t.append = append;
            t.average = average;
            t.averageBy = averageBy;
            t.choose = choose;
            t.chunkBySize = chunkBySize;
            t.collect = collect;
            t.compareWith = compareWith;
            t.concat = concat;
            t.contains = contains;
            t.copy = copy;
            t.copyTo = copyTo;
            t.copyToTypedArray = copyToTypedArray;
            t.empty = empty;
            t.equalsWith = equalsWith;
            t.exactlyOne = exactlyOne;
            t.exists = exists;
            t.exists2 = exists2;
            t.existsOffset = existsOffset;
            t.existsOffset2 = existsOffset2;
            t.fill = fill;
            t.filter = filter;
            t.find = find;
            t.findBack = findBack;
            t.findIndex = findIndex;
            t.findIndexBack = findIndexBack;
            t.findLastIndex = findLastIndex;
            t.fold = fold;
            t.fold2 = fold2;
            t.foldBack = foldBack;
            t.foldBack2 = foldBack2;
            t.foldBackIndexed = foldBackIndexed;
            t.foldBackIndexed2 = foldBackIndexed2;
            t.foldIndexed = foldIndexed;
            t.foldIndexed2 = foldIndexed2;
            t.forAll = forAll;
            t.forAll2 = forAll2;
            t.getSubArray = getSubArray;
            t.head = head;
            t.indexOf = indexOf;
            t.indexed = indexed;
            t.initialize = initialize;
            t.insertAt = insertAt;
            t.insertManyAt = insertManyAt;
            t.insertRangeInPlace = insertRangeInPlace;
            t.isEmpty = isEmpty;
            t.item = item;
            t.iterate = iterate;
            t.iterate2 = iterate2;
            t.iterateIndexed = iterateIndexed;
            t.iterateIndexed2 = iterateIndexed2;
            t.last = last;
            t.map = map;
            t.map2 = map2;
            t.map3 = map3;
            t.mapFold = mapFold;
            t.mapFoldBack = mapFoldBack;
            t.mapIndexed = mapIndexed;
            t.mapIndexed2 = mapIndexed2;
            t.mapIndexed3 = mapIndexed3;
            t.max = max;
            t.maxBy = maxBy;
            t.min = min;
            t.minBy = minBy;
            t.pairwise = pairwise;
            t.partition = partition;
            t.permute = permute;
            t.pick = pick;
            t.reduce = reduce;
            t.reduceBack = reduceBack;
            t.removeAllInPlace = removeAllInPlace;
            t.removeAt = removeAt;
            t.removeInPlace = removeInPlace;
            t.removeManyAt = removeManyAt;
            t.replicate = replicate;
            t.reverse = reverse;
            t.scan = scan;
            t.scanBack = scanBack;
            t.setSlice = setSlice;
            t.singleton = singleton;
            t.skip = skip;
            t.skipWhile = skipWhile;
            t.sort = sort;
            t.sortBy = sortBy;
            t.sortByDescending = sortByDescending;
            t.sortDescending = sortDescending;
            t.sortInPlace = sortInPlace;
            t.sortInPlaceBy = sortInPlaceBy;
            t.sortWith = sortWith;
            t.splitAt = splitAt;
            t.splitInto = splitInto;
            t.sum = sum;
            t.sumBy = sumBy;
            t.tail = tail;
            t.take = take;
            t.takeWhile = takeWhile;
            t.transpose = transpose;
            t.truncate = truncate;
            t.tryExactlyOne = tryExactlyOne;
            t.tryFind = tryFind;
            t.tryFindBack = tryFindBack;
            t.tryFindIndex = tryFindIndex;
            t.tryFindIndexBack = tryFindIndexBack;
            t.tryHead = tryHead;
            t.tryItem = tryItem;
            t.tryLast = tryLast;
            t.tryPick = tryPick;
            t.unfold = unfold;
            t.unzip = unzip;
            t.unzip3 = unzip3;
            t.updateAt = updateAt;
            t.where = where;
            t.windowed = windowed;
            t.zip = zip;
            t.zip3 = zip3;
            var n = r(6256);
            var i = r(4222);
            var o = r(1103);

            function Helpers_allocateArrayFromCons(e, t) {
                if (typeof e === "function") {
                    return new e(t)
                } else {
                    return new Array(t)
                }
            }

            function indexNotFound() {
                throw new Error("An index satisfying the predicate was not found in the collection.")
            }

            function differentLengths() {
                throw new Error("Arrays had different lengths")
            }

            function append(e, t, r) {
                const n = e.length | 0;
                const i = t.length | 0;
                const o = Helpers_allocateArrayFromCons(r, n + i);
                for (let t = 0; t <= n - 1; t++) {
                    o[t] = e[t]
                }
                for (let e = 0; e <= i - 1; e++) {
                    o[e + n] = t[e]
                }
                return o
            }

            function filter(e, t) {
                return t.filter(e)
            }

            function fill(e, t, r, n) {
                const i = t | 0;
                return e.fill(n, i, i + r)
            }

            function getSubArray(e, t, r) {
                const n = t | 0;
                return e.slice(n, n + r)
            }

            function last(e) {
                if (e.length === 0) {
                    throw new Error("The input array was empty\\nParameter name: array")
                }
                return e[e.length - 1]
            }

            function tryLast(e) {
                if (e.length === 0) {
                    return void 0
                } else {
                    return (0, n.some)(e[e.length - 1])
                }
            }

            function mapIndexed(e, t, r) {
                const n = t.length | 0;
                const i = Helpers_allocateArrayFromCons(r, n);
                for (let r = 0; r <= n - 1; r++) {
                    i[r] = e(r, t[r])
                }
                return i
            }

            function map(e, t, r) {
                const n = t.length | 0;
                const i = Helpers_allocateArrayFromCons(r, n);
                for (let r = 0; r <= n - 1; r++) {
                    i[r] = e(t[r])
                }
                return i
            }

            function mapIndexed2(e, t, r, n) {
                if (t.length !== r.length) {
                    throw new Error("Arrays had different lengths")
                }
                const i = Helpers_allocateArrayFromCons(n, t.length);
                for (let n = 0; n <= t.length - 1; n++) {
                    i[n] = e(n, t[n], r[n])
                }
                return i
            }

            function map2(e, t, r, n) {
                if (t.length !== r.length) {
                    throw new Error("Arrays had different lengths")
                }
                const i = Helpers_allocateArrayFromCons(n, t.length);
                for (let n = 0; n <= t.length - 1; n++) {
                    i[n] = e(t[n], r[n])
                }
                return i
            }

            function mapIndexed3(e, t, r, n, i) {
                if (t.length !== r.length ? true : r.length !== n.length) {
                    throw new Error("Arrays had different lengths")
                }
                const o = Helpers_allocateArrayFromCons(i, t.length);
                for (let i = 0; i <= t.length - 1; i++) {
                    o[i] = e(i, t[i], r[i], n[i])
                }
                return o
            }

            function map3(e, t, r, n, i) {
                if (t.length !== r.length ? true : r.length !== n.length) {
                    throw new Error("Arrays had different lengths")
                }
                const o = Helpers_allocateArrayFromCons(i, t.length);
                for (let i = 0; i <= t.length - 1; i++) {
                    o[i] = e(t[i], r[i], n[i])
                }
                return o
            }

            function mapFold(e, t, r, n) {
                const i = r.length | 0;
                if (i === 0) {
                    return [
                        [], t
                    ]
                } else {
                    let o = t;
                    const s = Helpers_allocateArrayFromCons(n, i);
                    for (let t = 0; t <= r.length - 1; t++) {
                        const n = e(o, r[t]);
                        s[t] = n[0];
                        o = n[1]
                    }
                    return [s, o]
                }
            }

            function mapFoldBack(e, t, r, n) {
                const i = t.length | 0;
                if (i === 0) {
                    return [
                        [], r
                    ]
                } else {
                    let o = r;
                    const s = Helpers_allocateArrayFromCons(n, i);
                    for (let r = t.length - 1; r >= 0; r--) {
                        const n = e(t[r], o);
                        s[r] = n[0];
                        o = n[1]
                    }
                    return [s, o]
                }
            }

            function indexed(e) {
                const t = e.length | 0;
                const r = new Array(t);
                for (let n = 0; n <= t - 1; n++) {
                    r[n] = [n, e[n]]
                }
                return r
            }

            function truncate(e, t) {
                const r = (0, i.max)(i.comparePrimitives, 0, e) | 0;
                const n = 0;
                return t.slice(n, n + r)
            }

            function concat(e, t) {
                const r = Array.isArray(e) ? e : Array.from(e);
                const n = r.length | 0;
                switch (n) {
                    case 0: {
                        return Helpers_allocateArrayFromCons(t, 0)
                    }
                    case 1: {
                        return r[0]
                    }
                    default: {
                        let e = 0;
                        let n = 0;
                        for (let e = 0; e <= r.length - 1; e++) {
                            const t = r[e];
                            n = n + t.length | 0
                        }
                        const i = Helpers_allocateArrayFromCons(t, n);
                        for (let t = 0; t <= r.length - 1; t++) {
                            const n = r[t];
                            for (let t = 0; t <= n.length - 1; t++) {
                                i[e] = n[t];
                                e = e + 1 | 0
                            }
                        }
                        return i
                    }
                }
            }

            function collect(e, t, r) {
                return concat(map(e, t, null), r)
            }

            function where(e, t) {
                return t.filter(e)
            }

            function contains(e, t, r) {
                const loop = n => {
                    e: while (true) {
                        const i = n;
                        if (i >= t.length) {
                            return false
                        } else if (r.Equals(e, t[i])) {
                            return true
                        } else {
                            n = i + 1;
                            continue e
                        }
                        break
                    }
                };
                return loop(0)
            }

            function empty(e) {
                return Helpers_allocateArrayFromCons(e, 0)
            }

            function singleton(e, t) {
                const r = Helpers_allocateArrayFromCons(t, 1);
                r[0] = e;
                return r
            }

            function initialize(e, t, r) {
                if (e < 0) {
                    throw new Error("The input must be non-negative\\nParameter name: count")
                }
                const n = Helpers_allocateArrayFromCons(r, e);
                for (let r = 0; r <= e - 1; r++) {
                    n[r] = t(r)
                }
                return n
            }

            function pairwise(e) {
                if (e.length < 2) {
                    return []
                } else {
                    const t = e.length - 1 | 0;
                    const r = new Array(t);
                    for (let n = 0; n <= t - 1; n++) {
                        r[n] = [e[n], e[n + 1]]
                    }
                    return r
                }
            }

            function replicate(e, t, r) {
                if (e < 0) {
                    throw new Error("The input must be non-negative\\nParameter name: count")
                }
                const n = Helpers_allocateArrayFromCons(r, e);
                for (let e = 0; e <= n.length - 1; e++) {
                    n[e] = t
                }
                return n
            }

            function copy(e) {
                return e.slice()
            }

            function reverse(e) {
                const t = e.slice();
                return t.reverse()
            }

            function scan(e, t, r, n) {
                const i = Helpers_allocateArrayFromCons(n, r.length + 1);
                i[0] = t;
                for (let t = 0; t <= r.length - 1; t++) {
                    i[t + 1] = e(i[t], r[t])
                }
                return i
            }

            function scanBack(e, t, r, n) {
                const i = Helpers_allocateArrayFromCons(n, t.length + 1);
                i[t.length] = r;
                for (let r = t.length - 1; r >= 0; r--) {
                    i[r] = e(t[r], i[r + 1])
                }
                return i
            }

            function skip(e, t, r) {
                if (e > t.length) {
                    throw new Error("count is greater than array length\\nParameter name: count")
                }
                if (e === t.length) {
                    return Helpers_allocateArrayFromCons(r, 0)
                } else {
                    const r = (e < 0 ? 0 : e) | 0;
                    return t.slice(r)
                }
            }

            function skipWhile(e, t, r) {
                let n = 0;
                while (n < t.length && e(t[n])) {
                    n = n + 1 | 0
                }
                if (n === t.length) {
                    return Helpers_allocateArrayFromCons(r, 0)
                } else {
                    const e = n | 0;
                    return t.slice(e)
                }
            }

            function take(e, t, r) {
                if (e < 0) {
                    throw new Error("The input must be non-negative\\nParameter name: count")
                }
                if (e > t.length) {
                    throw new Error("count is greater than array length\\nParameter name: count")
                }
                if (e === 0) {
                    return Helpers_allocateArrayFromCons(r, 0)
                } else {
                    const r = 0;
                    return t.slice(r, r + e)
                }
            }

            function takeWhile(e, t, r) {
                let n = 0;
                while (n < t.length && e(t[n])) {
                    n = n + 1 | 0
                }
                if (n === 0) {
                    return Helpers_allocateArrayFromCons(r, 0)
                } else {
                    const e = 0;
                    const r = n | 0;
                    return t.slice(e, e + r)
                }
            }

            function addInPlace(e, t) {
                t.push(e)
            }

            function addRangeInPlace(e, t) {
                const r = (0, i.getEnumerator)(e);
                try {
                    while (r["System.Collections.IEnumerator.MoveNext"]()) {
                        addInPlace(r["System.Collections.Generic.IEnumerator`1.get_Current"](), t)
                    }
                } finally {
                    (0, i.disposeSafe)(r)
                }
            }

            function insertRangeInPlace(e, t, r) {
                let n;
                let o = e;
                const s = (0, i.getEnumerator)(t);
                try {
                    while (s["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = s["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        n = o | 0, r.splice(n, 0, e);
                        o = o + 1 | 0
                    }
                } finally {
                    (0, i.disposeSafe)(s)
                }
            }

            function removeInPlace(e, t) {
                const r = t.indexOf(e, 0) | 0;
                if (r > -1) {
                    t.splice(r, 1);
                    return true
                } else {
                    return false
                }
            }

            function removeAllInPlace(e, t) {
                const countRemoveAll = r => {
                    const n = t.findIndex(e) | 0;
                    if (n > -1) {
                        t.splice(n, 1);
                        return countRemoveAll(r) + 1 | 0
                    } else {
                        return r | 0
                    }
                };
                return countRemoveAll(0) | 0
            }

            function copyTo(e, t, r, n, i) {
                const o = n - t | 0;
                for (let n = t; n <= t + i - 1; n++) {
                    r[n + o] = e[n]
                }
            }

            function copyToTypedArray(e, t, r, n, i) {
                try {
                    r.set(e.subarray(t, t + i), n)
                } catch (o) {
                    copyTo(e, t, r, n, i)
                }
            }

            function indexOf(e, t, r, i) {
                const o = (0, n.defaultArg)(r, 0) | 0;
                const s = e.indexOf(t, o) | 0;
                if (i != null && s >= o + (0, n.value)(i)) {
                    return -1
                } else {
                    return s | 0
                }
            }

            function partition(e, t, r) {
                const n = t.length | 0;
                const i = Helpers_allocateArrayFromCons(r, n);
                const o = Helpers_allocateArrayFromCons(r, n);
                let s = 0;
                let a = 0;
                for (let r = 0; r <= n - 1; r++) {
                    if (e(t[r])) {
                        i[s] = t[r];
                        s = s + 1 | 0
                    } else {
                        o[a] = t[r];
                        a = a + 1 | 0
                    }
                }
                return [truncate(s, i), truncate(a, o)]
            }

            function find(e, t) {
                const r = t.find(e);
                if (r == null) {
                    return indexNotFound()
                } else {
                    return (0, n.value)(r)
                }
            }

            function tryFind(e, t) {
                return t.find(e)
            }

            function findIndex(e, t) {
                const r = t.findIndex(e) | 0;
                if (r > -1) {
                    return r | 0
                } else {
                    return indexNotFound() | 0
                }
            }

            function tryFindIndex(e, t) {
                const r = t.findIndex(e) | 0;
                if (r > -1) {
                    return r
                } else {
                    return void 0
                }
            }

            function pick(e, t) {
                const loop = r => {
                    e: while (true) {
                        const i = r;
                        if (i >= t.length) {
                            return indexNotFound()
                        } else {
                            const o = e(t[i]);
                            if (o != null) {
                                return (0, n.value)(o)
                            } else {
                                r = i + 1;
                                continue e
                            }
                        }
                        break
                    }
                };
                return loop(0)
            }

            function tryPick(e, t) {
                const loop = r => {
                    e: while (true) {
                        const n = r;
                        if (n >= t.length) {
                            return void 0
                        } else {
                            const i = e(t[n]);
                            if (i == null) {
                                r = n + 1;
                                continue e
                            } else {
                                return i
                            }
                        }
                        break
                    }
                };
                return loop(0)
            }

            function findBack(e, t) {
                const loop = r => {
                    e: while (true) {
                        const n = r;
                        if (n < 0) {
                            return indexNotFound()
                        } else if (e(t[n])) {
                            return t[n]
                        } else {
                            r = n - 1;
                            continue e
                        }
                        break
                    }
                };
                return loop(t.length - 1)
            }

            function tryFindBack(e, t) {
                const loop = r => {
                    e: while (true) {
                        const i = r;
                        if (i < 0) {
                            return void 0
                        } else if (e(t[i])) {
                            return (0, n.some)(t[i])
                        } else {
                            r = i - 1;
                            continue e
                        }
                        break
                    }
                };
                return loop(t.length - 1)
            }

            function findLastIndex(e, t) {
                const loop = r => {
                    e: while (true) {
                        const n = r;
                        if (n < 0) {
                            return -1
                        } else if (e(t[n])) {
                            return n | 0
                        } else {
                            r = n - 1;
                            continue e
                        }
                        break
                    }
                };
                return loop(t.length - 1) | 0
            }

            function findIndexBack(e, t) {
                const loop = r => {
                    e: while (true) {
                        const n = r;
                        if (n < 0) {
                            return indexNotFound() | 0
                        } else if (e(t[n])) {
                            return n | 0
                        } else {
                            r = n - 1;
                            continue e
                        }
                        break
                    }
                };
                return loop(t.length - 1) | 0
            }

            function tryFindIndexBack(e, t) {
                const loop = r => {
                    e: while (true) {
                        const n = r;
                        if (n < 0) {
                            return void 0
                        } else if (e(t[n])) {
                            return n
                        } else {
                            r = n - 1;
                            continue e
                        }
                        break
                    }
                };
                return loop(t.length - 1)
            }

            function choose(e, t, r) {
                const i = [];
                for (let r = 0; r <= t.length - 1; r++) {
                    const o = e(t[r]);
                    if (o != null) {
                        const e = (0, n.value)(o);
                        i.push(e)
                    }
                }
                if (typeof r === "function") {
                    return map((e => e), i, r)
                } else {
                    return i
                }
            }

            function foldIndexed(e, t, r) {
                return r.reduce(((t, r, n) => e(n, t, r)), t)
            }

            function fold(e, t, r) {
                return r.reduce(e, t)
            }

            function iterate(e, t) {
                for (let r = 0; r <= t.length - 1; r++) {
                    e(t[r])
                }
            }

            function iterateIndexed(e, t) {
                for (let r = 0; r <= t.length - 1; r++) {
                    e(r, t[r])
                }
            }

            function iterate2(e, t, r) {
                if (t.length !== r.length) {
                    differentLengths()
                }
                for (let n = 0; n <= t.length - 1; n++) {
                    e(t[n], r[n])
                }
            }

            function iterateIndexed2(e, t, r) {
                if (t.length !== r.length) {
                    differentLengths()
                }
                for (let n = 0; n <= t.length - 1; n++) {
                    e(n, t[n], r[n])
                }
            }

            function isEmpty(e) {
                return e.length === 0
            }

            function forAll(e, t) {
                return t.every(e)
            }

            function permute(e, t) {
                const r = t.length | 0;
                const n = t.slice();
                const i = new Array(r);
                iterateIndexed(((t, o) => {
                    const s = e(t) | 0;
                    if (s < 0 ? true : s >= r) {
                        throw new Error("Not a valid permutation")
                    }
                    n[s] = o;
                    i[s] = 1
                }), t);
                if (!i.every((e => 1 === e))) {
                    throw new Error("Not a valid permutation")
                }
                return n
            }

            function setSlice(e, t, r, i) {
                const o = (0, n.defaultArg)(t, 0) | 0;
                const s = (0, n.defaultArg)(r, 0) | 0;
                const a = (s > 0 ? s : e.length - 1) - o | 0;
                for (let t = 0; t <= a; t++) {
                    e[t + o] = i[t]
                }
            }

            function sortInPlaceBy(e, t, r) {
                t.sort(((t, n) => r.Compare(e(t), e(n))))
            }

            function sortInPlace(e, t) {
                e.sort(((e, r) => t.Compare(e, r)))
            }

            function sort(e, t) {
                const r = e.slice();
                r.sort(((e, r) => t.Compare(e, r)));
                return r
            }

            function sortBy(e, t, r) {
                const n = t.slice();
                return n.sort(((t, n) => r.Compare(e(t), e(n)))), n
            }

            function sortDescending(e, t) {
                const r = e.slice();
                r.sort(((e, r) => t.Compare(e, r) * -1));
                return r
            }

            function sortByDescending(e, t, r) {
                const n = t.slice();
                return n.sort(((t, n) => r.Compare(e(t), e(n)) * -1)), n
            }

            function sortWith(e, t) {
                const r = e;
                const n = t.slice();
                n.sort(r);
                return n
            }

            function allPairs(e, t) {
                const r = e.length | 0;
                const n = t.length | 0;
                const i = new Array(r * n);
                for (let r = 0; r <= e.length - 1; r++) {
                    for (let o = 0; o <= t.length - 1; o++) {
                        i[r * n + o] = [e[r], t[o]]
                    }
                }
                return i
            }

            function unfold(e, t) {
                const r = [];
                const loop = t => {
                    e: while (true) {
                        const n = t;
                        const i = e(n);
                        if (i != null) {
                            const e = i[0];
                            const n = i[1];
                            r.push(e);
                            t = n;
                            continue e
                        }
                        break
                    }
                };
                loop(t);
                return r
            }

            function unzip(e) {
                const t = e.length | 0;
                const r = new Array(t);
                const n = new Array(t);
                iterateIndexed(((e, t) => {
                    r[e] = t[0];
                    n[e] = t[1]
                }), e);
                return [r, n]
            }

            function unzip3(e) {
                const t = e.length | 0;
                const r = new Array(t);
                const n = new Array(t);
                const i = new Array(t);
                iterateIndexed(((e, t) => {
                    r[e] = t[0];
                    n[e] = t[1];
                    i[e] = t[2]
                }), e);
                return [r, n, i]
            }

            function zip(e, t) {
                if (e.length !== t.length) {
                    differentLengths()
                }
                const r = new Array(e.length);
                for (let n = 0; n <= e.length - 1; n++) {
                    r[n] = [e[n], t[n]]
                }
                return r
            }

            function zip3(e, t, r) {
                if (e.length !== t.length ? true : t.length !== r.length) {
                    differentLengths()
                }
                const n = new Array(e.length);
                for (let i = 0; i <= e.length - 1; i++) {
                    n[i] = [e[i], t[i], r[i]]
                }
                return n
            }

            function chunkBySize(e, t) {
                if (e < 1) {
                    throw new Error("The input must be positive.\\nParameter name: size")
                }
                if (t.length === 0) {
                    return [
                        []
                    ]
                } else {
                    const r = [];
                    for (let n = 0; n <= ~~Math.ceil(t.length / e) - 1; n++) {
                        let i;
                        const o = n * e | 0;
                        i = t.slice(o, o + e);
                        r.push(i)
                    }
                    return r
                }
            }

            function splitAt(e, t) {
                let r;
                if (e < 0 ? true : e > t.length) {
                    throw new Error(o.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                return [(r = 0, t.slice(r, r + e)), t.slice(e)]
            }

            function compareWith(e, t, r) {
                if (t == null) {
                    if (r == null) {
                        return 0
                    } else {
                        return -1
                    }
                } else if (r == null) {
                    return 1
                } else {
                    let n = 0;
                    let i = 0;
                    const o = t.length | 0;
                    const s = r.length | 0;
                    if (o > s) {
                        return 1
                    } else if (o < s) {
                        return -1
                    } else {
                        while (n < o && i === 0) {
                            i = e(t[n], r[n]) | 0;
                            n = n + 1 | 0
                        }
                        return i | 0
                    }
                }
            }

            function equalsWith(e, t, r) {
                if (t == null) {
                    if (r == null) {
                        return true
                    } else {
                        return false
                    }
                } else if (r == null) {
                    return false
                } else {
                    let n = 0;
                    let i = true;
                    const o = t.length | 0;
                    const s = r.length | 0;
                    if (o > s) {
                        return false
                    } else if (o < s) {
                        return false
                    } else {
                        while (n < o && i) {
                            i = e(t[n], r[n]);
                            n = n + 1 | 0
                        }
                        return i
                    }
                }
            }

            function exactlyOne(e) {
                if (e.length === 1) {
                    return e[0]
                } else if (e.length === 0) {
                    throw new Error("The input sequence was empty\\nParameter name: array")
                } else {
                    throw new Error("Input array too long\\nParameter name: array")
                }
            }

            function tryExactlyOne(e) {
                if (e.length === 1) {
                    return (0, n.some)(e[0])
                } else {
                    return void 0
                }
            }

            function head(e) {
                if (e.length === 0) {
                    throw new Error("The input array was empty\\nParameter name: array")
                } else {
                    return e[0]
                }
            }

            function tryHead(e) {
                if (e.length === 0) {
                    return void 0
                } else {
                    return (0, n.some)(e[0])
                }
            }

            function tail(e) {
                if (e.length === 0) {
                    throw new Error("Not enough elements\\nParameter name: array")
                }
                return e.slice(1)
            }

            function item(e, t) {
                return t[e]
            }

            function tryItem(e, t) {
                if (e < 0 ? true : e >= t.length) {
                    return void 0
                } else {
                    return (0, n.some)(t[e])
                }
            }

            function foldBackIndexed(e, t, r) {
                return t.reduceRight(((t, r, n) => e(n, r, t)), r)
            }

            function foldBack(e, t, r) {
                return t.reduceRight(((t, r) => e(r, t)), r)
            }

            function foldIndexed2(e, t, r, n) {
                let i = t;
                if (r.length !== n.length) {
                    throw new Error("Arrays have different lengths")
                }
                for (let t = 0; t <= r.length - 1; t++) {
                    i = e(t, i, r[t], n[t])
                }
                return i
            }

            function fold2(e, t, r, n) {
                return foldIndexed2(((t, r, n, i) => e(r, n, i)), t, r, n)
            }

            function foldBackIndexed2(e, t, r, n) {
                let i = n;
                if (t.length !== r.length) {
                    differentLengths()
                }
                const o = t.length | 0;
                for (let n = 1; n <= o; n++) {
                    i = e(n - 1, t[o - n], r[o - n], i)
                }
                return i
            }

            function foldBack2(e, t, r, n) {
                return foldBackIndexed2(((t, r, n, i) => e(r, n, i)), t, r, n)
            }

            function reduce(e, t) {
                if (t.length === 0) {
                    throw new Error("The input array was empty")
                }
                const r = e;
                return t.reduce(r)
            }

            function reduceBack(e, t) {
                if (t.length === 0) {
                    throw new Error("The input array was empty")
                }
                const r = e;
                return t.reduceRight(r)
            }

            function forAll2(e, t, r) {
                return fold2(((t, r, n) => t && e(r, n)), true, t, r)
            }

            function existsOffset(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o === i.length) {
                        return false
                    } else if (n(i[o])) {
                        return true
                    } else {
                        e = n;
                        t = i;
                        r = o + 1;
                        continue e
                    }
                    break
                }
            }

            function exists(e, t) {
                return existsOffset(e, t, 0)
            }

            function existsOffset2(e, t, r, n) {
                e: while (true) {
                    const i = e,
                        o = t,
                        s = r,
                        a = n;
                    if (a === o.length) {
                        return false
                    } else if (i(o[a], s[a])) {
                        return true
                    } else {
                        e = i;
                        t = o;
                        r = s;
                        n = a + 1;
                        continue e
                    }
                    break
                }
            }

            function exists2(e, t, r) {
                if (t.length !== r.length) {
                    differentLengths()
                }
                return existsOffset2(e, t, r, 0)
            }

            function sum(e, t) {
                let r = t.GetZero();
                for (let n = 0; n <= e.length - 1; n++) {
                    r = t.Add(r, e[n])
                }
                return r
            }

            function sumBy(e, t, r) {
                let n = r.GetZero();
                for (let i = 0; i <= t.length - 1; i++) {
                    n = r.Add(n, e(t[i]))
                }
                return n
            }

            function maxBy(e, t, r) {
                return reduce(((t, n) => r.Compare(e(n), e(t)) > 0 ? n : t), t)
            }

            function max(e, t) {
                return reduce(((e, r) => t.Compare(r, e) > 0 ? r : e), e)
            }

            function minBy(e, t, r) {
                return reduce(((t, n) => r.Compare(e(n), e(t)) > 0 ? t : n), t)
            }

            function min(e, t) {
                return reduce(((e, r) => t.Compare(r, e) > 0 ? e : r), e)
            }

            function average(e, t) {
                if (e.length === 0) {
                    throw new Error("The input array was empty\\nParameter name: array")
                }
                let r = t.GetZero();
                for (let n = 0; n <= e.length - 1; n++) {
                    r = t.Add(r, e[n])
                }
                return t.DivideByInt(r, e.length)
            }

            function averageBy(e, t, r) {
                if (t.length === 0) {
                    throw new Error("The input array was empty\\nParameter name: array")
                }
                let n = r.GetZero();
                for (let i = 0; i <= t.length - 1; i++) {
                    n = r.Add(n, e(t[i]))
                }
                return r.DivideByInt(n, t.length)
            }

            function windowed(e, t) {
                if (e <= 0) {
                    throw new Error("windowSize must be positive")
                }
                let r;
                const n = (0, i.max)(i.comparePrimitives, 0, t.length - e + 1) | 0;
                r = new Array(n);
                for (let n = e; n <= t.length; n++) {
                    r[n - e] = t.slice(n - e, n - 1 + 1)
                }
                return r
            }

            function splitInto(e, t) {
                if (e < 1) {
                    throw new Error("The input must be positive.\\nParameter name: chunks")
                }
                if (t.length === 0) {
                    return [
                        []
                    ]
                } else {
                    const r = [];
                    const n = (0, i.min)(i.comparePrimitives, e, t.length) | 0;
                    const o = ~~(t.length / n) | 0;
                    const s = t.length % n | 0;
                    for (let e = 0; e <= n - 1; e++) {
                        const n = (e < s ? o + 1 : o) | 0;
                        let a;
                        const l = e * o + (0, i.min)(i.comparePrimitives, s, e) | 0;
                        a = t.slice(l, l + n);
                        r.push(a)
                    }
                    return r
                }
            }

            function transpose(e, t) {
                const r = Array.isArray(e) ? e : Array.from(e);
                const n = r.length | 0;
                if (n === 0) {
                    return new Array(0)
                } else {
                    const e = r[0];
                    const i = e.length | 0;
                    if (!forAll((e => e.length === i), r)) {
                        differentLengths()
                    }
                    const o = new Array(i);
                    for (let e = 0; e <= i - 1; e++) {
                        o[e] = Helpers_allocateArrayFromCons(t, n);
                        for (let t = 0; t <= n - 1; t++) {
                            o[e][t] = r[t][e]
                        }
                    }
                    return o
                }
            }

            function insertAt(e, t, r) {
                const n = r.length | 0;
                if (e < 0 ? true : e > n) {
                    throw new Error(o.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                const i = new r.constructor(n + 1);
                for (let t = 0; t <= e - 1; t++) {
                    i[t] = r[t]
                }
                i[e] = t;
                for (let t = e; t <= n - 1; t++) {
                    i[t + 1] = r[t]
                }
                return i
            }

            function insertManyAt(e, t, r) {
                const n = r.length | 0;
                if (e < 0 ? true : e > n) {
                    throw new Error(o.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                const i = Array.from(t);
                const s = i.length | 0;
                const a = new r.constructor(n + s);
                for (let t = 0; t <= e - 1; t++) {
                    a[t] = r[t]
                }
                for (let t = 0; t <= s - 1; t++) {
                    a[e + t] = i[t]
                }
                for (let t = e; t <= n - 1; t++) {
                    a[t + s] = r[t]
                }
                return a
            }

            function removeAt(e, t) {
                if (e < 0 ? true : e >= t.length) {
                    throw new Error(o.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                let r = -1;
                return filter((t => {
                    r = r + 1 | 0;
                    return r !== e
                }), t)
            }

            function removeManyAt(e, t, r) {
                let n = -1;
                let i = -1;
                const s = filter((r => {
                    n = n + 1 | 0;
                    if (n === e) {
                        i = 0;
                        return false
                    } else if (n > e) {
                        if (n < e + t) {
                            return false
                        } else {
                            i = 1;
                            return true
                        }
                    } else {
                        return true
                    }
                }), r);
                const a = (i === 0 && n + 1 === e + t ? 1 : i) | 0;
                if (a < 1) {
                    const e = a < 0 ? "index" : "count";
                    throw new Error(o.SR_indexOutOfBounds + "\\nParameter name: " + e)
                }
                return s
            }

            function updateAt(e, t, r) {
                const n = r.length | 0;
                if (e < 0 ? true : e >= n) {
                    throw new Error(o.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                const i = new r.constructor(n);
                for (let o = 0; o <= n - 1; o++) {
                    i[o] = o === e ? t : r[o]
                }
                return i
            }
        },
        5361: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.abs = abs;
            t.compare = compare;
            t.divRem = divRem;
            t.equals = equals;
            t.fromByteArray = fromByteArray;
            t.fromInt32 = fromInt32;
            t.fromInt64 = fromInt64;
            t.fromOne = fromOne;
            t.fromString = fromString;
            t.fromZero = fromZero;
            t.get_Zero = t.get_One = void 0;
            t.greatestCommonDivisor = greatestCommonDivisor;
            t.hash = hash;
            t.isBigInt = isBigInt;
            t.isOne = isOne;
            t.isZero = isZero;
            t.one = void 0;
            t.op_Addition = op_Addition;
            t.op_BitwiseAnd = op_BitwiseAnd;
            t.op_BitwiseOr = op_BitwiseOr;
            t.op_Division = op_Division;
            t.op_Equality = op_Equality;
            t.op_ExclusiveOr = op_ExclusiveOr;
            t.op_GreaterThan = op_GreaterThan;
            t.op_GreaterThanOrEqual = op_GreaterThanOrEqual;
            t.op_Inequality = op_Inequality;
            t.op_LeftShift = op_LeftShift;
            t.op_LessThan = op_LessThan;
            t.op_LessThanOrEqual = op_LessThanOrEqual;
            t.op_Modulus = op_Modulus;
            t.op_Multiply = op_Multiply;
            t.op_RightShift = op_RightShift;
            t.op_Subtraction = op_Subtraction;
            t.op_UnaryNegation = op_UnaryNegation;
            t.op_UnaryPlus = op_UnaryPlus;
            t.parse = parse;
            t.pow = pow;
            t.sign = sign;
            t.toByte = toByte;
            t.toByteArray = toByteArray;
            t.toDecimal = toDecimal;
            t.toDouble = toDouble;
            t.toInt16 = toInt16;
            t.toInt32 = toInt32;
            t.toInt64 = toInt64;
            t.toSByte = toSByte;
            t.toSingle = toSingle;
            t.toString = toString;
            t.toUInt16 = toUInt16;
            t.toUInt32 = toUInt32;
            t.toUInt64 = toUInt64;
            t.tryParse = tryParse;
            t.zero = t.two = void 0;
            var n = r(4949);
            var i = r(2836);
            var o = r(4222);
            var s = r(6638);
            var a = r(5359);
            var l = r(9054);

            function isBigInt(e) {
                return e instanceof n.BigInteger
            }

            function tryParse(e, t) {
                try {
                    t.contents = (0, n.BigInteger_Parse_Z721C83C5)(e);
                    return true
                } catch (e) {
                    return false
                }
            }

            function divRem(e, t, r) {
                const i = (0, n.BigInteger_DivRem_56F059C0)(e, t);
                r.contents = i[1];
                return i[0]
            }

            function parse(e) {
                return (0, n.BigInteger_Parse_Z721C83C5)(e)
            }

            function greatestCommonDivisor(e, t) {
                return (0, n.BigInteger_GreatestCommonDivisor_56F059C0)(e, t)
            }

            function pow(e, t) {
                return (0, n.BigInteger_Pow_62E082A2)(e, t)
            }

            function abs(e) {
                return (0, n.BigInteger_Abs_Z665282C2)(e)
            }
            const _ = (0, n.BigInteger_get_Zero)();
            t.zero = _;
            const u = (0, n.BigInteger_get_One)();
            t.one = u;
            const c = (0, n.BigInteger_get_Two)();
            t.two = c;

            function fromString(e) {
                return (0, n.BigInteger_Parse_Z721C83C5)(e)
            }

            function fromZero() {
                return (0, n.BigInteger_get_Zero)()
            }

            function fromOne() {
                return (0, n.BigInteger_get_One)()
            }

            function fromInt64(e) {
                return (0, n.BigInteger_$ctor_Z524259C1)(e)
            }

            function fromInt32(e) {
                if (e > 2147483647) {
                    return (0, n.BigInteger_$ctor_Z524259C1)((0, i.fromInteger)(e, false, 6))
                } else {
                    return (0, n.BigInteger_$ctor_Z524259A4)(e)
                }
            }

            function toSByte(e) {
                return (0, n.BigInteger__get_ToSByte)(e)
            }

            function toByte(e) {
                return (0, n.BigInteger__get_ToByte)(e)
            }

            function toInt16(e) {
                return (0, n.BigInteger__get_ToInt16)(e)
            }

            function toUInt16(e) {
                return (0, n.BigInteger__get_ToUInt16)(e)
            }

            function toInt32(e) {
                return (0, n.BigInteger__get_ToInt32)(e)
            }

            function toUInt32(e) {
                return (0, n.BigInteger__get_ToUInt32)(e)
            }

            function toInt64(e) {
                return (0, n.BigInteger__get_ToInt64)(e)
            }

            function toUInt64(e) {
                return (0, n.BigInteger__get_ToUInt64)(e)
            }

            function toSingle(e) {
                return (0, n.BigInteger__get_ToSingle)(e)
            }

            function toDouble(e) {
                return (0, n.BigInteger__get_ToDouble)(e)
            }

            function toDecimal(e) {
                return (0, n.BigInteger__get_ToDecimal)(e)
            }

            function sign(e) {
                return (0, n.BigInteger__get_Sign)(e)
            }

            function isZero(e) {
                return (0, n.BigInteger__get_IsZero)(e)
            }

            function isOne(e) {
                return (0, n.BigInteger__get_IsOne)(e)
            }

            function hash(e) {
                return (0, o.safeHash)(e)
            }

            function compare(e, t) {
                return e.CompareTo(t)
            }

            function equals(e, t) {
                return (0, o.equals)(e, t)
            }

            function toString(e) {
                return (0, s.toString)(e)
            }
            const d = (0, n.BigInteger_get_Zero)();
            t.get_Zero = d;
            const p = (0, n.BigInteger_get_One)();
            t.get_One = p;

            function op_Addition(e, t) {
                return (0, n.BigInteger_op_Addition_56F059C0)(e, t)
            }

            function op_Subtraction(e, t) {
                return (0, n.BigInteger_op_Subtraction_56F059C0)(e, t)
            }

            function op_Multiply(e, t) {
                return (0, n.BigInteger_op_Multiply_56F059C0)(e, t)
            }

            function op_Division(e, t) {
                return (0, n.BigInteger_op_Division_56F059C0)(e, t)
            }

            function op_Modulus(e, t) {
                return (0, n.BigInteger_op_Modulus_56F059C0)(e, t)
            }

            function op_UnaryNegation(e) {
                return (0, n.BigInteger_op_UnaryNegation_Z665282C2)(e)
            }

            function op_UnaryPlus(e) {
                return (0, n.BigInteger_op_UnaryPlus_Z665282C2)(e)
            }

            function op_RightShift(e, t) {
                return (0, n.BigInteger_op_RightShift_62E082A2)(e, t)
            }

            function op_LeftShift(e, t) {
                return (0, n.BigInteger_op_LeftShift_62E082A2)(e, t)
            }

            function op_BitwiseAnd(e, t) {
                return (0, n.BigInteger_op_BitwiseAnd_56F059C0)(e, t)
            }

            function op_BitwiseOr(e, t) {
                return (0, n.BigInteger_op_BitwiseOr_56F059C0)(e, t)
            }

            function op_ExclusiveOr(e, t) {
                return (0, n.BigInteger_op_ExclusiveOr_56F059C0)(e, t)
            }

            function op_LessThan(e, t) {
                return (0, n.BigInteger_op_LessThan_56F059C0)(e, t)
            }

            function op_LessThanOrEqual(e, t) {
                return (0, n.BigInteger_op_LessThanOrEqual_56F059C0)(e, t)
            }

            function op_GreaterThan(e, t) {
                return (0, n.BigInteger_op_GreaterThan_56F059C0)(e, t)
            }

            function op_GreaterThanOrEqual(e, t) {
                return (0, n.BigInteger_op_GreaterThanOrEqual_56F059C0)(e, t)
            }

            function op_Equality(e, t) {
                return (0, n.BigInteger_op_Equality_56F059C0)(e, t)
            }

            function op_Inequality(e, t) {
                return (0, n.BigInteger_op_Inequality_56F059C0)(e, t)
            }

            function flipTwosComplement(e, t) {
                let r;
                const n = [e, t];
                if (n[1]) {
                    return [(e ^ 255) & 255, true]
                } else if (n[0] === 0) {
                    return [0, false]
                } else {
                    return [(e ^ 254 << (r = new Int32Array([0, 1, 2, 3, 4, 5, 6, 7]), r.find((t => (e & 1 << t) > 0)))) & 255, true]
                }
            }

            function toByteArray(e) {
                if ((0, o.equals)(e, _)) {
                    return new Uint8Array([0])
                } else {
                    const t = (0, o.compare)(e, _) > 0;
                    const r = t ? e : (0, n.BigInteger_op_Multiply_56F059C0)((0, n.BigInteger_$ctor_Z524259A4)(-1), e);
                    const s = fromInt64((0, i.fromInteger)(4294967295, false, 6));
                    const loop = (e, r, i) => {
                        let u, c, d, p;
                        e: while (true) {
                            const f = e,
                                h = r,
                                g = i;
                            if ((0, o.compare)(h, _) <= 0) {
                                const e = t ? (0, a.skipWhile)((e => e === 0), f) : (0, a.skipWhile)((e => e === 255), f);
                                const r = ((0, a.head)(e) & 128) !== 0;
                                return (0, l.reverse)((0, a.toArray)(t && r ? (0, a.cons)(0, e) : !t && !r ? (0, a.cons)(255, e) : e))
                            } else {
                                const o = toUInt32((0, n.BigInteger_op_BitwiseAnd_56F059C0)(h, s));
                                if (t) {
                                    const t = o & 255;
                                    let s;
                                    const l = o >>> 8;
                                    s = l & 255;
                                    let _;
                                    const c = o >>> 16;
                                    _ = c & 255;
                                    e = (0, a.ofArrayWithTail)([(u = o >>> 24, u & 255), _, s, t], f);
                                    r = (0, n.BigInteger_op_RightShift_62E082A2)(h, 32);
                                    i = false;
                                    continue e
                                } else {
                                    const t = flipTwosComplement(o & 255, g);
                                    const s = flipTwosComplement((c = o >>> 8, c & 255), t[1]);
                                    const l = flipTwosComplement((d = o >>> 16, d & 255), s[1]);
                                    const _ = flipTwosComplement((p = o >>> 24, p & 255), l[1]);
                                    e = (0, a.ofArrayWithTail)([_[0], l[0], s[0], t[0]], f);
                                    r = (0, n.BigInteger_op_RightShift_62E082A2)(h, 32);
                                    i = _[1];
                                    continue e
                                }
                            }
                            break
                        }
                    };
                    return loop((0, a.empty)(), r, false)
                }
            }

            function fromByteArray(e) {
                if (e == null) {
                    throw new Error("bytes")
                }
                if (e.length === 0) {
                    return _
                } else {
                    const t = (e[e.length - 1] & 128) === 0;
                    const r = (0, l.fill)(new Uint8Array(4), 0, 4, 0);
                    const loop = (s, u, c, d) => {
                        e: while (true) {
                            const p = s,
                                f = u,
                                h = c,
                                g = d;
                            if (h === 0) {
                                const e = (0, a.fold)(((e, t) => (0, n.BigInteger_op_Addition_56F059C0)((0, n.BigInteger_op_LeftShift_62E082A2)(e, 32), fromInt64((0, i.fromInteger)(t, false, 6)))), _, p);
                                if (t) {
                                    return e
                                } else {
                                    return (0, n.BigInteger_op_Multiply_56F059C0)((0, n.BigInteger_$ctor_Z524259A4)(-1), e)
                                }
                            } else {
                                const n = (0, o.min)(o.comparePrimitives, h, 4) | 0;
                                for (let t = 0; t <= n - 1; t++) {
                                    r[t] = e[f + t]
                                }
                                if (t) {
                                    (0, l.fill)(r, n, 4 - n, 0);
                                    s = (0, a.cons)((((r[0] | r[1] << 8 >>> 0) >>> 0 | r[2] << 16 >>> 0) >>> 0 | r[3] << 24 >>> 0) >>> 0, p);
                                    u = f + n;
                                    c = h - n;
                                    d = false;
                                    continue e
                                } else {
                                    (0, l.fill)(r, n, 4 - n, 255);
                                    const e = flipTwosComplement(r[0], g);
                                    const t = flipTwosComplement(r[1], e[1]);
                                    const i = flipTwosComplement(r[2], t[1]);
                                    const o = flipTwosComplement(r[3], i[1]);
                                    s = (0, a.cons)((((e[0] | t[0] << 8 >>> 0) >>> 0 | i[0] << 16 >>> 0) >>> 0 | o[0] << 24 >>> 0) >>> 0, p);
                                    u = f + n;
                                    c = h - n;
                                    d = o[1];
                                    continue e
                                }
                            }
                            break
                        }
                    };
                    return loop((0, a.empty)(), 0, e.length, false)
                }
            }
        },
        3834: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BigNat = void 0;
            t.BigNat$reflection = BigNat$reflection;
            t.BigNatModule_FFT_Fp_m2PowNthRoot = BigNatModule_FFT_Fp_m2PowNthRoot;
            t.BigNatModule_FFT_Fp_minv = BigNatModule_FFT_Fp_minv;
            t.BigNatModule_FFT_Fp_mone = void 0;
            t.BigNatModule_FFT_Fp_mpow = BigNatModule_FFT_Fp_mpow;
            t.BigNatModule_FFT_Fp_mpowL = BigNatModule_FFT_Fp_mpowL;
            t.BigNatModule_FFT_Fp_mzero = t.BigNatModule_FFT_Fp_mtwo = void 0;
            t.BigNatModule_FFT_Fp_ofInt32 = BigNatModule_FFT_Fp_ofInt32;
            t.BigNatModule_FFT_Fp_p64 = t.BigNatModule_FFT_Fp_p = void 0;
            t.BigNatModule_FFT_Fp_toInt = BigNatModule_FFT_Fp_toInt;
            t.BigNatModule_FFT_computFftInPlace = BigNatModule_FFT_computFftInPlace;
            t.BigNatModule_FFT_computeFFT = BigNatModule_FFT_computeFFT;
            t.BigNatModule_FFT_computeFftPaddedPolynomialProduct = BigNatModule_FFT_computeFftPaddedPolynomialProduct;
            t.BigNatModule_FFT_computeFftPolynomialProduct = BigNatModule_FFT_computeFftPolynomialProduct;
            t.BigNatModule_FFT_computeInverseFftInPlace = BigNatModule_FFT_computeInverseFftInPlace;
            t.BigNatModule_FFT_k = t.BigNatModule_FFT_g = void 0;
            t.BigNatModule_FFT_leastBounding2Power = BigNatModule_FFT_leastBounding2Power;
            t.BigNatModule_FFT_p = t.BigNatModule_FFT_mzero = t.BigNatModule_FFT_mone = t.BigNatModule_FFT_maxTwoPower = t.BigNatModule_FFT_maxFp = t.BigNatModule_FFT_maxBitsInsideFp = t.BigNatModule_FFT_m = void 0;
            t.BigNatModule_FFT_padTo = BigNatModule_FFT_padTo;
            t.BigNatModule_FFT_pow32 = BigNatModule_FFT_pow32;
            t.BigNatModule_FFT_w = t.BigNatModule_FFT_twoPowerTable = t.BigNatModule_FFT_primeP = void 0;
            t.BigNatModule_IsZero = BigNatModule_IsZero;
            t.BigNatModule_add = BigNatModule_add;
            t.BigNatModule_addP = BigNatModule_addP;
            t.BigNatModule_baseShift64C = t.BigNatModule_baseShift64B = t.BigNatModule_baseShift32B = t.BigNatModule_baseNi64 = t.BigNatModule_baseN = t.BigNatModule_baseMaski64 = t.BigNatModule_baseMaskU = t.BigNatModule_baseMask64C = t.BigNatModule_baseMask64B = t.BigNatModule_baseMask64A = t.BigNatModule_baseMask32B = t.BigNatModule_baseMask32A = t.BigNatModule_baseMask = t.BigNatModule_baseBits = void 0;
            t.BigNatModule_bitAnd = BigNatModule_bitAnd;
            t.BigNatModule_bitOr = BigNatModule_bitOr;
            t.BigNatModule_bitXor = BigNatModule_bitXor;
            t.BigNatModule_bitmask = void 0;
            t.BigNatModule_bits = BigNatModule_bits;
            t.BigNatModule_bound = BigNatModule_bound;
            t.BigNatModule_boundInt64 = t.BigNatModule_boundInt = t.BigNatModule_boundBase = void 0;
            t.BigNatModule_calculateTableTow = BigNatModule_calculateTableTow;
            t.BigNatModule_coeff = BigNatModule_coeff;
            t.BigNatModule_coeff64 = BigNatModule_coeff64;
            t.BigNatModule_compare = BigNatModule_compare;
            t.BigNatModule_contributeArr = BigNatModule_contributeArr;
            t.BigNatModule_copyN = BigNatModule_copyN;
            t.BigNatModule_createN = BigNatModule_createN;
            t.BigNatModule_decodePoly = BigNatModule_decodePoly;
            t.BigNatModule_decodeResultBits = BigNatModule_decodeResultBits;
            t.BigNatModule_degree = BigNatModule_degree;
            t.BigNatModule_div = BigNatModule_div;
            t.BigNatModule_divbase = BigNatModule_divbase;
            t.BigNatModule_divmod = BigNatModule_divmod;
            t.BigNatModule_embed = BigNatModule_embed;
            t.BigNatModule_embed64 = BigNatModule_embed64;
            t.BigNatModule_encodePoly = BigNatModule_encodePoly;
            t.BigNatModule_encoding = void 0;
            t.BigNatModule_encoding$reflection = BigNatModule_encoding$reflection;
            t.BigNatModule_encodingGivenResultBits = BigNatModule_encodingGivenResultBits;
            t.BigNatModule_equal = BigNatModule_equal;
            t.BigNatModule_eval32 = BigNatModule_eval32;
            t.BigNatModule_eval64 = BigNatModule_eval64;
            t.BigNatModule_extractBits = BigNatModule_extractBits;
            t.BigNatModule_factorial = BigNatModule_factorial;
            t.BigNatModule_getSmall = BigNatModule_getSmall;
            t.BigNatModule_gt = BigNatModule_gt;
            t.BigNatModule_gte = BigNatModule_gte;
            t.BigNatModule_hash = BigNatModule_hash;
            t.BigNatModule_hcf = BigNatModule_hcf;
            t.BigNatModule_isOne = BigNatModule_isOne;
            t.BigNatModule_isSmall = BigNatModule_isSmall;
            t.BigNatModule_isZero = BigNatModule_isZero;
            t.BigNatModule_lt = BigNatModule_lt;
            t.BigNatModule_lte = BigNatModule_lte;
            t.BigNatModule_max = BigNatModule_max;
            t.BigNatModule_maxInt = BigNatModule_maxInt;
            t.BigNatModule_min = BigNatModule_min;
            t.BigNatModule_minDigitsKaratsuba = void 0;
            t.BigNatModule_minInt = BigNatModule_minInt;
            t.BigNatModule_mkEncoding = BigNatModule_mkEncoding;
            t.BigNatModule_modbase = BigNatModule_modbase;
            t.BigNatModule_mul = BigNatModule_mul;
            t.BigNatModule_mulKaratsuba = BigNatModule_mulKaratsuba;
            t.BigNatModule_mulSchoolBook = BigNatModule_mulSchoolBook;
            t.BigNatModule_mulSchoolBookBothSmall = BigNatModule_mulSchoolBookBothSmall;
            t.BigNatModule_mulSchoolBookCarry = BigNatModule_mulSchoolBookCarry;
            t.BigNatModule_mulSchoolBookNeitherSmall = BigNatModule_mulSchoolBookNeitherSmall;
            t.BigNatModule_mulSchoolBookOneSmall = BigNatModule_mulSchoolBookOneSmall;
            t.BigNatModule_normN = BigNatModule_normN;
            t.BigNatModule_ofInt32 = BigNatModule_ofInt32;
            t.BigNatModule_ofInt64 = BigNatModule_ofInt64;
            t.BigNatModule_ofString = BigNatModule_ofString;
            t.BigNatModule_one = void 0;
            t.BigNatModule_pow = BigNatModule_pow;
            t.BigNatModule_pow32 = BigNatModule_pow32;
            t.BigNatModule_pow64 = BigNatModule_pow64;
            t.BigNatModule_powi = BigNatModule_powi;
            t.BigNatModule_productDigitsUpperSchoolBook = t.BigNatModule_productDigitsUpperFft = void 0;
            t.BigNatModule_quickMulUsingFft = BigNatModule_quickMulUsingFft;
            t.BigNatModule_recMulKaratsuba = BigNatModule_recMulKaratsuba;
            t.BigNatModule_rem = BigNatModule_rem;
            t.BigNatModule_removeFactor = BigNatModule_removeFactor;
            t.BigNatModule_restrictTo = BigNatModule_restrictTo;
            t.BigNatModule_scale = BigNatModule_scale;
            t.BigNatModule_scaleAdd = BigNatModule_scaleAdd;
            t.BigNatModule_scaleAddInPlace = BigNatModule_scaleAddInPlace;
            t.BigNatModule_scaleSub = BigNatModule_scaleSub;
            t.BigNatModule_scaleSubInPlace = BigNatModule_scaleSubInPlace;
            t.BigNatModule_setBound = BigNatModule_setBound;
            t.BigNatModule_setCoeff = BigNatModule_setCoeff;
            t.BigNatModule_shiftCompare = BigNatModule_shiftCompare;
            t.BigNatModule_shiftDown = BigNatModule_shiftDown;
            t.BigNatModule_shiftUp = BigNatModule_shiftUp;
            t.BigNatModule_singleDigitForceSchoolBook = void 0;
            t.BigNatModule_sub = BigNatModule_sub;
            t.BigNatModule_subP = BigNatModule_subP;
            t.BigNatModule_table = void 0;
            t.BigNatModule_toFloat = BigNatModule_toFloat;
            t.BigNatModule_toString = BigNatModule_toString;
            t.BigNatModule_toUInt32 = BigNatModule_toUInt32;
            t.BigNatModule_toUInt64 = BigNatModule_toUInt64;
            t.BigNatModule_twopowersI64 = t.BigNatModule_twopowers = t.BigNatModule_two = void 0;
            t.BigNatModule_wordBits = BigNatModule_wordBits;
            t.BigNatModule_zero = void 0;
            var n = r(6638);
            var i = r(6356);
            var o = r(2836);
            var s = r(9054);
            var a = r(5359);
            var l = r(4222);
            var _ = r(9937);
            class BigNat extends n.Record {
                constructor(e, t) {
                    super();
                    this.bound = e | 0;
                    this.digits = t
                }
            }
            t.BigNat = BigNat;

            function BigNat$reflection() {
                return (0, i.record_type)("BigInt.BigNat", [], BigNat, (() => [
                    ["bound", i.int32_type],
                    ["digits", (0, i.array_type)(i.int32_type)]
                ]))
            }

            function BigNatModule_FFT_pow32(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n === 0) {
                        return 1
                    } else if (n % 2 === 0) {
                        e = r * r;
                        t = ~~(n / 2);
                        continue e
                    } else {
                        return r * BigNatModule_FFT_pow32(r * r, ~~(n / 2)) | 0
                    }
                    break
                }
            }

            function BigNatModule_FFT_leastBounding2Power(e) {
                const findBounding2Power = (e, t, r) => {
                    e: while (true) {
                        const n = e,
                            i = t,
                            o = r;
                        if (n <= i) {
                            return [i, o]
                        } else {
                            e = n;
                            t = i * 2;
                            r = o + 1;
                            continue e
                        }
                        break
                    }
                };
                return findBounding2Power(e, 1, 0)
            }
            const u = (0, o.fromBits)(2013265921, 0, false);
            t.BigNatModule_FFT_p = u;
            const c = [27, 15, 31, 440564289];
            const d = c[3];
            t.BigNatModule_FFT_w = d;
            const p = c[1];
            t.BigNatModule_FFT_m = p;
            const f = c[0];
            t.BigNatModule_FFT_k = f;
            const h = c[2];
            t.BigNatModule_FFT_g = h;
            const g = u;
            t.BigNatModule_FFT_primeP = g;
            const m = 30;
            t.BigNatModule_FFT_maxBitsInsideFp = m;
            const y = 2013265921;
            t.BigNatModule_FFT_Fp_p = y;
            const S = (0, o.fromBits)(2013265921, 0, true);
            t.BigNatModule_FFT_Fp_p64 = S;

            function BigNatModule_FFT_Fp_toInt(e) {
                return ~~e
            }

            function BigNatModule_FFT_Fp_ofInt32(e) {
                return e >>> 0
            }
            const T = 0;
            t.BigNatModule_FFT_Fp_mzero = T;
            const x = 1;
            t.BigNatModule_FFT_Fp_mone = x;
            const C = 2;
            t.BigNatModule_FFT_Fp_mtwo = C;

            function BigNatModule_FFT_Fp_mpow(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n === 0) {
                        return x
                    } else if (n % 2 === 0) {
                        e = (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(r, true, 6), (0, o.fromInteger)(r, true, 6)), S)) >>> 0;
                        t = ~~(n / 2);
                        continue e
                    } else {
                        const e = BigNatModule_FFT_Fp_mpow((0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(r, true, 6), (0, o.fromInteger)(r, true, 6)), S)) >>> 0, ~~(n / 2));
                        return (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(r, true, 6), (0, o.fromInteger)(e, true, 6)), S)) >>> 0
                    }
                    break
                }
            }

            function BigNatModule_FFT_Fp_mpowL(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if ((0, o.equals)(n, (0, o.fromBits)(0, 0, false))) {
                        return x
                    } else if ((0, o.equals)((0, o.op_Modulus)(n, (0, o.fromBits)(2, 0, false)), (0, o.fromBits)(0, 0, false))) {
                        e = (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(r, true, 6), (0, o.fromInteger)(r, true, 6)), S)) >>> 0;
                        t = (0, o.op_Division)(n, (0, o.fromBits)(2, 0, false));
                        continue e
                    } else {
                        const e = BigNatModule_FFT_Fp_mpowL((0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(r, true, 6), (0, o.fromInteger)(r, true, 6)), S)) >>> 0, (0, o.op_Division)(n, (0, o.fromBits)(2, 0, false)));
                        return (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(r, true, 6), (0, o.fromInteger)(e, true, 6)), S)) >>> 0
                    }
                    break
                }
            }

            function BigNatModule_FFT_Fp_m2PowNthRoot(e) {
                return BigNatModule_FFT_Fp_mpow(d >>> 0, BigNatModule_FFT_pow32(2, f - e))
            }

            function BigNatModule_FFT_Fp_minv(e) {
                return BigNatModule_FFT_Fp_mpowL(e, (0, o.op_Subtraction)(g, (0, o.fromBits)(2, 0, false)))
            }

            function BigNatModule_FFT_computeFFT(e, t, r, n, i, s, a) {
                let l, _, u;
                if (r === 1) {
                    s[a] = i[t]
                } else {
                    const c = ~~(r / 2) | 0;
                    const d = (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(n, true, 6), (0, o.fromInteger)(n, true, 6)), S)) >>> 0;
                    const p = a + c | 0;
                    BigNatModule_FFT_computeFFT(e * 2, t, c, d, i, s, a);
                    BigNatModule_FFT_computeFFT(e * 2, e + t, c, d, i, s, p);
                    let f = x;
                    for (let e = 0; e <= c - 1; e++) {
                        const t = s[a + e];
                        const r = s[p + e];
                        s[a + e] = (t + (l = f, (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(l, true, 6), (0, o.fromInteger)(r, true, 6)), S)) >>> 0)) % y;
                        s[p + e] = (t + y - (_ = f, (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(_, true, 6), (0, o.fromInteger)(r, true, 6)), S)) >>> 0)) % y;
                        f = (u = f, (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(n, true, 6), (0, o.fromInteger)(u, true, 6)), S)) >>> 0)
                    }
                }
            }

            function BigNatModule_FFT_computFftInPlace(e, t, r) {
                const n = (0, s.fill)(new Uint32Array(e), 0, e, T);
                BigNatModule_FFT_computeFFT(1, 0, e, t, r, n, 0);
                return n
            }

            function BigNatModule_FFT_computeInverseFftInPlace(e, t, r) {
                const n = BigNatModule_FFT_Fp_minv(e >>> 0);
                return (0, s.map)((e => (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(n, true, 6), (0, o.fromInteger)(e, true, 6)), S)) >>> 0), BigNatModule_FFT_computFftInPlace(e, BigNatModule_FFT_Fp_minv(t), r), Uint32Array)
            }
            const N = 29;
            t.BigNatModule_FFT_maxTwoPower = N;
            const A = (0, s.initialize)(N - 1, (e => BigNatModule_FFT_pow32(2, e)), Int32Array);
            t.BigNatModule_FFT_twoPowerTable = A;

            function BigNatModule_FFT_computeFftPaddedPolynomialProduct(e, t, r, n) {
                const i = BigNatModule_FFT_Fp_m2PowNthRoot(t);
                const a = e | 0;
                const l = BigNatModule_FFT_computFftInPlace(a, i, r);
                const _ = BigNatModule_FFT_computFftInPlace(a, i, n);
                return BigNatModule_FFT_computeInverseFftInPlace(a, i, (0, s.initialize)(a, (e => {
                    const t = l[e];
                    const r = _[e];
                    return (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(t, true, 6), (0, o.fromInteger)(r, true, 6)), S)) >>> 0
                }), Uint32Array))
            }

            function BigNatModule_FFT_padTo(e, t) {
                const r = t.length | 0;
                return (0, s.initialize)(e, (e => e < r ? BigNatModule_FFT_Fp_ofInt32(t[e]) : T), Uint32Array)
            }

            function BigNatModule_FFT_computeFftPolynomialProduct(e, t, r, n) {
                const i = BigNatModule_FFT_leastBounding2Power(e + r + 1);
                const a = i[0] | 0;
                const l = BigNatModule_FFT_Fp_m2PowNthRoot(i[1]);
                const _ = BigNatModule_FFT_padTo(a, t);
                const u = BigNatModule_FFT_padTo(a, n);
                const c = a | 0;
                const d = BigNatModule_FFT_computFftInPlace(c, l, _);
                const p = BigNatModule_FFT_computFftInPlace(c, l, u);
                return (0, s.map)(BigNatModule_FFT_Fp_toInt, BigNatModule_FFT_computeInverseFftInPlace(c, l, (0, s.initialize)(c, (e => {
                    const t = d[e];
                    const r = p[e];
                    return (0, o.toInt)((0, o.op_Modulus)((0, o.op_Multiply)((0, o.fromInteger)(t, true, 6), (0, o.fromInteger)(r, true, 6)), S)) >>> 0
                }), Uint32Array)), Int32Array)
            }
            const E = T;
            t.BigNatModule_FFT_mzero = E;
            const v = x;
            t.BigNatModule_FFT_mone = v;
            const M = (y + y - v) % y;
            t.BigNatModule_FFT_maxFp = M;

            function BigNatModule_bound(e) {
                return e.bound
            }

            function BigNatModule_setBound(e, t) {
                e.bound = t | 0
            }

            function BigNatModule_coeff(e, t) {
                return e.digits[t]
            }

            function BigNatModule_coeff64(e, t) {
                return (0, o.fromInteger)(BigNatModule_coeff(e, t), false, 2)
            }

            function BigNatModule_setCoeff(e, t, r) {
                e.digits[t] = r | 0
            }

            function BigNatModule_pow64(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n === 0) {
                        return (0, o.fromBits)(1, 0, false)
                    } else if (n % 2 === 0) {
                        e = (0, o.op_Multiply)(r, r);
                        t = ~~(n / 2);
                        continue e
                    } else {
                        return (0, o.op_Multiply)(r, BigNatModule_pow64((0, o.op_Multiply)(r, r), ~~(n / 2)))
                    }
                    break
                }
            }

            function BigNatModule_pow32(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n === 0) {
                        return 1
                    } else if (n % 2 === 0) {
                        e = r * r;
                        t = ~~(n / 2);
                        continue e
                    } else {
                        return r * BigNatModule_pow32(r * r, ~~(n / 2)) | 0
                    }
                    break
                }
            }

            function BigNatModule_hash(e) {
                let t = 0;
                for (let r = 0; r <= e.bound - 1; r++) {
                    t = e.digits[r] + (t << 3) | 0
                }
                return t | 0
            }

            function BigNatModule_maxInt(e, t) {
                if (e < t) {
                    return t | 0
                } else {
                    return e | 0
                }
            }

            function BigNatModule_minInt(e, t) {
                if (e < t) {
                    return e | 0
                } else {
                    return t | 0
                }
            }
            const w = 24;
            t.BigNatModule_baseBits = w;
            const b = 16777216;
            t.BigNatModule_baseN = b;
            const F = 16777215;
            t.BigNatModule_baseMask = F;
            const B = (0, o.fromBits)(16777216, 0, false);
            t.BigNatModule_baseNi64 = B;
            const I = (0, o.fromBits)(16777215, 0, false);
            t.BigNatModule_baseMaski64 = I;
            const L = (0, o.fromBits)(16777215, 0, true);
            t.BigNatModule_baseMaskU = L;
            const P = 16777215;
            t.BigNatModule_baseMask32A = P;
            const O = 255;
            t.BigNatModule_baseMask32B = O;
            const R = 24;
            t.BigNatModule_baseShift32B = R;
            const D = 16777215;
            t.BigNatModule_baseMask64A = D;
            const k = 16777215;
            t.BigNatModule_baseMask64B = k;
            const $ = 65535;
            t.BigNatModule_baseMask64C = $;
            const j = 24;
            t.BigNatModule_baseShift64B = j;
            const U = 48;
            t.BigNatModule_baseShift64C = U;

            function BigNatModule_divbase(e) {
                return ~~(e >>> 0 >>> w)
            }

            function BigNatModule_modbase(e) {
                return e & F
            }

            function BigNatModule_createN(e) {
                return new BigNat(e, new Int32Array(e))
            }

            function BigNatModule_copyN(e) {
                return new BigNat(e.bound, (0, s.copy)(e.digits))
            }

            function BigNatModule_normN(e) {
                const findLeastBound = (e, t) => {
                    e: while (true) {
                        const r = e,
                            n = t;
                        if (n === -1 ? true : r[n] !== 0) {
                            return n + 1 | 0
                        } else {
                            e = r;
                            t = n - 1;
                            continue e
                        }
                        break
                    }
                };
                const t = findLeastBound(e.digits, e.bound - 1) | 0;
                e.bound = t | 0;
                return e
            }
            const Z = 2;
            t.BigNatModule_boundInt = Z;
            const q = 3;
            t.BigNatModule_boundInt64 = q;
            const H = 1;
            t.BigNatModule_boundBase = H;

            function BigNatModule_embed(e) {
                const t = (e < 0 ? 0 : e) | 0;
                if (t < b) {
                    const e = BigNatModule_createN(1);
                    e.digits[0] = t | 0;
                    return BigNatModule_normN(e)
                } else {
                    const e = BigNatModule_createN(Z);
                    for (let r = 0; r <= Z - 1; r++) {
                        e.digits[r] = ~~(t / BigNatModule_pow32(b, r)) % b | 0
                    }
                    return BigNatModule_normN(e)
                }
            }

            function BigNatModule_embed64(e) {
                const t = (0, o.compare)(e, (0, o.fromBits)(0, 0, false)) < 0 ? (0, o.fromBits)(0, 0, false) : e;
                const r = BigNatModule_createN(q);
                for (let e = 0; e <= q - 1; e++) {
                    r.digits[e] = ~~(0, o.toInt)((0, o.op_Modulus)((0, o.op_Division)(t, BigNatModule_pow64(B, e)), B)) | 0
                }
                return BigNatModule_normN(r)
            }

            function BigNatModule_eval32(e) {
                if (e.bound === 1) {
                    return e.digits[0] | 0
                } else {
                    let t = 0;
                    for (let r = e.bound - 1; r >= 0; r--) {
                        t = e.digits[r] + b * t | 0
                    }
                    return t | 0
                }
            }

            function BigNatModule_eval64(e) {
                if (e.bound === 1) {
                    return (0, o.fromInteger)(e.digits[0], false, 2)
                } else {
                    let t = (0, o.fromBits)(0, 0, false);
                    for (let r = e.bound - 1; r >= 0; r--) {
                        t = (0, o.op_Addition)((0, o.fromInteger)(e.digits[r], false, 2), (0, o.op_Multiply)(B, t))
                    }
                    return t
                }
            }
            const z = BigNatModule_embed(1);
            t.BigNatModule_one = z;
            const K = BigNatModule_embed(0);
            t.BigNatModule_zero = K;

            function BigNatModule_restrictTo(e, t) {
                return new BigNat(BigNatModule_minInt(e, t.bound), t.digits)
            }

            function BigNatModule_shiftUp(e, t) {
                const r = BigNatModule_createN(t.bound + e);
                for (let n = 0; n <= t.bound - 1; n++) {
                    r.digits[n + e] = t.digits[n] | 0
                }
                return r
            }

            function BigNatModule_shiftDown(e, t) {
                if (t.bound - e <= 0) {
                    return K
                } else {
                    const r = BigNatModule_createN(t.bound - e);
                    for (let n = 0; n <= r.bound - 1; n++) {
                        r.digits[n] = t.digits[n + e] | 0
                    }
                    return r
                }
            }

            function BigNatModule_degree(e) {
                return e.bound - 1
            }

            function BigNatModule_addP(e, t, r, n, i, o) {
                let s, a, l, _;
                e: while (true) {
                    const u = e,
                        c = t,
                        d = r,
                        p = n,
                        f = i,
                        h = o;
                    if (u < c) {
                        const g = (s = p, a = u | 0, a < s.bound ? s.digits[a] : 0) + (l = f, _ = u | 0, _ < l.bound ? l.digits[_] : 0) + d | 0;
                        h.digits[u] = BigNatModule_modbase(g) | 0;
                        e = u + 1;
                        t = c;
                        r = BigNatModule_divbase(g);
                        n = p;
                        i = f;
                        o = h;
                        continue e
                    }
                    break
                }
            }

            function BigNatModule_add(e, t) {
                const r = 1 + BigNatModule_maxInt(e.bound, t.bound) | 0;
                const n = BigNatModule_createN(r);
                BigNatModule_addP(0, r, 0, e, t, n);
                return BigNatModule_normN(n)
            }

            function BigNatModule_subP(e, t, r, n, i, o) {
                let s, a, l, _;
                e: while (true) {
                    const u = e,
                        c = t,
                        d = r,
                        p = n,
                        f = i,
                        h = o;
                    if (u < c) {
                        const g = (s = p, a = u | 0, a < s.bound ? s.digits[a] : 0) - (l = f, _ = u | 0, _ < l.bound ? l.digits[_] : 0) + d | 0;
                        if (g > 0) {
                            h.digits[u] = BigNatModule_modbase(g) | 0;
                            e = u + 1;
                            t = c;
                            r = BigNatModule_divbase(g);
                            n = p;
                            i = f;
                            o = h;
                            continue e
                        } else {
                            const s = g + b | 0;
                            h.digits[u] = BigNatModule_modbase(s) | 0;
                            e = u + 1;
                            t = c;
                            r = BigNatModule_divbase(s) - 1;
                            n = p;
                            i = f;
                            o = h;
                            continue e
                        }
                    } else {
                        return d !== 0
                    }
                    break
                }
            }

            function BigNatModule_sub(e, t) {
                const r = BigNatModule_maxInt(e.bound, t.bound) | 0;
                const n = BigNatModule_createN(r);
                if (BigNatModule_subP(0, r, 0, e, t, n)) {
                    return BigNatModule_embed(0)
                } else {
                    return BigNatModule_normN(n)
                }
            }

            function BigNatModule_isZero(e) {
                return e.bound === 0
            }

            function BigNatModule_IsZero(e) {
                return BigNatModule_isZero(e)
            }

            function BigNatModule_isOne(e) {
                if (e.bound === 1) {
                    return e.digits[0] === 1
                } else {
                    return false
                }
            }

            function BigNatModule_equal(e, t) {
                if (e.bound === t.bound) {
                    const check = (e, t, r) => {
                        e: while (true) {
                            const n = e,
                                i = t,
                                o = r;
                            if (o === -1) {
                                return true
                            } else if (n[o] === i[o]) {
                                e = n;
                                t = i;
                                r = o - 1;
                                continue e
                            } else {
                                return false
                            }
                            break
                        }
                    };
                    return check(e.digits, t.digits, e.bound - 1)
                } else {
                    return false
                }
            }

            function BigNatModule_shiftCompare(e, t, r, n) {
                if (e.bound + t < r.bound + n) {
                    return -1
                } else if (e.bound + t > r.bound + t) {
                    return 1
                } else {
                    const check = (e, r, i) => {
                        e: while (true) {
                            const o = e,
                                s = r,
                                a = i;
                            if (a === -1) {
                                return 0
                            } else {
                                const l = (a < t ? 0 : o[a - t]) | 0;
                                const _ = (a < n ? 0 : s[a - n]) | 0;
                                if (l === _) {
                                    e = o;
                                    r = s;
                                    i = a - 1;
                                    continue e
                                } else if (l < _) {
                                    return -1
                                } else {
                                    return 1
                                }
                            }
                            break
                        }
                    };
                    return check(e.digits, r.digits, e.bound + t - 1) | 0
                }
            }

            function BigNatModule_compare(e, t) {
                if (e.bound < t.bound) {
                    return -1
                } else if (e.bound > t.bound) {
                    return 1
                } else {
                    const check = (e, t, r) => {
                        e: while (true) {
                            const n = e,
                                i = t,
                                o = r;
                            if (o === -1) {
                                return 0
                            } else if (n[o] === i[o]) {
                                e = n;
                                t = i;
                                r = o - 1;
                                continue e
                            } else if (n[o] < i[o]) {
                                return -1
                            } else {
                                return 1
                            }
                            break
                        }
                    };
                    return check(e.digits, t.digits, e.bound - 1) | 0
                }
            }

            function BigNatModule_lt(e, t) {
                return BigNatModule_compare(e, t) === -1
            }

            function BigNatModule_gt(e, t) {
                return BigNatModule_compare(e, t) === 1
            }

            function BigNatModule_lte(e, t) {
                return BigNatModule_compare(e, t) !== 1
            }

            function BigNatModule_gte(e, t) {
                return BigNatModule_compare(e, t) !== -1
            }

            function BigNatModule_min(e, t) {
                if (BigNatModule_lt(e, t)) {
                    return e
                } else {
                    return t
                }
            }

            function BigNatModule_max(e, t) {
                if (BigNatModule_lt(e, t)) {
                    return t
                } else {
                    return e
                }
            }

            function BigNatModule_contributeArr(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        s = r;
                    const a = (0, o.op_Addition)((0, o.fromInteger)(n[i], false, 2), s);
                    const l = (0, o.op_Division)(a, B);
                    const _ = ~~(0, o.toInt)((0, o.op_BitwiseAnd)(a, I)) | 0;
                    n[i] = _ | 0;
                    if ((0, o.compare)(l, (0, o.fromBits)(0, 0, false)) > 0) {
                        e = n;
                        t = i + 1;
                        r = l;
                        continue e
                    }
                    break
                }
            }

            function BigNatModule_scale(e, t) {
                const r = BigNatModule_createN(t.bound + Z);
                const n = (0, o.fromInteger)(e, false, 2);
                for (let e = 0; e <= t.bound - 1; e++) {
                    BigNatModule_contributeArr(r.digits, e, (0, o.op_Multiply)(n, (0, o.fromInteger)(t.digits[e], false, 2)))
                }
                return BigNatModule_normN(r)
            }

            function BigNatModule_mulSchoolBookBothSmall(e, t) {
                const r = BigNatModule_createN(2);
                const n = (0, o.op_Multiply)((0, o.fromInteger)(e, false, 2), (0, o.fromInteger)(t, false, 2));
                BigNatModule_setCoeff(r, 0, ~~(0, o.toInt)((0, o.op_BitwiseAnd)(n, I)));
                BigNatModule_setCoeff(r, 1, ~~(0, o.toInt)((0, o.op_Division)(n, B)));
                return BigNatModule_normN(r)
            }

            function BigNatModule_mulSchoolBookCarry(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        s = r;
                    if ((0, o.compare)(i, (0, o.fromBits)(0, 0, false)) > 0) {
                        const a = (0, o.op_Addition)(BigNatModule_coeff64(n, s), i);
                        BigNatModule_setCoeff(n, s, ~~(0, o.toInt)((0, o.op_BitwiseAnd)(a, I)));
                        e = n;
                        t = (0, o.op_Division)(a, B);
                        r = s + 1;
                        continue e
                    }
                    break
                }
            }

            function BigNatModule_mulSchoolBookOneSmall(e, t) {
                const r = BigNatModule_bound(e) | 0;
                const n = BigNatModule_createN(r + 1);
                const i = (0, o.fromInteger)(t, false, 2);
                let s = (0, o.fromBits)(0, 0, false);
                for (let t = 0; t <= r - 1; t++) {
                    const r = (0, o.op_Addition)((0, o.op_Addition)(s, BigNatModule_coeff64(n, t)), (0, o.op_Multiply)(BigNatModule_coeff64(e, t), i));
                    BigNatModule_setCoeff(n, t, ~~(0, o.toInt)((0, o.op_BitwiseAnd)(r, I)));
                    s = (0, o.op_Division)(r, B)
                }
                BigNatModule_mulSchoolBookCarry(n, s, r);
                return BigNatModule_normN(n)
            }

            function BigNatModule_mulSchoolBookNeitherSmall(e, t) {
                const r = BigNatModule_createN(e.bound + t.bound);
                const n = r.digits;
                for (let i = 0; i <= e.bound - 1; i++) {
                    const s = (0, o.fromInteger)(e.digits[i], false, 2);
                    let a = (0, o.fromBits)(0, 0, false);
                    let l = i;
                    for (let e = 0; e <= t.bound - 1; e++) {
                        const r = (0, o.fromInteger)(t.digits[e], false, 2);
                        const i = (0, o.op_Addition)((0, o.op_Addition)((0, o.fromInteger)(n[l], false, 2), a), (0, o.op_Multiply)(s, r));
                        n[l] = ~~(0, o.toInt)((0, o.op_BitwiseAnd)(i, I)) | 0;
                        a = (0, o.op_Division)(i, B);
                        l = l + 1 | 0
                    }
                    BigNatModule_mulSchoolBookCarry(r, a, l)
                }
                return BigNatModule_normN(r)
            }

            function BigNatModule_mulSchoolBook(e, t) {
                const r = BigNatModule_bound(e) === 1;
                const n = BigNatModule_bound(t) === 1;
                if (r && n) {
                    return BigNatModule_mulSchoolBookBothSmall(BigNatModule_coeff(e, 0), BigNatModule_coeff(t, 0))
                } else if (r) {
                    return BigNatModule_mulSchoolBookOneSmall(t, BigNatModule_coeff(e, 0))
                } else if (n) {
                    return BigNatModule_mulSchoolBookOneSmall(e, BigNatModule_coeff(t, 0))
                } else {
                    return BigNatModule_mulSchoolBookNeitherSmall(e, t)
                }
            }
            class BigNatModule_encoding extends n.Record {
                constructor(e, t, r, n, i, o, s) {
                    super();
                    this.bigL = e | 0;
                    this.twoToBigL = t | 0;
                    this.k = r | 0;
                    this.bigK = n | 0;
                    this.bigN = i | 0;
                    this.split = o | 0;
                    this.splits = s
                }
            }
            t.BigNatModule_encoding = BigNatModule_encoding;

            function BigNatModule_encoding$reflection() {
                return (0, i.record_type)("BigInt.BigNatModule.encoding", [], BigNatModule_encoding, (() => [
                    ["bigL", i.int32_type],
                    ["twoToBigL", i.int32_type],
                    ["k", i.int32_type],
                    ["bigK", i.int32_type],
                    ["bigN", i.int32_type],
                    ["split", i.int32_type],
                    ["splits", (0, i.array_type)(i.int32_type)]
                ]))
            }

            function BigNatModule_mkEncoding(e, t, r, n) {
                return new BigNatModule_encoding(e, BigNatModule_pow32(2, e), t, r, n, ~~(w / e), (0, s.initialize)(~~(w / e), (t => BigNatModule_pow32(2, e * t)), Int32Array))
            }
            const G = [BigNatModule_mkEncoding(1, 28, 268435456, 268435456), BigNatModule_mkEncoding(2, 26, 67108864, 134217728), BigNatModule_mkEncoding(3, 24, 16777216, 50331648), BigNatModule_mkEncoding(4, 22, 4194304, 16777216), BigNatModule_mkEncoding(5, 20, 1048576, 5242880), BigNatModule_mkEncoding(6, 18, 262144, 1572864), BigNatModule_mkEncoding(7, 16, 65536, 458752), BigNatModule_mkEncoding(8, 14, 16384, 131072), BigNatModule_mkEncoding(9, 12, 4096, 36864), BigNatModule_mkEncoding(10, 10, 1024, 10240), BigNatModule_mkEncoding(11, 8, 256, 2816), BigNatModule_mkEncoding(12, 6, 64, 768), BigNatModule_mkEncoding(13, 4, 16, 208)];
            t.BigNatModule_table = G;

            function BigNatModule_calculateTableTow(e) {
                const t = m - 2 * e | 0;
                const r = BigNatModule_pow64((0, o.fromBits)(2, 0, false), t);
                return [e, t, r, (0, o.op_Multiply)(r, (0, o.fromInteger)(e, false, 2))]
            }

            function BigNatModule_encodingGivenResultBits(e) {
                const selectFrom = t => {
                    e: while (true) {
                        const r = t;
                        if (r + 1 < G.length && e < G[r + 1].bigN) {
                            t = r + 1;
                            continue e
                        } else {
                            return G[r]
                        }
                        break
                    }
                };
                if (e >= G[0].bigN) {
                    throw new Error("Product is huge, around 268435456 bits, beyond quickmul")
                } else {
                    return selectFrom(0)
                }
            }
            const V = (0, s.initialize)(w, (e => BigNatModule_pow32(2, e) - 1), Int32Array);
            t.BigNatModule_bitmask = V;
            const W = (0, s.initialize)(w, (e => BigNatModule_pow32(2, e)), Int32Array);
            t.BigNatModule_twopowers = W;
            const Y = (0, s.initialize)(w, (e => BigNatModule_pow64((0, o.fromBits)(2, 0, false), e)));
            t.BigNatModule_twopowersI64 = Y;

            function BigNatModule_wordBits(e) {
                const hi = t => {
                    e: while (true) {
                        const r = t;
                        if (r === 0) {
                            return 0
                        } else if ((e & W[r - 1]) !== 0) {
                            return r | 0
                        } else {
                            t = r - 1;
                            continue e
                        }
                        break
                    }
                };
                return hi(w) | 0
            }

            function BigNatModule_bits(e) {
                if (e.bound === 0) {
                    return 0
                } else {
                    return BigNatModule_degree(e) * w + BigNatModule_wordBits(e.digits[BigNatModule_degree(e)]) | 0
                }
            }

            function BigNatModule_extractBits(e, t, r) {
                let n, i, o, s, a, l;
                const _ = ~~(r / w) | 0;
                const u = ~~((r + t.bigL - 1) / w) | 0;
                if (_ !== u) {
                    const a = r % w | 0;
                    return ((n = e, i = _ | 0, i < n.bound ? n.digits[i] : 0) >> a | (o = e, s = u | 0, s < o.bound ? o.digits[s] : 0) << w - a) & V[t.bigL] | 0
                } else {
                    return (a = e, l = _ | 0, l < a.bound ? a.digits[l] : 0) >> r % w & V[t.bigL] | 0
                }
            }

            function BigNatModule_encodePoly(e, t) {
                const r = (0, s.fill)(new Uint32Array(e.bigK), 0, e.bigK, BigNatModule_FFT_Fp_ofInt32(0));
                const n = t.bound * w | 0;
                const encoder = (i, o) => {
                    e: while (true) {
                        const s = i,
                            a = o;
                        if (s === e.bigK ? true : a > n) {} else {
                            const n = BigNatModule_extractBits(t, e, a) | 0;
                            r[s] = BigNatModule_FFT_Fp_ofInt32(n);
                            i = s + 1;
                            o = a + e.bigL;
                            continue e
                        }
                        break
                    }
                };
                encoder(0, 0);
                return r
            }

            function BigNatModule_decodeResultBits(e, t) {
                let r = 0;
                for (let e = 0; e <= t.length - 1; e++) {
                    if (t[e] !== E) {
                        r = e | 0
                    }
                }
                return m + e.bigL * r + 1 + 1 | 0
            }

            function BigNatModule_decodePoly(e, t) {
                const r = ~~(BigNatModule_decodeResultBits(e, t) / w) + 1 | 0;
                const n = BigNatModule_createN(r);
                const evaluate = (i, s, a) => {
                    e: while (true) {
                        const l = i,
                            _ = s,
                            u = a;
                        if (l === e.bigK) {} else {
                            if (_ >= r) {} else {
                                BigNatModule_contributeArr(n.digits, _, (0, o.op_Multiply)((0, o.fromInteger)(BigNatModule_FFT_Fp_toInt(t[l]), false, 2), Y[u]))
                            }
                            const c = u + e.bigL | 0;
                            const d = c >= w ? [_ + 1, c - w] : [_, c];
                            i = l + 1;
                            s = d[0];
                            a = d[1];
                            continue e
                        }
                        break
                    }
                };
                evaluate(0, 0, 0);
                return BigNatModule_normN(n)
            }

            function BigNatModule_quickMulUsingFft(e, t) {
                const r = BigNatModule_encodingGivenResultBits(BigNatModule_bits(e) + BigNatModule_bits(t));
                return BigNatModule_normN(BigNatModule_decodePoly(r, BigNatModule_FFT_computeFftPaddedPolynomialProduct(r.bigK, r.k, BigNatModule_encodePoly(r, e), BigNatModule_encodePoly(r, t))))
            }
            const X = 16;
            t.BigNatModule_minDigitsKaratsuba = X;

            function BigNatModule_recMulKaratsuba(e, t, r) {
                const n = BigNatModule_maxInt(t.bound, r.bound) | 0;
                if (n > X) {
                    const i = ~~(n / 2) | 0;
                    const o = BigNatModule_restrictTo(i, t);
                    const s = BigNatModule_shiftDown(i, t);
                    const a = BigNatModule_restrictTo(i, r);
                    const l = BigNatModule_shiftDown(i, r);
                    const _ = e(o, a);
                    const u = e(BigNatModule_add(o, s), BigNatModule_add(a, l));
                    const c = e(s, l);
                    return BigNatModule_add(_, BigNatModule_shiftUp(i, BigNatModule_add(BigNatModule_sub(u, BigNatModule_add(_, c)), BigNatModule_shiftUp(i, c))))
                } else {
                    return BigNatModule_mulSchoolBook(t, r)
                }
            }

            function BigNatModule_mulKaratsuba(e, t) {
                return BigNatModule_recMulKaratsuba(BigNatModule_mulKaratsuba, e, t)
            }
            const Q = ~~(64e3 / w);
            t.BigNatModule_productDigitsUpperSchoolBook = Q;
            const J = ~~(32e3 / w);
            t.BigNatModule_singleDigitForceSchoolBook = J;
            const ee = ~~(G[0].bigN / w);
            t.BigNatModule_productDigitsUpperFft = ee;

            function BigNatModule_mul(e, t) {
                return BigNatModule_mulSchoolBook(e, t)
            }

            function BigNatModule_scaleSubInPlace(e, t, r, n) {
                const i = [e.digits, BigNatModule_degree(e)];
                const s = i[0];
                const a = [r.digits, BigNatModule_degree(r)];
                const l = a[1] | 0;
                const _ = a[0];
                const u = (0, o.fromInteger)(t, false, 2);
                let c = 0;
                let d = (0, o.op_Multiply)(u, (0, o.fromInteger)(_[0], false, 2));
                while ((0, o.compare)(d, (0, o.fromBits)(0, 0, false)) > 0 ? true : c < l) {
                    if (c > i[1]) {
                        throw new Error("scaleSubInPlace: pre-condition did not apply, result would be -ve")
                    }
                    let e = ~~(0, o.toInt)((0, o.op_BitwiseAnd)(d, I));
                    let t = (0, o.op_Division)(d, B);
                    if (e <= s[c + n]) {
                        s[c + n] = s[c + n] - e | 0
                    } else {
                        s[c + n] = s[c + n] + (b - e) | 0;
                        t = (0, o.op_Addition)(t, (0, o.fromBits)(1, 0, false))
                    }
                    if (c < l) {
                        d = (0, o.op_Addition)(t, (0, o.op_Multiply)(u, (0, o.fromInteger)(_[c + 1], false, 2)))
                    } else {
                        d = t
                    }
                    c = c + 1 | 0
                }
                BigNatModule_normN(e)
            }

            function BigNatModule_scaleSub(e, t, r, n) {
                const i = BigNatModule_add(e, K);
                BigNatModule_scaleSubInPlace(i, t, r, n);
                return BigNatModule_normN(i)
            }

            function BigNatModule_scaleAddInPlace(e, t, r, n) {
                const i = [e.digits, BigNatModule_degree(e)];
                const s = i[0];
                const a = [r.digits, BigNatModule_degree(r)];
                const l = a[1] | 0;
                const _ = a[0];
                const u = (0, o.fromInteger)(t, false, 2);
                let c = 0;
                let d = (0, o.op_Multiply)(u, (0, o.fromInteger)(_[0], false, 2));
                while ((0, o.compare)(d, (0, o.fromBits)(0, 0, false)) > 0 ? true : c < l) {
                    if (c > i[1]) {
                        throw new Error("scaleSubInPlace: pre-condition did not apply, result would be -ve")
                    }
                    let e = ~~(0, o.toInt)((0, o.op_BitwiseAnd)(d, I));
                    let t = (0, o.op_Division)(d, B);
                    if (e < b - s[c + n]) {
                        s[c + n] = s[c + n] + e | 0
                    } else {
                        s[c + n] = e - (b - s[c + n]) | 0;
                        t = (0, o.op_Addition)(t, (0, o.fromBits)(1, 0, false))
                    }
                    if (c < l) {
                        d = (0, o.op_Addition)(t, (0, o.op_Multiply)(u, (0, o.fromInteger)(_[c + 1], false, 2)))
                    } else {
                        d = t
                    }
                    c = c + 1 | 0
                }
                BigNatModule_normN(e)
            }

            function BigNatModule_scaleAdd(e, t, r, n) {
                const i = BigNatModule_add(e, K);
                BigNatModule_scaleAddInPlace(i, t, r, n);
                return BigNatModule_normN(i)
            }

            function BigNatModule_removeFactor(e, t, r) {
                const n = [BigNatModule_degree(t), BigNatModule_degree(e)];
                const i = n[1] | 0;
                const s = n[0] | 0;
                if (i < s + r) {
                    return 0
                } else {
                    const n = [t.digits, e.digits];
                    const a = n[1];
                    const l = n[0];
                    const _ = (s === 0 ? i === r ? ~~(a[r] / l[0]) : ~~(0, o.toInt)((0, o.op_Division)((0, o.op_Addition)((0, o.op_Multiply)((0, o.fromInteger)(a[i], false, 2), B), (0, o.fromInteger)(a[i - 1], false, 2)), (0, o.fromInteger)(l[0], false, 2))) : i === s + r ? ~~(a[i] / (l[s] + 1)) : ~~(0, o.toInt)((0, o.op_Division)((0, o.op_Addition)((0, o.op_Multiply)((0, o.fromInteger)(a[i], false, 2), B), (0, o.fromInteger)(a[i - 1], false, 2)), (0, o.op_Addition)((0, o.fromInteger)(l[s], false, 2), (0, o.fromBits)(1, 0, false))))) | 0;
                    if (_ === 0) {
                        if (BigNatModule_shiftCompare(t, r, e, 0) !== 1) {
                            return 1
                        } else {
                            return 0
                        }
                    } else {
                        return _ | 0
                    }
                }
            }

            function BigNatModule_divmod(e, t) {
                if (BigNatModule_isZero(t)) {
                    throw new Error
                } else if (BigNatModule_degree(e) < BigNatModule_degree(t)) {
                    return [K, e]
                } else {
                    const r = BigNatModule_copyN(e);
                    const n = BigNatModule_createN(BigNatModule_degree(e) - BigNatModule_degree(t) + 1 + 1);
                    let i = BigNatModule_degree(e);
                    const o = BigNatModule_degree(t) | 0;
                    let s = i - o;
                    const Invariant = e => {};
                    let a = false;
                    while (!a) {
                        Invariant([n, r, s, i]);
                        const e = BigNatModule_removeFactor(r, t, s) | 0;
                        if (e > 0) {
                            BigNatModule_scaleSubInPlace(r, e, t, s);
                            BigNatModule_scaleAddInPlace(n, e, z, s);
                            Invariant([n, r, s, i])
                        } else {
                            a = e === 0 && s === 0;
                            if (!a) {
                                if (i === o + s) {
                                    Invariant([n, r, s - 1, i]);
                                    s = s - 1 | 0
                                } else {
                                    Invariant([n, r, s - 1, i - 1]);
                                    s = s - 1 | 0;
                                    i = i - 1 | 0
                                }
                            }
                        }
                    }
                    return [BigNatModule_normN(n), BigNatModule_normN(r)]
                }
            }

            function BigNatModule_div(e, t) {
                return BigNatModule_divmod(e, t)[0]
            }

            function BigNatModule_rem(e, t) {
                return BigNatModule_divmod(e, t)[1]
            }

            function BigNatModule_bitAnd(e, t) {
                const r = BigNatModule_createN(BigNatModule_minInt(e.bound, t.bound));
                for (let n = 0; n <= r.bound - 1; n++) {
                    r.digits[n] = e.digits[n] & t.digits[n] | 0
                }
                return BigNatModule_normN(r)
            }

            function BigNatModule_bitOr(e, t) {
                const r = BigNatModule_createN(BigNatModule_maxInt(e.bound, t.bound));
                for (let t = 0; t <= e.bound - 1; t++) {
                    r.digits[t] = r.digits[t] | e.digits[t] | 0
                }
                for (let e = 0; e <= t.bound - 1; e++) {
                    r.digits[e] = r.digits[e] | t.digits[e] | 0
                }
                return BigNatModule_normN(r)
            }

            function BigNatModule_bitXor(e, t) {
                const r = BigNatModule_createN(BigNatModule_maxInt(e.bound, t.bound));
                for (let t = 0; t <= e.bound - 1; t++) {
                    r.digits[t] = r.digits[t] ^ e.digits[t] | 0
                }
                for (let e = 0; e <= t.bound - 1; e++) {
                    r.digits[e] = r.digits[e] ^ t.digits[e] | 0
                }
                return BigNatModule_normN(r)
            }

            function BigNatModule_hcf(e, t) {
                const hcfloop = (e, t) => {
                    e: while (true) {
                        const r = e,
                            n = t;
                        if (BigNatModule_equal(K, r)) {
                            return n
                        } else {
                            e = BigNatModule_divmod(n, r)[1];
                            t = r;
                            continue e
                        }
                        break
                    }
                };
                if (BigNatModule_lt(e, t)) {
                    return hcfloop(e, t)
                } else {
                    return hcfloop(t, e)
                }
            }
            const te = BigNatModule_embed(2);
            t.BigNatModule_two = te;

            function BigNatModule_powi(e, t) {
                const power = (e, t, r) => {
                    e: while (true) {
                        const n = e,
                            i = t,
                            o = r;
                        if (o === 0) {
                            return n
                        } else if (o % 2 === 0) {
                            e = n;
                            t = BigNatModule_mul(i, i);
                            r = ~~(o / 2);
                            continue e
                        } else {
                            e = BigNatModule_mul(i, n);
                            t = BigNatModule_mul(i, i);
                            r = ~~(o / 2);
                            continue e
                        }
                        break
                    }
                };
                return power(z, e, t)
            }

            function BigNatModule_pow(e, t) {
                const power = (e, t, r) => {
                    e: while (true) {
                        const n = e,
                            i = t,
                            o = r;
                        if (BigNatModule_isZero(o)) {
                            return n
                        } else {
                            const s = BigNatModule_divmod(o, te);
                            const a = s[0];
                            if (BigNatModule_isZero(s[1])) {
                                e = n;
                                t = BigNatModule_mul(i, i);
                                r = a;
                                continue e
                            } else {
                                e = BigNatModule_mul(i, n);
                                t = BigNatModule_mul(i, i);
                                r = a;
                                continue e
                            }
                        }
                        break
                    }
                };
                return power(z, e, t)
            }

            function BigNatModule_toFloat(e) {
                const evalFloat = (t, r, n) => {
                    e: while (true) {
                        const i = t,
                            o = r,
                            s = n;
                        if (s === e.bound) {
                            return i
                        } else {
                            t = i + o * e.digits[s];
                            r = o * b;
                            n = s + 1;
                            continue e
                        }
                        break
                    }
                };
                return evalFloat(0, 1, 0)
            }

            function BigNatModule_ofInt32(e) {
                return BigNatModule_embed(e)
            }

            function BigNatModule_ofInt64(e) {
                return BigNatModule_embed64(e)
            }

            function BigNatModule_toUInt32(e) {
                const t = e.bound | 0;
                switch (t) {
                    case 0: {
                        return 0
                    }
                    case 1: {
                        const t = e.digits[0] | 0;
                        return t >>> 0
                    }
                    case 2: {
                        const t = [e.digits[0], e.digits[1]];
                        const r = t[1] | 0;
                        if (r > O) {
                            throw new Error
                        }
                        return ((t[0] & P) >>> 0) + ((r & O) >>> 0 << R >>> 0)
                    }
                    default: {
                        throw new Error
                    }
                }
            }

            function BigNatModule_toUInt64(e) {
                const t = e.bound | 0;
                switch (t) {
                    case 0: {
                        return (0, o.fromBits)(0, 0, true)
                    }
                    case 1: {
                        return (0, o.fromInteger)(e.digits[0], true, 2)
                    }
                    case 2: {
                        const t = [e.digits[0], e.digits[1]];
                        return (0, o.op_Addition)((0, o.fromInteger)(t[0] & D, true, 2), (0, o.op_LeftShift)((0, o.fromInteger)(t[1] & k, true, 2), j))
                    }
                    case 3: {
                        const t = [e.digits[0], e.digits[1], e.digits[2]];
                        const r = t[2] | 0;
                        if (r > $) {
                            throw new Error
                        }
                        return (0, o.op_Addition)((0, o.op_Addition)((0, o.fromInteger)(t[0] & D, true, 2), (0, o.op_LeftShift)((0, o.fromInteger)(t[1] & k, true, 2), j)), (0, o.op_LeftShift)((0, o.fromInteger)(r & $, true, 2), U))
                    }
                    default: {
                        throw new Error
                    }
                }
            }

            function BigNatModule_toString(e) {
                const t = BigNatModule_degree(e) | 0;
                const route = (e, r, n) => {
                    e: while (true) {
                        const i = e,
                            o = r,
                            s = n;
                        if (BigNatModule_degree(s) > t) {
                            return (0, a.cons)([o, s], i)
                        } else {
                            e = (0, a.cons)([o, s], i);
                            r = o + 1;
                            n = BigNatModule_mul(s, s);
                            continue e
                        }
                        break
                    }
                };
                const collect = (e, t, r, n) => {
                    e: while (true) {
                        const i = e,
                            o = t,
                            s = r,
                            _ = n;
                        if (!(0, a.isEmpty)(_)) {
                            const l = (0, a.tail)(_);
                            const u = BigNatModule_divmod(s, (0, a.head)(_)[1]);
                            const c = u[1];
                            const d = u[0];
                            if (i && BigNatModule_isZero(d)) {
                                e = i;
                                t = o;
                                r = c;
                                n = l;
                                continue e
                            } else {
                                e = i;
                                t = collect(false, o, c, l);
                                r = d;
                                n = l;
                                continue e
                            }
                        } else {
                            const e = BigNatModule_eval32(s) | 0;
                            if (i && e === 0) {
                                return o
                            } else {
                                return (0, a.cons)((0, l.int32ToString)(e), o)
                            }
                        }
                        break
                    }
                };
                const r = collect(true, (0, a.empty)(), e, route((0, a.empty)(), 0, BigNatModule_embed(10)));
                if ((0, a.isEmpty)(r)) {
                    return "0"
                } else {
                    return (0, _.join)("", (0, a.toArray)(r))
                }
            }

            function BigNatModule_ofString(e) {
                const t = e.length | 0;
                if ((0, _.isNullOrEmpty)(e)) {
                    throw new Error("empty string\\nParameter name: str")
                }
                const r = BigNatModule_embed(10);
                const build = (n, i) => {
                    e: while (true) {
                        const o = n,
                            s = i;
                        if (s === t) {
                            return o
                        } else {
                            const t = e[s];
                            const a = t.charCodeAt(0) - 48 | 0;
                            if (0 <= a && a <= 9) {
                                n = BigNatModule_add(BigNatModule_mul(r, o), BigNatModule_embed(a));
                                i = s + 1;
                                continue e
                            } else {
                                throw new Error
                            }
                        }
                        break
                    }
                };
                return build(BigNatModule_embed(0), 0)
            }

            function BigNatModule_isSmall(e) {
                return e.bound <= 1
            }

            function BigNatModule_getSmall(e) {
                const t = e;
                const r = 0;
                if (r < t.bound) {
                    return t.digits[r] | 0
                } else {
                    return 0
                }
            }

            function BigNatModule_factorial(e) {
                const productR = (e, t) => {
                    if (BigNatModule_equal(e, t)) {
                        return e
                    } else {
                        const r = BigNatModule_div(BigNatModule_add(e, t), BigNatModule_ofInt32(2));
                        return BigNatModule_mul(productR(e, r), productR(BigNatModule_add(r, z), t))
                    }
                };
                return productR(z, e)
            }
        },
        4949: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.BigInteger = void 0;
            t.BigInteger$reflection = BigInteger$reflection;
            t.BigInteger_$ctor_Z2BE94A1 = BigInteger_$ctor_Z2BE94A1;
            t.BigInteger_$ctor_Z524259A4 = BigInteger_$ctor_Z524259A4;
            t.BigInteger_$ctor_Z524259C1 = BigInteger_$ctor_Z524259C1;
            t.BigInteger_Abs_Z665282C2 = BigInteger_Abs_Z665282C2;
            t.BigInteger_DivRem_56F059C0 = BigInteger_DivRem_56F059C0;
            t.BigInteger_Factorial_Z665282C2 = BigInteger_Factorial_Z665282C2;
            t.BigInteger_FromInt32_Z524259A4 = BigInteger_FromInt32_Z524259A4;
            t.BigInteger_FromInt64_Z524259C1 = BigInteger_FromInt64_Z524259C1;
            t.BigInteger_GreatestCommonDivisor_56F059C0 = BigInteger_GreatestCommonDivisor_56F059C0;
            t.BigInteger_Parse_Z721C83C5 = BigInteger_Parse_Z721C83C5;
            t.BigInteger_Pow_62E082A2 = BigInteger_Pow_62E082A2;
            t.BigInteger_Scale_Z320F31E = BigInteger_Scale_Z320F31E;
            t.BigInteger__get_IsNegative = BigInteger__get_IsNegative;
            t.BigInteger__get_IsOne = BigInteger__get_IsOne;
            t.BigInteger__get_IsPositive = BigInteger__get_IsPositive;
            t.BigInteger__get_IsSmall = BigInteger__get_IsSmall;
            t.BigInteger__get_IsZero = BigInteger__get_IsZero;
            t.BigInteger__get_Sign = BigInteger__get_Sign;
            t.BigInteger__get_SignInt = BigInteger__get_SignInt;
            t.BigInteger__get_StructuredDisplayString = BigInteger__get_StructuredDisplayString;
            t.BigInteger__get_ToByte = BigInteger__get_ToByte;
            t.BigInteger__get_ToDecimal = BigInteger__get_ToDecimal;
            t.BigInteger__get_ToDouble = BigInteger__get_ToDouble;
            t.BigInteger__get_ToInt16 = BigInteger__get_ToInt16;
            t.BigInteger__get_ToInt32 = BigInteger__get_ToInt32;
            t.BigInteger__get_ToInt64 = BigInteger__get_ToInt64;
            t.BigInteger__get_ToSByte = BigInteger__get_ToSByte;
            t.BigInteger__get_ToSingle = BigInteger__get_ToSingle;
            t.BigInteger__get_ToUInt16 = BigInteger__get_ToUInt16;
            t.BigInteger__get_ToUInt32 = BigInteger__get_ToUInt32;
            t.BigInteger__get_ToUInt64 = BigInteger__get_ToUInt64;
            t.BigInteger__get_V = BigInteger__get_V;
            t.BigInteger_addnn_6A57060 = BigInteger_addnn_6A57060;
            t.BigInteger_compare_56F059C0 = BigInteger_compare_56F059C0;
            t.BigInteger_create_Z2BE94A1 = BigInteger_create_Z2BE94A1;
            t.BigInteger_get_One = BigInteger_get_One;
            t.BigInteger_get_Two = BigInteger_get_Two;
            t.BigInteger_get_Zero = BigInteger_get_Zero;
            t.BigInteger_hash_Z665282C2 = BigInteger_hash_Z665282C2;
            t.BigInteger_nat_Z67CCE57D = BigInteger_nat_Z67CCE57D;
            t.BigInteger_negn_Z67CCE57D = BigInteger_negn_Z67CCE57D;
            t.BigInteger_op_Addition_56F059C0 = BigInteger_op_Addition_56F059C0;
            t.BigInteger_op_BitwiseAnd_56F059C0 = BigInteger_op_BitwiseAnd_56F059C0;
            t.BigInteger_op_BitwiseOr_56F059C0 = BigInteger_op_BitwiseOr_56F059C0;
            t.BigInteger_op_Division_56F059C0 = BigInteger_op_Division_56F059C0;
            t.BigInteger_op_Equality_56F059C0 = BigInteger_op_Equality_56F059C0;
            t.BigInteger_op_ExclusiveOr_56F059C0 = BigInteger_op_ExclusiveOr_56F059C0;
            t.BigInteger_op_GreaterThanOrEqual_56F059C0 = BigInteger_op_GreaterThanOrEqual_56F059C0;
            t.BigInteger_op_GreaterThan_56F059C0 = BigInteger_op_GreaterThan_56F059C0;
            t.BigInteger_op_Inequality_56F059C0 = BigInteger_op_Inequality_56F059C0;
            t.BigInteger_op_LeftShift_62E082A2 = BigInteger_op_LeftShift_62E082A2;
            t.BigInteger_op_LessThanOrEqual_56F059C0 = BigInteger_op_LessThanOrEqual_56F059C0;
            t.BigInteger_op_LessThan_56F059C0 = BigInteger_op_LessThan_56F059C0;
            t.BigInteger_op_Modulus_56F059C0 = BigInteger_op_Modulus_56F059C0;
            t.BigInteger_op_Multiply_56F059C0 = BigInteger_op_Multiply_56F059C0;
            t.BigInteger_op_RightShift_62E082A2 = BigInteger_op_RightShift_62E082A2;
            t.BigInteger_op_Subtraction_56F059C0 = BigInteger_op_Subtraction_56F059C0;
            t.BigInteger_op_UnaryNegation_Z665282C2 = BigInteger_op_UnaryNegation_Z665282C2;
            t.BigInteger_op_UnaryPlus_Z665282C2 = BigInteger_op_UnaryPlus_Z665282C2;
            t.BigInteger_posn_Z67CCE57D = BigInteger_posn_Z67CCE57D;
            t.BigInteger_subnn_6A57060 = BigInteger_subnn_6A57060;
            var n = r(3834);
            var i = r(6638);
            var o = r(6356);
            var s = r(9054);
            var a = r(2836);
            var l = r(7526);
            var _ = _interopRequireDefault(r(5638));

            function _interopRequireDefault(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            class BigInteger extends i.Record {
                constructor(e, t) {
                    super();
                    this.signInt = e | 0;
                    this.v = t
                }
                toString() {
                    const e = this;
                    const t = BigInteger__get_SignInt(e) | 0;
                    switch (t) {
                        case -1: {
                            return (0, n.BigNatModule_isZero)(BigInteger__get_V(e)) ? "0" : "-" + (0, n.BigNatModule_toString)(BigInteger__get_V(e))
                        }
                        case 0: {
                            return "0"
                        }
                        case 1: {
                            return (0, n.BigNatModule_toString)(BigInteger__get_V(e))
                        }
                        default: {
                            throw new Error("signs should be +/- 1 or 0")
                        }
                    }
                }
                Equals(e) {
                    const t = this;
                    return e instanceof BigInteger && BigInteger_op_Equality_56F059C0(t, e)
                }
                GetHashCode() {
                    const e = this;
                    return BigInteger_hash_Z665282C2(e) | 0
                }
                toJSON(e) {
                    const t = this;
                    return (0, i.toString)(t)
                }
                CompareTo(e) {
                    const t = this;
                    if (e instanceof BigInteger) {
                        return BigInteger_compare_56F059C0(t, e) | 0
                    } else {
                        throw new Error("the objects are not comparable\\nParameter name: obj")
                    }
                }
            }
            t.BigInteger = BigInteger;

            function BigInteger$reflection() {
                return (0, o.class_type)("BigInt.BigInteger", void 0, BigInteger, (0, o.class_type)("System.ValueType"))
            }

            function BigInteger_$ctor_Z2BE94A1(e, t) {
                return new BigInteger(e, t)
            }(() => {
                BigInteger.smallLim = 4096;
                BigInteger.smallPosTab = (0, s.initialize)(BigInteger.smallLim, n.BigNatModule_ofInt32);
                BigInteger.one = BigInteger_$ctor_Z524259A4(1);
                BigInteger.two = BigInteger_$ctor_Z524259A4(2);
                BigInteger.zero = BigInteger_$ctor_Z524259A4(0)
            })();

            function BigInteger_nat_Z67CCE57D(e) {
                if ((0, n.BigNatModule_isSmall)(e) && (0, n.BigNatModule_getSmall)(e) < BigInteger.smallLim) {
                    return BigInteger.smallPosTab[(0, n.BigNatModule_getSmall)(e)]
                } else {
                    return e
                }
            }

            function BigInteger_create_Z2BE94A1(e, t) {
                return BigInteger_$ctor_Z2BE94A1(e, BigInteger_nat_Z67CCE57D(t))
            }

            function BigInteger_posn_Z67CCE57D(e) {
                return BigInteger_$ctor_Z2BE94A1(1, BigInteger_nat_Z67CCE57D(e))
            }

            function BigInteger_negn_Z67CCE57D(e) {
                return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D(e))
            }

            function BigInteger__get_Sign(e) {
                if (BigInteger__get_IsZero(e)) {
                    return 0
                } else {
                    return e.signInt | 0
                }
            }

            function BigInteger__get_SignInt(e) {
                return e.signInt
            }

            function BigInteger__get_V(e) {
                return e.v
            }

            function BigInteger_op_Equality_56F059C0(e, t) {
                const r = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                let i;
                if (r[0] === -1) {
                    if (r[1] === -1) {
                        i = 1
                    } else if (r[1] === 0) {
                        i = 8
                    } else if (r[1] === 1) {
                        i = 3
                    } else {
                        i = 9
                    }
                } else if (r[0] === 0) {
                    if (r[1] === -1) {
                        i = 6
                    } else if (r[1] === 0) {
                        i = 4
                    } else if (r[1] === 1) {
                        i = 5
                    } else {
                        i = 9
                    }
                } else if (r[0] === 1) {
                    if (r[1] === -1) {
                        i = 2
                    } else if (r[1] === 0) {
                        i = 7
                    } else if (r[1] === 1) {
                        i = 0
                    } else {
                        i = 9
                    }
                } else {
                    i = 9
                }
                switch (i) {
                    case 0: {
                        return (0, n.BigNatModule_equal)(BigInteger__get_V(e), BigInteger__get_V(t))
                    }
                    case 1: {
                        return (0, n.BigNatModule_equal)(BigInteger__get_V(e), BigInteger__get_V(t))
                    }
                    case 2: {
                        if ((0, n.BigNatModule_isZero)(BigInteger__get_V(e))) {
                            return (0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                        } else {
                            return false
                        }
                    }
                    case 3: {
                        if ((0, n.BigNatModule_isZero)(BigInteger__get_V(e))) {
                            return (0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                        } else {
                            return false
                        }
                    }
                    case 4: {
                        return true
                    }
                    case 5: {
                        return (0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                    }
                    case 6: {
                        return (0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                    }
                    case 7: {
                        return (0, n.BigNatModule_isZero)(BigInteger__get_V(e))
                    }
                    case 8: {
                        return (0, n.BigNatModule_isZero)(BigInteger__get_V(e))
                    }
                    case 9: {
                        throw new Error("signs should be +/- 1 or 0\\nParameter name: x")
                    }
                }
            }

            function BigInteger_op_Inequality_56F059C0(e, t) {
                return !BigInteger_op_Equality_56F059C0(e, t)
            }

            function BigInteger_op_LessThan_56F059C0(e, t) {
                const r = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                let i;
                if (r[0] === -1) {
                    if (r[1] === -1) {
                        i = 1
                    } else if (r[1] === 0) {
                        i = 8
                    } else if (r[1] === 1) {
                        i = 3
                    } else {
                        i = 9
                    }
                } else if (r[0] === 0) {
                    if (r[1] === -1) {
                        i = 6
                    } else if (r[1] === 0) {
                        i = 4
                    } else if (r[1] === 1) {
                        i = 5
                    } else {
                        i = 9
                    }
                } else if (r[0] === 1) {
                    if (r[1] === -1) {
                        i = 2
                    } else if (r[1] === 0) {
                        i = 7
                    } else if (r[1] === 1) {
                        i = 0
                    } else {
                        i = 9
                    }
                } else {
                    i = 9
                }
                switch (i) {
                    case 0: {
                        return (0, n.BigNatModule_lt)(BigInteger__get_V(e), BigInteger__get_V(t))
                    }
                    case 1: {
                        return (0, n.BigNatModule_lt)(BigInteger__get_V(t), BigInteger__get_V(e))
                    }
                    case 2: {
                        return false
                    }
                    case 3: {
                        if (!(0, n.BigNatModule_isZero)(BigInteger__get_V(e))) {
                            return true
                        } else {
                            return !(0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                        }
                    }
                    case 4: {
                        return false
                    }
                    case 5: {
                        return !(0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                    }
                    case 6: {
                        return false
                    }
                    case 7: {
                        return false
                    }
                    case 8: {
                        return !(0, n.BigNatModule_isZero)(BigInteger__get_V(e))
                    }
                    case 9: {
                        throw new Error("signs should be +/- 1 or 0\\nParameter name: x")
                    }
                }
            }

            function BigInteger_op_GreaterThan_56F059C0(e, t) {
                const r = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                let i;
                if (r[0] === -1) {
                    if (r[1] === -1) {
                        i = 1
                    } else if (r[1] === 0) {
                        i = 8
                    } else if (r[1] === 1) {
                        i = 3
                    } else {
                        i = 9
                    }
                } else if (r[0] === 0) {
                    if (r[1] === -1) {
                        i = 6
                    } else if (r[1] === 0) {
                        i = 4
                    } else if (r[1] === 1) {
                        i = 5
                    } else {
                        i = 9
                    }
                } else if (r[0] === 1) {
                    if (r[1] === -1) {
                        i = 2
                    } else if (r[1] === 0) {
                        i = 7
                    } else if (r[1] === 1) {
                        i = 0
                    } else {
                        i = 9
                    }
                } else {
                    i = 9
                }
                switch (i) {
                    case 0: {
                        return (0, n.BigNatModule_gt)(BigInteger__get_V(e), BigInteger__get_V(t))
                    }
                    case 1: {
                        return (0, n.BigNatModule_gt)(BigInteger__get_V(t), BigInteger__get_V(e))
                    }
                    case 2: {
                        if (!(0, n.BigNatModule_isZero)(BigInteger__get_V(e))) {
                            return true
                        } else {
                            return !(0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                        }
                    }
                    case 3: {
                        return false
                    }
                    case 4: {
                        return false
                    }
                    case 5: {
                        return false
                    }
                    case 6: {
                        return !(0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                    }
                    case 7: {
                        return !(0, n.BigNatModule_isZero)(BigInteger__get_V(e))
                    }
                    case 8: {
                        return false
                    }
                    case 9: {
                        throw new Error("signs should be +/- 1 or 0\\nParameter name: x")
                    }
                }
            }

            function BigInteger_compare_56F059C0(e, t) {
                if (BigInteger_op_LessThan_56F059C0(e, t)) {
                    return -1
                } else if (BigInteger_op_Equality_56F059C0(e, t)) {
                    return 0
                } else {
                    return 1
                }
            }

            function BigInteger_hash_Z665282C2(e) {
                if (BigInteger__get_SignInt(e) === 0) {
                    return 1
                } else {
                    return BigInteger__get_SignInt(e) + (0, n.BigNatModule_hash)(BigInteger__get_V(e)) | 0
                }
            }

            function BigInteger__get_StructuredDisplayString(e) {
                return (0, i.toString)(e)
            }

            function BigInteger_$ctor_Z524259A4(e) {
                if (e >= 0) {
                    return BigInteger_$ctor_Z2BE94A1(1, BigInteger_nat_Z67CCE57D((0, n.BigNatModule_ofInt32)(e)))
                } else if (e === -2147483648) {
                    return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D((0, n.BigNatModule_ofInt64)((0, a.op_UnaryNegation)((0, a.fromInteger)(e, false, 2)))))
                } else {
                    return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D((0, n.BigNatModule_ofInt32)((0, l.op_UnaryNegation_Int32)(e))))
                }
            }

            function BigInteger_$ctor_Z524259C1(e) {
                if ((0, a.compare)(e, (0, a.fromBits)(0, 0, false)) >= 0) {
                    return BigInteger_$ctor_Z2BE94A1(1, BigInteger_nat_Z67CCE57D((0, n.BigNatModule_ofInt64)(e)))
                } else if ((0, a.equals)(e, (0, a.fromBits)(0, 2147483648, false))) {
                    return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D((0, n.BigNatModule_add)((0, n.BigNatModule_ofInt64)((0, a.fromBits)(4294967295, 2147483647, false)), n.BigNatModule_one)))
                } else {
                    return BigInteger_$ctor_Z2BE94A1(-1, BigInteger_nat_Z67CCE57D((0, n.BigNatModule_ofInt64)((0, a.op_UnaryNegation)(e))))
                }
            }

            function BigInteger_get_One() {
                return BigInteger.one
            }

            function BigInteger_get_Two() {
                return BigInteger.two
            }

            function BigInteger_get_Zero() {
                return BigInteger.zero
            }

            function BigInteger_op_UnaryNegation_Z665282C2(e) {
                const t = BigInteger__get_SignInt(e) | 0;
                if (t === 0) {
                    return BigInteger_get_Zero()
                } else {
                    return BigInteger_create_Z2BE94A1((0, l.op_UnaryNegation_Int32)(t), BigInteger__get_V(e))
                }
            }

            function BigInteger_Scale_Z320F31E(e, t) {
                if (BigInteger__get_SignInt(t) === 0) {
                    return BigInteger_get_Zero()
                } else if (e < 0) {
                    return BigInteger_create_Z2BE94A1((0, l.op_UnaryNegation_Int32)(BigInteger__get_SignInt(t)), (0, n.BigNatModule_scale)((0, l.op_UnaryNegation_Int32)(e), BigInteger__get_V(t)))
                } else {
                    return BigInteger_create_Z2BE94A1(BigInteger__get_SignInt(t), (0, n.BigNatModule_scale)(e, BigInteger__get_V(t)))
                }
            }

            function BigInteger_subnn_6A57060(e, t) {
                if ((0, n.BigNatModule_gte)(e, t)) {
                    return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_sub)(e, t))
                } else {
                    return BigInteger_negn_Z67CCE57D((0, n.BigNatModule_sub)(t, e))
                }
            }

            function BigInteger_addnn_6A57060(e, t) {
                return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_add)(e, t))
            }

            function BigInteger__get_IsZero(e) {
                if (BigInteger__get_SignInt(e) === 0) {
                    return true
                } else {
                    return (0, n.BigNatModule_isZero)(BigInteger__get_V(e))
                }
            }

            function BigInteger__get_IsOne(e) {
                if (BigInteger__get_SignInt(e) === 1) {
                    return (0, n.BigNatModule_isOne)(BigInteger__get_V(e))
                } else {
                    return false
                }
            }

            function BigInteger_op_Addition_56F059C0(e, t) {
                if (BigInteger__get_IsZero(t)) {
                    return e
                } else if (BigInteger__get_IsZero(e)) {
                    return t
                } else {
                    const r = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                    let n;
                    if (r[0] === -1) {
                        if (r[1] === -1) {
                            n = 1
                        } else if (r[1] === 1) {
                            n = 3
                        } else {
                            n = 4
                        }
                    } else if (r[0] === 1) {
                        if (r[1] === -1) {
                            n = 2
                        } else if (r[1] === 1) {
                            n = 0
                        } else {
                            n = 4
                        }
                    } else {
                        n = 4
                    }
                    switch (n) {
                        case 0: {
                            return BigInteger_addnn_6A57060(BigInteger__get_V(e), BigInteger__get_V(t))
                        }
                        case 1: {
                            return BigInteger_op_UnaryNegation_Z665282C2(BigInteger_addnn_6A57060(BigInteger__get_V(e), BigInteger__get_V(t)))
                        }
                        case 2: {
                            return BigInteger_subnn_6A57060(BigInteger__get_V(e), BigInteger__get_V(t))
                        }
                        case 3: {
                            return BigInteger_subnn_6A57060(BigInteger__get_V(t), BigInteger__get_V(e))
                        }
                        case 4: {
                            throw new Error("signs should be +/- 1\\nParameter name: x")
                        }
                    }
                }
            }

            function BigInteger_op_Subtraction_56F059C0(e, t) {
                if (BigInteger__get_IsZero(t)) {
                    return e
                } else if (BigInteger__get_IsZero(e)) {
                    return BigInteger_op_UnaryNegation_Z665282C2(t)
                } else {
                    const r = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                    let n;
                    if (r[0] === -1) {
                        if (r[1] === -1) {
                            n = 1
                        } else if (r[1] === 1) {
                            n = 3
                        } else {
                            n = 4
                        }
                    } else if (r[0] === 1) {
                        if (r[1] === -1) {
                            n = 2
                        } else if (r[1] === 1) {
                            n = 0
                        } else {
                            n = 4
                        }
                    } else {
                        n = 4
                    }
                    switch (n) {
                        case 0: {
                            return BigInteger_subnn_6A57060(BigInteger__get_V(e), BigInteger__get_V(t))
                        }
                        case 1: {
                            return BigInteger_subnn_6A57060(BigInteger__get_V(t), BigInteger__get_V(e))
                        }
                        case 2: {
                            return BigInteger_addnn_6A57060(BigInteger__get_V(e), BigInteger__get_V(t))
                        }
                        case 3: {
                            return BigInteger_op_UnaryNegation_Z665282C2(BigInteger_addnn_6A57060(BigInteger__get_V(e), BigInteger__get_V(t)))
                        }
                        case 4: {
                            throw new Error("signs should be +/- 1\\nParameter name: x")
                        }
                    }
                }
            }

            function BigInteger_op_Multiply_56F059C0(e, t) {
                if (BigInteger__get_IsZero(e)) {
                    return e
                } else if (BigInteger__get_IsZero(t)) {
                    return t
                } else if (BigInteger__get_IsOne(e)) {
                    return t
                } else if (BigInteger__get_IsOne(t)) {
                    return e
                } else {
                    const r = (0, n.BigNatModule_mul)(BigInteger__get_V(e), BigInteger__get_V(t));
                    return BigInteger_create_Z2BE94A1(BigInteger__get_SignInt(e) * BigInteger__get_SignInt(t), r)
                }
            }

            function BigInteger_DivRem_56F059C0(e, t) {
                if (BigInteger__get_IsZero(t)) {
                    throw new Error
                }
                if (BigInteger__get_IsZero(e)) {
                    return [BigInteger_get_Zero(), BigInteger_get_Zero()]
                } else {
                    const r = (0, n.BigNatModule_divmod)(BigInteger__get_V(e), BigInteger__get_V(t));
                    const i = r[1];
                    const o = r[0];
                    const s = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                    let a;
                    if (s[0] === -1) {
                        if (s[1] === -1) {
                            a = 1
                        } else if (s[1] === 1) {
                            a = 3
                        } else {
                            a = 4
                        }
                    } else if (s[0] === 1) {
                        if (s[1] === -1) {
                            a = 2
                        } else if (s[1] === 1) {
                            a = 0
                        } else {
                            a = 4
                        }
                    } else {
                        a = 4
                    }
                    switch (a) {
                        case 0: {
                            return [BigInteger_posn_Z67CCE57D(o), BigInteger_posn_Z67CCE57D(i)]
                        }
                        case 1: {
                            return [BigInteger_posn_Z67CCE57D(o), BigInteger_negn_Z67CCE57D(i)]
                        }
                        case 2: {
                            return [BigInteger_negn_Z67CCE57D(o), BigInteger_posn_Z67CCE57D(i)]
                        }
                        case 3: {
                            return [BigInteger_negn_Z67CCE57D(o), BigInteger_negn_Z67CCE57D(i)]
                        }
                        case 4: {
                            throw new Error("signs should be +/- 1\\nParameter name: x")
                        }
                    }
                }
            }

            function BigInteger_op_Division_56F059C0(e, t) {
                return BigInteger_DivRem_56F059C0(e, t)[0]
            }

            function BigInteger_op_Modulus_56F059C0(e, t) {
                return BigInteger_DivRem_56F059C0(e, t)[1]
            }

            function BigInteger_op_RightShift_62E082A2(e, t) {
                return BigInteger_op_Division_56F059C0(e, BigInteger_Pow_62E082A2(BigInteger_get_Two(), t))
            }

            function BigInteger_op_LeftShift_62E082A2(e, t) {
                return BigInteger_op_Multiply_56F059C0(e, BigInteger_Pow_62E082A2(BigInteger_get_Two(), t))
            }

            function BigInteger_op_BitwiseAnd_56F059C0(e, t) {
                return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_bitAnd)(BigInteger__get_V(e), BigInteger__get_V(t)))
            }

            function BigInteger_op_BitwiseOr_56F059C0(e, t) {
                return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_bitOr)(BigInteger__get_V(e), BigInteger__get_V(t)))
            }

            function BigInteger_op_ExclusiveOr_56F059C0(e, t) {
                return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_bitXor)(BigInteger__get_V(e), BigInteger__get_V(t)))
            }

            function BigInteger_GreatestCommonDivisor_56F059C0(e, t) {
                const r = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                if (r[0] === 0) {
                    if (r[1] === 0) {
                        return BigInteger_get_Zero()
                    } else {
                        return BigInteger_posn_Z67CCE57D(BigInteger__get_V(t))
                    }
                } else if (r[1] === 0) {
                    return BigInteger_posn_Z67CCE57D(BigInteger__get_V(e))
                } else {
                    return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_hcf)(BigInteger__get_V(e), BigInteger__get_V(t)))
                }
            }

            function BigInteger__get_IsNegative(e) {
                if (BigInteger__get_SignInt(e) === -1) {
                    return !BigInteger__get_IsZero(e)
                } else {
                    return false
                }
            }

            function BigInteger__get_IsPositive(e) {
                if (BigInteger__get_SignInt(e) === 1) {
                    return !BigInteger__get_IsZero(e)
                } else {
                    return false
                }
            }

            function BigInteger_Abs_Z665282C2(e) {
                if (BigInteger__get_SignInt(e) === -1) {
                    return BigInteger_op_UnaryNegation_Z665282C2(e)
                } else {
                    return e
                }
            }

            function BigInteger_op_LessThanOrEqual_56F059C0(e, t) {
                const r = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                let i;
                if (r[0] === -1) {
                    if (r[1] === -1) {
                        i = 1
                    } else if (r[1] === 0) {
                        i = 6
                    } else if (r[1] === 1) {
                        i = 3
                    } else {
                        i = 9
                    }
                } else if (r[0] === 0) {
                    if (r[1] === -1) {
                        i = 8
                    } else if (r[1] === 0) {
                        i = 4
                    } else if (r[1] === 1) {
                        i = 7
                    } else {
                        i = 9
                    }
                } else if (r[0] === 1) {
                    if (r[1] === -1) {
                        i = 2
                    } else if (r[1] === 0) {
                        i = 5
                    } else if (r[1] === 1) {
                        i = 0
                    } else {
                        i = 9
                    }
                } else {
                    i = 9
                }
                switch (i) {
                    case 0: {
                        return (0, n.BigNatModule_lte)(BigInteger__get_V(e), BigInteger__get_V(t))
                    }
                    case 1: {
                        return (0, n.BigNatModule_lte)(BigInteger__get_V(t), BigInteger__get_V(e))
                    }
                    case 2: {
                        if ((0, n.BigNatModule_isZero)(BigInteger__get_V(e))) {
                            return (0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                        } else {
                            return false
                        }
                    }
                    case 3: {
                        return true
                    }
                    case 4: {
                        return true
                    }
                    case 5: {
                        return (0, n.BigNatModule_isZero)(BigInteger__get_V(e))
                    }
                    case 6: {
                        return true
                    }
                    case 7: {
                        return true
                    }
                    case 8: {
                        return (0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                    }
                    case 9: {
                        throw new Error("signs should be +/- 1 or 0\\nParameter name: x")
                    }
                }
            }

            function BigInteger_op_GreaterThanOrEqual_56F059C0(e, t) {
                const r = [BigInteger__get_SignInt(e), BigInteger__get_SignInt(t)];
                let i;
                if (r[0] === -1) {
                    if (r[1] === -1) {
                        i = 1
                    } else if (r[1] === 0) {
                        i = 6
                    } else if (r[1] === 1) {
                        i = 3
                    } else {
                        i = 9
                    }
                } else if (r[0] === 0) {
                    if (r[1] === -1) {
                        i = 8
                    } else if (r[1] === 0) {
                        i = 4
                    } else if (r[1] === 1) {
                        i = 7
                    } else {
                        i = 9
                    }
                } else if (r[0] === 1) {
                    if (r[1] === -1) {
                        i = 2
                    } else if (r[1] === 0) {
                        i = 5
                    } else if (r[1] === 1) {
                        i = 0
                    } else {
                        i = 9
                    }
                } else {
                    i = 9
                }
                switch (i) {
                    case 0: {
                        return (0, n.BigNatModule_gte)(BigInteger__get_V(e), BigInteger__get_V(t))
                    }
                    case 1: {
                        return (0, n.BigNatModule_gte)(BigInteger__get_V(t), BigInteger__get_V(e))
                    }
                    case 2: {
                        return true
                    }
                    case 3: {
                        if ((0, n.BigNatModule_isZero)(BigInteger__get_V(e))) {
                            return (0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                        } else {
                            return false
                        }
                    }
                    case 4: {
                        return true
                    }
                    case 5: {
                        return true
                    }
                    case 6: {
                        return (0, n.BigNatModule_isZero)(BigInteger__get_V(e))
                    }
                    case 7: {
                        return (0, n.BigNatModule_isZero)(BigInteger__get_V(t))
                    }
                    case 8: {
                        return true
                    }
                    case 9: {
                        throw new Error("signs should be +/- 1 or 0\\nParameter name: x")
                    }
                }
            }

            function BigInteger_Pow_62E082A2(e, t) {
                if (t < 0) {
                    throw new Error("y")
                }
                const r = [BigInteger__get_IsZero(e), t];
                if (r[0]) {
                    if (r[1] === 0) {
                        return BigInteger_get_One()
                    } else {
                        return BigInteger_get_Zero()
                    }
                } else {
                    const r = BigInteger_$ctor_Z524259A4(t);
                    return BigInteger_create_Z2BE94A1((0, n.BigNatModule_isZero)((0, n.BigNatModule_rem)(BigInteger__get_V(r), n.BigNatModule_two)) ? 1 : BigInteger__get_SignInt(e), (0, n.BigNatModule_pow)(BigInteger__get_V(e), BigInteger__get_V(r)))
                }
            }

            function BigInteger__get_ToInt32(e) {
                if (BigInteger__get_IsZero(e)) {
                    return 0
                } else {
                    const t = (0, n.BigNatModule_toUInt32)(BigInteger__get_V(e));
                    if (t <= 2147483647 >>> 0) {
                        return BigInteger__get_SignInt(e) * ~~t | 0
                    } else if (BigInteger__get_SignInt(e) === -1 && t === 2147483647 + 1 >>> 0) {
                        return -2147483648
                    } else {
                        throw new Error
                    }
                }
            }

            function BigInteger__get_ToUInt32(e) {
                if (BigInteger__get_IsZero(e)) {
                    return 0
                } else {
                    return (0, n.BigNatModule_toUInt32)(BigInteger__get_V(e))
                }
            }

            function BigInteger__get_ToInt64(e) {
                if (BigInteger__get_IsZero(e)) {
                    return (0, a.fromBits)(0, 0, false)
                } else {
                    const t = (0, n.BigNatModule_toUInt64)(BigInteger__get_V(e));
                    if ((0, a.compare)(t, (0, a.fromValue)((0, a.fromBits)(4294967295, 2147483647, false), true)) <= 0) {
                        return (0, a.op_Multiply)((0, a.fromInteger)(BigInteger__get_SignInt(e), false, 2), (0, a.fromValue)(t, false))
                    } else if (BigInteger__get_SignInt(e) === -1 && (0, a.equals)(t, (0, a.fromValue)((0, a.op_Addition)((0, a.fromBits)(4294967295, 2147483647, false), (0, a.fromBits)(1, 0, false)), true))) {
                        return (0, a.fromBits)(0, 2147483648, false)
                    } else {
                        throw new Error
                    }
                }
            }

            function BigInteger__get_ToUInt64(e) {
                if (BigInteger__get_IsZero(e)) {
                    return (0, a.fromBits)(0, 0, true)
                } else {
                    return (0, n.BigNatModule_toUInt64)(BigInteger__get_V(e))
                }
            }

            function BigInteger__get_ToDouble(e) {
                const t = BigInteger__get_SignInt(e) | 0;
                switch (t) {
                    case -1: {
                        return -(0, n.BigNatModule_toFloat)(BigInteger__get_V(e))
                    }
                    case 0: {
                        return 0
                    }
                    case 1: {
                        return (0, n.BigNatModule_toFloat)(BigInteger__get_V(e))
                    }
                    default: {
                        throw new Error("signs should be +/- 1 or 0\\nParameter name: x")
                    }
                }
            }

            function BigInteger__get_ToSByte(e) {
                return (BigInteger__get_ToInt32(e) + 128 & 255) - 128
            }

            function BigInteger__get_ToByte(e) {
                return BigInteger__get_ToUInt32(e) & 255
            }

            function BigInteger__get_ToInt16(e) {
                return (BigInteger__get_ToInt32(e) + 32768 & 65535) - 32768
            }

            function BigInteger__get_ToUInt16(e) {
                return BigInteger__get_ToUInt32(e) & 65535
            }

            function BigInteger__get_ToSingle(e) {
                return BigInteger__get_ToDouble(e)
            }

            function BigInteger__get_ToDecimal(e) {
                return new _.default(BigInteger__get_ToDouble(e))
            }

            function BigInteger_Parse_Z721C83C5(e) {
                if (e == null) {
                    throw new Error("text")
                }
                const t = e.trim();
                const r = t.length | 0;
                if (r === 0) {
                    throw new Error
                }
                const i = [t[0], r];
                if (i[0] === "+") {
                    if (i[1] === 1) {
                        throw new Error
                    } else {
                        return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_ofString)(t.slice(1, r - 1 + 1)))
                    }
                } else if (i[0] === "-") {
                    if (i[1] === 1) {
                        throw new Error
                    } else {
                        return BigInteger_negn_Z67CCE57D((0, n.BigNatModule_ofString)(t.slice(1, r - 1 + 1)))
                    }
                } else {
                    return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_ofString)(t))
                }
            }

            function BigInteger__get_IsSmall(e) {
                if (BigInteger__get_IsZero(e)) {
                    return true
                } else {
                    return (0, n.BigNatModule_isSmall)(BigInteger__get_V(e))
                }
            }

            function BigInteger_Factorial_Z665282C2(e) {
                if (BigInteger__get_IsNegative(e)) {
                    throw new Error("mustBeNonNegative\\nParameter name: x")
                }
                if (BigInteger__get_IsPositive(e)) {
                    return BigInteger_posn_Z67CCE57D((0, n.BigNatModule_factorial)(BigInteger__get_V(e)))
                } else {
                    return BigInteger_get_One()
                }
            }

            function BigInteger_op_UnaryPlus_Z665282C2(e) {
                return e
            }

            function BigInteger_FromInt64_Z524259C1(e) {
                return BigInteger_$ctor_Z524259C1(e)
            }

            function BigInteger_FromInt32_Z524259A4(e) {
                return BigInteger_$ctor_Z524259A4(e)
            }
        },
        13: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DateTime = DateTime;
            t.add = add;
            t.addDays = addDays;
            t.addHours = addHours;
            t.addMilliseconds = addMilliseconds;
            t.addMinutes = addMinutes;
            t.addMonths = addMonths;
            t.addSeconds = addSeconds;
            t.addYears = addYears;
            t.compareTo = t.compare = void 0;
            t.create = create;
            t.date = date;
            t.dateOffsetToString = dateOffsetToString;
            t.dateToHalfUTCString = dateToHalfUTCString;
            t.day = day;
            t.dayOfWeek = dayOfWeek;
            t.dayOfYear = dayOfYear;
            t.daysInMonth = daysInMonth;
            t["default"] = void 0;
            t.equals = equals;
            t.fromDateTimeOffset = fromDateTimeOffset;
            t.fromTicks = fromTicks;
            t.getTicks = getTicks;
            t.hour = hour;
            t.isDaylightSavingTime = isDaylightSavingTime;
            t.isLeapYear = isLeapYear;
            t.maxValue = maxValue;
            t.millisecond = millisecond;
            t.minValue = minValue;
            t.minute = minute;
            t.month = month;
            t.now = now;
            t.op_Addition = op_Addition;
            t.op_Subtraction = op_Subtraction;
            t.parse = parse;
            t.parseRaw = parseRaw;
            t.second = second;
            t.specifyKind = specifyKind;
            t.subtract = subtract;
            t.timeOfDay = timeOfDay;
            t.toLocalTime = toLocalTime;
            t.toLongDateString = toLongDateString;
            t.toLongTimeString = toLongTimeString;
            t.toShortDateString = toShortDateString;
            t.toShortTimeString = toShortTimeString;
            t.toString = toString;
            t.toUniversalTime = toUniversalTime;
            t.today = today;
            t.tryParse = tryParse;
            t.utcNow = utcNow;
            t.year = year;
            var n = r(2836);
            var i = r(4222);

            function dateOffsetToString(e) {
                const t = e < 0;
                e = Math.abs(e);
                const r = ~~(e / 36e5);
                const n = e % 36e5 / 6e4;
                return (t ? "-" : "+") + (0, i.padWithZeros)(r, 2) + ":" + (0, i.padWithZeros)(n, 2)
            }

            function dateToHalfUTCString(e, t) {
                const r = e.toISOString();
                return t === "first" ? r.substring(0, r.indexOf("T")) : r.substring(r.indexOf("T") + 1, r.length - 1)
            }

            function dateToISOString(e, t) {
                if (t) {
                    return e.toISOString()
                } else {
                    const t = e.kind == null ? true : e.kind === 2;
                    return (0, i.padWithZeros)(e.getFullYear(), 4) + "-" + (0, i.padWithZeros)(e.getMonth() + 1, 2) + "-" + (0, i.padWithZeros)(e.getDate(), 2) + "T" + (0, i.padWithZeros)(e.getHours(), 2) + ":" + (0, i.padWithZeros)(e.getMinutes(), 2) + ":" + (0, i.padWithZeros)(e.getSeconds(), 2) + "." + (0, i.padWithZeros)(e.getMilliseconds(), 3) + (t ? dateOffsetToString(e.getTimezoneOffset() * -6e4) : "")
                }
            }

            function dateToISOStringWithOffset(e, t) {
                const r = e.toISOString();
                return r.substring(0, r.length - 1) + dateOffsetToString(t)
            }

            function dateToStringWithCustomFormat(e, t, r) {
                return t.replace(/(\w)\1*/g, (t => {
                    let n = Number.NaN;
                    switch (t.substring(0, 1)) {
                        case "y":
                            const i = r ? e.getUTCFullYear() : e.getFullYear();
                            n = t.length < 4 ? i % 100 : i;
                            break;
                        case "M":
                            n = (r ? e.getUTCMonth() : e.getMonth()) + 1;
                            break;
                        case "d":
                            n = r ? e.getUTCDate() : e.getDate();
                            break;
                        case "H":
                            n = r ? e.getUTCHours() : e.getHours();
                            break;
                        case "h":
                            const o = r ? e.getUTCHours() : e.getHours();
                            n = o > 12 ? o % 12 : o;
                            break;
                        case "m":
                            n = r ? e.getUTCMinutes() : e.getMinutes();
                            break;
                        case "s":
                            n = r ? e.getUTCSeconds() : e.getSeconds();
                            break;
                        case "f":
                            n = r ? e.getUTCMilliseconds() : e.getMilliseconds();
                            break
                    }
                    if (Number.isNaN(n)) {
                        return t
                    } else {
                        return n < 10 && t.length > 1 ? "0" + n : "" + n
                    }
                }))
            }

            function dateToStringWithOffset(e, t) {
                var r, n, i;
                const o = new Date(e.getTime() + ((r = e.offset) !== null && r !== void 0 ? r : 0));
                if (typeof t !== "string") {
                    return o.toISOString().replace(/\.\d+/, "").replace(/[A-Z]|\.\d+/g, " ") + dateOffsetToString((n = e.offset) !== null && n !== void 0 ? n : 0)
                } else if (t.length === 1) {
                    switch (t) {
                        case "D":
                        case "d":
                            return dateToHalfUTCString(o, "first");
                        case "T":
                        case "t":
                            return dateToHalfUTCString(o, "second");
                        case "O":
                        case "o":
                            return dateToISOStringWithOffset(o, (i = e.offset) !== null && i !== void 0 ? i : 0);
                        default:
                            throw new Error("Unrecognized Date print format")
                    }
                } else {
                    return dateToStringWithCustomFormat(o, t, true)
                }
            }

            function dateToStringWithKind(e, t) {
                const r = e.kind === 1;
                if (typeof t !== "string") {
                    return r ? e.toUTCString() : e.toLocaleString()
                } else if (t.length === 1) {
                    switch (t) {
                        case "D":
                        case "d":
                            return r ? dateToHalfUTCString(e, "first") : e.toLocaleDateString();
                        case "T":
                        case "t":
                            return r ? dateToHalfUTCString(e, "second") : e.toLocaleTimeString();
                        case "O":
                        case "o":
                            return dateToISOString(e, r);
                        default:
                            throw new Error("Unrecognized Date print format")
                    }
                } else {
                    return dateToStringWithCustomFormat(e, t, r)
                }
            }

            function toString(e, t, r) {
                return e.offset != null ? dateToStringWithOffset(e, t) : dateToStringWithKind(e, t)
            }

            function DateTime(e, t) {
                const r = new Date(e);
                r.kind = (t == null ? 0 : t) | 0;
                return r
            }

            function fromTicks(e, t) {
                e = (0, n.fromValue)(e);
                t = t != null ? t : 2;
                let r = DateTime((0, n.ticksToUnixEpochMilliseconds)(e), t);
                if (t !== 1) {
                    r = DateTime(r.getTime() - (0, i.dateOffset)(r), t)
                }
                return r
            }

            function fromDateTimeOffset(e, t) {
                var r;
                switch (t) {
                    case 1:
                        return DateTime(e.getTime(), 1);
                    case 2:
                        return DateTime(e.getTime(), 2);
                    default:
                        const n = DateTime(e.getTime() + ((r = e.offset) !== null && r !== void 0 ? r : 0), t);
                        return DateTime(n.getTime() - (0, i.dateOffset)(n), t)
                }
            }

            function getTicks(e) {
                return (0, n.unixEpochMillisecondsToTicks)(e.getTime(), (0, i.dateOffset)(e))
            }

            function minValue() {
                return DateTime(-621355968e5, 0)
            }

            function maxValue() {
                return DateTime(0xe677d21fdbff, 0)
            }

            function parseRaw(e) {
                function fail() {
                    throw new Error(`The string is not a valid Date: ${e}`)
                }
                if (e == null || e.trim() === "") {
                    fail()
                }
                if (e.length === 10 && e[4] === "-" && e[7] === "-") {
                    e += "T00:00:00"
                }
                let t = new Date(e);
                let r = null;
                if (isNaN(t.getTime())) {
                    const n = /^\s*(\d+[^\w\s:]\d+[^\w\s:]\d+)?\s*(\d+:\d+(?::\d+(?:\.\d+)?)?)?\s*([AaPp][Mm])?\s*(Z|[+-]([01]?\d):?([0-5]?\d)?)?\s*$/.exec(e);
                    if (n != null) {
                        let e;
                        let i = 0;
                        if (n[2] != null) {
                            const e = n[2].split(":");
                            i = parseInt(e[0], 10) * 3600 + parseInt(e[1] || "0", 10) * 60 + parseFloat(e[2] || "0");
                            if (n[3] != null && n[3].toUpperCase() === "PM") {
                                i += 720
                            }
                        }
                        if (n[4] != null) {
                            if (n[1] != null) {
                                e = new Date(n[1] + " UTC")
                            } else {
                                const t = new Date;
                                e = new Date(t.getUTCFullYear() + "/" + (t.getUTCMonth() + 1) + "/" + t.getUTCDate())
                            }
                            if (n[4] === "Z") {
                                r = "Z"
                            } else {
                                let e = parseInt(n[5], 10) * 60 + parseInt(n[6] || "0", 10);
                                if (n[4][0] === "-") {
                                    e *= -1
                                }
                                r = e;
                                i -= e * 60
                            }
                        } else {
                            if (n[1] != null) {
                                e = new Date(n[1])
                            } else {
                                const t = new Date;
                                e = new Date(t.getFullYear() + "/" + (t.getMonth() + 1) + "/" + t.getDate())
                            }
                        }
                        t = new Date(e.getTime() + i * 1e3);
                        t = new Date(t.getTime() + (t.getTimezoneOffset() - e.getTimezoneOffset()) * 6e4)
                    } else {
                        fail()
                    }
                    if (isNaN(t.getTime())) {
                        fail()
                    }
                }
                return [t, r]
            }

            function parse(e, t = false) {
                const [r, n] = parseRaw(e);
                const i = n != null ? t && n === "Z" ? 1 : 2 : 0;
                return DateTime(r.getTime(), i)
            }

            function tryParse(e, t) {
                try {
                    t.contents = parse(e);
                    return true
                } catch (e) {
                    return false
                }
            }

            function create(e, t, r, n = 0, i = 0, o = 0, s = 0, a) {
                const l = a === 1 ? Date.UTC(e, t - 1, r, n, i, o, s) : new Date(e, t - 1, r, n, i, o, s).getTime();
                if (isNaN(l)) {
                    throw new Error("The parameters describe an unrepresentable Date.")
                }
                const _ = DateTime(l, a);
                if (e <= 99) {
                    _.setFullYear(e, t - 1, r)
                }
                return _
            }

            function now() {
                return DateTime(Date.now(), 2)
            }

            function utcNow() {
                return DateTime(Date.now(), 1)
            }

            function today() {
                return date(now())
            }

            function isLeapYear(e) {
                return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0
            }

            function daysInMonth(e, t) {
                return t === 2 ? isLeapYear(e) ? 29 : 28 : t >= 8 ? t % 2 === 0 ? 31 : 30 : t % 2 === 0 ? 30 : 31
            }

            function toUniversalTime(e) {
                return e.kind === 1 ? e : DateTime(e.getTime(), 1)
            }

            function toLocalTime(e) {
                return e.kind === 2 ? e : DateTime(e.getTime(), 2)
            }

            function specifyKind(e, t) {
                return create(year(e), month(e), day(e), hour(e), minute(e), second(e), millisecond(e), t)
            }

            function timeOfDay(e) {
                return hour(e) * 36e5 + minute(e) * 6e4 + second(e) * 1e3 + millisecond(e)
            }

            function date(e) {
                return create(year(e), month(e), day(e), 0, 0, 0, 0, e.kind)
            }

            function day(e) {
                return e.kind === 1 ? e.getUTCDate() : e.getDate()
            }

            function hour(e) {
                return e.kind === 1 ? e.getUTCHours() : e.getHours()
            }

            function millisecond(e) {
                return e.kind === 1 ? e.getUTCMilliseconds() : e.getMilliseconds()
            }

            function minute(e) {
                return e.kind === 1 ? e.getUTCMinutes() : e.getMinutes()
            }

            function month(e) {
                return (e.kind === 1 ? e.getUTCMonth() : e.getMonth()) + 1
            }

            function second(e) {
                return e.kind === 1 ? e.getUTCSeconds() : e.getSeconds()
            }

            function year(e) {
                return e.kind === 1 ? e.getUTCFullYear() : e.getFullYear()
            }

            function dayOfWeek(e) {
                return e.kind === 1 ? e.getUTCDay() : e.getDay()
            }

            function dayOfYear(e) {
                const t = year(e);
                const r = month(e);
                let n = day(e);
                for (let e = 1; e < r; e++) {
                    n += daysInMonth(t, e)
                }
                return n
            }

            function add(e, t) {
                const r = DateTime(e.getTime() + t, e.kind);
                if (e.kind === 2) {
                    const t = e.getTimezoneOffset();
                    const n = r.getTimezoneOffset();
                    return t !== n ? DateTime(r.getTime() + (n - t) * 6e4, e.kind) : r
                } else {
                    return r
                }
            }

            function addDays(e, t) {
                return add(e, t * 864e5)
            }

            function addHours(e, t) {
                return add(e, t * 36e5)
            }

            function addMinutes(e, t) {
                return add(e, t * 6e4)
            }

            function addSeconds(e, t) {
                return add(e, t * 1e3)
            }

            function addMilliseconds(e, t) {
                return add(e, t)
            }

            function addYears(e, t) {
                const r = month(e);
                const n = year(e) + t;
                const i = daysInMonth(n, r);
                const o = Math.min(i, day(e));
                return create(n, r, o, hour(e), minute(e), second(e), millisecond(e), e.kind)
            }

            function addMonths(e, t) {
                let r = month(e) + t;
                let n = 0;
                let i = 0;
                if (r > 12) {
                    n = r % 12;
                    i = Math.floor(r / 12);
                    r = n
                } else if (r < 1) {
                    n = 12 + r % 12;
                    i = Math.floor(r / 12) + (n === 12 ? -1 : 0);
                    r = n
                }
                const o = year(e) + i;
                const s = daysInMonth(o, r);
                const a = Math.min(s, day(e));
                return create(o, r, a, hour(e), minute(e), second(e), millisecond(e), e.kind)
            }

            function subtract(e, t) {
                return typeof t === "number" ? add(e, -t) : e.getTime() - t.getTime()
            }

            function toLongDateString(e) {
                return e.toDateString()
            }

            function toShortDateString(e) {
                return e.toLocaleDateString()
            }

            function toLongTimeString(e) {
                return e.toLocaleTimeString()
            }

            function toShortTimeString(e) {
                return e.toLocaleTimeString().replace(/:\d\d(?!:)/, "")
            }

            function equals(e, t) {
                return e.getTime() === t.getTime()
            }
            const o = i.compareDates;
            t.compare = o;
            const s = i.compareDates;
            t.compareTo = s;

            function op_Addition(e, t) {
                return add(e, t)
            }

            function op_Subtraction(e, t) {
                return subtract(e, t)
            }

            function isDaylightSavingTime(e) {
                const t = new Date(e.getFullYear(), 0, 1);
                const r = new Date(e.getFullYear(), 6, 1);
                return isDST(t.getTimezoneOffset(), r.getTimezoneOffset(), e.getTimezoneOffset())
            }

            function isDST(e, t, r) {
                return Math.min(e, t) === r
            }
            var a = DateTime;
            t["default"] = a
        },
        5638: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.abs = abs;
            t.add = void 0;
            t.ceiling = ceiling;
            t.compare = compare;
            t.divide = t["default"] = void 0;
            t.equals = equals;
            t.floor = floor;
            t.fromIntArray = fromIntArray;
            t.fromInts = fromInts;
            t.fromParts = fromParts;
            t.getBits = getBits;
            t.negate = t.multiply = t.get_Zero = t.get_One = t.get_MinusOne = t.get_MinValue = t.get_MaxValue = void 0;
            t.op_Addition = op_Addition;
            t.op_Division = op_Division;
            t.op_Modulus = op_Modulus;
            t.op_Multiply = op_Multiply;
            t.op_Subtraction = op_Subtraction;
            t.op_UnaryNegation = op_UnaryNegation;
            t.parse = parse;
            t.pow = pow;
            t.remainder = void 0;
            t.round = round;
            t.sqrt = sqrt;
            t.subtract = void 0;
            t.toNumber = toNumber;
            t.toString = toString;
            t.truncate = truncate;
            t.tryParse = tryParse;
            var n = _interopRequireDefault(r(524));
            var i = r(6638);

            function _interopRequireDefault(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            var o = n.default;
            t["default"] = o;
            const s = new n.default(0);
            t.get_Zero = s;
            const a = new n.default(1);
            t.get_One = a;
            const l = new n.default(-1);
            t.get_MinusOne = l;
            const _ = new n.default("79228162514264337593543950335");
            t.get_MaxValue = _;
            const u = new n.default("-79228162514264337593543950335");
            t.get_MinValue = u;

            function compare(e, t) {
                return e.cmp(t)
            }

            function equals(e, t) {
                return !e.cmp(t)
            }

            function abs(e) {
                return e.abs()
            }

            function round(e, t = 0) {
                return e.round(t, 2)
            }

            function truncate(e) {
                return e.round(0, 0)
            }

            function ceiling(e) {
                return e.round(0, e.cmp(0) >= 0 ? 3 : 0)
            }

            function floor(e) {
                return e.round(0, e.cmp(0) >= 0 ? 0 : 3)
            }

            function pow(e, t) {
                return e.pow(t)
            }

            function sqrt(e) {
                return e.sqrt()
            }

            function op_Addition(e, t) {
                return e.add(t)
            }

            function op_Subtraction(e, t) {
                return e.sub(t)
            }

            function op_Multiply(e, t) {
                return e.mul(t)
            }

            function op_Division(e, t) {
                return e.div(t)
            }

            function op_Modulus(e, t) {
                return e.mod(t)
            }

            function op_UnaryNegation(e) {
                const t = new n.default(e);
                t.s = -t.s || 0;
                return t
            }
            const c = op_Addition;
            t.add = c;
            const d = op_Subtraction;
            t.subtract = d;
            const p = op_Multiply;
            t.multiply = p;
            const f = op_Division;
            t.divide = f;
            const h = op_Modulus;
            t.remainder = h;
            const g = op_UnaryNegation;
            t.negate = g;

            function toString(e) {
                return e.toString()
            }

            function tryParse(e, t) {
                try {
                    t.contents = new n.default(e.trim());
                    return true
                } catch (e) {
                    return false
                }
            }

            function parse(e) {
                const t = new i.FSharpRef(s);
                if (tryParse(e, t)) {
                    return t.contents
                } else {
                    throw new Error("Input string was not in a correct format.")
                }
            }

            function toNumber(e) {
                return +e
            }

            function decimalToHex(e, t) {
                const r = new Uint8Array(t / 4 | 0);
                let n = 1;
                for (let t = 0; t < e.length; t++) {
                    let i = e[t];
                    for (let e = 0; e < n; e++) {
                        const t = r[e] * 10 + i | 0;
                        r[e] = t & 15;
                        i = t >> 4
                    }
                    if (i !== 0) {
                        r[n++] = i
                    }
                }
                return r.slice(0, n)
            }

            function hexToDecimal(e, t) {
                const r = new Uint8Array(t * 301 / 1e3 + 1 | 0);
                let n = 1;
                for (let t = e.length - 1; t >= 0; t--) {
                    let i = e[t];
                    for (let e = 0; e < n; e++) {
                        const t = r[e] * 16 + i | 0;
                        r[e] = t % 10 | 0;
                        i = t / 10 | 0
                    }
                    while (i > 0) {
                        r[n++] = i % 10 | 0;
                        i = i / 10 | 0
                    }
                }
                return r.slice(0, n)
            }

            function setInt32Bits(e, t, r) {
                for (let n = 0; n < 8; n++) {
                    e[r + n] = t >> n * 4 & 15
                }
            }

            function getInt32Bits(e, t) {
                let r = 0;
                for (let n = 0; n < 8; n++) {
                    r = r | e[t + n] << n * 4
                }
                return r
            }

            function fromIntArray(e) {
                return fromInts(e[0], e[1], e[2], e[3])
            }

            function fromInts(e, t, r, n) {
                const i = n < 0;
                const o = n >> 16 & 127;
                return fromParts(e, t, r, i, o)
            }

            function fromParts(e, t, r, i, o) {
                const s = 96;
                const a = new Uint8Array(s / 4);
                setInt32Bits(a, e, 0);
                setInt32Bits(a, t, 8);
                setInt32Bits(a, r, 16);
                const l = hexToDecimal(a, s);
                o = o & 127;
                const _ = new n.default(0);
                _.c = Array.from(l.reverse());
                _.e = l.length - o - 1;
                _.s = i ? -1 : 1;
                const u = new n.default(_);
                return u
            }

            function getBits(e) {
                const t = 96;
                const r = Uint8Array.from(e.c);
                const n = decimalToHex(r, t);
                const i = getInt32Bits(n, 0);
                const o = getInt32Bits(n, 8);
                const s = getInt32Bits(n, 16);
                const a = e.toString();
                const l = a.indexOf(".");
                const _ = l < 0 ? 0 : a.length - l - 1;
                const u = (_ & 127) << 16 | (e.s < 0 ? 2147483648 : 0);
                return [i, o, s, u]
            }
        },
        5153: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ComparisonIdentity_FromFunction = ComparisonIdentity_FromFunction;
            t.ComparisonIdentity_Structural = ComparisonIdentity_Structural;
            t.HashIdentity_FromFunctions = HashIdentity_FromFunctions;
            t.HashIdentity_Reference = HashIdentity_Reference;
            t.HashIdentity_Structural = HashIdentity_Structural;
            var n = r(4222);

            function HashIdentity_FromFunctions(e, t) {
                return {
                    Equals(e, r) {
                        return t(e, r)
                    },
                    GetHashCode(t) {
                        return e(t)
                    }
                }
            }

            function HashIdentity_Structural() {
                return HashIdentity_FromFunctions(n.structuralHash, n.equals)
            }

            function HashIdentity_Reference() {
                return HashIdentity_FromFunctions(n.physicalHash, ((e, t) => e === t))
            }

            function ComparisonIdentity_FromFunction(e) {
                return {
                    Compare(t, r) {
                        return e(t, r)
                    }
                }
            }

            function ComparisonIdentity_Structural() {
                return ComparisonIdentity_FromFunction(n.compare)
            }
        },
        3093: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ExtraTopLevelOperators_LazyPattern = ExtraTopLevelOperators_LazyPattern;
            t.LanguagePrimitives_FastGenericComparer = LanguagePrimitives_FastGenericComparer;
            t.LanguagePrimitives_FastGenericComparerFromTable = LanguagePrimitives_FastGenericComparerFromTable;
            t.LanguagePrimitives_FastGenericEqualityComparer = LanguagePrimitives_FastGenericEqualityComparer;
            t.LanguagePrimitives_FastGenericEqualityComparerFromTable = LanguagePrimitives_FastGenericEqualityComparerFromTable;
            t.LanguagePrimitives_GenericEqualityERComparer = t.LanguagePrimitives_GenericEqualityComparer = void 0;
            t.Operators_Failure = Operators_Failure;
            t.Operators_FailurePattern = Operators_FailurePattern;
            t.Operators_Lock = Operators_Lock;
            t.Operators_NullArg = Operators_NullArg;
            t.Operators_Using = Operators_Using;
            t.PrintfModule_PrintFormatToStringBuilder = PrintfModule_PrintFormatToStringBuilder;
            t.PrintfModule_PrintFormatToStringBuilderThen = PrintfModule_PrintFormatToStringBuilderThen;
            var n = r(4222);
            var i = r(5153);
            var o = r(8443);
            const s = {
                ["System.Collections.IEqualityComparer.Equals541DA560"](e, t) {
                    return (0, n.equals)(e, t)
                },
                ["System.Collections.IEqualityComparer.GetHashCode4E60E31B"](e) {
                    return (0, n.structuralHash)(e)
                }
            };
            t.LanguagePrimitives_GenericEqualityComparer = s;
            const a = {
                ["System.Collections.IEqualityComparer.Equals541DA560"](e, t) {
                    return (0, n.equals)(e, t)
                },
                ["System.Collections.IEqualityComparer.GetHashCode4E60E31B"](e) {
                    return (0, n.structuralHash)(e)
                }
            };
            t.LanguagePrimitives_GenericEqualityERComparer = a;

            function LanguagePrimitives_FastGenericComparer() {
                return (0, i.ComparisonIdentity_Structural)()
            }

            function LanguagePrimitives_FastGenericComparerFromTable() {
                return (0, i.ComparisonIdentity_Structural)()
            }

            function LanguagePrimitives_FastGenericEqualityComparer() {
                return (0, i.HashIdentity_Structural)()
            }

            function LanguagePrimitives_FastGenericEqualityComparerFromTable() {
                return (0, i.HashIdentity_Structural)()
            }

            function Operators_Failure(e) {
                return new Error(e)
            }

            function Operators_FailurePattern(e) {
                return e.message
            }

            function Operators_NullArg(e) {
                throw new Error(e)
            }

            function Operators_Using(e, t) {
                try {
                    return t(e)
                } finally {
                    if ((0, n.equals)(e, null)) {} else {
                        (0, n.disposeSafe)(e)
                    }
                }
            }

            function Operators_Lock(e, t) {
                return t()
            }

            function ExtraTopLevelOperators_LazyPattern(e) {
                return e.Value
            }

            function PrintfModule_PrintFormatToStringBuilderThen(e, t, r) {
                return r.cont((r => {
                    (0, o.StringBuilder__Append_Z721C83C5)(t, r);
                    return e()
                }))
            }

            function PrintfModule_PrintFormatToStringBuilder(e, t) {
                return PrintfModule_PrintFormatToStringBuilderThen((() => {}), e, t)
            }
        },
        1103: (e, t) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.SR_notEnoughElements = t.SR_keyNotFoundAlt = t.SR_inputWasEmpty = t.SR_inputSequenceTooLong = t.SR_inputSequenceEmpty = t.SR_inputMustBeNonNegative = t.SR_indexOutOfBounds = t.SR_differentLengths = void 0;
            const r = "The index was outside the range of elements in the collection.";
            t.SR_indexOutOfBounds = r;
            const n = "Collection was empty.";
            t.SR_inputWasEmpty = n;
            const i = "The input must be non-negative.";
            t.SR_inputMustBeNonNegative = i;
            const o = "The input sequence was empty.";
            t.SR_inputSequenceEmpty = o;
            const s = "The input sequence contains more than one element.";
            t.SR_inputSequenceTooLong = s;
            const a = "An index satisfying the predicate was not found in the collection.";
            t.SR_keyNotFoundAlt = a;
            const l = "The collections had different lengths.";
            t.SR_differentLengths = l;
            const _ = "The input sequence has an insufficient number of elements.";
            t.SR_notEnoughElements = _
        },
        7526: (e, t) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.NumberStyles = void 0;
            t.divRem = divRem;
            t.isValid = isValid;
            t.op_UnaryNegation_Int16 = op_UnaryNegation_Int16;
            t.op_UnaryNegation_Int32 = op_UnaryNegation_Int32;
            t.op_UnaryNegation_Int8 = op_UnaryNegation_Int8;
            t.parse = parse;
            t.tryParse = tryParse;
            var r;
            t.NumberStyles = r;
            (function(e) {
                e[e["AllowHexSpecifier"] = 512] = "AllowHexSpecifier"
            })(r || (t.NumberStyles = r = {}));

            function validResponse(e, t) {
                const [, r, n, i] = e;
                return {
                    sign: r || "",
                    prefix: n || "",
                    digits: i,
                    radix: t
                }
            }

            function getRange(e, t) {
                switch (t) {
                    case 8:
                        return e ? [0, 255] : [-128, 127];
                    case 16:
                        return e ? [0, 65535] : [-32768, 32767];
                    case 32:
                        return e ? [0, 4294967295] : [-2147483648, 2147483647];
                    default:
                        throw new Error("Invalid bit size.")
                }
            }

            function getInvalidDigits(e) {
                switch (e) {
                    case 2:
                        return /[^0-1]/;
                    case 8:
                        return /[^0-7]/;
                    case 10:
                        return /[^0-9]/;
                    case 16:
                        return /[^0-9a-fA-F]/;
                    default:
                        throw new Error("Invalid Base.")
                }
            }

            function getRadix(e, t) {
                if (t & r.AllowHexSpecifier) {
                    return 16
                } else {
                    switch (e) {
                        case "0b":
                        case "0B":
                            return 2;
                        case "0o":
                        case "0O":
                            return 8;
                        case "0x":
                        case "0X":
                            return 16;
                        default:
                            return 10
                    }
                }
            }

            function isValid(e, t, r) {
                const n = /^\s*([\+\-])?(0[xXoObB])?([0-9a-fA-F]+)\s*$/;
                const i = n.exec(e.replace(/_/g, ""));
                if (i != null) {
                    const [, , e, n] = i;
                    r = r || getRadix(e, t);
                    const o = getInvalidDigits(r);
                    if (!o.test(n)) {
                        return validResponse(i, r)
                    }
                }
                return null
            }

            function parse(e, t, r, n, i) {
                const o = isValid(e, t, i);
                if (o != null) {
                    let e = Number.parseInt(o.sign + o.digits, o.radix);
                    if (!Number.isNaN(e)) {
                        const [t, i] = getRange(true, n);
                        if (!r && o.radix !== 10 && e >= t && e <= i) {
                            e = e << 32 - n >> 32 - n
                        }
                        const [s, a] = getRange(r, n);
                        if (e >= s && e <= a) {
                            return e
                        }
                    }
                }
                throw new Error("Input string was not in a correct format.")
            }

            function tryParse(e, t, r, n, i) {
                try {
                    i.contents = parse(e, t, r, n);
                    return true
                } catch (e) {
                    return false
                }
            }

            function op_UnaryNegation_Int8(e) {
                return e === -128 ? e : -e
            }

            function op_UnaryNegation_Int16(e) {
                return e === -32768 ? e : -e
            }

            function op_UnaryNegation_Int32(e) {
                return e === -2147483648 ? e : -e
            }

            function divRem(e, t, r) {
                const n = ~~(e / t);
                const i = e % t;
                if (r != null) {
                    r.contents = i;
                    return n
                } else {
                    return [n, i]
                }
            }
        },
        5359: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.FSharpList = void 0;
            t.FSharpList$reflection = FSharpList$reflection;
            t.FSharpList_Cons_305B8EAC = FSharpList_Cons_305B8EAC;
            t.FSharpList__get_Head = FSharpList__get_Head;
            t.FSharpList__get_IsEmpty = FSharpList__get_IsEmpty;
            t.FSharpList__get_Item_Z524259A4 = FSharpList__get_Item_Z524259A4;
            t.FSharpList__get_Length = FSharpList__get_Length;
            t.FSharpList__get_Tail = FSharpList__get_Tail;
            t.FSharpList_get_Empty = FSharpList_get_Empty;
            t.ListEnumerator$1 = void 0;
            t.ListEnumerator$1$reflection = ListEnumerator$1$reflection;
            t.ListEnumerator$1_$ctor_3002E699 = ListEnumerator$1_$ctor_3002E699;
            t.allPairs = allPairs;
            t.append = append;
            t.average = average;
            t.averageBy = averageBy;
            t.choose = choose;
            t.chunkBySize = chunkBySize;
            t.collect = collect;
            t.compareWith = compareWith;
            t.concat = concat;
            t.cons = cons;
            t.contains = contains;
            t.empty = empty;
            t.exactlyOne = exactlyOne;
            t.exists = exists;
            t.exists2 = exists2;
            t.filter = filter;
            t.find = find;
            t.findBack = findBack;
            t.findIndex = findIndex;
            t.findIndexBack = findIndexBack;
            t.fold = fold;
            t.fold2 = fold2;
            t.foldBack = foldBack;
            t.foldBack2 = foldBack2;
            t.foldIndexed = foldIndexed;
            t.forAll = forAll;
            t.forAll2 = forAll2;
            t.getSlice = getSlice;
            t.head = head;
            t.indexed = indexed;
            t.initialize = initialize;
            t.insertAt = insertAt;
            t.insertManyAt = insertManyAt;
            t.isEmpty = isEmpty;
            t.item = item;
            t.iterate = iterate;
            t.iterate2 = iterate2;
            t.iterateIndexed = iterateIndexed;
            t.iterateIndexed2 = iterateIndexed2;
            t.last = last;
            t.length = length;
            t.map = map;
            t.map2 = map2;
            t.map3 = map3;
            t.mapFold = mapFold;
            t.mapFoldBack = mapFoldBack;
            t.mapIndexed = mapIndexed;
            t.mapIndexed2 = mapIndexed2;
            t.max = max;
            t.maxBy = maxBy;
            t.min = min;
            t.minBy = minBy;
            t.ofArray = ofArray;
            t.ofArrayWithTail = ofArrayWithTail;
            t.ofSeq = ofSeq;
            t.pairwise = pairwise;
            t.partition = partition;
            t.permute = permute;
            t.pick = pick;
            t.reduce = reduce;
            t.reduceBack = reduceBack;
            t.removeAt = removeAt;
            t.removeManyAt = removeManyAt;
            t.replicate = replicate;
            t.reverse = reverse;
            t.scan = scan;
            t.scanBack = scanBack;
            t.singleton = singleton;
            t.skip = skip;
            t.skipWhile = skipWhile;
            t.sort = sort;
            t.sortBy = sortBy;
            t.sortByDescending = sortByDescending;
            t.sortDescending = sortDescending;
            t.sortWith = sortWith;
            t.splitAt = splitAt;
            t.splitInto = splitInto;
            t.sum = sum;
            t.sumBy = sumBy;
            t.tail = tail;
            t.take = take;
            t.takeWhile = takeWhile;
            t.toArray = toArray;
            t.toSeq = toSeq;
            t.transpose = transpose;
            t.truncate = truncate;
            t.tryExactlyOne = tryExactlyOne;
            t.tryFind = tryFind;
            t.tryFindBack = tryFindBack;
            t.tryFindIndex = tryFindIndex;
            t.tryFindIndexBack = tryFindIndexBack;
            t.tryHead = tryHead;
            t.tryItem = tryItem;
            t.tryLast = tryLast;
            t.tryPick = tryPick;
            t.unfold = unfold;
            t.unzip = unzip;
            t.unzip3 = unzip3;
            t.updateAt = updateAt;
            t.where = where;
            t.windowed = windowed;
            t.zip = zip;
            t.zip3 = zip3;
            var n = r(9937);
            var i = r(4222);
            var o = r(6638);
            var s = r(6356);
            var a = r(1103);
            var l = r(6256);
            var _ = r(9054);
            class FSharpList extends o.Record {
                constructor(e, t) {
                    super();
                    this.head = e;
                    this.tail = t
                }
                toString() {
                    const e = this;
                    return "[" + (0, n.join)("; ", e) + "]"
                }
                Equals(e) {
                    const t = this;
                    if (t === e) {
                        return true
                    } else {
                        const loop = (e, t) => {
                            e: while (true) {
                                const r = e,
                                    n = t;
                                const o = [r.tail, n.tail];
                                if (o[0] != null) {
                                    if (o[1] != null) {
                                        const s = o[0];
                                        const a = o[1];
                                        if ((0, i.equals)(r.head, n.head)) {
                                            e = s;
                                            t = a;
                                            continue e
                                        } else {
                                            return false
                                        }
                                    } else {
                                        return false
                                    }
                                } else if (o[1] != null) {
                                    return false
                                } else {
                                    return true
                                }
                                break
                            }
                        };
                        return loop(t, e)
                    }
                }
                GetHashCode() {
                    const e = this;
                    const loop = (e, t, r) => {
                        e: while (true) {
                            const n = e,
                                o = t,
                                s = r;
                            const a = s.tail;
                            if (a != null) {
                                const l = a;
                                if (n > 18) {
                                    return o | 0
                                } else {
                                    e = n + 1;
                                    t = (o << 1) + (0, i.structuralHash)(s.head) + 631 * n;
                                    r = l;
                                    continue e
                                }
                            } else {
                                return o | 0
                            }
                            break
                        }
                    };
                    return loop(0, 0, e) | 0
                }
                toJSON(e) {
                    const t = this;
                    return Array.from(t)
                }
                CompareTo(e) {
                    const t = this;
                    const loop = (e, t) => {
                        e: while (true) {
                            const r = e,
                                n = t;
                            const o = [r.tail, n.tail];
                            if (o[0] != null) {
                                if (o[1] != null) {
                                    const s = o[0];
                                    const a = o[1];
                                    const l = (0, i.compare)(r.head, n.head) | 0;
                                    if (l === 0) {
                                        e = s;
                                        t = a;
                                        continue e
                                    } else {
                                        return l | 0
                                    }
                                } else {
                                    return 1
                                }
                            } else if (o[1] != null) {
                                return -1
                            } else {
                                return 0
                            }
                            break
                        }
                    };
                    return loop(t, e) | 0
                }
                GetEnumerator() {
                    const e = this;
                    return ListEnumerator$1_$ctor_3002E699(e)
                } [Symbol.iterator]() {
                    return (0, i.toIterator)(this.GetEnumerator())
                } ["System.Collections.IEnumerable.GetEnumerator"]() {
                    const e = this;
                    return (0, i.getEnumerator)(e)
                }
            }
            t.FSharpList = FSharpList;

            function FSharpList$reflection(e) {
                return (0, s.record_type)("ListModule.FSharpList", [e], FSharpList, (() => [
                    ["head", e],
                    ["tail", (0, s.option_type)(FSharpList$reflection(e))]
                ]))
            }
            class ListEnumerator$1 {
                constructor(e) {
                    this.xs = e;
                    this.it = this.xs;
                    this.current = null
                } ["System.Collections.Generic.IEnumerator`1.get_Current"]() {
                    const e = this;
                    return e.current
                } ["System.Collections.IEnumerator.get_Current"]() {
                    const e = this;
                    return e.current
                } ["System.Collections.IEnumerator.MoveNext"]() {
                    const e = this;
                    const t = e.it.tail;
                    if (t != null) {
                        const r = t;
                        e.current = e.it.head;
                        e.it = r;
                        return true
                    } else {
                        return false
                    }
                } ["System.Collections.IEnumerator.Reset"]() {
                    const e = this;
                    e.it = e.xs;
                    e.current = null
                }
                Dispose() {}
            }
            t.ListEnumerator$1 = ListEnumerator$1;

            function ListEnumerator$1$reflection(e) {
                return (0, s.class_type)("ListModule.ListEnumerator`1", [e], ListEnumerator$1)
            }

            function ListEnumerator$1_$ctor_3002E699(e) {
                return new ListEnumerator$1(e)
            }

            function FSharpList_get_Empty() {
                return new FSharpList(null, void 0)
            }

            function FSharpList_Cons_305B8EAC(e, t) {
                return new FSharpList(e, t)
            }

            function FSharpList__get_IsEmpty(e) {
                return e.tail == null
            }

            function FSharpList__get_Length(e) {
                const loop = (e, t) => {
                    e: while (true) {
                        const r = e,
                            n = t;
                        const i = n.tail;
                        if (i != null) {
                            e = r + 1;
                            t = i;
                            continue e
                        } else {
                            return r | 0
                        }
                        break
                    }
                };
                return loop(0, e) | 0
            }

            function FSharpList__get_Head(e) {
                const t = e.tail;
                if (t != null) {
                    return e.head
                } else {
                    throw new Error(a.SR_inputWasEmpty + "\\nParameter name: " + "list")
                }
            }

            function FSharpList__get_Tail(e) {
                const t = e.tail;
                if (t != null) {
                    return t
                } else {
                    throw new Error(a.SR_inputWasEmpty + "\\nParameter name: " + "list")
                }
            }

            function FSharpList__get_Item_Z524259A4(e, t) {
                const loop = (e, r) => {
                    e: while (true) {
                        const n = e,
                            i = r;
                        const o = i.tail;
                        if (o != null) {
                            if (n === t) {
                                return i.head
                            } else {
                                e = n + 1;
                                r = o;
                                continue e
                            }
                        } else {
                            throw new Error(a.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                        }
                        break
                    }
                };
                return loop(0, e)
            }

            function empty() {
                return FSharpList_get_Empty()
            }

            function cons(e, t) {
                return FSharpList_Cons_305B8EAC(e, t)
            }

            function singleton(e) {
                return FSharpList_Cons_305B8EAC(e, FSharpList_get_Empty())
            }

            function isEmpty(e) {
                return FSharpList__get_IsEmpty(e)
            }

            function length(e) {
                return FSharpList__get_Length(e)
            }

            function head(e) {
                return FSharpList__get_Head(e)
            }

            function tryHead(e) {
                if (FSharpList__get_IsEmpty(e)) {
                    return void 0
                } else {
                    return (0, l.some)(FSharpList__get_Head(e))
                }
            }

            function tail(e) {
                return FSharpList__get_Tail(e)
            }

            function tryLast(e) {
                e: while (true) {
                    const t = e;
                    if (FSharpList__get_IsEmpty(t)) {
                        return void 0
                    } else {
                        const r = FSharpList__get_Tail(t);
                        if (FSharpList__get_IsEmpty(r)) {
                            return (0, l.some)(FSharpList__get_Head(t))
                        } else {
                            e = r;
                            continue e
                        }
                    }
                    break
                }
            }

            function last(e) {
                const t = tryLast(e);
                if (t == null) {
                    throw new Error(a.SR_inputWasEmpty)
                } else {
                    return (0, l.value)(t)
                }
            }

            function compareWith(e, t, r) {
                const loop = (t, r) => {
                    e: while (true) {
                        const n = t,
                            i = r;
                        const o = [FSharpList__get_IsEmpty(n), FSharpList__get_IsEmpty(i)];
                        if (o[0]) {
                            if (o[1]) {
                                return 0
                            } else {
                                return -1
                            }
                        } else if (o[1]) {
                            return 1
                        } else {
                            const o = e(FSharpList__get_Head(n), FSharpList__get_Head(i)) | 0;
                            if (o === 0) {
                                t = FSharpList__get_Tail(n);
                                r = FSharpList__get_Tail(i);
                                continue e
                            } else {
                                return o | 0
                            }
                        }
                        break
                    }
                };
                return loop(t, r) | 0
            }

            function toArray(e) {
                const t = FSharpList__get_Length(e) | 0;
                const r = (0, _.fill)(new Array(t), 0, t, null);
                const loop = (e, t) => {
                    e: while (true) {
                        const n = e,
                            i = t;
                        if (!FSharpList__get_IsEmpty(i)) {
                            r[n] = FSharpList__get_Head(i);
                            e = n + 1;
                            t = FSharpList__get_Tail(i);
                            continue e
                        }
                        break
                    }
                };
                loop(0, e);
                return r
            }

            function fold(e, t, r) {
                let n = t;
                let i = r;
                while (!FSharpList__get_IsEmpty(i)) {
                    n = e(n, FSharpList__get_Head(i));
                    i = FSharpList__get_Tail(i)
                }
                return n
            }

            function reverse(e) {
                return fold(((e, t) => FSharpList_Cons_305B8EAC(t, e)), FSharpList_get_Empty(), e)
            }

            function foldBack(e, t, r) {
                return (0, _.foldBack)(e, toArray(t), r)
            }

            function foldIndexed(e, t, r) {
                const loop = (t, r, n) => {
                    e: while (true) {
                        const i = t,
                            o = r,
                            s = n;
                        if (FSharpList__get_IsEmpty(s)) {
                            return o
                        } else {
                            t = i + 1;
                            r = e(i, o, FSharpList__get_Head(s));
                            n = FSharpList__get_Tail(s);
                            continue e
                        }
                        break
                    }
                };
                return loop(0, t, r)
            }

            function fold2(e, t, r, n) {
                let i = t;
                let o = r;
                let s = n;
                while (!FSharpList__get_IsEmpty(o) && !FSharpList__get_IsEmpty(s)) {
                    i = e(i, FSharpList__get_Head(o), FSharpList__get_Head(s));
                    o = FSharpList__get_Tail(o);
                    s = FSharpList__get_Tail(s)
                }
                return i
            }

            function foldBack2(e, t, r, n) {
                return (0, _.foldBack2)(e, toArray(t), toArray(r), n)
            }

            function unfold(e, t) {
                const loop = (t, r) => {
                    let n;
                    e: while (true) {
                        const i = t,
                            o = r;
                        const s = e(i);
                        if (s != null) {
                            t = s[1];
                            r = (n = new FSharpList(s[0], void 0), o.tail = n, n);
                            continue e
                        } else {
                            return o
                        }
                        break
                    }
                };
                const r = FSharpList_get_Empty();
                const n = loop(t, r);
                const i = FSharpList_get_Empty();
                n.tail = i;
                return FSharpList__get_Tail(r)
            }

            function iterate(e, t) {
                fold(((t, r) => {
                    e(r)
                }), void 0, t)
            }

            function iterate2(e, t, r) {
                fold2(((t, r, n) => {
                    e(r, n)
                }), void 0, t, r)
            }

            function iterateIndexed(e, t) {
                fold(((t, r) => {
                    e(t, r);
                    return t + 1 | 0
                }), 0, t)
            }

            function iterateIndexed2(e, t, r) {
                fold2(((t, r, n) => {
                    e(t, r, n);
                    return t + 1 | 0
                }), 0, t, r)
            }

            function toSeq(e) {
                return e
            }

            function ofArrayWithTail(e, t) {
                let r = t;
                for (let t = e.length - 1; t >= 0; t--) {
                    r = FSharpList_Cons_305B8EAC(e[t], r)
                }
                return r
            }

            function ofArray(e) {
                return ofArrayWithTail(e, FSharpList_get_Empty())
            }

            function ofSeq(e) {
                let t, r;
                if ((0, i.isArrayLike)(e)) {
                    return ofArray(e)
                } else if (e instanceof FSharpList) {
                    return e
                } else {
                    const n = FSharpList_get_Empty();
                    let o = n;
                    const s = (0, i.getEnumerator)(e);
                    try {
                        while (s["System.Collections.IEnumerator.MoveNext"]()) {
                            const e = s["System.Collections.Generic.IEnumerator`1.get_Current"]();
                            o = (t = o, r = new FSharpList(e, void 0), t.tail = r, r)
                        }
                    } finally {
                        (0, i.disposeSafe)(s)
                    }
                    const a = o;
                    const l = FSharpList_get_Empty();
                    a.tail = l;
                    return FSharpList__get_Tail(n)
                }
            }

            function concat(e) {
                const t = FSharpList_get_Empty();
                let r = t;
                const action = e => {
                    r = fold(((e, t) => {
                        const r = new FSharpList(t, void 0);
                        e.tail = r;
                        return r
                    }), r, e)
                };
                if ((0, i.isArrayLike)(e)) {
                    e.forEach(action)
                } else if (e instanceof FSharpList) {
                    iterate(action, e)
                } else {
                    const t = (0, i.getEnumerator)(e);
                    try {
                        while (t["System.Collections.IEnumerator.MoveNext"]()) {
                            action(t["System.Collections.Generic.IEnumerator`1.get_Current"]())
                        }
                    } finally {
                        (0, i.disposeSafe)(t)
                    }
                }
                const n = r;
                const o = FSharpList_get_Empty();
                n.tail = o;
                return FSharpList__get_Tail(t)
            }

            function scan(e, t, r) {
                let n, i, o;
                const s = FSharpList_get_Empty();
                let a = (n = new FSharpList(t, void 0), s.tail = n, n);
                let l = t;
                let _ = r;
                while (!FSharpList__get_IsEmpty(_)) {
                    l = e(l, FSharpList__get_Head(_));
                    a = (i = a, o = new FSharpList(l, void 0), i.tail = o, o);
                    _ = FSharpList__get_Tail(_)
                }
                const u = a;
                const c = FSharpList_get_Empty();
                u.tail = c;
                return FSharpList__get_Tail(s)
            }

            function scanBack(e, t, r) {
                return ofArray((0, _.scanBack)(e, toArray(t), r))
            }

            function append(e, t) {
                return fold(((e, t) => FSharpList_Cons_305B8EAC(t, e)), t, reverse(e))
            }

            function collect(e, t) {
                let r, n;
                const i = FSharpList_get_Empty();
                let o = i;
                let s = t;
                while (!FSharpList__get_IsEmpty(s)) {
                    let t = e(FSharpList__get_Head(s));
                    while (!FSharpList__get_IsEmpty(t)) {
                        o = (r = o, n = new FSharpList(FSharpList__get_Head(t), void 0), r.tail = n, n);
                        t = FSharpList__get_Tail(t)
                    }
                    s = FSharpList__get_Tail(s)
                }
                const a = o;
                const l = FSharpList_get_Empty();
                a.tail = l;
                return FSharpList__get_Tail(i)
            }

            function mapIndexed(e, t) {
                const r = FSharpList_get_Empty();
                const n = foldIndexed(((t, r, n) => {
                    let i;
                    return i = new FSharpList(e(t, n), void 0), r.tail = i, i
                }), r, t);
                const i = FSharpList_get_Empty();
                n.tail = i;
                return FSharpList__get_Tail(r)
            }

            function map(e, t) {
                const r = FSharpList_get_Empty();
                const n = fold(((t, r) => {
                    let n;
                    return n = new FSharpList(e(r), void 0), t.tail = n, n
                }), r, t);
                const i = FSharpList_get_Empty();
                n.tail = i;
                return FSharpList__get_Tail(r)
            }

            function indexed(e) {
                return mapIndexed(((e, t) => [e, t]), e)
            }

            function map2(e, t, r) {
                const n = FSharpList_get_Empty();
                const i = fold2(((t, r, n) => {
                    let i;
                    return i = new FSharpList(e(r, n), void 0), t.tail = i, i
                }), n, t, r);
                const o = FSharpList_get_Empty();
                i.tail = o;
                return FSharpList__get_Tail(n)
            }

            function mapIndexed2(e, t, r) {
                const loop = (t, r, n, i) => {
                    let o;
                    e: while (true) {
                        const s = t,
                            a = r,
                            l = n,
                            _ = i;
                        if (FSharpList__get_IsEmpty(l) ? true : FSharpList__get_IsEmpty(_)) {
                            return a
                        } else {
                            t = s + 1;
                            r = (o = new FSharpList(e(s, FSharpList__get_Head(l), FSharpList__get_Head(_)), void 0), a.tail = o, o);
                            n = FSharpList__get_Tail(l);
                            i = FSharpList__get_Tail(_);
                            continue e
                        }
                        break
                    }
                };
                const n = FSharpList_get_Empty();
                const i = loop(0, n, t, r);
                const o = FSharpList_get_Empty();
                i.tail = o;
                return FSharpList__get_Tail(n)
            }

            function map3(e, t, r, n) {
                const loop = (t, r, n, i) => {
                    let o;
                    e: while (true) {
                        const s = t,
                            a = r,
                            l = n,
                            _ = i;
                        if ((FSharpList__get_IsEmpty(a) ? true : FSharpList__get_IsEmpty(l)) ? true : FSharpList__get_IsEmpty(_)) {
                            return s
                        } else {
                            t = (o = new FSharpList(e(FSharpList__get_Head(a), FSharpList__get_Head(l), FSharpList__get_Head(_)), void 0), s.tail = o, o);
                            r = FSharpList__get_Tail(a);
                            n = FSharpList__get_Tail(l);
                            i = FSharpList__get_Tail(_);
                            continue e
                        }
                        break
                    }
                };
                const i = FSharpList_get_Empty();
                const o = loop(i, t, r, n);
                const s = FSharpList_get_Empty();
                o.tail = s;
                return FSharpList__get_Tail(i)
            }

            function mapFold(e, t, r) {
                const n = FSharpList_get_Empty();
                const i = fold(((t, r) => {
                    let n;
                    const i = e(t[1], r);
                    return [(n = new FSharpList(i[0], void 0), t[0].tail = n, n), i[1]]
                }), [n, t], r);
                const o = FSharpList_get_Empty();
                i[0].tail = o;
                return [FSharpList__get_Tail(n), i[1]]
            }

            function mapFoldBack(e, t, r) {
                return mapFold(((t, r) => e(r, t)), r, reverse(t))
            }

            function tryPick(e, t) {
                const loop = t => {
                    e: while (true) {
                        const r = t;
                        if (FSharpList__get_IsEmpty(r)) {
                            return void 0
                        } else {
                            const n = e(FSharpList__get_Head(r));
                            if (n == null) {
                                t = FSharpList__get_Tail(r);
                                continue e
                            } else {
                                return n
                            }
                        }
                        break
                    }
                };
                return loop(t)
            }

            function pick(e, t) {
                const r = tryPick(e, t);
                if (r == null) {
                    throw new Error(a.SR_keyNotFoundAlt)
                } else {
                    return (0, l.value)(r)
                }
            }

            function tryFind(e, t) {
                return tryPick((t => e(t) ? (0, l.some)(t) : void 0), t)
            }

            function find(e, t) {
                const r = tryFind(e, t);
                if (r == null) {
                    throw new Error(a.SR_keyNotFoundAlt)
                } else {
                    return (0, l.value)(r)
                }
            }

            function tryFindBack(e, t) {
                return (0, _.tryFindBack)(e, toArray(t))
            }

            function findBack(e, t) {
                const r = tryFindBack(e, t);
                if (r == null) {
                    throw new Error(a.SR_keyNotFoundAlt)
                } else {
                    return (0, l.value)(r)
                }
            }

            function tryFindIndex(e, t) {
                const loop = (t, r) => {
                    e: while (true) {
                        const n = t,
                            i = r;
                        if (FSharpList__get_IsEmpty(i)) {
                            return void 0
                        } else if (e(FSharpList__get_Head(i))) {
                            return n
                        } else {
                            t = n + 1;
                            r = FSharpList__get_Tail(i);
                            continue e
                        }
                        break
                    }
                };
                return loop(0, t)
            }

            function findIndex(e, t) {
                const r = tryFindIndex(e, t);
                if (r == null) {
                    throw new Error(a.SR_keyNotFoundAlt)
                } else {
                    return r | 0
                }
            }

            function tryFindIndexBack(e, t) {
                return (0, _.tryFindIndexBack)(e, toArray(t))
            }

            function findIndexBack(e, t) {
                const r = tryFindIndexBack(e, t);
                if (r == null) {
                    throw new Error(a.SR_keyNotFoundAlt)
                } else {
                    return r | 0
                }
            }

            function tryItem(e, t) {
                const loop = (t, r) => {
                    e: while (true) {
                        const n = t,
                            i = r;
                        if (FSharpList__get_IsEmpty(i)) {
                            return void 0
                        } else if (n === e) {
                            return (0, l.some)(FSharpList__get_Head(i))
                        } else {
                            t = n + 1;
                            r = FSharpList__get_Tail(i);
                            continue e
                        }
                        break
                    }
                };
                return loop(0, t)
            }

            function item(e, t) {
                return FSharpList__get_Item_Z524259A4(t, e)
            }

            function filter(e, t) {
                const r = FSharpList_get_Empty();
                const n = fold(((t, r) => {
                    if (e(r)) {
                        const e = new FSharpList(r, void 0);
                        t.tail = e;
                        return e
                    } else {
                        return t
                    }
                }), r, t);
                const i = FSharpList_get_Empty();
                n.tail = i;
                return FSharpList__get_Tail(r)
            }

            function partition(e, t) {
                const r = [FSharpList_get_Empty(), FSharpList_get_Empty()];
                const n = r[1];
                const o = r[0];
                const s = fold((0, i.uncurry)(2, (t => {
                    const r = t[0];
                    const n = t[1];
                    return t => {
                        let i, o;
                        return e(t) ? [(i = new FSharpList(t, void 0), r.tail = i, i), n] : [r, (o = new FSharpList(t, void 0), n.tail = o, o)]
                    }
                })), [o, n], t);
                const a = FSharpList_get_Empty();
                s[0].tail = a;
                const l = FSharpList_get_Empty();
                s[1].tail = l;
                return [FSharpList__get_Tail(o), FSharpList__get_Tail(n)]
            }

            function choose(e, t) {
                const r = FSharpList_get_Empty();
                const n = fold(((t, r) => {
                    const n = e(r);
                    if (n == null) {
                        return t
                    } else {
                        const e = new FSharpList((0, l.value)(n), void 0);
                        t.tail = e;
                        return e
                    }
                }), r, t);
                const i = FSharpList_get_Empty();
                n.tail = i;
                return FSharpList__get_Tail(r)
            }

            function contains(e, t, r) {
                return tryFindIndex((t => r.Equals(e, t)), t) != null
            }

            function initialize(e, t) {
                let r, n;
                const i = FSharpList_get_Empty();
                let o = i;
                for (let i = 0; i <= e - 1; i++) {
                    o = (r = o, n = new FSharpList(t(i), void 0), r.tail = n, n)
                }
                const s = o;
                const a = FSharpList_get_Empty();
                s.tail = a;
                return FSharpList__get_Tail(i)
            }

            function replicate(e, t) {
                return initialize(e, (e => t))
            }

            function reduce(e, t) {
                if (FSharpList__get_IsEmpty(t)) {
                    throw new Error(a.SR_inputWasEmpty)
                } else {
                    return fold(e, head(t), tail(t))
                }
            }

            function reduceBack(e, t) {
                if (FSharpList__get_IsEmpty(t)) {
                    throw new Error(a.SR_inputWasEmpty)
                } else {
                    return foldBack(e, tail(t), head(t))
                }
            }

            function forAll(e, t) {
                return fold(((t, r) => t && e(r)), true, t)
            }

            function forAll2(e, t, r) {
                return fold2(((t, r, n) => t && e(r, n)), true, t, r)
            }

            function exists(e, t) {
                return tryFindIndex(e, t) != null
            }

            function exists2(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    const s = [FSharpList__get_IsEmpty(i), FSharpList__get_IsEmpty(o)];
                    let l;
                    if (s[0]) {
                        if (s[1]) {
                            l = 0
                        } else {
                            l = 2
                        }
                    } else if (s[1]) {
                        l = 2
                    } else {
                        l = 1
                    }
                    switch (l) {
                        case 0: {
                            return false
                        }
                        case 1: {
                            if (n(FSharpList__get_Head(i), FSharpList__get_Head(o))) {
                                return true
                            } else {
                                e = n;
                                t = FSharpList__get_Tail(i);
                                r = FSharpList__get_Tail(o);
                                continue e
                            }
                        }
                        case 2: {
                            throw new Error(a.SR_differentLengths + "\\nParameter name: " + "list2")
                        }
                    }
                    break
                }
            }

            function unzip(e) {
                return foldBack(((e, t) => [FSharpList_Cons_305B8EAC(e[0], t[0]), FSharpList_Cons_305B8EAC(e[1], t[1])]), e, [FSharpList_get_Empty(), FSharpList_get_Empty()])
            }

            function unzip3(e) {
                return foldBack(((e, t) => [FSharpList_Cons_305B8EAC(e[0], t[0]), FSharpList_Cons_305B8EAC(e[1], t[1]), FSharpList_Cons_305B8EAC(e[2], t[2])]), e, [FSharpList_get_Empty(), FSharpList_get_Empty(), FSharpList_get_Empty()])
            }

            function zip(e, t) {
                return map2(((e, t) => [e, t]), e, t)
            }

            function zip3(e, t, r) {
                return map3(((e, t, r) => [e, t, r]), e, t, r)
            }

            function sortWith(e, t) {
                const r = toArray(t);
                r.sort(e);
                return ofArray(r)
            }

            function sort(e, t) {
                return sortWith(((e, r) => t.Compare(e, r)), e)
            }

            function sortBy(e, t, r) {
                return sortWith(((t, n) => r.Compare(e(t), e(n))), t)
            }

            function sortDescending(e, t) {
                return sortWith(((e, r) => t.Compare(e, r) * -1), e)
            }

            function sortByDescending(e, t, r) {
                return sortWith(((t, n) => r.Compare(e(t), e(n)) * -1), t)
            }

            function sum(e, t) {
                return fold(((e, r) => t.Add(e, r)), t.GetZero(), e)
            }

            function sumBy(e, t, r) {
                return fold(((t, n) => r.Add(t, e(n))), r.GetZero(), t)
            }

            function maxBy(e, t, r) {
                return reduce(((t, n) => r.Compare(e(n), e(t)) > 0 ? n : t), t)
            }

            function max(e, t) {
                return reduce(((e, r) => t.Compare(r, e) > 0 ? r : e), e)
            }

            function minBy(e, t, r) {
                return reduce(((t, n) => r.Compare(e(n), e(t)) > 0 ? t : n), t)
            }

            function min(e, t) {
                return reduce(((e, r) => t.Compare(r, e) > 0 ? e : r), e)
            }

            function average(e, t) {
                let r = 0;
                const n = fold(((e, n) => {
                    r = r + 1 | 0;
                    return t.Add(e, n)
                }), t.GetZero(), e);
                return t.DivideByInt(n, r)
            }

            function averageBy(e, t, r) {
                let n = 0;
                const i = fold(((t, i) => {
                    n = n + 1 | 0;
                    return r.Add(t, e(i))
                }), r.GetZero(), t);
                return r.DivideByInt(i, n)
            }

            function permute(e, t) {
                return ofArray((0, _.permute)(e, toArray(t)))
            }

            function chunkBySize(e, t) {
                return ofArray((0, _.map)(ofArray, (0, _.chunkBySize)(e, toArray(t))))
            }

            function allPairs(e, t) {
                const r = FSharpList_get_Empty();
                let n = r;
                iterate((e => {
                    iterate((t => {
                        let r, i;
                        n = (r = n, i = new FSharpList([e, t], void 0), r.tail = i, i)
                    }), t)
                }), e);
                const i = n;
                const o = FSharpList_get_Empty();
                i.tail = o;
                return FSharpList__get_Tail(r)
            }

            function skip(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (r <= 0) {
                        return n
                    } else if (FSharpList__get_IsEmpty(n)) {
                        throw new Error(a.SR_notEnoughElements + "\\nParameter name: " + "list")
                    } else {
                        e = r - 1;
                        t = FSharpList__get_Tail(n);
                        continue e
                    }
                    break
                }
            }

            function skipWhile(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (FSharpList__get_IsEmpty(n)) {
                        return n
                    } else if (!r(FSharpList__get_Head(n))) {
                        return n
                    } else {
                        e = r;
                        t = FSharpList__get_Tail(n);
                        continue e
                    }
                    break
                }
            }

            function take(e, t) {
                if (e < 0) {
                    throw new Error(a.SR_inputMustBeNonNegative + "\\nParameter name: " + "count")
                }
                const loop = (e, t, r) => {
                    let n;
                    e: while (true) {
                        const i = e,
                            o = t,
                            s = r;
                        if (i <= 0) {
                            return o
                        } else if (FSharpList__get_IsEmpty(s)) {
                            throw new Error(a.SR_notEnoughElements + "\\nParameter name: " + "list")
                        } else {
                            e = i - 1;
                            t = (n = new FSharpList(FSharpList__get_Head(s), void 0), o.tail = n, n);
                            r = FSharpList__get_Tail(s);
                            continue e
                        }
                        break
                    }
                };
                const r = FSharpList_get_Empty();
                const n = loop(e, r, t);
                const i = FSharpList_get_Empty();
                n.tail = i;
                return FSharpList__get_Tail(r)
            }

            function takeWhile(e, t) {
                const loop = (t, r) => {
                    let n;
                    e: while (true) {
                        const i = t,
                            o = r;
                        if (FSharpList__get_IsEmpty(o)) {
                            return i
                        } else if (!e(FSharpList__get_Head(o))) {
                            return i
                        } else {
                            t = (n = new FSharpList(FSharpList__get_Head(o), void 0), i.tail = n, n);
                            r = FSharpList__get_Tail(o);
                            continue e
                        }
                        break
                    }
                };
                const r = FSharpList_get_Empty();
                const n = loop(r, t);
                const i = FSharpList_get_Empty();
                n.tail = i;
                return FSharpList__get_Tail(r)
            }

            function truncate(e, t) {
                const loop = (e, t, r) => {
                    let n;
                    e: while (true) {
                        const i = e,
                            o = t,
                            s = r;
                        if (i <= 0) {
                            return o
                        } else if (FSharpList__get_IsEmpty(s)) {
                            return o
                        } else {
                            e = i - 1;
                            t = (n = new FSharpList(FSharpList__get_Head(s), void 0), o.tail = n, n);
                            r = FSharpList__get_Tail(s);
                            continue e
                        }
                        break
                    }
                };
                const r = FSharpList_get_Empty();
                const n = loop(e, r, t);
                const i = FSharpList_get_Empty();
                n.tail = i;
                return FSharpList__get_Tail(r)
            }

            function getSlice(e, t, r) {
                const n = length(r) | 0;
                const i = (0, l.defaultArg)(e, 0) | 0;
                const o = (0, l.defaultArg)(t, n - 1) | 0;
                if (i < 0) {
                    throw new Error(a.SR_indexOutOfBounds + "\\nParameter name: " + "startIndex")
                } else if (o >= n) {
                    throw new Error(a.SR_indexOutOfBounds + "\\nParameter name: " + "endIndex")
                } else if (o < i) {
                    return FSharpList_get_Empty()
                } else {
                    return take(o - i + 1, skip(i, r))
                }
            }

            function splitAt(e, t) {
                if (e < 0) {
                    throw new Error(a.SR_inputMustBeNonNegative + "\\nParameter name: " + "index")
                }
                if (e > FSharpList__get_Length(t)) {
                    throw new Error(a.SR_notEnoughElements + "\\nParameter name: " + "index")
                }
                return [take(e, t), skip(e, t)]
            }

            function exactlyOne(e) {
                if (FSharpList__get_IsEmpty(e)) {
                    throw new Error(a.SR_inputSequenceEmpty + "\\nParameter name: " + "list")
                } else if (FSharpList__get_IsEmpty(FSharpList__get_Tail(e))) {
                    return FSharpList__get_Head(e)
                } else {
                    throw new Error(a.SR_inputSequenceTooLong + "\\nParameter name: " + "list")
                }
            }

            function tryExactlyOne(e) {
                if (!FSharpList__get_IsEmpty(e) && FSharpList__get_IsEmpty(FSharpList__get_Tail(e))) {
                    return (0, l.some)(FSharpList__get_Head(e))
                } else {
                    return void 0
                }
            }

            function where(e, t) {
                return filter(e, t)
            }

            function pairwise(e) {
                return ofArray((0, _.pairwise)(toArray(e)))
            }

            function windowed(e, t) {
                return ofArray((0, _.map)(ofArray, (0, _.windowed)(e, toArray(t))))
            }

            function splitInto(e, t) {
                return ofArray((0, _.map)(ofArray, (0, _.splitInto)(e, toArray(t))))
            }

            function transpose(e) {
                return ofArray((0, _.map)(ofArray, (0, _.transpose)((0, _.map)(toArray, Array.from(e)))))
            }

            function insertAt(e, t, r) {
                let n = -1;
                let i = false;
                const o = fold(((r, o) => {
                    n = n + 1 | 0;
                    if (n === e) {
                        i = true;
                        return FSharpList_Cons_305B8EAC(o, FSharpList_Cons_305B8EAC(t, r))
                    } else {
                        return FSharpList_Cons_305B8EAC(o, r)
                    }
                }), FSharpList_get_Empty(), r);
                return reverse(i ? o : n + 1 === e ? FSharpList_Cons_305B8EAC(t, o) : (() => {
                    throw new Error(a.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                })())
            }

            function insertManyAt(e, t, r) {
                let n = -1;
                let i = false;
                const o = ofSeq(t);
                const s = fold(((t, r) => {
                    n = n + 1 | 0;
                    if (n === e) {
                        i = true;
                        return FSharpList_Cons_305B8EAC(r, append(o, t))
                    } else {
                        return FSharpList_Cons_305B8EAC(r, t)
                    }
                }), FSharpList_get_Empty(), r);
                return reverse(i ? s : n + 1 === e ? append(o, s) : (() => {
                    throw new Error(a.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                })())
            }

            function removeAt(e, t) {
                let r = -1;
                let n = false;
                const i = filter((t => {
                    r = r + 1 | 0;
                    if (r === e) {
                        n = true;
                        return false
                    } else {
                        return true
                    }
                }), t);
                if (!n) {
                    throw new Error(a.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                return i
            }

            function removeManyAt(e, t, r) {
                let n = -1;
                let i = -1;
                const o = filter((r => {
                    n = n + 1 | 0;
                    if (n === e) {
                        i = 0;
                        return false
                    } else if (n > e) {
                        if (n < e + t) {
                            return false
                        } else {
                            i = 1;
                            return true
                        }
                    } else {
                        return true
                    }
                }), r);
                const s = (i === 0 && n + 1 === e + t ? 1 : i) | 0;
                if (s < 1) {
                    const e = s < 0 ? "index" : "count";
                    throw new Error(a.SR_indexOutOfBounds + "\\nParameter name: " + e)
                }
                return o
            }

            function updateAt(e, t, r) {
                let n = false;
                const i = mapIndexed(((r, i) => {
                    if (r === e) {
                        n = true;
                        return t
                    } else {
                        return i
                    }
                }), r);
                if (!n) {
                    throw new Error(a.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                return i
            }
        },
        2836: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.abs = abs;
            t["default"] = t.compare = void 0;
            t.divRem = divRem;
            t.fromInt = t.fromBytes = t.fromBits = t.equals = void 0;
            t.fromInteger = fromInteger;
            t.op_UnaryNegation = t.op_Subtraction = t.op_RightShiftUnsigned = t.op_RightShift = t.op_Multiply = t.op_Modulus = t.op_LogicalNot = t.op_LessThanOrEqual = t.op_LessThan = t.op_LeftShift = t.op_Inequality = t.op_GreaterThanOrEqual = t.op_GreaterThan = t.op_ExclusiveOr = t.op_Equality = t.op_Division = t.op_BitwiseOr = t.op_BitwiseAnd = t.op_Addition = t.get_Zero = t.get_One = t.getLowBitsUnsigned = t.getLowBits = t.getHighBitsUnsigned = t.getHighBits = t.fromValue = t.fromString = t.fromNumber = void 0;
            t.parse = parse;
            t.ticksToUnixEpochMilliseconds = ticksToUnixEpochMilliseconds;
            t.toString = t.toNumber = t.toInt = t.toBytes = void 0;
            t.tryParse = tryParse;
            t.unixEpochMillisecondsToTicks = unixEpochMillisecondsToTicks;
            var n = r(7526);
            var i = _interopRequireWildcard(r(6865));

            function _getRequireWildcardCache(e) {
                if (typeof WeakMap !== "function") return null;
                var t = new WeakMap;
                var r = new WeakMap;
                return (_getRequireWildcardCache = function(e) {
                    return e ? r : t
                })(e)
            }

            function _interopRequireWildcard(e, t) {
                if (!t && e && e.__esModule) {
                    return e
                }
                if (e === null || typeof e !== "object" && typeof e !== "function") {
                    return {
                        default: e
                    }
                }
                var r = _getRequireWildcardCache(t);
                if (r && r.has(e)) {
                    return r.get(e)
                }
                var n = {};
                var i = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var o in e) {
                    if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
                        var s = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                        if (s && (s.get || s.set)) {
                            Object.defineProperty(n, o, s)
                        } else {
                            n[o] = e[o]
                        }
                    }
                }
                n.default = e;
                if (r) {
                    r.set(e, n)
                }
                return n
            }
            var o = i.Long;
            t["default"] = o;
            const s = i.ZERO;
            t.get_Zero = s;
            const a = i.ONE;
            t.get_One = a;
            const l = i.add;
            t.op_Addition = l;
            const _ = i.subtract;
            t.op_Subtraction = _;
            const u = i.multiply;
            t.op_Multiply = u;
            const c = i.divide;
            t.op_Division = c;
            const d = i.modulo;
            t.op_Modulus = d;
            const p = i.negate;
            t.op_UnaryNegation = p;
            const f = i.shiftLeft;
            t.op_LeftShift = f;
            const h = i.shiftRight;
            t.op_RightShift = h;
            const g = i.shiftRightUnsigned;
            t.op_RightShiftUnsigned = g;
            const m = i.and;
            t.op_BitwiseAnd = m;
            const y = i.or;
            t.op_BitwiseOr = y;
            const S = i.xor;
            t.op_ExclusiveOr = S;
            const T = i.not;
            t.op_LogicalNot = T;
            const x = i.lessThan;
            t.op_LessThan = x;
            const C = i.lessThanOrEqual;
            t.op_LessThanOrEqual = C;
            const N = i.greaterThan;
            t.op_GreaterThan = N;
            const A = i.greaterThanOrEqual;
            t.op_GreaterThanOrEqual = A;
            const E = i.equals;
            t.op_Equality = E;
            const v = i.notEquals;
            t.op_Inequality = v;
            const M = i.equals;
            t.equals = M;
            const w = i.compare;
            t.compare = w;
            const b = i.fromInt;
            t.fromInt = b;
            const F = i.fromBits;
            t.fromBits = F;
            const B = i.fromBytes;
            t.fromBytes = B;
            const I = i.fromNumber;
            t.fromNumber = I;
            const L = i.fromString;
            t.fromString = L;
            const P = i.fromValue;
            t.fromValue = P;
            const O = i.toInt;
            t.toInt = O;
            const R = i.toBytes;
            t.toBytes = R;
            const D = i.toNumber;
            t.toNumber = D;
            const k = i.toString;
            t.toString = k;
            const $ = i.getLowBits;
            t.getLowBits = $;
            const j = i.getHighBits;
            t.getHighBits = j;
            const U = i.getLowBitsUnsigned;
            t.getLowBitsUnsigned = U;
            const Z = i.getHighBitsUnsigned;
            t.getHighBitsUnsigned = Z;

            function getMaxValue(e, t, r) {
                switch (t) {
                    case 2:
                        return e ? "1111111111111111111111111111111111111111111111111111111111111111" : r ? "1000000000000000000000000000000000000000000000000000000000000000" : "111111111111111111111111111111111111111111111111111111111111111";
                    case 8:
                        return e ? "1777777777777777777777" : r ? "1000000000000000000000" : "777777777777777777777";
                    case 10:
                        return e ? "18446744073709551615" : r ? "9223372036854775808" : "9223372036854775807";
                    case 16:
                        return e ? "FFFFFFFFFFFFFFFF" : r ? "8000000000000000" : "7FFFFFFFFFFFFFFF";
                    default:
                        throw new Error("Invalid radix.")
                }
            }

            function abs(e) {
                if (!e.unsigned && i.isNegative(e)) {
                    return p(e)
                } else {
                    return e
                }
            }

            function fromInteger(e, t, r) {
                let n = e;
                let o = 0;
                switch (r) {
                    case 0:
                        n = e << 24 >> 24;
                        o = n;
                        break;
                    case 4:
                        n = e << 24 >>> 24;
                        break;
                    case 1:
                        n = e << 16 >> 16;
                        o = n;
                        break;
                    case 5:
                        n = e << 16 >>> 16;
                        break;
                    case 2:
                        n = e >> 0;
                        o = n;
                        break;
                    case 6:
                        n = e >>> 0;
                        break
                }
                return i.fromBits(n, o >> 31, t)
            }

            function parse(e, t, r, o, s) {
                const a = (0, n.isValid)(e, t, s);
                if (a != null) {
                    const lessOrEqual = (e, t) => {
                        const r = Math.max(e.length, t.length);
                        return e.padStart(r, "0") <= t.padStart(r, "0")
                    };
                    const t = a.sign === "-";
                    const n = getMaxValue(r || a.radix !== 10, a.radix, t);
                    if (lessOrEqual(a.digits.toUpperCase(), n)) {
                        e = t ? a.sign + a.digits : a.digits;
                        return i.fromString(e, r, a.radix)
                    }
                }
                throw new Error("Input string was not in a correct format.")
            }

            function tryParse(e, t, r, n, i) {
                try {
                    i.contents = parse(e, t, r, n);
                    return true
                } catch (e) {
                    return false
                }
            }

            function unixEpochMillisecondsToTicks(e, t) {
                return u(l(l(i.fromNumber(e), 621355968e5), t), 1e4)
            }

            function ticksToUnixEpochMilliseconds(e) {
                return i.toNumber(_(c(e, 1e4), 621355968e5))
            }

            function divRem(e, t, r) {
                const n = c(e, t);
                const i = d(e, t);
                if (r != null) {
                    r.contents = i;
                    return n
                } else {
                    return [n, i]
                }
            }
        },
        5466: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.FSharpMap = void 0;
            t.FSharpMap$reflection = FSharpMap$reflection;
            t.FSharpMap_$ctor = FSharpMap_$ctor;
            t.FSharpMap_Create = FSharpMap_Create;
            t.FSharpMap__Add = FSharpMap__Add;
            t.FSharpMap__Change = FSharpMap__Change;
            t.FSharpMap__ComputeHashCode = FSharpMap__ComputeHashCode;
            t.FSharpMap__ContainsKey = FSharpMap__ContainsKey;
            t.FSharpMap__Exists = FSharpMap__Exists;
            t.FSharpMap__Filter = FSharpMap__Filter;
            t.FSharpMap__Fold = FSharpMap__Fold;
            t.FSharpMap__FoldSection = FSharpMap__FoldSection;
            t.FSharpMap__ForAll = FSharpMap__ForAll;
            t.FSharpMap__Iterate = FSharpMap__Iterate;
            t.FSharpMap__Map = FSharpMap__Map;
            t.FSharpMap__MapRange = FSharpMap__MapRange;
            t.FSharpMap__Partition = FSharpMap__Partition;
            t.FSharpMap__Remove = FSharpMap__Remove;
            t.FSharpMap__ToArray = FSharpMap__ToArray;
            t.FSharpMap__ToList = FSharpMap__ToList;
            t.FSharpMap__TryFind = FSharpMap__TryFind;
            t.FSharpMap__TryGetValue = FSharpMap__TryGetValue;
            t.FSharpMap__TryPick = FSharpMap__TryPick;
            t.FSharpMap__get_Comparer = FSharpMap__get_Comparer;
            t.FSharpMap__get_Count = FSharpMap__get_Count;
            t.FSharpMap__get_IsEmpty = FSharpMap__get_IsEmpty;
            t.FSharpMap__get_Item = FSharpMap__get_Item;
            t.FSharpMap__get_Keys = FSharpMap__get_Keys;
            t.FSharpMap__get_Tree = FSharpMap__get_Tree;
            t.FSharpMap__get_Values = FSharpMap__get_Values;
            t.FSharpMap_get_Empty = FSharpMap_get_Empty;
            t.MapTreeLeaf$2 = void 0;
            t.MapTreeLeaf$2$reflection = MapTreeLeaf$2$reflection;
            t.MapTreeLeaf$2_$ctor_5BDDA1 = MapTreeLeaf$2_$ctor_5BDDA1;
            t.MapTreeLeaf$2__get_Key = MapTreeLeaf$2__get_Key;
            t.MapTreeLeaf$2__get_Value = MapTreeLeaf$2__get_Value;
            t.MapTreeModule_MapIterator$2 = void 0;
            t.MapTreeModule_MapIterator$2$reflection = MapTreeModule_MapIterator$2$reflection;
            t.MapTreeModule_add = MapTreeModule_add;
            t.MapTreeModule_alreadyFinished = MapTreeModule_alreadyFinished;
            t.MapTreeModule_change = MapTreeModule_change;
            t.MapTreeModule_collapseLHS = MapTreeModule_collapseLHS;
            t.MapTreeModule_copyToArray = MapTreeModule_copyToArray;
            t.MapTreeModule_current = MapTreeModule_current;
            t.MapTreeModule_empty = MapTreeModule_empty;
            t.MapTreeModule_exists = MapTreeModule_exists;
            t.MapTreeModule_existsOpt = MapTreeModule_existsOpt;
            t.MapTreeModule_filter = MapTreeModule_filter;
            t.MapTreeModule_filter1 = MapTreeModule_filter1;
            t.MapTreeModule_filterAux = MapTreeModule_filterAux;
            t.MapTreeModule_find = MapTreeModule_find;
            t.MapTreeModule_fold = MapTreeModule_fold;
            t.MapTreeModule_foldBack = MapTreeModule_foldBack;
            t.MapTreeModule_foldBackOpt = MapTreeModule_foldBackOpt;
            t.MapTreeModule_foldOpt = MapTreeModule_foldOpt;
            t.MapTreeModule_foldSection = MapTreeModule_foldSection;
            t.MapTreeModule_foldSectionOpt = MapTreeModule_foldSectionOpt;
            t.MapTreeModule_forall = MapTreeModule_forall;
            t.MapTreeModule_forallOpt = MapTreeModule_forallOpt;
            t.MapTreeModule_iter = MapTreeModule_iter;
            t.MapTreeModule_iterOpt = MapTreeModule_iterOpt;
            t.MapTreeModule_map = MapTreeModule_map;
            t.MapTreeModule_mapi = MapTreeModule_mapi;
            t.MapTreeModule_mapiOpt = MapTreeModule_mapiOpt;
            t.MapTreeModule_mem = MapTreeModule_mem;
            t.MapTreeModule_mk = MapTreeModule_mk;
            t.MapTreeModule_mkFromEnumerator = MapTreeModule_mkFromEnumerator;
            t.MapTreeModule_mkIEnumerator = MapTreeModule_mkIEnumerator;
            t.MapTreeModule_mkIterator = MapTreeModule_mkIterator;
            t.MapTreeModule_moveNext = MapTreeModule_moveNext;
            t.MapTreeModule_notStarted = MapTreeModule_notStarted;
            t.MapTreeModule_ofArray = MapTreeModule_ofArray;
            t.MapTreeModule_ofList = MapTreeModule_ofList;
            t.MapTreeModule_ofSeq = MapTreeModule_ofSeq;
            t.MapTreeModule_partition = MapTreeModule_partition;
            t.MapTreeModule_partition1 = MapTreeModule_partition1;
            t.MapTreeModule_partitionAux = MapTreeModule_partitionAux;
            t.MapTreeModule_rebalance = MapTreeModule_rebalance;
            t.MapTreeModule_remove = MapTreeModule_remove;
            t.MapTreeModule_size = MapTreeModule_size;
            t.MapTreeModule_sizeAux = MapTreeModule_sizeAux;
            t.MapTreeModule_spliceOutSuccessor = MapTreeModule_spliceOutSuccessor;
            t.MapTreeModule_toArray = MapTreeModule_toArray;
            t.MapTreeModule_toList = MapTreeModule_toList;
            t.MapTreeModule_toSeq = MapTreeModule_toSeq;
            t.MapTreeModule_tryFind = MapTreeModule_tryFind;
            t.MapTreeModule_tryPick = MapTreeModule_tryPick;
            t.MapTreeModule_tryPickOpt = MapTreeModule_tryPickOpt;
            t.MapTreeNode$2 = void 0;
            t.MapTreeNode$2$reflection = MapTreeNode$2$reflection;
            t.MapTreeNode$2_$ctor_499A11FD = MapTreeNode$2_$ctor_499A11FD;
            t.MapTreeNode$2__get_Height = MapTreeNode$2__get_Height;
            t.MapTreeNode$2__get_Left = MapTreeNode$2__get_Left;
            t.MapTreeNode$2__get_Right = MapTreeNode$2__get_Right;
            t.add = add;
            t.change = change;
            t.containsKey = containsKey;
            t.count = count;
            t.empty = empty;
            t.exists = exists;
            t.filter = filter;
            t.find = find;
            t.findKey = findKey;
            t.fold = fold;
            t.foldBack = foldBack;
            t.forAll = forAll;
            t.isEmpty = isEmpty;
            t.iterate = iterate;
            t.keys = keys;
            t.map = map;
            t.ofArray = ofArray;
            t.ofList = ofList;
            t.ofSeq = ofSeq;
            t.partition = partition;
            t.pick = pick;
            t.remove = remove;
            t.toArray = toArray;
            t.toList = toList;
            t.toSeq = toSeq;
            t.tryFind = tryFind;
            t.tryFindKey = tryFindKey;
            t.tryPick = tryPick;
            t.values = values;
            var n = r(6356);
            var i = r(6256);
            var o = r(5359);
            var s = r(9054);
            var a = r(4222);
            var l = r(6638);
            var _ = r(2078);
            var u = r(9937);
            var c = r(3093);
            class MapTreeLeaf$2 {
                constructor(e, t) {
                    this.k = e;
                    this.v = t
                }
            }
            t.MapTreeLeaf$2 = MapTreeLeaf$2;

            function MapTreeLeaf$2$reflection(e, t) {
                return (0, n.class_type)("Map.MapTreeLeaf`2", [e, t], MapTreeLeaf$2)
            }

            function MapTreeLeaf$2_$ctor_5BDDA1(e, t) {
                return new MapTreeLeaf$2(e, t)
            }

            function MapTreeLeaf$2__get_Key(e) {
                return e.k
            }

            function MapTreeLeaf$2__get_Value(e) {
                return e.v
            }
            class MapTreeNode$2 extends MapTreeLeaf$2 {
                constructor(e, t, r, n, i) {
                    super(e, t);
                    this.left = r;
                    this.right = n;
                    this.h = i | 0
                }
            }
            t.MapTreeNode$2 = MapTreeNode$2;

            function MapTreeNode$2$reflection(e, t) {
                return (0, n.class_type)("Map.MapTreeNode`2", [e, t], MapTreeNode$2, MapTreeLeaf$2$reflection(e, t))
            }

            function MapTreeNode$2_$ctor_499A11FD(e, t, r, n, i) {
                return new MapTreeNode$2(e, t, r, n, i)
            }

            function MapTreeNode$2__get_Left(e) {
                return e.left
            }

            function MapTreeNode$2__get_Right(e) {
                return e.right
            }

            function MapTreeNode$2__get_Height(e) {
                return e.h
            }

            function MapTreeModule_empty() {
                return void 0
            }

            function MapTreeModule_sizeAux(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n != null) {
                        const i = n;
                        if (i instanceof MapTreeNode$2) {
                            e = MapTreeModule_sizeAux(r + 1, MapTreeNode$2__get_Left(i));
                            t = MapTreeNode$2__get_Right(i);
                            continue e
                        } else {
                            return r + 1 | 0
                        }
                    } else {
                        return r | 0
                    }
                    break
                }
            }

            function MapTreeModule_size(e) {
                return MapTreeModule_sizeAux(0, e)
            }

            function MapTreeModule_mk(e, t, r, n) {
                let i;
                const o = e;
                if (o != null) {
                    const e = o;
                    i = e instanceof MapTreeNode$2 ? MapTreeNode$2__get_Height(e) : 1
                } else {
                    i = 0
                }
                let s;
                const a = n;
                if (a != null) {
                    const e = a;
                    s = e instanceof MapTreeNode$2 ? MapTreeNode$2__get_Height(e) : 1
                } else {
                    s = 0
                }
                const l = (i < s ? s : i) | 0;
                if (l === 0) {
                    return MapTreeLeaf$2_$ctor_5BDDA1(t, r)
                } else {
                    return MapTreeNode$2_$ctor_499A11FD(t, r, e, n, l + 1)
                }
            }

            function MapTreeModule_rebalance(e, t, r, n) {
                let o, s, a, l;
                let _;
                const u = e;
                if (u != null) {
                    const e = u;
                    _ = e instanceof MapTreeNode$2 ? MapTreeNode$2__get_Height(e) : 1
                } else {
                    _ = 0
                }
                let c;
                const d = n;
                if (d != null) {
                    const e = d;
                    c = e instanceof MapTreeNode$2 ? MapTreeNode$2__get_Height(e) : 1
                } else {
                    c = 0
                }
                if (c > _ + 2) {
                    const a = (0, i.value)(n);
                    if (a instanceof MapTreeNode$2) {
                        if ((o = MapTreeNode$2__get_Left(a), o != null ? (s = o, s instanceof MapTreeNode$2 ? MapTreeNode$2__get_Height(s) : 1) : 0) > _ + 1) {
                            const n = (0, i.value)(MapTreeNode$2__get_Left(a));
                            if (n instanceof MapTreeNode$2) {
                                return MapTreeModule_mk(MapTreeModule_mk(e, t, r, MapTreeNode$2__get_Left(n)), MapTreeLeaf$2__get_Key(n), MapTreeLeaf$2__get_Value(n), MapTreeModule_mk(MapTreeNode$2__get_Right(n), MapTreeLeaf$2__get_Key(a), MapTreeLeaf$2__get_Value(a), MapTreeNode$2__get_Right(a)))
                            } else {
                                throw new Error("internal error: Map.rebalance")
                            }
                        } else {
                            return MapTreeModule_mk(MapTreeModule_mk(e, t, r, MapTreeNode$2__get_Left(a)), MapTreeLeaf$2__get_Key(a), MapTreeLeaf$2__get_Value(a), MapTreeNode$2__get_Right(a))
                        }
                    } else {
                        throw new Error("internal error: Map.rebalance")
                    }
                } else if (_ > c + 2) {
                    const o = (0, i.value)(e);
                    if (o instanceof MapTreeNode$2) {
                        if ((a = MapTreeNode$2__get_Right(o), a != null ? (l = a, l instanceof MapTreeNode$2 ? MapTreeNode$2__get_Height(l) : 1) : 0) > c + 1) {
                            const e = (0, i.value)(MapTreeNode$2__get_Right(o));
                            if (e instanceof MapTreeNode$2) {
                                return MapTreeModule_mk(MapTreeModule_mk(MapTreeNode$2__get_Left(o), MapTreeLeaf$2__get_Key(o), MapTreeLeaf$2__get_Value(o), MapTreeNode$2__get_Left(e)), MapTreeLeaf$2__get_Key(e), MapTreeLeaf$2__get_Value(e), MapTreeModule_mk(MapTreeNode$2__get_Right(e), t, r, n))
                            } else {
                                throw new Error("internal error: Map.rebalance")
                            }
                        } else {
                            return MapTreeModule_mk(MapTreeNode$2__get_Left(o), MapTreeLeaf$2__get_Key(o), MapTreeLeaf$2__get_Value(o), MapTreeModule_mk(MapTreeNode$2__get_Right(o), t, r, n))
                        }
                    } else {
                        throw new Error("internal error: Map.rebalance")
                    }
                } else {
                    return MapTreeModule_mk(e, t, r, n)
                }
            }

            function MapTreeModule_add(e, t, r, n) {
                if (n != null) {
                    const i = n;
                    const o = e.Compare(t, MapTreeLeaf$2__get_Key(i)) | 0;
                    if (i instanceof MapTreeNode$2) {
                        if (o < 0) {
                            return MapTreeModule_rebalance(MapTreeModule_add(e, t, r, MapTreeNode$2__get_Left(i)), MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i), MapTreeNode$2__get_Right(i))
                        } else if (o === 0) {
                            return MapTreeNode$2_$ctor_499A11FD(t, r, MapTreeNode$2__get_Left(i), MapTreeNode$2__get_Right(i), MapTreeNode$2__get_Height(i))
                        } else {
                            return MapTreeModule_rebalance(MapTreeNode$2__get_Left(i), MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i), MapTreeModule_add(e, t, r, MapTreeNode$2__get_Right(i)))
                        }
                    } else if (o < 0) {
                        return MapTreeNode$2_$ctor_499A11FD(t, r, MapTreeModule_empty(), n, 2)
                    } else if (o === 0) {
                        return MapTreeLeaf$2_$ctor_5BDDA1(t, r)
                    } else {
                        return MapTreeNode$2_$ctor_499A11FD(t, r, n, MapTreeModule_empty(), 2)
                    }
                } else {
                    return MapTreeLeaf$2_$ctor_5BDDA1(t, r)
                }
            }

            function MapTreeModule_tryFind(e, t, r) {
                e: while (true) {
                    const n = e,
                        o = t,
                        s = r;
                    if (s != null) {
                        const a = s;
                        const l = n.Compare(o, MapTreeLeaf$2__get_Key(a)) | 0;
                        if (l === 0) {
                            return (0, i.some)(MapTreeLeaf$2__get_Value(a))
                        } else if (a instanceof MapTreeNode$2) {
                            e = n;
                            t = o;
                            r = l < 0 ? MapTreeNode$2__get_Left(a) : MapTreeNode$2__get_Right(a);
                            continue e
                        } else {
                            return void 0
                        }
                    } else {
                        return void 0
                    }
                    break
                }
            }

            function MapTreeModule_find(e, t, r) {
                const n = MapTreeModule_tryFind(e, t, r);
                if (n == null) {
                    throw new Error
                } else {
                    return (0, i.value)(n)
                }
            }

            function MapTreeModule_partition1(e, t, r, n, i, o) {
                if (t(r, n)) {
                    return [MapTreeModule_add(e, r, n, i), o]
                } else {
                    return [i, MapTreeModule_add(e, r, n, o)]
                }
            }

            function MapTreeModule_partitionAux(e, t, r, n, i) {
                e: while (true) {
                    const o = e,
                        s = t,
                        a = r,
                        l = n,
                        _ = i;
                    const u = [l, _];
                    if (a != null) {
                        const l = a;
                        if (l instanceof MapTreeNode$2) {
                            const a = MapTreeModule_partitionAux(o, s, MapTreeNode$2__get_Right(l), u[0], u[1]);
                            const _ = MapTreeModule_partition1(o, s, MapTreeLeaf$2__get_Key(l), MapTreeLeaf$2__get_Value(l), a[0], a[1]);
                            e = o;
                            t = s;
                            r = MapTreeNode$2__get_Left(l);
                            n = _[0];
                            i = _[1];
                            continue e
                        } else {
                            return MapTreeModule_partition1(o, s, MapTreeLeaf$2__get_Key(l), MapTreeLeaf$2__get_Value(l), u[0], u[1])
                        }
                    } else {
                        return u
                    }
                    break
                }
            }

            function MapTreeModule_partition(e, t, r) {
                return MapTreeModule_partitionAux(e, t, r, MapTreeModule_empty(), MapTreeModule_empty())
            }

            function MapTreeModule_filter1(e, t, r, n, i) {
                if (t(r, n)) {
                    return MapTreeModule_add(e, r, n, i)
                } else {
                    return i
                }
            }

            function MapTreeModule_filterAux(e, t, r, n) {
                e: while (true) {
                    const i = e,
                        o = t,
                        s = r,
                        a = n;
                    if (s != null) {
                        const l = s;
                        if (l instanceof MapTreeNode$2) {
                            const s = MapTreeModule_filterAux(i, o, MapTreeNode$2__get_Left(l), a);
                            const _ = MapTreeModule_filter1(i, o, MapTreeLeaf$2__get_Key(l), MapTreeLeaf$2__get_Value(l), s);
                            e = i;
                            t = o;
                            r = MapTreeNode$2__get_Right(l);
                            n = _;
                            continue e
                        } else {
                            return MapTreeModule_filter1(i, o, MapTreeLeaf$2__get_Key(l), MapTreeLeaf$2__get_Value(l), a)
                        }
                    } else {
                        return a
                    }
                    break
                }
            }

            function MapTreeModule_filter(e, t, r) {
                return MapTreeModule_filterAux(e, t, r, MapTreeModule_empty())
            }

            function MapTreeModule_spliceOutSuccessor(e) {
                if (e != null) {
                    const t = e;
                    if (t instanceof MapTreeNode$2) {
                        if (MapTreeNode$2__get_Left(t) == null) {
                            return [MapTreeLeaf$2__get_Key(t), MapTreeLeaf$2__get_Value(t), MapTreeNode$2__get_Right(t)]
                        } else {
                            const e = MapTreeModule_spliceOutSuccessor(MapTreeNode$2__get_Left(t));
                            return [e[0], e[1], MapTreeModule_mk(e[2], MapTreeLeaf$2__get_Key(t), MapTreeLeaf$2__get_Value(t), MapTreeNode$2__get_Right(t))]
                        }
                    } else {
                        return [MapTreeLeaf$2__get_Key(t), MapTreeLeaf$2__get_Value(t), MapTreeModule_empty()]
                    }
                } else {
                    throw new Error("internal error: Map.spliceOutSuccessor")
                }
            }

            function MapTreeModule_remove(e, t, r) {
                if (r != null) {
                    const n = r;
                    const i = e.Compare(t, MapTreeLeaf$2__get_Key(n)) | 0;
                    if (n instanceof MapTreeNode$2) {
                        if (i < 0) {
                            return MapTreeModule_rebalance(MapTreeModule_remove(e, t, MapTreeNode$2__get_Left(n)), MapTreeLeaf$2__get_Key(n), MapTreeLeaf$2__get_Value(n), MapTreeNode$2__get_Right(n))
                        } else if (i === 0) {
                            if (MapTreeNode$2__get_Left(n) == null) {
                                return MapTreeNode$2__get_Right(n)
                            } else if (MapTreeNode$2__get_Right(n) == null) {
                                return MapTreeNode$2__get_Left(n)
                            } else {
                                const e = MapTreeModule_spliceOutSuccessor(MapTreeNode$2__get_Right(n));
                                return MapTreeModule_mk(MapTreeNode$2__get_Left(n), e[0], e[1], e[2])
                            }
                        } else {
                            return MapTreeModule_rebalance(MapTreeNode$2__get_Left(n), MapTreeLeaf$2__get_Key(n), MapTreeLeaf$2__get_Value(n), MapTreeModule_remove(e, t, MapTreeNode$2__get_Right(n)))
                        }
                    } else if (i === 0) {
                        return MapTreeModule_empty()
                    } else {
                        return r
                    }
                } else {
                    return MapTreeModule_empty()
                }
            }

            function MapTreeModule_change(e, t, r, n) {
                if (n != null) {
                    const o = n;
                    if (o instanceof MapTreeNode$2) {
                        const n = e.Compare(t, MapTreeLeaf$2__get_Key(o)) | 0;
                        if (n < 0) {
                            return MapTreeModule_rebalance(MapTreeModule_change(e, t, r, MapTreeNode$2__get_Left(o)), MapTreeLeaf$2__get_Key(o), MapTreeLeaf$2__get_Value(o), MapTreeNode$2__get_Right(o))
                        } else if (n === 0) {
                            const e = r((0, i.some)(MapTreeLeaf$2__get_Value(o)));
                            if (e != null) {
                                return MapTreeNode$2_$ctor_499A11FD(t, (0, i.value)(e), MapTreeNode$2__get_Left(o), MapTreeNode$2__get_Right(o), MapTreeNode$2__get_Height(o))
                            } else if (MapTreeNode$2__get_Left(o) == null) {
                                return MapTreeNode$2__get_Right(o)
                            } else if (MapTreeNode$2__get_Right(o) == null) {
                                return MapTreeNode$2__get_Left(o)
                            } else {
                                const e = MapTreeModule_spliceOutSuccessor(MapTreeNode$2__get_Right(o));
                                return MapTreeModule_mk(MapTreeNode$2__get_Left(o), e[0], e[1], e[2])
                            }
                        } else {
                            return MapTreeModule_rebalance(MapTreeNode$2__get_Left(o), MapTreeLeaf$2__get_Key(o), MapTreeLeaf$2__get_Value(o), MapTreeModule_change(e, t, r, MapTreeNode$2__get_Right(o)))
                        }
                    } else {
                        const s = e.Compare(t, MapTreeLeaf$2__get_Key(o)) | 0;
                        if (s < 0) {
                            const e = r(void 0);
                            if (e != null) {
                                return MapTreeNode$2_$ctor_499A11FD(t, (0, i.value)(e), MapTreeModule_empty(), n, 2)
                            } else {
                                return n
                            }
                        } else if (s === 0) {
                            const e = r((0, i.some)(MapTreeLeaf$2__get_Value(o)));
                            if (e != null) {
                                return MapTreeLeaf$2_$ctor_5BDDA1(t, (0, i.value)(e))
                            } else {
                                return MapTreeModule_empty()
                            }
                        } else {
                            const e = r(void 0);
                            if (e != null) {
                                return MapTreeNode$2_$ctor_499A11FD(t, (0, i.value)(e), n, MapTreeModule_empty(), 2)
                            } else {
                                return n
                            }
                        }
                    }
                } else {
                    const e = r(void 0);
                    if (e != null) {
                        return MapTreeLeaf$2_$ctor_5BDDA1(t, (0, i.value)(e))
                    } else {
                        return n
                    }
                }
            }

            function MapTreeModule_mem(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o != null) {
                        const s = o;
                        const a = n.Compare(i, MapTreeLeaf$2__get_Key(s)) | 0;
                        if (s instanceof MapTreeNode$2) {
                            if (a < 0) {
                                e = n;
                                t = i;
                                r = MapTreeNode$2__get_Left(s);
                                continue e
                            } else if (a === 0) {
                                return true
                            } else {
                                e = n;
                                t = i;
                                r = MapTreeNode$2__get_Right(s);
                                continue e
                            }
                        } else {
                            return a === 0
                        }
                    } else {
                        return false
                    }
                    break
                }
            }

            function MapTreeModule_iterOpt(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n != null) {
                        const i = n;
                        if (i instanceof MapTreeNode$2) {
                            MapTreeModule_iterOpt(r, MapTreeNode$2__get_Left(i));
                            r(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i));
                            e = r;
                            t = MapTreeNode$2__get_Right(i);
                            continue e
                        } else {
                            r(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i))
                        }
                    }
                    break
                }
            }

            function MapTreeModule_iter(e, t) {
                MapTreeModule_iterOpt(e, t)
            }

            function MapTreeModule_tryPickOpt(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n != null) {
                        const i = n;
                        if (i instanceof MapTreeNode$2) {
                            const n = MapTreeModule_tryPickOpt(r, MapTreeNode$2__get_Left(i));
                            if (n == null) {
                                const n = r(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i));
                                if (n == null) {
                                    e = r;
                                    t = MapTreeNode$2__get_Right(i);
                                    continue e
                                } else {
                                    return n
                                }
                            } else {
                                return n
                            }
                        } else {
                            return r(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i))
                        }
                    } else {
                        return void 0
                    }
                    break
                }
            }

            function MapTreeModule_tryPick(e, t) {
                return MapTreeModule_tryPickOpt(e, t)
            }

            function MapTreeModule_existsOpt(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n != null) {
                        const i = n;
                        if (i instanceof MapTreeNode$2) {
                            if (MapTreeModule_existsOpt(r, MapTreeNode$2__get_Left(i)) ? true : r(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i))) {
                                return true
                            } else {
                                e = r;
                                t = MapTreeNode$2__get_Right(i);
                                continue e
                            }
                        } else {
                            return r(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i))
                        }
                    } else {
                        return false
                    }
                    break
                }
            }

            function MapTreeModule_exists(e, t) {
                return MapTreeModule_existsOpt(e, t)
            }

            function MapTreeModule_forallOpt(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n != null) {
                        const i = n;
                        if (i instanceof MapTreeNode$2) {
                            if (MapTreeModule_forallOpt(r, MapTreeNode$2__get_Left(i)) && r(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i))) {
                                e = r;
                                t = MapTreeNode$2__get_Right(i);
                                continue e
                            } else {
                                return false
                            }
                        } else {
                            return r(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i))
                        }
                    } else {
                        return true
                    }
                    break
                }
            }

            function MapTreeModule_forall(e, t) {
                return MapTreeModule_forallOpt(e, t)
            }

            function MapTreeModule_map(e, t) {
                if (t != null) {
                    const r = t;
                    if (r instanceof MapTreeNode$2) {
                        const t = MapTreeModule_map(e, MapTreeNode$2__get_Left(r));
                        const n = e(MapTreeLeaf$2__get_Value(r));
                        const i = MapTreeModule_map(e, MapTreeNode$2__get_Right(r));
                        return MapTreeNode$2_$ctor_499A11FD(MapTreeLeaf$2__get_Key(r), n, t, i, MapTreeNode$2__get_Height(r))
                    } else {
                        return MapTreeLeaf$2_$ctor_5BDDA1(MapTreeLeaf$2__get_Key(r), e(MapTreeLeaf$2__get_Value(r)))
                    }
                } else {
                    return MapTreeModule_empty()
                }
            }

            function MapTreeModule_mapiOpt(e, t) {
                if (t != null) {
                    const r = t;
                    if (r instanceof MapTreeNode$2) {
                        const t = MapTreeModule_mapiOpt(e, MapTreeNode$2__get_Left(r));
                        const n = e(MapTreeLeaf$2__get_Key(r), MapTreeLeaf$2__get_Value(r));
                        const i = MapTreeModule_mapiOpt(e, MapTreeNode$2__get_Right(r));
                        return MapTreeNode$2_$ctor_499A11FD(MapTreeLeaf$2__get_Key(r), n, t, i, MapTreeNode$2__get_Height(r))
                    } else {
                        return MapTreeLeaf$2_$ctor_5BDDA1(MapTreeLeaf$2__get_Key(r), e(MapTreeLeaf$2__get_Key(r), MapTreeLeaf$2__get_Value(r)))
                    }
                } else {
                    return MapTreeModule_empty()
                }
            }

            function MapTreeModule_mapi(e, t) {
                return MapTreeModule_mapiOpt(e, t)
            }

            function MapTreeModule_foldBackOpt(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (i != null) {
                        const s = i;
                        if (s instanceof MapTreeNode$2) {
                            const i = MapTreeModule_foldBackOpt(n, MapTreeNode$2__get_Right(s), o);
                            const a = n(MapTreeLeaf$2__get_Key(s), MapTreeLeaf$2__get_Value(s), i);
                            e = n;
                            t = MapTreeNode$2__get_Left(s);
                            r = a;
                            continue e
                        } else {
                            return n(MapTreeLeaf$2__get_Key(s), MapTreeLeaf$2__get_Value(s), o)
                        }
                    } else {
                        return o
                    }
                    break
                }
            }

            function MapTreeModule_foldBack(e, t, r) {
                return MapTreeModule_foldBackOpt(e, t, r)
            }

            function MapTreeModule_foldOpt(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o != null) {
                        const s = o;
                        if (s instanceof MapTreeNode$2) {
                            e = n;
                            t = n(MapTreeModule_foldOpt(n, i, MapTreeNode$2__get_Left(s)), MapTreeLeaf$2__get_Key(s), MapTreeLeaf$2__get_Value(s));
                            r = MapTreeNode$2__get_Right(s);
                            continue e
                        } else {
                            return n(i, MapTreeLeaf$2__get_Key(s), MapTreeLeaf$2__get_Value(s))
                        }
                    } else {
                        return i
                    }
                    break
                }
            }

            function MapTreeModule_fold(e, t, r) {
                return MapTreeModule_foldOpt(e, t, r)
            }

            function MapTreeModule_foldSectionOpt(e, t, r, n, i, o) {
                const foldFromTo = (n, i, o) => {
                    e: while (true) {
                        const s = n,
                            a = i,
                            l = o;
                        if (a != null) {
                            const _ = a;
                            if (_ instanceof MapTreeNode$2) {
                                const a = e.Compare(t, MapTreeLeaf$2__get_Key(_)) | 0;
                                const u = e.Compare(MapTreeLeaf$2__get_Key(_), r) | 0;
                                const c = a < 0 ? foldFromTo(s, MapTreeNode$2__get_Left(_), l) : l;
                                const d = a <= 0 && u <= 0 ? s(MapTreeLeaf$2__get_Key(_), MapTreeLeaf$2__get_Value(_), c) : c;
                                if (u < 0) {
                                    n = s;
                                    i = MapTreeNode$2__get_Right(_);
                                    o = d;
                                    continue e
                                } else {
                                    return d
                                }
                            } else if (e.Compare(t, MapTreeLeaf$2__get_Key(_)) <= 0 && e.Compare(MapTreeLeaf$2__get_Key(_), r) <= 0) {
                                return s(MapTreeLeaf$2__get_Key(_), MapTreeLeaf$2__get_Value(_), l)
                            } else {
                                return l
                            }
                        } else {
                            return l
                        }
                        break
                    }
                };
                if (e.Compare(t, r) === 1) {
                    return o
                } else {
                    return foldFromTo(n, i, o)
                }
            }

            function MapTreeModule_foldSection(e, t, r, n, i, o) {
                return MapTreeModule_foldSectionOpt(e, t, r, n, i, o)
            }

            function MapTreeModule_toList(e) {
                const loop = (e, t) => {
                    e: while (true) {
                        const r = e,
                            n = t;
                        if (r != null) {
                            const i = r;
                            if (i instanceof MapTreeNode$2) {
                                e = MapTreeNode$2__get_Left(i);
                                t = (0, o.cons)([MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i)], loop(MapTreeNode$2__get_Right(i), n));
                                continue e
                            } else {
                                return (0, o.cons)([MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i)], n)
                            }
                        } else {
                            return n
                        }
                        break
                    }
                };
                return loop(e, (0, o.empty)())
            }

            function MapTreeModule_copyToArray(e, t, r) {
                let n = r;
                MapTreeModule_iter(((e, r) => {
                    t[n] = [e, r];
                    n = n + 1 | 0
                }), e)
            }

            function MapTreeModule_toArray(e) {
                const t = MapTreeModule_size(e) | 0;
                const r = (0, s.fill)(new Array(t), 0, t, [null, null]);
                MapTreeModule_copyToArray(e, r, 0);
                return r
            }

            function MapTreeModule_ofList(e, t) {
                return (0, o.fold)(((t, r) => MapTreeModule_add(e, r[0], r[1], t)), MapTreeModule_empty(), t)
            }

            function MapTreeModule_mkFromEnumerator(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o["System.Collections.IEnumerator.MoveNext"]()) {
                        const s = o["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        e = n;
                        t = MapTreeModule_add(n, s[0], s[1], i);
                        r = o;
                        continue e
                    } else {
                        return i
                    }
                    break
                }
            }

            function MapTreeModule_ofArray(e, t) {
                let r = MapTreeModule_empty();
                for (let n = 0; n <= t.length - 1; n++) {
                    const i = t[n];
                    r = MapTreeModule_add(e, i[0], i[1], r)
                }
                return r
            }

            function MapTreeModule_ofSeq(e, t) {
                if ((0, a.isArrayLike)(t)) {
                    return MapTreeModule_ofArray(e, t)
                } else if (t instanceof o.FSharpList) {
                    return MapTreeModule_ofList(e, t)
                } else {
                    const r = (0, a.getEnumerator)(t);
                    try {
                        return MapTreeModule_mkFromEnumerator(e, MapTreeModule_empty(), r)
                    } finally {
                        (0, a.disposeSafe)(r)
                    }
                }
            }
            class MapTreeModule_MapIterator$2 extends l.Record {
                constructor(e, t) {
                    super();
                    this.stack = e;
                    this.started = t
                }
            }
            t.MapTreeModule_MapIterator$2 = MapTreeModule_MapIterator$2;

            function MapTreeModule_MapIterator$2$reflection(e, t) {
                return (0, n.record_type)("Map.MapTreeModule.MapIterator`2", [e, t], MapTreeModule_MapIterator$2, (() => [
                    ["stack", (0, n.list_type)((0, n.option_type)(MapTreeLeaf$2$reflection(e, t)))],
                    ["started", n.bool_type]
                ]))
            }

            function MapTreeModule_collapseLHS(e) {
                e: while (true) {
                    const t = e;
                    if (!(0, o.isEmpty)(t)) {
                        const r = (0, o.tail)(t);
                        const n = (0, o.head)(t);
                        if (n != null) {
                            const i = n;
                            if (i instanceof MapTreeNode$2) {
                                e = (0, o.ofArrayWithTail)([MapTreeNode$2__get_Left(i), MapTreeLeaf$2_$ctor_5BDDA1(MapTreeLeaf$2__get_Key(i), MapTreeLeaf$2__get_Value(i)), MapTreeNode$2__get_Right(i)], r);
                                continue e
                            } else {
                                return t
                            }
                        } else {
                            e = r;
                            continue e
                        }
                    } else {
                        return (0, o.empty)()
                    }
                    break
                }
            }

            function MapTreeModule_mkIterator(e) {
                return new MapTreeModule_MapIterator$2(MapTreeModule_collapseLHS((0, o.singleton)(e)), false)
            }

            function MapTreeModule_notStarted() {
                throw new Error("enumeration not started")
            }

            function MapTreeModule_alreadyFinished() {
                throw new Error("enumeration already finished")
            }

            function MapTreeModule_current(e) {
                if (e.started) {
                    const t = e.stack;
                    if (!(0, o.isEmpty)(t)) {
                        if ((0, o.head)(t) != null) {
                            const e = (0, o.head)(t);
                            if (e instanceof MapTreeNode$2) {
                                throw new Error("Please report error: Map iterator, unexpected stack for current")
                            } else {
                                return [MapTreeLeaf$2__get_Key(e), MapTreeLeaf$2__get_Value(e)]
                            }
                        } else {
                            throw new Error("Please report error: Map iterator, unexpected stack for current")
                        }
                    } else {
                        return MapTreeModule_alreadyFinished()
                    }
                } else {
                    return MapTreeModule_notStarted()
                }
            }

            function MapTreeModule_moveNext(e) {
                if (e.started) {
                    const t = e.stack;
                    if (!(0, o.isEmpty)(t)) {
                        if ((0, o.head)(t) != null) {
                            const r = (0, o.head)(t);
                            if (r instanceof MapTreeNode$2) {
                                throw new Error("Please report error: Map iterator, unexpected stack for moveNext")
                            } else {
                                e.stack = MapTreeModule_collapseLHS((0, o.tail)(t));
                                return !(0, o.isEmpty)(e.stack)
                            }
                        } else {
                            throw new Error("Please report error: Map iterator, unexpected stack for moveNext")
                        }
                    } else {
                        return false
                    }
                } else {
                    e.started = true;
                    return !(0, o.isEmpty)(e.stack)
                }
            }

            function MapTreeModule_mkIEnumerator(e) {
                let t = MapTreeModule_mkIterator(e);
                return {
                    ["System.Collections.Generic.IEnumerator`1.get_Current"]() {
                        return MapTreeModule_current(t)
                    },
                    ["System.Collections.IEnumerator.get_Current"]() {
                        return MapTreeModule_current(t)
                    },
                    ["System.Collections.IEnumerator.MoveNext"]() {
                        return MapTreeModule_moveNext(t)
                    },
                    ["System.Collections.IEnumerator.Reset"]() {
                        t = MapTreeModule_mkIterator(e)
                    },
                    Dispose() {}
                }
            }

            function MapTreeModule_toSeq(e) {
                return (0, _.unfold)((e => {
                    if (e["System.Collections.IEnumerator.MoveNext"]()) {
                        return [e["System.Collections.Generic.IEnumerator`1.get_Current"](), e]
                    } else {
                        return void 0
                    }
                }), MapTreeModule_mkIEnumerator(e))
            }
            class FSharpMap {
                constructor(e, t) {
                    this.comparer = e;
                    this.tree = t
                }
                GetHashCode() {
                    const e = this;
                    return FSharpMap__ComputeHashCode(e) | 0
                }
                Equals(e) {
                    const t = this;
                    if (e instanceof FSharpMap) {
                        const r = (0, a.getEnumerator)(t);
                        try {
                            const t = (0, a.getEnumerator)(e);
                            try {
                                const loop = () => {
                                    const e = r["System.Collections.IEnumerator.MoveNext"]();
                                    if (e === t["System.Collections.IEnumerator.MoveNext"]()) {
                                        if (!e) {
                                            return true
                                        } else {
                                            const e = r["System.Collections.Generic.IEnumerator`1.get_Current"]();
                                            const n = t["System.Collections.Generic.IEnumerator`1.get_Current"]();
                                            if ((0, a.equals)(e[0], n[0]) && (0, a.equals)(e[1], n[1])) {
                                                return loop()
                                            } else {
                                                return false
                                            }
                                        }
                                    } else {
                                        return false
                                    }
                                };
                                return loop()
                            } finally {
                                (0, a.disposeSafe)(t)
                            }
                        } finally {
                            (0, a.disposeSafe)(r)
                        }
                    } else {
                        return false
                    }
                }
                toString() {
                    const e = this;
                    return "map [" + (0, u.join)("; ", (0, _.map)((e => (0, u.format)("({0}, {1})", e[0], e[1])), e)) + "]"
                }
                get[Symbol.toStringTag]() {
                    return "FSharpMap"
                }
                toJSON(e) {
                    const t = this;
                    return Array.from(t)
                }
                GetEnumerator() {
                    const e = this;
                    return MapTreeModule_mkIEnumerator(e.tree)
                } [Symbol.iterator]() {
                    return (0, a.toIterator)(this.GetEnumerator())
                } ["System.Collections.IEnumerable.GetEnumerator"]() {
                    const e = this;
                    return MapTreeModule_mkIEnumerator(e.tree)
                }
                CompareTo(e) {
                    const t = this;
                    if (e instanceof FSharpMap) {
                        return (0, _.compareWith)(((e, r) => {
                            const n = t.comparer.Compare(e[0], r[0]) | 0;
                            return (n !== 0 ? n : (0, a.compare)(e[1], r[1])) | 0
                        }), t, e) | 0
                    } else {
                        throw new Error("not comparable\\nParameter name: obj")
                    }
                } ["System.Collections.Generic.ICollection`1.Add2B595"](e) {
                    throw new Error("Map cannot be mutated")
                } ["System.Collections.Generic.ICollection`1.Clear"]() {
                    throw new Error("Map cannot be mutated")
                } ["System.Collections.Generic.ICollection`1.Remove2B595"](e) {
                    throw new Error("Map cannot be mutated")
                } ["System.Collections.Generic.ICollection`1.Contains2B595"](e) {
                    const t = this;
                    return FSharpMap__ContainsKey(t, e[0]) && (0, a.equals)(FSharpMap__get_Item(t, e[0]), e[1])
                } ["System.Collections.Generic.ICollection`1.CopyToZ2E171D71"](e, t) {
                    const r = this;
                    MapTreeModule_copyToArray(r.tree, e, t)
                } ["System.Collections.Generic.ICollection`1.get_IsReadOnly"]() {
                    return true
                } ["System.Collections.Generic.ICollection`1.get_Count"]() {
                    const e = this;
                    return FSharpMap__get_Count(e) | 0
                } ["System.Collections.Generic.IReadOnlyCollection`1.get_Count"]() {
                    const e = this;
                    return FSharpMap__get_Count(e) | 0
                }
                get size() {
                    const e = this;
                    return FSharpMap__get_Count(e) | 0
                }
                clear() {
                    throw new Error("Map cannot be mutated")
                }
                delete(e) {
                    throw new Error("Map cannot be mutated");
                    return false
                }
                entries() {
                    const e = this;
                    return (0, _.map)((e => [e[0], e[1]]), e)
                }
                get(e) {
                    const t = this;
                    return FSharpMap__get_Item(t, e)
                }
                has(e) {
                    const t = this;
                    return FSharpMap__ContainsKey(t, e)
                }
                keys() {
                    const e = this;
                    return (0, _.map)((e => e[0]), e)
                }
                set(e, t) {
                    const r = this;
                    throw new Error("Map cannot be mutated");
                    return r
                }
                values() {
                    const e = this;
                    return (0, _.map)((e => e[1]), e)
                }
                forEach(e, t) {
                    const r = this;
                    (0, _.iterate)((t => {
                        e(t[1], t[0], r)
                    }), r)
                }
            }
            t.FSharpMap = FSharpMap;

            function FSharpMap$reflection(e, t) {
                return (0, n.class_type)("Map.FSharpMap", [e, t], FSharpMap)
            }

            function FSharpMap_$ctor(e, t) {
                return new FSharpMap(e, t)
            }(() => {
                FSharpMap.empty = FSharpMap_$ctor((0, c.LanguagePrimitives_FastGenericComparer)(), MapTreeModule_empty())
            })();

            function FSharpMap_get_Empty() {
                return FSharpMap.empty
            }

            function FSharpMap_Create(e) {
                const t = (0, c.LanguagePrimitives_FastGenericComparer)();
                return FSharpMap_$ctor(t, MapTreeModule_ofSeq(t, e))
            }

            function FSharpMap__get_Comparer(e) {
                return e.comparer
            }

            function FSharpMap__get_Tree(e) {
                return e.tree
            }

            function FSharpMap__Add(e, t, r) {
                return FSharpMap_$ctor(e.comparer, MapTreeModule_add(e.comparer, t, r, e.tree))
            }

            function FSharpMap__Change(e, t, r) {
                return FSharpMap_$ctor(e.comparer, MapTreeModule_change(e.comparer, t, r, e.tree))
            }

            function FSharpMap__get_IsEmpty(e) {
                return e.tree == null
            }

            function FSharpMap__get_Item(e, t) {
                return MapTreeModule_find(e.comparer, t, e.tree)
            }

            function FSharpMap__TryPick(e, t) {
                return MapTreeModule_tryPick(t, e.tree)
            }

            function FSharpMap__Exists(e, t) {
                return MapTreeModule_exists(t, e.tree)
            }

            function FSharpMap__Filter(e, t) {
                return FSharpMap_$ctor(e.comparer, MapTreeModule_filter(e.comparer, t, e.tree))
            }

            function FSharpMap__ForAll(e, t) {
                return MapTreeModule_forall(t, e.tree)
            }

            function FSharpMap__Fold(e, t, r) {
                return MapTreeModule_foldBack(t, e.tree, r)
            }

            function FSharpMap__FoldSection(e, t, r, n, i) {
                return MapTreeModule_foldSection(e.comparer, t, r, n, e.tree, i)
            }

            function FSharpMap__Iterate(e, t) {
                MapTreeModule_iter(t, e.tree)
            }

            function FSharpMap__MapRange(e, t) {
                return FSharpMap_$ctor(e.comparer, MapTreeModule_map(t, e.tree))
            }

            function FSharpMap__Map(e, t) {
                return FSharpMap_$ctor(e.comparer, MapTreeModule_mapi(t, e.tree))
            }

            function FSharpMap__Partition(e, t) {
                const r = MapTreeModule_partition(e.comparer, t, e.tree);
                return [FSharpMap_$ctor(e.comparer, r[0]), FSharpMap_$ctor(e.comparer, r[1])]
            }

            function FSharpMap__get_Count(e) {
                return MapTreeModule_size(e.tree)
            }

            function FSharpMap__ContainsKey(e, t) {
                return MapTreeModule_mem(e.comparer, t, e.tree)
            }

            function FSharpMap__Remove(e, t) {
                return FSharpMap_$ctor(e.comparer, MapTreeModule_remove(e.comparer, t, e.tree))
            }

            function FSharpMap__TryGetValue(e, t, r) {
                const n = MapTreeModule_tryFind(e.comparer, t, e.tree);
                if (n == null) {
                    return false
                } else {
                    const e = (0, i.value)(n);
                    r.contents = e;
                    return true
                }
            }

            function FSharpMap__get_Keys(e) {
                return (0, s.map)((e => e[0]), MapTreeModule_toArray(e.tree))
            }

            function FSharpMap__get_Values(e) {
                return (0, s.map)((e => e[1]), MapTreeModule_toArray(e.tree))
            }

            function FSharpMap__TryFind(e, t) {
                return MapTreeModule_tryFind(e.comparer, t, e.tree)
            }

            function FSharpMap__ToList(e) {
                return MapTreeModule_toList(e.tree)
            }

            function FSharpMap__ToArray(e) {
                return MapTreeModule_toArray(e.tree)
            }

            function FSharpMap__ComputeHashCode(e) {
                const combineHash = (e, t) => (e << 1) + t + 631;
                let t = 0;
                const r = (0, a.getEnumerator)(e);
                try {
                    while (r["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = r["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        t = combineHash(t, (0, a.structuralHash)(e[0])) | 0;
                        t = combineHash(t, (0, a.structuralHash)(e[1])) | 0
                    }
                } finally {
                    (0, a.disposeSafe)(r)
                }
                return t | 0
            }

            function isEmpty(e) {
                return FSharpMap__get_IsEmpty(e)
            }

            function add(e, t, r) {
                return FSharpMap__Add(r, e, t)
            }

            function change(e, t, r) {
                return FSharpMap__Change(r, e, t)
            }

            function find(e, t) {
                return FSharpMap__get_Item(t, e)
            }

            function tryFind(e, t) {
                return FSharpMap__TryFind(t, e)
            }

            function remove(e, t) {
                return FSharpMap__Remove(t, e)
            }

            function containsKey(e, t) {
                return FSharpMap__ContainsKey(t, e)
            }

            function iterate(e, t) {
                FSharpMap__Iterate(t, e)
            }

            function tryPick(e, t) {
                return FSharpMap__TryPick(t, e)
            }

            function pick(e, t) {
                const r = tryPick(e, t);
                if (r != null) {
                    return (0, i.value)(r)
                } else {
                    throw new Error
                }
            }

            function exists(e, t) {
                return FSharpMap__Exists(t, e)
            }

            function filter(e, t) {
                return FSharpMap__Filter(t, e)
            }

            function partition(e, t) {
                return FSharpMap__Partition(t, e)
            }

            function forAll(e, t) {
                return FSharpMap__ForAll(t, e)
            }

            function map(e, t) {
                return FSharpMap__Map(t, e)
            }

            function fold(e, t, r) {
                return MapTreeModule_fold(e, t, FSharpMap__get_Tree(r))
            }

            function foldBack(e, t, r) {
                return MapTreeModule_foldBack(e, FSharpMap__get_Tree(t), r)
            }

            function toSeq(e) {
                return (0, _.map)((e => [e[0], e[1]]), e)
            }

            function findKey(e, t) {
                return (0, _.pick)((t => {
                    const r = t[0];
                    if (e(r, t[1])) {
                        return (0, i.some)(r)
                    } else {
                        return void 0
                    }
                }), t)
            }

            function tryFindKey(e, t) {
                return (0, _.tryPick)((t => {
                    const r = t[0];
                    if (e(r, t[1])) {
                        return (0, i.some)(r)
                    } else {
                        return void 0
                    }
                }), t)
            }

            function ofList(e) {
                return FSharpMap_Create(e)
            }

            function ofSeq(e) {
                return FSharpMap_Create(e)
            }

            function ofArray(e) {
                const t = (0, c.LanguagePrimitives_FastGenericComparer)();
                return FSharpMap_$ctor(t, MapTreeModule_ofArray(t, e))
            }

            function toList(e) {
                return FSharpMap__ToList(e)
            }

            function toArray(e) {
                return FSharpMap__ToArray(e)
            }

            function keys(e) {
                return FSharpMap__get_Keys(e)
            }

            function values(e) {
                return FSharpMap__get_Values(e)
            }

            function empty() {
                return FSharpMap_get_Empty()
            }

            function count(e) {
                return FSharpMap__get_Count(e)
            }
        },
        7384: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.addToDict = addToDict;
            t.addToSet = addToSet;
            t.containsValue = containsValue;
            t.getItemFromDict = getItemFromDict;
            t.keyValueList = keyValueList;
            t.tryGetValue = tryGetValue;
            var n = r(4222);
            var i = r(6638);
            const o = {
                None: 0,
                LowerFirst: 1,
                SnakeCase: 2,
                SnakeCaseAllCaps: 3,
                KebabCase: 4
            };

            function dashify(e, t) {
                return e.replace(/[a-z]?[A-Z]/g, (e => e.length === 1 ? e.toLowerCase() : e.charAt(0) + t + e.charAt(1).toLowerCase()))
            }

            function changeCase(e, t) {
                switch (t) {
                    case o.LowerFirst:
                        return e.charAt(0).toLowerCase() + e.slice(1);
                    case o.SnakeCase:
                        return dashify(e, "_");
                    case o.SnakeCaseAllCaps:
                        return dashify(e, "_").toUpperCase();
                    case o.KebabCase:
                        return dashify(e, "-");
                    case o.None:
                    default:
                        return e
                }
            }

            function keyValueList(e, t = o.None) {
                const r = {};
                const n = t;

                function fail(e) {
                    throw new Error("Cannot infer key and value of " + String(e))
                }

                function assign(e, t, n) {
                    e = changeCase(e, t);
                    r[e] = n
                }
                for (let t of e) {
                    let e = o.None;
                    if (t == null) {
                        fail(t)
                    }
                    if (t instanceof i.Union) {
                        const r = t.cases()[t.tag];
                        t = t.fields.length === 0 ? r : [r].concat(t.fields);
                        e = n
                    }
                    if (Array.isArray(t)) {
                        switch (t.length) {
                            case 0:
                                fail(t);
                                break;
                            case 1:
                                assign(t[0], e, true);
                                break;
                            case 2:
                                const r = t[1];
                                assign(t[0], e, r);
                                break;
                            default:
                                assign(t[0], e, t.slice(1))
                        }
                    } else if (typeof t === "string") {
                        assign(t, e, true)
                    } else {
                        fail(t)
                    }
                }
                return r
            }

            function containsValue(e, t) {
                for (const r of t) {
                    if ((0, n.equals)(e, r[1])) {
                        return true
                    }
                }
                return false
            }

            function tryGetValue(e, t, r) {
                if (e.has(t)) {
                    r.contents = e.get(t);
                    return true
                }
                return false
            }

            function addToSet(e, t) {
                if (t.has(e)) {
                    return false
                }
                t.add(e);
                return true
            }

            function addToDict(e, t, r) {
                if (e.has(t)) {
                    throw new Error("An item with the same key has already been added. Key: " + t)
                }
                e.set(t, r)
            }

            function getItemFromDict(e, t) {
                if (e.has(t)) {
                    return e.get(t)
                } else {
                    throw new Error(`The given key '${t}' was not present in the dictionary.`)
                }
            }
        },
        9131: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.HashSet = void 0;
            t.HashSet$reflection = HashSet$reflection;
            t.HashSet_$ctor_Z6150332D = HashSet_$ctor_Z6150332D;
            t.HashSet__Add_2B595 = HashSet__Add_2B595;
            t.HashSet__Clear = HashSet__Clear;
            t.HashSet__Contains_2B595 = HashSet__Contains_2B595;
            t.HashSet__Remove_2B595 = HashSet__Remove_2B595;
            t.HashSet__get_Comparer = HashSet__get_Comparer;
            t.HashSet__get_Count = HashSet__get_Count;
            var n = r(4222);
            var i = r(2078);
            var o = r(6638);
            var s = r(6356);
            var a = r(7384);
            var l = r(6256);
            class HashSet {
                constructor(e, t) {
                    const r = new o.FSharpRef(null);
                    this.comparer = t;
                    r.contents = this;
                    this.hashMap = new Map([]);
                    this["init@8-2"] = 1;
                    const i = (0, n.getEnumerator)(e);
                    try {
                        while (i["System.Collections.IEnumerator.MoveNext"]()) {
                            const e = i["System.Collections.Generic.IEnumerator`1.get_Current"]();
                            HashSet__Add_2B595(r.contents, e)
                        }
                    } finally {
                        (0, n.disposeSafe)(i)
                    }
                }
                get[Symbol.toStringTag]() {
                    return "HashSet"
                }
                toJSON(e) {
                    const t = this;
                    return Array.from(t)
                } ["System.Collections.IEnumerable.GetEnumerator"]() {
                    const e = this;
                    return (0, n.getEnumerator)(e)
                }
                GetEnumerator() {
                    const e = this;
                    return (0, n.getEnumerator)((0, i.concat)(e.hashMap.values()))
                } [Symbol.iterator]() {
                    return (0, n.toIterator)(this.GetEnumerator())
                } ["System.Collections.Generic.ICollection`1.Add2B595"](e) {
                    const t = this;
                    HashSet__Add_2B595(t, e)
                } ["System.Collections.Generic.ICollection`1.Clear"]() {
                    const e = this;
                    HashSet__Clear(e)
                } ["System.Collections.Generic.ICollection`1.Contains2B595"](e) {
                    const t = this;
                    return HashSet__Contains_2B595(t, e)
                } ["System.Collections.Generic.ICollection`1.CopyToZ2E171D71"](e, t) {
                    const r = this;
                    (0, i.iterateIndexed)(((r, n) => {
                        e[t + r] = n
                    }), r)
                } ["System.Collections.Generic.ICollection`1.get_Count"]() {
                    const e = this;
                    return HashSet__get_Count(e) | 0
                } ["System.Collections.Generic.ICollection`1.get_IsReadOnly"]() {
                    return false
                } ["System.Collections.Generic.ICollection`1.Remove2B595"](e) {
                    const t = this;
                    return HashSet__Remove_2B595(t, e)
                }
                get size() {
                    const e = this;
                    return HashSet__get_Count(e) | 0
                }
                add(e) {
                    const t = this;
                    HashSet__Add_2B595(t, e);
                    return t
                }
                clear() {
                    const e = this;
                    HashSet__Clear(e)
                }
                delete(e) {
                    const t = this;
                    return HashSet__Remove_2B595(t, e)
                }
                has(e) {
                    const t = this;
                    return HashSet__Contains_2B595(t, e)
                }
                keys() {
                    const e = this;
                    return (0, i.map)((e => e), e)
                }
                values() {
                    const e = this;
                    return (0, i.map)((e => e), e)
                }
                entries() {
                    const e = this;
                    return (0, i.map)((e => [e, e]), e)
                }
                forEach(e, t) {
                    const r = this;
                    (0, i.iterate)((t => {
                        e(t, t, r)
                    }), r)
                }
            }
            t.HashSet = HashSet;

            function HashSet$reflection(e) {
                return (0, s.class_type)("Fable.Collections.HashSet", [e], HashSet)
            }

            function HashSet_$ctor_Z6150332D(e, t) {
                return new HashSet(e, t)
            }

            function HashSet__TryFindIndex_2B595(e, t) {
                const r = e.comparer.GetHashCode(t) | 0;
                let n;
                let i = null;
                n = [(0, a.tryGetValue)(e.hashMap, r, new o.FSharpRef((() => i), (e => {
                    i = e
                }))), i];
                if (n[0]) {
                    return [true, r, n[1].findIndex((r => e.comparer.Equals(t, r)))]
                } else {
                    return [false, r, -1]
                }
            }

            function HashSet__TryFind_2B595(e, t) {
                const r = HashSet__TryFindIndex_2B595(e, t);
                let n;
                if (r[0]) {
                    if (r[2] > -1) {
                        n = 0
                    } else {
                        n = 1
                    }
                } else {
                    n = 1
                }
                switch (n) {
                    case 0: {
                        return (0, l.some)((0, a.getItemFromDict)(e.hashMap, r[1])[r[2]])
                    }
                    case 1: {
                        return void 0
                    }
                }
            }

            function HashSet__get_Comparer(e) {
                return e.comparer
            }

            function HashSet__Clear(e) {
                e.hashMap.clear()
            }

            function HashSet__get_Count(e) {
                let t = 0;
                let r = (0, n.getEnumerator)(e.hashMap.values());
                try {
                    while (r["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = r["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        t = t + e.length | 0
                    }
                } finally {
                    (0, n.disposeSafe)(r)
                }
                return t | 0
            }

            function HashSet__Add_2B595(e, t) {
                const r = HashSet__TryFindIndex_2B595(e, t);
                let n;
                if (r[0]) {
                    if (r[2] > -1) {
                        n = 0
                    } else {
                        n = 1
                    }
                } else {
                    n = 1
                }
                switch (n) {
                    case 0: {
                        return false
                    }
                    case 1: {
                        if (r[0]) {
                            const n = void(0, a.getItemFromDict)(e.hashMap, r[1]).push(t);
                            return true
                        } else {
                            e.hashMap.set(r[1], [t]);
                            return true
                        }
                    }
                }
            }

            function HashSet__Contains_2B595(e, t) {
                const r = HashSet__TryFindIndex_2B595(e, t);
                let n;
                if (r[0]) {
                    if (r[2] > -1) {
                        n = 0
                    } else {
                        n = 1
                    }
                } else {
                    n = 1
                }
                switch (n) {
                    case 0: {
                        return true
                    }
                    case 1: {
                        return false
                    }
                }
            }

            function HashSet__Remove_2B595(e, t) {
                const r = HashSet__TryFindIndex_2B595(e, t);
                let n;
                if (r[0]) {
                    if (r[2] > -1) {
                        n = 0
                    } else {
                        n = 1
                    }
                } else {
                    n = 1
                }
                switch (n) {
                    case 0: {
                        (0, a.getItemFromDict)(e.hashMap, r[1]).splice(r[2], 1);
                        return true
                    }
                    case 1: {
                        return false
                    }
                }
            }
        },
        6468: (e, t) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.compare = compare;
            t.isNumeric = isNumeric;
            t.multiply = multiply;
            t.symbol = void 0;
            t.toExponential = toExponential;
            t.toFixed = toFixed;
            t.toHex = toHex;
            t.toPrecision = toPrecision;
            const r = Symbol("numeric");
            t.symbol = r;

            function isNumeric(e) {
                return typeof e === "number" || (e === null || e === void 0 ? void 0 : e[r])
            }

            function compare(e, t) {
                if (typeof e === "number") {
                    return e < t ? -1 : e > t ? 1 : 0
                } else {
                    return e.CompareTo(t)
                }
            }

            function multiply(e, t) {
                if (typeof e === "number") {
                    return e * t
                } else {
                    return e[r]().multiply(t)
                }
            }

            function toFixed(e, t) {
                if (typeof e === "number") {
                    return e.toFixed(t)
                } else {
                    return e[r]().toFixed(t)
                }
            }

            function toPrecision(e, t) {
                if (typeof e === "number") {
                    return e.toPrecision(t)
                } else {
                    return e[r]().toPrecision(t)
                }
            }

            function toExponential(e, t) {
                if (typeof e === "number") {
                    return e.toExponential(t)
                } else {
                    return e[r]().toExponential(t)
                }
            }

            function toHex(e) {
                if (typeof e === "number") {
                    return (Number(e) >>> 0).toString(16)
                } else {
                    return e[r]().toHex()
                }
            }
        },
        6256: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Some = void 0;
            t.bind = bind;
            t.defaultArg = defaultArg;
            t.defaultArgWith = defaultArgWith;
            t.filter = filter;
            t.flatten = flatten;
            t.map = map;
            t.map2 = map2;
            t.map3 = map3;
            t.ofNullable = ofNullable;
            t.some = some;
            t.toArray = toArray;
            t.toNullable = toNullable;
            t.tryOp = tryOp;
            t.value = value;
            var n = r(4222);
            class Some {
                constructor(e) {
                    this.value = e
                }
                toJSON() {
                    return this.value
                }
                toString() {
                    return String(this.value)
                }
                GetHashCode() {
                    return (0, n.structuralHash)(this.value)
                }
                Equals(e) {
                    if (e == null) {
                        return false
                    } else {
                        return (0, n.equals)(this.value, e instanceof Some ? e.value : e)
                    }
                }
                CompareTo(e) {
                    if (e == null) {
                        return 1
                    } else {
                        return (0, n.compare)(this.value, e instanceof Some ? e.value : e)
                    }
                }
            }
            t.Some = Some;

            function some(e) {
                return e == null || e instanceof Some ? new Some(e) : e
            }

            function value(e) {
                if (e == null) {
                    throw new Error("Option has no value")
                } else {
                    return e instanceof Some ? e.value : e
                }
            }

            function ofNullable(e) {
                return e == null ? undefined : e
            }

            function toNullable(e) {
                return e == null ? null : value(e)
            }

            function flatten(e) {
                return e == null ? undefined : value(e)
            }

            function toArray(e) {
                return e == null ? [] : [value(e)]
            }

            function defaultArg(e, t) {
                return e != null ? value(e) : t
            }

            function defaultArgWith(e, t) {
                return e != null ? value(e) : t()
            }

            function filter(e, t) {
                return t != null ? e(value(t)) ? t : undefined : t
            }

            function map(e, t) {
                return t != null ? some(e(value(t))) : undefined
            }

            function map2(e, t, r) {
                return t != null && r != null ? e(value(t), value(r)) : undefined
            }

            function map3(e, t, r, n) {
                return t != null && r != null && n != null ? e(value(t), value(r), value(n)) : undefined
            }

            function bind(e, t) {
                return t != null ? e(value(t)) : undefined
            }

            function tryOp(e, t) {
                try {
                    return some(e(t))
                } catch (e) {
                    return undefined
                }
            }
        },
        857: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.integralRangeStep = integralRangeStep;
            t.makeRangeStepFunction = makeRangeStepFunction;
            t.rangeBigInt = rangeBigInt;
            t.rangeChar = rangeChar;
            t.rangeDecimal = rangeDecimal;
            t.rangeDouble = rangeDouble;
            t.rangeInt64 = rangeInt64;
            t.rangeUInt64 = rangeUInt64;
            var n = r(4222);
            var i = r(2078);
            var o = r(5361);
            var s = r(5638);
            var a = r(2836);

            function makeRangeStepFunction(e, t, r, i) {
                const o = (0, n.compare)(e, r) | 0;
                if (o === 0) {
                    throw new Error("The step of a range cannot be zero")
                }
                const s = o > 0;
                return r => {
                    const o = (0, n.compare)(r, t) | 0;
                    return (s && o <= 0 ? true : !s && o >= 0) ? [r, i(r, e)] : void 0
                }
            }

            function integralRangeStep(e, t, r, n, o) {
                const s = makeRangeStepFunction(t, r, n, o);
                return (0, i.delay)((() => (0, i.unfold)(s, e)))
            }

            function rangeBigInt(e, t, r) {
                return integralRangeStep(e, t, r, (0, o.fromZero)(), o.op_Addition)
            }

            function rangeDecimal(e, t, r) {
                return integralRangeStep(e, t, r, (0, s.fromParts)(0, 0, 0, false, 0), s.op_Addition)
            }

            function rangeDouble(e, t, r) {
                return integralRangeStep(e, t, r, 0, ((e, t) => e + t))
            }

            function rangeInt64(e, t, r) {
                return integralRangeStep(e, t, r, (0, a.fromBits)(0, 0, false), a.op_Addition)
            }

            function rangeUInt64(e, t, r) {
                return integralRangeStep(e, t, r, (0, a.fromBits)(0, 0, true), a.op_Addition)
            }

            function rangeChar(e, t) {
                const r = t.charCodeAt(0) | 0;
                return (0, i.delay)((() => (0, i.unfold)((e => {
                    if (e <= r) {
                        return [String.fromCharCode(e), e + 1]
                    } else {
                        return void 0
                    }
                }), e.charCodeAt(0))))
            }
        },
        6356: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.TypeInfo = t.MethodInfo = t.GenericParameter = t.CaseInfo = void 0;
            t.anonRecord_type = anonRecord_type;
            t.array_type = array_type;
            t.char_type = t.bool_type = void 0;
            t.class_type = class_type;
            t.createInstance = createInstance;
            t.decimal_type = void 0;
            t.delegate_type = delegate_type;
            t.enum_type = enum_type;
            t.equals = equals;
            t.float64_type = t.float32_type = void 0;
            t.fullName = fullName;
            t.generic_type = generic_type;
            t.getCaseFields = getCaseFields;
            t.getCaseName = getCaseName;
            t.getCaseTag = getCaseTag;
            t.getElementType = getElementType;
            t.getEnumName = getEnumName;
            t.getEnumNames = getEnumNames;
            t.getEnumUnderlyingType = getEnumUnderlyingType;
            t.getEnumValues = getEnumValues;
            t.getFunctionElements = getFunctionElements;
            t.getGenericTypeDefinition = getGenericTypeDefinition;
            t.getGenerics = getGenerics;
            t.getHashCode = getHashCode;
            t.getRecordElements = getRecordElements;
            t.getRecordField = getRecordField;
            t.getRecordFields = getRecordFields;
            t.getTupleElements = getTupleElements;
            t.getTupleField = getTupleField;
            t.getTupleFields = getTupleFields;
            t.getUnionCaseFields = getUnionCaseFields;
            t.getUnionCases = getUnionCases;
            t.getUnionFields = getUnionFields;
            t.getValue = getValue;
            t.int8_type = t.int32_type = t.int16_type = void 0;
            t.isArray = isArray;
            t.isEnum = isEnum;
            t.isEnumDefined = isEnumDefined;
            t.isFunction = isFunction;
            t.isGenericParameter = isGenericParameter;
            t.isGenericType = isGenericType;
            t.isInstanceOfType = isInstanceOfType;
            t.isRecord = isRecord;
            t.isSubclassOf = isSubclassOf;
            t.isTuple = isTuple;
            t.isUnion = isUnion;
            t.lambda_type = lambda_type;
            t.list_type = list_type;
            t.makeGenericType = makeGenericType;
            t.makeRecord = makeRecord;
            t.makeTuple = makeTuple;
            t.makeUnion = makeUnion;
            t.measure_type = measure_type;
            t.name = name;
            t.namespace = namespace;
            t.obj_type = void 0;
            t.option_type = option_type;
            t.parseEnum = parseEnum;
            t.record_type = record_type;
            t.string_type = void 0;
            t.tryParseEnum = tryParseEnum;
            t.tuple_type = tuple_type;
            t.uint8_type = t.uint32_type = t.uint16_type = void 0;
            t.union_type = union_type;
            t.unit_type = void 0;
            var n = r(6638);
            var i = r(4222);
            var o = _interopRequireDefault(r(5638));
            var s = r(2836);

            function _interopRequireDefault(e) {
                return e && e.__esModule ? e : {
                    default: e
                }
            }
            class CaseInfo {
                constructor(e, t, r, n) {
                    this.declaringType = e;
                    this.tag = t;
                    this.name = r;
                    this.fields = n
                }
            }
            t.CaseInfo = CaseInfo;
            class MethodInfo {
                constructor(e, t, r) {
                    this.name = e;
                    this.parameters = t;
                    this.returnType = r
                }
            }
            t.MethodInfo = MethodInfo;
            class TypeInfo {
                constructor(e, t, r, n, i, o, s) {
                    this.fullname = e;
                    this.generics = t;
                    this.construct = r;
                    this.parent = n;
                    this.fields = i;
                    this.cases = o;
                    this.enumCases = s
                }
                toString() {
                    return fullName(this)
                }
                GetHashCode() {
                    return getHashCode(this)
                }
                Equals(e) {
                    return equals(this, e)
                }
            }
            t.TypeInfo = TypeInfo;
            class GenericParameter extends TypeInfo {
                constructor(e) {
                    super(e)
                }
            }
            t.GenericParameter = GenericParameter;

            function getGenerics(e) {
                return e.generics != null ? e.generics : []
            }

            function getHashCode(e) {
                const t = (0, i.stringHash)(e.fullname);
                const r = getGenerics(e).map(getHashCode);
                return (0, i.combineHashCodes)([t, ...r])
            }

            function equals(e, t) {
                if (e.fullname === "") {
                    return t.fullname === "" && (0, i.equalArraysWith)(getRecordElements(e), getRecordElements(t), (([e, t], [r, n]) => e === r && equals(t, n)))
                } else {
                    return e.fullname === t.fullname && (0, i.equalArraysWith)(getGenerics(e), getGenerics(t), equals)
                }
            }

            function class_type(e, t, r, n) {
                return new TypeInfo(e, t, r, n)
            }

            function record_type(e, t, r, n) {
                return new TypeInfo(e, t, r, undefined, n)
            }

            function anonRecord_type(...e) {
                return new TypeInfo("", undefined, undefined, undefined, (() => e))
            }

            function union_type(e, t, r, n) {
                const i = new TypeInfo(e, t, r, undefined, undefined, (() => {
                    const e = r.prototype.cases();
                    return n().map(((t, r) => new CaseInfo(i, r, e[r], t)))
                }));
                return i
            }

            function tuple_type(...e) {
                return new TypeInfo("System.Tuple`" + e.length, e)
            }

            function delegate_type(...e) {
                return new TypeInfo("System.Func`" + e.length, e)
            }

            function lambda_type(e, t) {
                return new TypeInfo("Microsoft.FSharp.Core.FSharpFunc`2", [e, t])
            }

            function option_type(e) {
                return new TypeInfo("Microsoft.FSharp.Core.FSharpOption`1", [e])
            }

            function list_type(e) {
                return new TypeInfo("Microsoft.FSharp.Collections.FSharpList`1", [e])
            }

            function array_type(e) {
                return new TypeInfo("[]", [e])
            }

            function enum_type(e, t, r) {
                return new TypeInfo(e, [t], undefined, undefined, undefined, undefined, r)
            }

            function measure_type(e) {
                return new TypeInfo(e)
            }

            function generic_type(e) {
                return new GenericParameter(e)
            }
            const a = new TypeInfo("System.Object");
            t.obj_type = a;
            const l = new TypeInfo("Microsoft.FSharp.Core.Unit");
            t.unit_type = l;
            const _ = new TypeInfo("System.Char");
            t.char_type = _;
            const u = new TypeInfo("System.String");
            t.string_type = u;
            const c = new TypeInfo("System.Boolean");
            t.bool_type = c;
            const d = new TypeInfo("System.SByte");
            t.int8_type = d;
            const p = new TypeInfo("System.Byte");
            t.uint8_type = p;
            const f = new TypeInfo("System.Int16");
            t.int16_type = f;
            const h = new TypeInfo("System.UInt16");
            t.uint16_type = h;
            const g = new TypeInfo("System.Int32");
            t.int32_type = g;
            const m = new TypeInfo("System.UInt32");
            t.uint32_type = m;
            const y = new TypeInfo("System.Single");
            t.float32_type = y;
            const S = new TypeInfo("System.Double");
            t.float64_type = S;
            const T = new TypeInfo("System.Decimal");
            t.decimal_type = T;

            function name(e) {
                if (Array.isArray(e)) {
                    return e[0]
                } else if (e instanceof TypeInfo) {
                    const t = getElementType(e);
                    if (t != null) {
                        return name(t) + "[]"
                    } else {
                        const t = e.fullname.lastIndexOf(".");
                        return t === -1 ? e.fullname : e.fullname.substr(t + 1)
                    }
                } else {
                    return e.name
                }
            }

            function fullName(e) {
                const t = getElementType(e);
                if (t != null) {
                    return fullName(t) + "[]"
                } else if (e.generics == null || e.generics.length === 0) {
                    return e.fullname
                } else {
                    return e.fullname + "[" + e.generics.map((e => fullName(e))).join(",") + "]"
                }
            }

            function namespace(e) {
                const t = getElementType(e);
                if (t != null) {
                    return namespace(t)
                } else {
                    const t = e.fullname.lastIndexOf(".");
                    return t === -1 ? "" : e.fullname.substr(0, t)
                }
            }

            function isArray(e) {
                return getElementType(e) != null
            }

            function getElementType(e) {
                var t;
                return e.fullname === "[]" && ((t = e.generics) === null || t === void 0 ? void 0 : t.length) === 1 ? e.generics[0] : undefined
            }

            function isGenericType(e) {
                return e.generics != null && e.generics.length > 0
            }

            function isGenericParameter(e) {
                return e instanceof GenericParameter
            }

            function isEnum(e) {
                return e.enumCases != null && e.enumCases.length > 0
            }

            function isSubclassOf(e, t) {
                return t.fullname === a.fullname || e.parent != null && (e.parent.Equals(t) || isSubclassOf(e.parent, t))
            }

            function isErasedToNumber(e) {
                return isEnum(e) || [d.fullname, p.fullname, f.fullname, h.fullname, g.fullname, m.fullname, y.fullname, S.fullname].includes(e.fullname)
            }

            function isInstanceOfType(e, t) {
                if (e.fullname === a.fullname) return true;
                switch (typeof t) {
                    case "boolean":
                        return e.fullname === c.fullname;
                    case "string":
                        return e.fullname === u.fullname;
                    case "function":
                        return isFunction(e);
                    case "number":
                        return isErasedToNumber(e);
                    default:
                        return e.construct != null && t instanceof e.construct
                }
            }

            function getGenericTypeDefinition(e) {
                return e.generics == null ? e : new TypeInfo(e.fullname, e.generics.map((() => a)))
            }

            function getEnumUnderlyingType(e) {
                var t;
                return (t = e.generics) === null || t === void 0 ? void 0 : t[0]
            }

            function getEnumValues(e) {
                if (isEnum(e) && e.enumCases != null) {
                    return e.enumCases.map((e => e[1]))
                } else {
                    throw new Error(`${e.fullname} is not an enum type`)
                }
            }

            function getEnumNames(e) {
                if (isEnum(e) && e.enumCases != null) {
                    return e.enumCases.map((e => e[0]))
                } else {
                    throw new Error(`${e.fullname} is not an enum type`)
                }
            }

            function getEnumCase(e, t) {
                if (e.enumCases != null) {
                    if (typeof t === "string") {
                        for (const r of e.enumCases) {
                            if (r[0] === t) {
                                return r
                            }
                        }
                        throw new Error(`'${t}' was not found in ${e.fullname}`)
                    } else {
                        for (const r of e.enumCases) {
                            if (r[1] === t) {
                                return r
                            }
                        }
                        return ["", t]
                    }
                } else {
                    throw new Error(`${e.fullname} is not an enum type`)
                }
            }

            function parseEnum(e, t) {
                const r = parseInt(t, 10);
                return getEnumCase(e, isNaN(r) ? t : r)[1]
            }

            function tryParseEnum(e, t, r) {
                try {
                    r.contents = parseEnum(e, t);
                    return true
                } catch (e) {
                    return false
                }
            }

            function getEnumName(e, t) {
                return getEnumCase(e, t)[0]
            }

            function isEnumDefined(e, t) {
                try {
                    const r = getEnumCase(e, t);
                    return r[0] != null && r[0] !== ""
                } catch (e) {}
                return false
            }

            function getUnionCases(e) {
                if (e.cases != null) {
                    return e.cases()
                } else {
                    throw new Error(`${e.fullname} is not an F# union type`)
                }
            }

            function getRecordElements(e) {
                if (e.fields != null) {
                    return e.fields()
                } else {
                    throw new Error(`${e.fullname} is not an F# record type`)
                }
            }

            function getTupleElements(e) {
                if (isTuple(e) && e.generics != null) {
                    return e.generics
                } else {
                    throw new Error(`${e.fullname} is not a tuple type`)
                }
            }

            function getFunctionElements(e) {
                if (isFunction(e) && e.generics != null) {
                    const t = e.generics;
                    return [t[0], t[1]]
                } else {
                    throw new Error(`${e.fullname} is not an F# function type`)
                }
            }

            function isUnion(e) {
                return e instanceof TypeInfo ? e.cases != null : e instanceof n.Union
            }

            function isRecord(e) {
                return e instanceof TypeInfo ? e.fields != null : e instanceof n.Record
            }

            function isTuple(e) {
                return e.fullname.startsWith("System.Tuple")
            }

            function isFunction(e) {
                return e.fullname === "Microsoft.FSharp.Core.FSharpFunc`2"
            }

            function getUnionFields(e, t) {
                const r = getUnionCases(t);
                const n = r[e.tag];
                if (n == null) {
                    throw new Error(`Cannot find case ${e.name} in union type`)
                }
                return [n, e.fields]
            }

            function getUnionCaseFields(e) {
                return e.fields == null ? [] : e.fields
            }

            function getRecordFields(e) {
                return Object.keys(e).map((t => e[t]))
            }

            function getRecordField(e, t) {
                return e[t[0]]
            }

            function getTupleFields(e) {
                return e
            }

            function getTupleField(e, t) {
                return e[t]
            }

            function makeUnion(e, t) {
                const r = (e.fields || []).length;
                if (t.length !== r) {
                    throw new Error(`Expected an array of length ${r} but got ${t.length}`)
                }
                return e.declaringType.construct != null ? new e.declaringType.construct(e.tag, ...t) : {}
            }

            function makeRecord(e, t) {
                const r = getRecordElements(e);
                if (r.length !== t.length) {
                    throw new Error(`Expected an array of length ${r.length} but got ${t.length}`)
                }
                return e.construct != null ? new e.construct(...t) : r.reduce(((e, [r, n], i) => {
                    e[r] = t[i];
                    return e
                }), {})
            }

            function makeTuple(e, t) {
                return e
            }

            function makeGenericType(e, t) {
                return new TypeInfo(e.fullname, t, e.construct, e.parent, e.fields, e.cases)
            }

            function createInstance(e, t) {
                if (typeof e.construct === "function") {
                    return new e.construct(...t !== null && t !== void 0 ? t : [])
                } else if (isErasedToNumber(e)) {
                    return 0
                } else {
                    switch (e.fullname) {
                        case a.fullname:
                            return {};
                        case c.fullname:
                            return false;
                        case "System.Int64":
                        case "System.UInt64":
                            return (0, s.fromInt)(0);
                        case T.fullname:
                            return new o.default(0);
                        case _.fullname:
                            return null;
                        default:
                            throw new Error(`Cannot access constructor of ${e.fullname}`)
                    }
                }
            }

            function getValue(e, t) {
                return t[e[0]]
            }

            function assertUnion(e) {
                if (!(e instanceof n.Union)) {
                    throw new Error(`Value is not an F# union type`)
                }
            }

            function getCaseTag(e) {
                assertUnion(e);
                return e.tag
            }

            function getCaseName(e) {
                assertUnion(e);
                return e.cases()[e.tag]
            }

            function getCaseFields(e) {
                assertUnion(e);
                return e.fields
            }
        },
        3493: (e, t) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.create = create;
            t.escape = escape;
            t.isMatch = isMatch;
            t.match = match;
            t.matches = matches;
            t.options = options;
            t.replace = replace;
            t.split = split;
            t.unescape = unescape;

            function create(e, t = 0) {
                if ((t & ~(1 ^ 2 ^ 16 ^ 256)) !== 0) {
                    throw new Error("RegexOptions only supports: IgnoreCase, Multiline, Singleline and ECMAScript")
                }
                let r = "g";
                r += t & 1 ? "i" : "";
                r += t & 2 ? "m" : "";
                r += t & 16 ? "s" : "";
                return new RegExp(e, r)
            }

            function escape(e) {
                return e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&")
            }

            function unescape(e) {
                return e.replace(/\\([\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|])/g, "$1")
            }

            function isMatch(e, t, r = 0) {
                e.lastIndex = r;
                return e.test(t)
            }

            function match(e, t, r = 0) {
                e.lastIndex = r;
                return e.exec(t)
            }

            function matches(e, t, r = 0) {
                e.lastIndex = r;
                if (!e.global) {
                    throw new Error("Non-global RegExp")
                }
                let n = e.exec(t);
                const i = [];
                while (n !== null) {
                    i.push(n);
                    n = e.exec(t)
                }
                return i
            }

            function options(e) {
                let t = 256;
                t |= e.ignoreCase ? 1 : 0;
                t |= e.multiline ? 2 : 0;
                return t
            }

            function replace(e, t, r, n, i = 0) {
                function replacer() {
                    let e = arguments[0];
                    if (n) {
                        n--;
                        const t = [];
                        const i = arguments.length;
                        const o = typeof arguments[i - 1] !== "string";
                        let s = o ? i - 3 : i - 2;
                        for (let e = 0; e < s; e++) {
                            t.push(arguments[e])
                        }
                        t.index = arguments[s++];
                        t.input = arguments[s++];
                        if (o) {
                            t.groups = arguments[s]
                        }
                        e = r(t)
                    }
                    return e
                }
                if (typeof e === "string") {
                    const r = e;
                    e = create(t, n !== null && n !== void 0 ? n : 0);
                    t = r;
                    n = undefined
                }
                if (typeof r === "function") {
                    n = n == null ? -1 : n;
                    return t.substring(0, i) + t.substring(i).replace(e, replacer)
                } else {
                    r = r.replace(/\$0/g, (e => "$&")).replace(/\${([^}]+)}/g, "$<$1>");
                    if (n != null) {
                        let o;
                        const s = t.substring(i);
                        const a = matches(e, s);
                        const l = matches.length > n ? (o = a[n - 1], s.substring(0, o.index + o[0].length)) : s;
                        return t.substring(0, i) + l.replace(e, r) + t.substring(i + l.length)
                    } else {
                        return t.replace(e, r)
                    }
                }
            }

            function split(e, t, r, n = 0) {
                if (typeof e === "string") {
                    const n = e;
                    e = create(t, r !== null && r !== void 0 ? r : 0);
                    t = n;
                    r = undefined
                }
                t = t.substring(n);
                return t.split(e, r)
            }
        },
        2078: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CachedSeq$1 = void 0;
            t.CachedSeq$1$reflection = CachedSeq$1$reflection;
            t.CachedSeq$1_$ctor_Z7A8347D4 = CachedSeq$1_$ctor_Z7A8347D4;
            t.CachedSeq$1__Clear = CachedSeq$1__Clear;
            t.Enumerator_FromFunctions$1 = void 0;
            t.Enumerator_FromFunctions$1$reflection = Enumerator_FromFunctions$1$reflection;
            t.Enumerator_FromFunctions$1_$ctor_58C54629 = Enumerator_FromFunctions$1_$ctor_58C54629;
            t.Enumerator_Seq = void 0;
            t.Enumerator_Seq$reflection = Enumerator_Seq$reflection;
            t.Enumerator_Seq_$ctor_673A07F2 = Enumerator_Seq_$ctor_673A07F2;
            t.Enumerator_alreadyFinished = Enumerator_alreadyFinished;
            t.Enumerator_cast = Enumerator_cast;
            t.Enumerator_concat = Enumerator_concat;
            t.Enumerator_enumerateThenFinally = Enumerator_enumerateThenFinally;
            t.Enumerator_generateWhileSome = Enumerator_generateWhileSome;
            t.Enumerator_noReset = Enumerator_noReset;
            t.Enumerator_notStarted = Enumerator_notStarted;
            t.Enumerator_unfold = Enumerator_unfold;
            t.SR_resetNotSupported = t.SR_notEnoughElements = t.SR_keyNotFoundAlt = t.SR_inputSequenceTooLong = t.SR_inputSequenceEmpty = t.SR_enumerationNotStarted = t.SR_enumerationAlreadyFinished = void 0;
            t.allPairs = allPairs;
            t.append = append;
            t.average = average;
            t.averageBy = averageBy;
            t.cache = cache;
            t.cast = cast;
            t.checkNonNull = checkNonNull;
            t.choose = choose;
            t.chunkBySize = chunkBySize;
            t.collect = collect;
            t.compareWith = compareWith;
            t.concat = concat;
            t.contains = contains;
            t.delay = delay;
            t.empty = empty;
            t.enumerateFromFunctions = enumerateFromFunctions;
            t.enumerateThenFinally = enumerateThenFinally;
            t.enumerateUsing = enumerateUsing;
            t.enumerateWhile = enumerateWhile;
            t.exactlyOne = exactlyOne;
            t.exists = exists;
            t.exists2 = exists2;
            t.filter = filter;
            t.find = find;
            t.findBack = findBack;
            t.findIndex = findIndex;
            t.findIndexBack = findIndexBack;
            t.fold = fold;
            t.fold2 = fold2;
            t.foldBack = foldBack;
            t.foldBack2 = foldBack2;
            t.forAll = forAll;
            t.forAll2 = forAll2;
            t.generate = generate;
            t.generateIndexed = generateIndexed;
            t.head = head;
            t.indexNotFound = indexNotFound;
            t.indexed = indexed;
            t.initialize = initialize;
            t.initializeInfinite = initializeInfinite;
            t.insertAt = insertAt;
            t.insertManyAt = insertManyAt;
            t.isEmpty = isEmpty;
            t.item = item;
            t.iterate = iterate;
            t.iterate2 = iterate2;
            t.iterateIndexed = iterateIndexed;
            t.iterateIndexed2 = iterateIndexed2;
            t.last = last;
            t.length = length;
            t.map = map;
            t.map2 = map2;
            t.map3 = map3;
            t.mapFold = mapFold;
            t.mapFoldBack = mapFoldBack;
            t.mapIndexed = mapIndexed;
            t.mapIndexed2 = mapIndexed2;
            t.max = max;
            t.maxBy = maxBy;
            t.min = min;
            t.minBy = minBy;
            t.mkSeq = mkSeq;
            t.ofArray = ofArray;
            t.ofList = ofList;
            t.ofSeq = ofSeq;
            t.pairwise = pairwise;
            t.permute = permute;
            t.pick = pick;
            t.readOnly = readOnly;
            t.reduce = reduce;
            t.reduceBack = reduceBack;
            t.removeAt = removeAt;
            t.removeManyAt = removeManyAt;
            t.replicate = replicate;
            t.reverse = reverse;
            t.scan = scan;
            t.scanBack = scanBack;
            t.singleton = singleton;
            t.skip = skip;
            t.skipWhile = skipWhile;
            t.sort = sort;
            t.sortBy = sortBy;
            t.sortByDescending = sortByDescending;
            t.sortDescending = sortDescending;
            t.sortWith = sortWith;
            t.splitInto = splitInto;
            t.sum = sum;
            t.sumBy = sumBy;
            t.tail = tail;
            t.take = take;
            t.takeWhile = takeWhile;
            t.toArray = toArray;
            t.toList = toList;
            t.transpose = transpose;
            t.truncate = truncate;
            t.tryExactlyOne = tryExactlyOne;
            t.tryFind = tryFind;
            t.tryFindBack = tryFindBack;
            t.tryFindIndex = tryFindIndex;
            t.tryFindIndexBack = tryFindIndexBack;
            t.tryHead = tryHead;
            t.tryItem = tryItem;
            t.tryLast = tryLast;
            t.tryPick = tryPick;
            t.unfold = unfold;
            t.updateAt = updateAt;
            t.where = where;
            t.windowed = windowed;
            t.zip = zip;
            t.zip3 = zip3;
            var n = r(4222);
            var i = r(6638);
            var o = r(6356);
            var s = r(6256);
            var a = r(3093);
            var l = r(9054);
            var _ = r(5359);
            var u = r(1103);
            const c = "Enumeration already finished.";
            t.SR_enumerationAlreadyFinished = c;
            const d = "Enumeration has not started. Call MoveNext.";
            t.SR_enumerationNotStarted = d;
            const p = "The input sequence was empty.";
            t.SR_inputSequenceEmpty = p;
            const f = "The input sequence contains more than one element.";
            t.SR_inputSequenceTooLong = f;
            const h = "An index satisfying the predicate was not found in the collection.";
            t.SR_keyNotFoundAlt = h;
            const g = "The input sequence has an insufficient number of elements.";
            t.SR_notEnoughElements = g;
            const m = "Reset is not supported on this enumerator.";
            t.SR_resetNotSupported = m;

            function Enumerator_noReset() {
                throw new Error(m)
            }

            function Enumerator_notStarted() {
                throw new Error(d)
            }

            function Enumerator_alreadyFinished() {
                throw new Error(c)
            }
            class Enumerator_Seq {
                constructor(e) {
                    this.f = e
                }
                toString() {
                    const e = this;
                    const t = 4;
                    let r = 0;
                    let o = "seq [";
                    const s = (0, n.getEnumerator)(e);
                    try {
                        while (r < t && s["System.Collections.IEnumerator.MoveNext"]()) {
                            if (r > 0) {
                                o = o + "; "
                            }
                            o = o + (0, i.toString)(s["System.Collections.Generic.IEnumerator`1.get_Current"]());
                            r = r + 1 | 0
                        }
                        if (r === t) {
                            o = o + "; ..."
                        }
                        return o + "]"
                    } finally {
                        (0, n.disposeSafe)(s)
                    }
                }
                GetEnumerator() {
                    const e = this;
                    return e.f()
                } [Symbol.iterator]() {
                    return (0, n.toIterator)(this.GetEnumerator())
                } ["System.Collections.IEnumerable.GetEnumerator"]() {
                    const e = this;
                    return e.f()
                }
            }
            t.Enumerator_Seq = Enumerator_Seq;

            function Enumerator_Seq$reflection(e) {
                return (0, o.class_type)("SeqModule.Enumerator.Seq", [e], Enumerator_Seq)
            }

            function Enumerator_Seq_$ctor_673A07F2(e) {
                return new Enumerator_Seq(e)
            }
            class Enumerator_FromFunctions$1 {
                constructor(e, t, r) {
                    this.current = e;
                    this.next = t;
                    this.dispose = r
                } ["System.Collections.Generic.IEnumerator`1.get_Current"]() {
                    const e = this;
                    return e.current()
                } ["System.Collections.IEnumerator.get_Current"]() {
                    const e = this;
                    return e.current()
                } ["System.Collections.IEnumerator.MoveNext"]() {
                    const e = this;
                    return e.next()
                } ["System.Collections.IEnumerator.Reset"]() {
                    Enumerator_noReset()
                }
                Dispose() {
                    const e = this;
                    e.dispose()
                }
            }
            t.Enumerator_FromFunctions$1 = Enumerator_FromFunctions$1;

            function Enumerator_FromFunctions$1$reflection(e) {
                return (0, o.class_type)("SeqModule.Enumerator.FromFunctions`1", [e], Enumerator_FromFunctions$1)
            }

            function Enumerator_FromFunctions$1_$ctor_58C54629(e, t, r) {
                return new Enumerator_FromFunctions$1(e, t, r)
            }

            function Enumerator_cast(e) {
                return Enumerator_FromFunctions$1_$ctor_58C54629((() => e["System.Collections.IEnumerator.get_Current"]()), (() => e["System.Collections.IEnumerator.MoveNext"]()), (() => {
                    if ((0, n.isDisposable)(e)) {
                        (0, n.disposeSafe)(e)
                    }
                }))
            }

            function Enumerator_concat(e) {
                let t = void 0;
                let r = void 0;
                let i = false;
                let o = false;
                let a = void 0;
                const finish = () => {
                    o = true;
                    if (r != null) {
                        const e = r;
                        try {
                            (0, n.disposeSafe)(e)
                        } finally {
                            r = void 0
                        }
                    }
                    if (t != null) {
                        const e = t;
                        try {
                            (0, n.disposeSafe)(e)
                        } finally {
                            t = void 0
                        }
                    }
                };
                return Enumerator_FromFunctions$1_$ctor_58C54629((() => {
                    if (!i) {
                        Enumerator_notStarted()
                    } else if (o) {
                        Enumerator_alreadyFinished()
                    }
                    if (a != null) {
                        return (0, s.value)(a)
                    } else {
                        return Enumerator_alreadyFinished()
                    }
                }), (() => {
                    let l;
                    if (!i) {
                        i = true
                    }
                    if (o) {
                        return false
                    } else {
                        let i = void 0;
                        while (i == null) {
                            const o = [t, r];
                            if (o[0] != null) {
                                if (o[1] != null) {
                                    const e = o[1];
                                    if (e["System.Collections.IEnumerator.MoveNext"]()) {
                                        a = (0, s.some)(e["System.Collections.Generic.IEnumerator`1.get_Current"]());
                                        i = true
                                    } else {
                                        try {
                                            (0, n.disposeSafe)(e)
                                        } finally {
                                            r = void 0
                                        }
                                    }
                                } else {
                                    const e = o[0];
                                    if (e["System.Collections.IEnumerator.MoveNext"]()) {
                                        const t = e["System.Collections.Generic.IEnumerator`1.get_Current"]();
                                        r = (l = t, (0, n.getEnumerator)(l))
                                    } else {
                                        finish();
                                        i = false
                                    }
                                }
                            } else {
                                t = (0, n.getEnumerator)(e)
                            }
                        }
                        return (0, s.value)(i)
                    }
                }), (() => {
                    if (!o) {
                        finish()
                    }
                }))
            }

            function Enumerator_enumerateThenFinally(e, t) {
                return Enumerator_FromFunctions$1_$ctor_58C54629((() => t["System.Collections.Generic.IEnumerator`1.get_Current"]()), (() => t["System.Collections.IEnumerator.MoveNext"]()), (() => {
                    try {
                        (0, n.disposeSafe)(t)
                    } finally {
                        e()
                    }
                }))
            }

            function Enumerator_generateWhileSome(e, t, r) {
                let n = false;
                let i = void 0;
                let o = (0, s.some)(e());
                const dispose = () => {
                    if (o != null) {
                        const e = (0, s.value)(o);
                        try {
                            r(e)
                        } finally {
                            o = void 0
                        }
                    }
                };
                const finish = () => {
                    try {
                        dispose()
                    } finally {
                        i = void 0
                    }
                };
                return Enumerator_FromFunctions$1_$ctor_58C54629((() => {
                    if (!n) {
                        Enumerator_notStarted()
                    }
                    if (i != null) {
                        return (0, s.value)(i)
                    } else {
                        return Enumerator_alreadyFinished()
                    }
                }), (() => {
                    if (!n) {
                        n = true
                    }
                    if (o != null) {
                        const e = (0, s.value)(o);
                        let r;
                        try {
                            r = t(e)
                        } catch (e) {
                            finish();
                            throw e
                        }
                        if (r != null) {
                            i = r;
                            return true
                        } else {
                            finish();
                            return false
                        }
                    } else {
                        return false
                    }
                }), dispose)
            }

            function Enumerator_unfold(e, t) {
                let r = void 0;
                let n = t;
                return Enumerator_FromFunctions$1_$ctor_58C54629((() => {
                    if (r != null) {
                        const e = r[0];
                        const t = r[1];
                        return e
                    } else {
                        return Enumerator_notStarted()
                    }
                }), (() => {
                    r = e(n);
                    if (r != null) {
                        const e = r[0];
                        const t = r[1];
                        n = t;
                        return true
                    } else {
                        return false
                    }
                }), (() => {}))
            }

            function indexNotFound() {
                throw new Error(h)
            }

            function checkNonNull(e, t) {
                if (t == null) {
                    (0, a.Operators_NullArg)(e)
                }
            }

            function mkSeq(e) {
                return Enumerator_Seq_$ctor_673A07F2(e)
            }

            function ofSeq(e) {
                checkNonNull("source", e);
                return (0, n.getEnumerator)(e)
            }

            function delay(e) {
                return mkSeq((() => (0, n.getEnumerator)(e())))
            }

            function concat(e) {
                return mkSeq((() => Enumerator_concat(e)))
            }

            function unfold(e, t) {
                return mkSeq((() => Enumerator_unfold(e, t)))
            }

            function empty() {
                return delay((() => new Array(0)))
            }

            function singleton(e) {
                return delay((() => (0, l.singleton)(e)))
            }

            function ofArray(e) {
                return e
            }

            function toArray(e) {
                if (e instanceof _.FSharpList) {
                    return (0, _.toArray)(e)
                } else {
                    return Array.from(e)
                }
            }

            function ofList(e) {
                return e
            }

            function toList(e) {
                if ((0, n.isArrayLike)(e)) {
                    return (0, _.ofArray)(e)
                } else if (e instanceof _.FSharpList) {
                    return e
                } else {
                    return (0, _.ofSeq)(e)
                }
            }

            function generate(e, t, r) {
                return mkSeq((() => Enumerator_generateWhileSome(e, t, r)))
            }

            function generateIndexed(e, t, r) {
                return mkSeq((() => {
                    let n = -1;
                    return Enumerator_generateWhileSome(e, (e => {
                        n = n + 1 | 0;
                        return t(n, e)
                    }), r)
                }))
            }

            function append(e, t) {
                return concat([e, t])
            }

            function cast(e) {
                return mkSeq((() => {
                    checkNonNull("source", e);
                    return Enumerator_cast((0, n.getEnumerator)(e))
                }))
            }

            function choose(e, t) {
                return generate((() => ofSeq(t)), (t => {
                    let r = void 0;
                    while (r == null && t["System.Collections.IEnumerator.MoveNext"]()) {
                        r = e(t["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    }
                    return r
                }), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function compareWith(e, t, r) {
                const i = ofSeq(t);
                try {
                    const t = ofSeq(r);
                    try {
                        let r = 0;
                        let o = i["System.Collections.IEnumerator.MoveNext"]();
                        let s = t["System.Collections.IEnumerator.MoveNext"]();
                        while (r === 0 && o && s) {
                            r = e(i["System.Collections.Generic.IEnumerator`1.get_Current"](), t["System.Collections.Generic.IEnumerator`1.get_Current"]()) | 0;
                            if (r === 0) {
                                o = i["System.Collections.IEnumerator.MoveNext"]();
                                s = t["System.Collections.IEnumerator.MoveNext"]()
                            }
                        }
                        return (r !== 0 ? r : o ? 1 : s ? -1 : 0) | 0
                    } finally {
                        (0, n.disposeSafe)(t)
                    }
                } finally {
                    (0, n.disposeSafe)(i)
                }
            }

            function contains(e, t, r) {
                const i = ofSeq(t);
                try {
                    let t = false;
                    while (!t && i["System.Collections.IEnumerator.MoveNext"]()) {
                        t = r.Equals(e, i["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    }
                    return t
                } finally {
                    (0, n.disposeSafe)(i)
                }
            }

            function enumerateFromFunctions(e, t, r) {
                return generate(e, (e => t(e) ? (0, s.some)(r(e)) : void 0), (e => {
                    const t = e;
                    if ((0, n.isDisposable)(t)) {
                        (0, n.disposeSafe)(t)
                    }
                }))
            }

            function enumerateThenFinally(e, t) {
                const r = t;
                return mkSeq((() => {
                    try {
                        return Enumerator_enumerateThenFinally(r, ofSeq(e))
                    } catch (e) {
                        r();
                        throw e
                    }
                }))
            }

            function enumerateUsing(e, t) {
                const compensation = () => {
                    if ((0, n.equals)(e, null)) {} else {
                        let t = e;
                        (0, n.disposeSafe)(t)
                    }
                };
                return mkSeq((() => {
                    try {
                        return Enumerator_enumerateThenFinally(compensation, ofSeq(t(e)))
                    } catch (e) {
                        compensation();
                        throw e
                    }
                }))
            }

            function enumerateWhile(e, t) {
                return concat(unfold((r => e() ? [t, r + 1] : void 0), 0))
            }

            function filter(e, t) {
                return choose((t => {
                    if (e(t)) {
                        return (0, s.some)(t)
                    } else {
                        return void 0
                    }
                }), t)
            }

            function exists(e, t) {
                const r = ofSeq(t);
                try {
                    let t = false;
                    while (!t && r["System.Collections.IEnumerator.MoveNext"]()) {
                        t = e(r["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    }
                    return t
                } finally {
                    (0, n.disposeSafe)(r)
                }
            }

            function exists2(e, t, r) {
                const i = ofSeq(t);
                try {
                    const t = ofSeq(r);
                    try {
                        let r = false;
                        while (!r && i["System.Collections.IEnumerator.MoveNext"]() && t["System.Collections.IEnumerator.MoveNext"]()) {
                            r = e(i["System.Collections.Generic.IEnumerator`1.get_Current"](), t["System.Collections.Generic.IEnumerator`1.get_Current"]())
                        }
                        return r
                    } finally {
                        (0, n.disposeSafe)(t)
                    }
                } finally {
                    (0, n.disposeSafe)(i)
                }
            }

            function exactlyOne(e) {
                const t = ofSeq(e);
                try {
                    if (t["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = t["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        if (t["System.Collections.IEnumerator.MoveNext"]()) {
                            throw new Error(f + "\\nParameter name: " + "source")
                        } else {
                            return e
                        }
                    } else {
                        throw new Error(p + "\\nParameter name: " + "source")
                    }
                } finally {
                    (0, n.disposeSafe)(t)
                }
            }

            function tryExactlyOne(e) {
                const t = ofSeq(e);
                try {
                    if (t["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = t["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        return t["System.Collections.IEnumerator.MoveNext"]() ? void 0 : (0, s.some)(e)
                    } else {
                        return void 0
                    }
                } finally {
                    (0, n.disposeSafe)(t)
                }
            }

            function tryFind(e, t) {
                const r = ofSeq(t);
                try {
                    let t = void 0;
                    while (t == null && r["System.Collections.IEnumerator.MoveNext"]()) {
                        const n = r["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        if (e(n)) {
                            t = (0, s.some)(n)
                        }
                    }
                    return t
                } finally {
                    (0, n.disposeSafe)(r)
                }
            }

            function find(e, t) {
                const r = tryFind(e, t);
                if (r == null) {
                    return indexNotFound()
                } else {
                    return (0, s.value)(r)
                }
            }

            function tryFindBack(e, t) {
                return (0, l.tryFindBack)(e, toArray(t))
            }

            function findBack(e, t) {
                const r = tryFindBack(e, t);
                if (r == null) {
                    return indexNotFound()
                } else {
                    return (0, s.value)(r)
                }
            }

            function tryFindIndex(e, t) {
                const r = ofSeq(t);
                try {
                    const loop = t => {
                        e: while (true) {
                            const n = t;
                            if (r["System.Collections.IEnumerator.MoveNext"]()) {
                                if (e(r["System.Collections.Generic.IEnumerator`1.get_Current"]())) {
                                    return n
                                } else {
                                    t = n + 1;
                                    continue e
                                }
                            } else {
                                return void 0
                            }
                            break
                        }
                    };
                    return loop(0)
                } finally {
                    (0, n.disposeSafe)(r)
                }
            }

            function findIndex(e, t) {
                const r = tryFindIndex(e, t);
                if (r == null) {
                    return indexNotFound() | 0
                } else {
                    return r | 0
                }
            }

            function tryFindIndexBack(e, t) {
                return (0, l.tryFindIndexBack)(e, toArray(t))
            }

            function findIndexBack(e, t) {
                const r = tryFindIndexBack(e, t);
                if (r == null) {
                    return indexNotFound() | 0
                } else {
                    return r | 0
                }
            }

            function fold(e, t, r) {
                const i = ofSeq(r);
                try {
                    let r = t;
                    while (i["System.Collections.IEnumerator.MoveNext"]()) {
                        r = e(r, i["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    }
                    return r
                } finally {
                    (0, n.disposeSafe)(i)
                }
            }

            function foldBack(e, t, r) {
                return (0, l.foldBack)(e, toArray(t), r)
            }

            function fold2(e, t, r, i) {
                const o = ofSeq(r);
                try {
                    const r = ofSeq(i);
                    try {
                        let i = t;
                        while (o["System.Collections.IEnumerator.MoveNext"]() && r["System.Collections.IEnumerator.MoveNext"]()) {
                            i = e(i, o["System.Collections.Generic.IEnumerator`1.get_Current"](), r["System.Collections.Generic.IEnumerator`1.get_Current"]())
                        }
                        return i
                    } finally {
                        (0, n.disposeSafe)(r)
                    }
                } finally {
                    (0, n.disposeSafe)(o)
                }
            }

            function foldBack2(e, t, r, n) {
                return (0, l.foldBack2)(e, toArray(t), toArray(r), n)
            }

            function forAll(e, t) {
                return !exists((t => !e(t)), t)
            }

            function forAll2(e, t, r) {
                return !exists2(((t, r) => !e(t, r)), t, r)
            }

            function tryHead(e) {
                if ((0, n.isArrayLike)(e)) {
                    return (0, l.tryHead)(e)
                } else if (e instanceof _.FSharpList) {
                    return (0, _.tryHead)(e)
                } else {
                    const t = ofSeq(e);
                    try {
                        return t["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(t["System.Collections.Generic.IEnumerator`1.get_Current"]()) : void 0
                    } finally {
                        (0, n.disposeSafe)(t)
                    }
                }
            }

            function head(e) {
                const t = tryHead(e);
                if (t == null) {
                    throw new Error(p + "\\nParameter name: " + "source")
                } else {
                    return (0, s.value)(t)
                }
            }

            function initialize(e, t) {
                return unfold((r => r < e ? [t(r), r + 1] : void 0), 0)
            }

            function initializeInfinite(e) {
                return initialize(2147483647, e)
            }

            function isEmpty(e) {
                if ((0, n.isArrayLike)(e)) {
                    return e.length === 0
                } else if (e instanceof _.FSharpList) {
                    return (0, _.isEmpty)(e)
                } else {
                    const t = ofSeq(e);
                    try {
                        return !t["System.Collections.IEnumerator.MoveNext"]()
                    } finally {
                        (0, n.disposeSafe)(t)
                    }
                }
            }

            function tryItem(e, t) {
                if ((0, n.isArrayLike)(t)) {
                    return (0, l.tryItem)(e, t)
                } else if (t instanceof _.FSharpList) {
                    return (0, _.tryItem)(e, t)
                } else {
                    const r = ofSeq(t);
                    try {
                        const loop = e => {
                            e: while (true) {
                                const t = e;
                                if (!r["System.Collections.IEnumerator.MoveNext"]()) {
                                    return void 0
                                } else if (t === 0) {
                                    return (0, s.some)(r["System.Collections.Generic.IEnumerator`1.get_Current"]())
                                } else {
                                    e = t - 1;
                                    continue e
                                }
                                break
                            }
                        };
                        return loop(e)
                    } finally {
                        (0, n.disposeSafe)(r)
                    }
                }
            }

            function item(e, t) {
                const r = tryItem(e, t);
                if (r == null) {
                    throw new Error(g + "\\nParameter name: " + "index")
                } else {
                    return (0, s.value)(r)
                }
            }

            function iterate(e, t) {
                fold(((t, r) => {
                    e(r)
                }), void 0, t)
            }

            function iterate2(e, t, r) {
                fold2(((t, r, n) => {
                    e(r, n)
                }), void 0, t, r)
            }

            function iterateIndexed(e, t) {
                fold(((t, r) => {
                    e(t, r);
                    return t + 1 | 0
                }), 0, t)
            }

            function iterateIndexed2(e, t, r) {
                fold2(((t, r, n) => {
                    e(t, r, n);
                    return t + 1 | 0
                }), 0, t, r)
            }

            function tryLast(e) {
                const t = ofSeq(e);
                try {
                    const loop = e => {
                        e: while (true) {
                            const r = e;
                            if (!t["System.Collections.IEnumerator.MoveNext"]()) {
                                return r
                            } else {
                                e = t["System.Collections.Generic.IEnumerator`1.get_Current"]();
                                continue e
                            }
                            break
                        }
                    };
                    return t["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(loop(t["System.Collections.Generic.IEnumerator`1.get_Current"]())) : void 0
                } finally {
                    (0, n.disposeSafe)(t)
                }
            }

            function last(e) {
                const t = tryLast(e);
                if (t == null) {
                    throw new Error(g + "\\nParameter name: " + "source")
                } else {
                    return (0, s.value)(t)
                }
            }

            function length(e) {
                if ((0, n.isArrayLike)(e)) {
                    return e.length | 0
                } else if (e instanceof _.FSharpList) {
                    return (0, _.length)(e) | 0
                } else {
                    const t = ofSeq(e);
                    try {
                        let e = 0;
                        while (t["System.Collections.IEnumerator.MoveNext"]()) {
                            e = e + 1 | 0
                        }
                        return e | 0
                    } finally {
                        (0, n.disposeSafe)(t)
                    }
                }
            }

            function map(e, t) {
                return generate((() => ofSeq(t)), (t => t["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(e(t["System.Collections.Generic.IEnumerator`1.get_Current"]())) : void 0), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function mapIndexed(e, t) {
                return generateIndexed((() => ofSeq(t)), ((t, r) => r["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(e(t, r["System.Collections.Generic.IEnumerator`1.get_Current"]())) : void 0), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function indexed(e) {
                return mapIndexed(((e, t) => [e, t]), e)
            }

            function map2(e, t, r) {
                return generate((() => [ofSeq(t), ofSeq(r)]), (t => {
                    const r = t[0];
                    const n = t[1];
                    return r["System.Collections.IEnumerator.MoveNext"]() && n["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(e(r["System.Collections.Generic.IEnumerator`1.get_Current"](), n["System.Collections.Generic.IEnumerator`1.get_Current"]())) : void 0
                }), (e => {
                    try {
                        (0, n.disposeSafe)(e[0])
                    } finally {
                        (0, n.disposeSafe)(e[1])
                    }
                }))
            }

            function mapIndexed2(e, t, r) {
                return generateIndexed((() => [ofSeq(t), ofSeq(r)]), ((t, r) => {
                    const n = r[0];
                    const i = r[1];
                    return n["System.Collections.IEnumerator.MoveNext"]() && i["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(e(t, n["System.Collections.Generic.IEnumerator`1.get_Current"](), i["System.Collections.Generic.IEnumerator`1.get_Current"]())) : void 0
                }), (e => {
                    try {
                        (0, n.disposeSafe)(e[0])
                    } finally {
                        (0, n.disposeSafe)(e[1])
                    }
                }))
            }

            function map3(e, t, r, i) {
                return generate((() => [ofSeq(t), ofSeq(r), ofSeq(i)]), (t => {
                    const r = t[0];
                    const n = t[1];
                    const i = t[2];
                    return r["System.Collections.IEnumerator.MoveNext"]() && n["System.Collections.IEnumerator.MoveNext"]() && i["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(e(r["System.Collections.Generic.IEnumerator`1.get_Current"](), n["System.Collections.Generic.IEnumerator`1.get_Current"](), i["System.Collections.Generic.IEnumerator`1.get_Current"]())) : void 0
                }), (e => {
                    try {
                        (0, n.disposeSafe)(e[0])
                    } finally {
                        try {
                            (0, n.disposeSafe)(e[1])
                        } finally {
                            (0, n.disposeSafe)(e[2])
                        }
                    }
                }))
            }

            function readOnly(e) {
                checkNonNull("source", e);
                return map((e => e), e)
            }
            class CachedSeq$1 {
                constructor(e, t) {
                    this.cleanup = e;
                    this.res = t
                }
                Dispose() {
                    const e = this;
                    e.cleanup()
                }
                GetEnumerator() {
                    const e = this;
                    return (0, n.getEnumerator)(e.res)
                } [Symbol.iterator]() {
                    return (0, n.toIterator)(this.GetEnumerator())
                } ["System.Collections.IEnumerable.GetEnumerator"]() {
                    const e = this;
                    return (0, n.getEnumerator)(e.res)
                }
            }
            t.CachedSeq$1 = CachedSeq$1;

            function CachedSeq$1$reflection(e) {
                return (0, o.class_type)("SeqModule.CachedSeq`1", [e], CachedSeq$1)
            }

            function CachedSeq$1_$ctor_Z7A8347D4(e, t) {
                return new CachedSeq$1(e, t)
            }

            function CachedSeq$1__Clear(e) {
                e.cleanup()
            }

            function cache(e) {
                checkNonNull("source", e);
                const t = [];
                let r = void 0;
                return CachedSeq$1_$ctor_Z7A8347D4((() => {
                    (0, a.Operators_Lock)(t, (() => {
                        (0, n.clear)(t);
                        let e, i;
                        if (r != null) {
                            if ((0, s.value)(r) != null) {
                                e = 0;
                                i = (0, s.value)(r)
                            } else {
                                e = 1
                            }
                        } else {
                            e = 1
                        }
                        switch (e) {
                            case 0: {
                                (0, n.disposeSafe)(i);
                                break
                            }
                        }
                        r = void 0
                    }))
                }), unfold((i => (0, a.Operators_Lock)(t, (() => {
                    if (i < t.length) {
                        return [t[i], i + 1]
                    } else {
                        if (i >= t.length) {
                            let i;
                            if (r != null) {
                                i = (0, s.value)(r)
                            } else {
                                const t = (0, n.getEnumerator)(e);
                                r = (0, s.some)(t);
                                i = t
                            }
                            if (i == null) {} else {
                                const e = i;
                                if (e["System.Collections.IEnumerator.MoveNext"]()) {
                                    void t.push(e["System.Collections.Generic.IEnumerator`1.get_Current"]())
                                } else {
                                    (0, n.disposeSafe)(e);
                                    r = (0, s.some)(void 0)
                                }
                            }
                        }
                        return i < t.length ? [t[i], i + 1] : void 0
                    }
                }))), 0))
            }

            function allPairs(e, t) {
                const r = cache(t);
                return delay((() => concat(map((e => map((t => [e, t]), r)), e))))
            }

            function mapFold(e, t, r) {
                const n = (0, l.mapFold)(e, t, toArray(r));
                return [readOnly(n[0]), n[1]]
            }

            function mapFoldBack(e, t, r) {
                const n = (0, l.mapFoldBack)(e, toArray(t), r);
                return [readOnly(n[0]), n[1]]
            }

            function tryPick(e, t) {
                const r = ofSeq(t);
                try {
                    let t = void 0;
                    while (t == null && r["System.Collections.IEnumerator.MoveNext"]()) {
                        t = e(r["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    }
                    return t
                } finally {
                    (0, n.disposeSafe)(r)
                }
            }

            function pick(e, t) {
                const r = tryPick(e, t);
                if (r == null) {
                    return indexNotFound()
                } else {
                    return (0, s.value)(r)
                }
            }

            function reduce(e, t) {
                const r = ofSeq(t);
                try {
                    const loop = t => {
                        e: while (true) {
                            const n = t;
                            if (r["System.Collections.IEnumerator.MoveNext"]()) {
                                t = e(n, r["System.Collections.Generic.IEnumerator`1.get_Current"]());
                                continue e
                            } else {
                                return n
                            }
                            break
                        }
                    };
                    if (r["System.Collections.IEnumerator.MoveNext"]()) {
                        return loop(r["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    } else {
                        throw new Error(p)
                    }
                } finally {
                    (0, n.disposeSafe)(r)
                }
            }

            function reduceBack(e, t) {
                const r = toArray(t);
                if (r.length > 0) {
                    return r.reduceRight(e)
                } else {
                    throw new Error(p)
                }
            }

            function replicate(e, t) {
                return initialize(e, (e => t))
            }

            function reverse(e) {
                return delay((() => ofArray((0, l.reverse)(toArray(e)))))
            }

            function scan(e, t, r) {
                return delay((() => {
                    let n = t;
                    return concat([singleton(t), map((t => {
                        n = e(n, t);
                        return n
                    }), r)])
                }))
            }

            function scanBack(e, t, r) {
                return delay((() => ofArray((0, l.scanBack)(e, toArray(t), r))))
            }

            function skip(e, t) {
                return mkSeq((() => {
                    const r = ofSeq(t);
                    try {
                        for (let t = 1; t <= e; t++) {
                            if (!r["System.Collections.IEnumerator.MoveNext"]()) {
                                throw new Error(g + "\\nParameter name: " + "source")
                            }
                        }
                        return Enumerator_enumerateThenFinally((() => {}), r)
                    } catch (e) {
                        (0, n.disposeSafe)(r);
                        throw e
                    }
                }))
            }

            function skipWhile(e, t) {
                return delay((() => {
                    let r = true;
                    return filter((t => {
                        if (r) {
                            r = e(t)
                        }
                        return !r
                    }), t)
                }))
            }

            function tail(e) {
                return skip(1, e)
            }

            function take(e, t) {
                return generateIndexed((() => ofSeq(t)), ((t, r) => {
                    if (t < e) {
                        if (r["System.Collections.IEnumerator.MoveNext"]()) {
                            return (0, s.some)(r["System.Collections.Generic.IEnumerator`1.get_Current"]())
                        } else {
                            throw new Error(g + "\\nParameter name: " + "source")
                        }
                    } else {
                        return void 0
                    }
                }), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function takeWhile(e, t) {
                return generate((() => ofSeq(t)), (t => t["System.Collections.IEnumerator.MoveNext"]() && e(t["System.Collections.Generic.IEnumerator`1.get_Current"]()) ? (0, s.some)(t["System.Collections.Generic.IEnumerator`1.get_Current"]()) : void 0), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function truncate(e, t) {
                return generateIndexed((() => ofSeq(t)), ((t, r) => t < e && r["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(r["System.Collections.Generic.IEnumerator`1.get_Current"]()) : void 0), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function zip(e, t) {
                return map2(((e, t) => [e, t]), e, t)
            }

            function zip3(e, t, r) {
                return map3(((e, t, r) => [e, t, r]), e, t, r)
            }

            function collect(e, t) {
                return delay((() => concat(map(e, t))))
            }

            function where(e, t) {
                return filter(e, t)
            }

            function pairwise(e) {
                return delay((() => ofArray((0, l.pairwise)(toArray(e)))))
            }

            function splitInto(e, t) {
                return delay((() => ofArray((0, l.map)(ofArray, (0, l.splitInto)(e, toArray(t))))))
            }

            function windowed(e, t) {
                return delay((() => ofArray((0, l.map)(ofArray, (0, l.windowed)(e, toArray(t))))))
            }

            function transpose(e) {
                return delay((() => ofArray((0, l.map)(ofArray, (0, l.transpose)((0, l.map)(toArray, toArray(e)))))))
            }

            function sortWith(e, t) {
                return delay((() => {
                    const r = toArray(t);
                    r.sort(e);
                    return ofArray(r)
                }))
            }

            function sort(e, t) {
                return sortWith(((e, r) => t.Compare(e, r)), e)
            }

            function sortBy(e, t, r) {
                return sortWith(((t, n) => r.Compare(e(t), e(n))), t)
            }

            function sortDescending(e, t) {
                return sortWith(((e, r) => t.Compare(e, r) * -1), e)
            }

            function sortByDescending(e, t, r) {
                return sortWith(((t, n) => r.Compare(e(t), e(n)) * -1), t)
            }

            function sum(e, t) {
                return fold(((e, r) => t.Add(e, r)), t.GetZero(), e)
            }

            function sumBy(e, t, r) {
                return fold(((t, n) => r.Add(t, e(n))), r.GetZero(), t)
            }

            function maxBy(e, t, r) {
                return reduce(((t, n) => r.Compare(e(n), e(t)) > 0 ? n : t), t)
            }

            function max(e, t) {
                return reduce(((e, r) => t.Compare(r, e) > 0 ? r : e), e)
            }

            function minBy(e, t, r) {
                return reduce(((t, n) => r.Compare(e(n), e(t)) > 0 ? t : n), t)
            }

            function min(e, t) {
                return reduce(((e, r) => t.Compare(r, e) > 0 ? e : r), e)
            }

            function average(e, t) {
                let r = 0;
                const n = fold(((e, n) => {
                    r = r + 1 | 0;
                    return t.Add(e, n)
                }), t.GetZero(), e);
                if (r === 0) {
                    throw new Error(p + "\\nParameter name: " + "source")
                } else {
                    return t.DivideByInt(n, r)
                }
            }

            function averageBy(e, t, r) {
                let n = 0;
                const i = fold(((t, i) => {
                    n = n + 1 | 0;
                    return r.Add(t, e(i))
                }), r.GetZero(), t);
                if (n === 0) {
                    throw new Error(p + "\\nParameter name: " + "source")
                } else {
                    return r.DivideByInt(i, n)
                }
            }

            function permute(e, t) {
                return delay((() => ofArray((0, l.permute)(e, toArray(t)))))
            }

            function chunkBySize(e, t) {
                return delay((() => ofArray((0, l.map)(ofArray, (0, l.chunkBySize)(e, toArray(t))))))
            }

            function insertAt(e, t, r) {
                let i = false;
                if (e < 0) {
                    throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                return generateIndexed((() => ofSeq(r)), ((r, n) => {
                    if ((i ? true : r < e) && n["System.Collections.IEnumerator.MoveNext"]()) {
                        return (0, s.some)(n["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    } else if (r === e) {
                        i = true;
                        return (0, s.some)(t)
                    } else {
                        if (!i) {
                            throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                        }
                        return void 0
                    }
                }), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function insertManyAt(e, t, r) {
                let i = -1;
                if (e < 0) {
                    throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                return generateIndexed((() => [ofSeq(r), ofSeq(t)]), ((t, r) => {
                    const n = r[0];
                    const o = r[1];
                    if (t === e) {
                        i = 0
                    }
                    let a;
                    if (i === 0) {
                        if (o["System.Collections.IEnumerator.MoveNext"]()) {
                            a = (0, s.some)(o["System.Collections.Generic.IEnumerator`1.get_Current"]())
                        } else {
                            i = 1;
                            a = void 0
                        }
                    } else {
                        a = void 0
                    }
                    if (a == null) {
                        if (n["System.Collections.IEnumerator.MoveNext"]()) {
                            return (0, s.some)(n["System.Collections.Generic.IEnumerator`1.get_Current"]())
                        } else {
                            if (i < 1) {
                                throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                            }
                            return void 0
                        }
                    } else {
                        return (0, s.some)((0, s.value)(a))
                    }
                }), (e => {
                    (0, n.disposeSafe)(e[0]);
                    (0, n.disposeSafe)(e[1])
                }))
            }

            function removeAt(e, t) {
                let r = false;
                if (e < 0) {
                    throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                return generateIndexed((() => ofSeq(t)), ((t, n) => {
                    if ((r ? true : t < e) && n["System.Collections.IEnumerator.MoveNext"]()) {
                        return (0, s.some)(n["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    } else if (t === e && n["System.Collections.IEnumerator.MoveNext"]()) {
                        r = true;
                        return n["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(n["System.Collections.Generic.IEnumerator`1.get_Current"]()) : void 0
                    } else {
                        if (!r) {
                            throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                        }
                        return void 0
                    }
                }), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function removeManyAt(e, t, r) {
                if (e < 0) {
                    throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                return generateIndexed((() => ofSeq(r)), ((r, n) => {
                    if (r < e) {
                        if (n["System.Collections.IEnumerator.MoveNext"]()) {
                            return (0, s.some)(n["System.Collections.Generic.IEnumerator`1.get_Current"]())
                        } else {
                            throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                        }
                    } else {
                        if (r === e) {
                            for (let e = 1; e <= t; e++) {
                                if (!n["System.Collections.IEnumerator.MoveNext"]()) {
                                    throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "count")
                                }
                            }
                        }
                        return n["System.Collections.IEnumerator.MoveNext"]() ? (0, s.some)(n["System.Collections.Generic.IEnumerator`1.get_Current"]()) : void 0
                    }
                }), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }

            function updateAt(e, t, r) {
                let i = false;
                if (e < 0) {
                    throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                }
                return generateIndexed((() => ofSeq(r)), ((r, n) => {
                    if ((i ? true : r < e) && n["System.Collections.IEnumerator.MoveNext"]()) {
                        return (0, s.some)(n["System.Collections.Generic.IEnumerator`1.get_Current"]())
                    } else if (r === e && n["System.Collections.IEnumerator.MoveNext"]()) {
                        i = true;
                        return (0, s.some)(t)
                    } else {
                        if (!i) {
                            throw new Error(u.SR_indexOutOfBounds + "\\nParameter name: " + "index")
                        }
                        return void 0
                    }
                }), (e => {
                    (0, n.disposeSafe)(e)
                }))
            }
        },
        1337: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.FSharpSet = void 0;
            t.FSharpSet$reflection = FSharpSet$reflection;
            t.FSharpSet_$ctor = FSharpSet_$ctor;
            t.FSharpSet_Compare = FSharpSet_Compare;
            t.FSharpSet_Empty = FSharpSet_Empty;
            t.FSharpSet_Equality = FSharpSet_Equality;
            t.FSharpSet_Intersection = FSharpSet_Intersection;
            t.FSharpSet_IntersectionMany = FSharpSet_IntersectionMany;
            t.FSharpSet__Add = FSharpSet__Add;
            t.FSharpSet__ComputeHashCode = FSharpSet__ComputeHashCode;
            t.FSharpSet__Contains = FSharpSet__Contains;
            t.FSharpSet__Exists = FSharpSet__Exists;
            t.FSharpSet__Filter = FSharpSet__Filter;
            t.FSharpSet__Fold = FSharpSet__Fold;
            t.FSharpSet__ForAll = FSharpSet__ForAll;
            t.FSharpSet__IsProperSubsetOf = FSharpSet__IsProperSubsetOf;
            t.FSharpSet__IsProperSupersetOf = FSharpSet__IsProperSupersetOf;
            t.FSharpSet__IsSubsetOf = FSharpSet__IsSubsetOf;
            t.FSharpSet__IsSupersetOf = FSharpSet__IsSupersetOf;
            t.FSharpSet__Iterate = FSharpSet__Iterate;
            t.FSharpSet__Map = FSharpSet__Map;
            t.FSharpSet__Partition = FSharpSet__Partition;
            t.FSharpSet__Remove = FSharpSet__Remove;
            t.FSharpSet__ToArray = FSharpSet__ToArray;
            t.FSharpSet__ToList = FSharpSet__ToList;
            t.FSharpSet__get_Choose = FSharpSet__get_Choose;
            t.FSharpSet__get_Comparer = FSharpSet__get_Comparer;
            t.FSharpSet__get_Count = FSharpSet__get_Count;
            t.FSharpSet__get_IsEmpty = FSharpSet__get_IsEmpty;
            t.FSharpSet__get_MaximumElement = FSharpSet__get_MaximumElement;
            t.FSharpSet__get_MinimumElement = FSharpSet__get_MinimumElement;
            t.FSharpSet__get_Tree = FSharpSet__get_Tree;
            t.FSharpSet_op_Addition = FSharpSet_op_Addition;
            t.FSharpSet_op_Subtraction = FSharpSet_op_Subtraction;
            t.SetTreeLeaf$1 = void 0;
            t.SetTreeLeaf$1$reflection = SetTreeLeaf$1$reflection;
            t.SetTreeLeaf$1_$ctor_2B595 = SetTreeLeaf$1_$ctor_2B595;
            t.SetTreeLeaf$1__get_Key = SetTreeLeaf$1__get_Key;
            t.SetTreeModule_SetIterator$1 = void 0;
            t.SetTreeModule_SetIterator$1$reflection = SetTreeModule_SetIterator$1$reflection;
            t.SetTreeModule_add = SetTreeModule_add;
            t.SetTreeModule_alreadyFinished = SetTreeModule_alreadyFinished;
            t.SetTreeModule_balance = SetTreeModule_balance;
            t.SetTreeModule_choose = SetTreeModule_choose;
            t.SetTreeModule_collapseLHS = SetTreeModule_collapseLHS;
            t.SetTreeModule_compare = SetTreeModule_compare;
            t.SetTreeModule_compareStacks = SetTreeModule_compareStacks;
            t.SetTreeModule_copyToArray = SetTreeModule_copyToArray;
            t.SetTreeModule_count = SetTreeModule_count;
            t.SetTreeModule_countAux = SetTreeModule_countAux;
            t.SetTreeModule_current = SetTreeModule_current;
            t.SetTreeModule_diff = SetTreeModule_diff;
            t.SetTreeModule_diffAux = SetTreeModule_diffAux;
            t.SetTreeModule_empty = SetTreeModule_empty;
            t.SetTreeModule_exists = SetTreeModule_exists;
            t.SetTreeModule_filter = SetTreeModule_filter;
            t.SetTreeModule_filterAux = SetTreeModule_filterAux;
            t.SetTreeModule_fold = SetTreeModule_fold;
            t.SetTreeModule_foldBack = SetTreeModule_foldBack;
            t.SetTreeModule_foldBackOpt = SetTreeModule_foldBackOpt;
            t.SetTreeModule_foldOpt = SetTreeModule_foldOpt;
            t.SetTreeModule_forall = SetTreeModule_forall;
            t.SetTreeModule_intersection = SetTreeModule_intersection;
            t.SetTreeModule_intersectionAux = SetTreeModule_intersectionAux;
            t.SetTreeModule_iter = SetTreeModule_iter;
            t.SetTreeModule_maximumElement = SetTreeModule_maximumElement;
            t.SetTreeModule_maximumElementAux = SetTreeModule_maximumElementAux;
            t.SetTreeModule_maximumElementOpt = SetTreeModule_maximumElementOpt;
            t.SetTreeModule_mem = SetTreeModule_mem;
            t.SetTreeModule_minimumElement = SetTreeModule_minimumElement;
            t.SetTreeModule_minimumElementAux = SetTreeModule_minimumElementAux;
            t.SetTreeModule_minimumElementOpt = SetTreeModule_minimumElementOpt;
            t.SetTreeModule_mk = SetTreeModule_mk;
            t.SetTreeModule_mkFromEnumerator = SetTreeModule_mkFromEnumerator;
            t.SetTreeModule_mkIEnumerator = SetTreeModule_mkIEnumerator;
            t.SetTreeModule_mkIterator = SetTreeModule_mkIterator;
            t.SetTreeModule_moveNext = SetTreeModule_moveNext;
            t.SetTreeModule_notStarted = SetTreeModule_notStarted;
            t.SetTreeModule_ofArray = SetTreeModule_ofArray;
            t.SetTreeModule_ofList = SetTreeModule_ofList;
            t.SetTreeModule_ofSeq = SetTreeModule_ofSeq;
            t.SetTreeModule_partition = SetTreeModule_partition;
            t.SetTreeModule_partition1 = SetTreeModule_partition1;
            t.SetTreeModule_partitionAux = SetTreeModule_partitionAux;
            t.SetTreeModule_properSubset = SetTreeModule_properSubset;
            t.SetTreeModule_rebalance = SetTreeModule_rebalance;
            t.SetTreeModule_remove = SetTreeModule_remove;
            t.SetTreeModule_spliceOutSuccessor = SetTreeModule_spliceOutSuccessor;
            t.SetTreeModule_split = SetTreeModule_split;
            t.SetTreeModule_subset = SetTreeModule_subset;
            t.SetTreeModule_toArray = SetTreeModule_toArray;
            t.SetTreeModule_toList = SetTreeModule_toList;
            t.SetTreeModule_union = SetTreeModule_union;
            t.SetTreeNode$1 = void 0;
            t.SetTreeNode$1$reflection = SetTreeNode$1$reflection;
            t.SetTreeNode$1_$ctor_Z6E7BE5F7 = SetTreeNode$1_$ctor_Z6E7BE5F7;
            t.SetTreeNode$1__get_Height = SetTreeNode$1__get_Height;
            t.SetTreeNode$1__get_Left = SetTreeNode$1__get_Left;
            t.SetTreeNode$1__get_Right = SetTreeNode$1__get_Right;
            t.add = add;
            t.contains = contains;
            t.count = count;
            t.difference = difference;
            t.empty = empty;
            t.exceptWith = exceptWith;
            t.exists = exists;
            t.filter = filter;
            t.fold = fold;
            t.foldBack = foldBack;
            t.forAll = forAll;
            t.intersect = intersect;
            t.intersectMany = intersectMany;
            t.intersectWith = intersectWith;
            t.isEmpty = isEmpty;
            t.isProperSubset = isProperSubset;
            t.isProperSubsetOf = isProperSubsetOf;
            t.isProperSuperset = isProperSuperset;
            t.isProperSupersetOf = isProperSupersetOf;
            t.isSubset = isSubset;
            t.isSubsetOf = isSubsetOf;
            t.isSuperset = isSuperset;
            t.isSupersetOf = isSupersetOf;
            t.iterate = iterate;
            t.map = map;
            t.maxElement = maxElement;
            t.minElement = minElement;
            t.newMutableSetWith = newMutableSetWith;
            t.ofArray = ofArray;
            t.ofList = ofList;
            t.ofSeq = ofSeq;
            t.partition = partition;
            t.remove = remove;
            t.singleton = singleton;
            t.toArray = toArray;
            t.toList = toList;
            t.toSeq = toSeq;
            t.union = union;
            t.unionMany = unionMany;
            t.unionWith = unionWith;
            var n = r(6356);
            var i = r(6256);
            var o = r(6638);
            var s = r(5359);
            var a = r(9054);
            var l = r(4222);
            var _ = r(9937);
            var u = r(2078);
            var c = r(9131);
            class SetTreeLeaf$1 {
                constructor(e) {
                    this.k = e
                }
            }
            t.SetTreeLeaf$1 = SetTreeLeaf$1;

            function SetTreeLeaf$1$reflection(e) {
                return (0, n.class_type)("Set.SetTreeLeaf`1", [e], SetTreeLeaf$1)
            }

            function SetTreeLeaf$1_$ctor_2B595(e) {
                return new SetTreeLeaf$1(e)
            }

            function SetTreeLeaf$1__get_Key(e) {
                return e.k
            }
            class SetTreeNode$1 extends SetTreeLeaf$1 {
                constructor(e, t, r, n) {
                    super(e);
                    this.left = t;
                    this.right = r;
                    this.h = n | 0
                }
            }
            t.SetTreeNode$1 = SetTreeNode$1;

            function SetTreeNode$1$reflection(e) {
                return (0, n.class_type)("Set.SetTreeNode`1", [e], SetTreeNode$1, SetTreeLeaf$1$reflection(e))
            }

            function SetTreeNode$1_$ctor_Z6E7BE5F7(e, t, r, n) {
                return new SetTreeNode$1(e, t, r, n)
            }

            function SetTreeNode$1__get_Left(e) {
                return e.left
            }

            function SetTreeNode$1__get_Right(e) {
                return e.right
            }

            function SetTreeNode$1__get_Height(e) {
                return e.h
            }

            function SetTreeModule_empty() {
                return void 0
            }

            function SetTreeModule_countAux(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (r != null) {
                        const i = r;
                        if (i instanceof SetTreeNode$1) {
                            e = SetTreeNode$1__get_Left(i);
                            t = SetTreeModule_countAux(SetTreeNode$1__get_Right(i), n + 1);
                            continue e
                        } else {
                            return n + 1 | 0
                        }
                    } else {
                        return n | 0
                    }
                    break
                }
            }

            function SetTreeModule_count(e) {
                return SetTreeModule_countAux(e, 0)
            }

            function SetTreeModule_mk(e, t, r) {
                let n;
                const i = e;
                if (i != null) {
                    const e = i;
                    n = e instanceof SetTreeNode$1 ? SetTreeNode$1__get_Height(e) : 1
                } else {
                    n = 0
                }
                let o;
                const s = r;
                if (s != null) {
                    const e = s;
                    o = e instanceof SetTreeNode$1 ? SetTreeNode$1__get_Height(e) : 1
                } else {
                    o = 0
                }
                const a = (n < o ? o : n) | 0;
                if (a === 0) {
                    return SetTreeLeaf$1_$ctor_2B595(t)
                } else {
                    return SetTreeNode$1_$ctor_Z6E7BE5F7(t, e, r, a + 1)
                }
            }

            function SetTreeModule_rebalance(e, t, r) {
                let n, o, s, a;
                let l;
                const _ = e;
                if (_ != null) {
                    const e = _;
                    l = e instanceof SetTreeNode$1 ? SetTreeNode$1__get_Height(e) : 1
                } else {
                    l = 0
                }
                let u;
                const c = r;
                if (c != null) {
                    const e = c;
                    u = e instanceof SetTreeNode$1 ? SetTreeNode$1__get_Height(e) : 1
                } else {
                    u = 0
                }
                if (u > l + 2) {
                    const s = (0, i.value)(r);
                    if (s instanceof SetTreeNode$1) {
                        if ((n = SetTreeNode$1__get_Left(s), n != null ? (o = n, o instanceof SetTreeNode$1 ? SetTreeNode$1__get_Height(o) : 1) : 0) > l + 1) {
                            const r = (0, i.value)(SetTreeNode$1__get_Left(s));
                            if (r instanceof SetTreeNode$1) {
                                return SetTreeModule_mk(SetTreeModule_mk(e, t, SetTreeNode$1__get_Left(r)), SetTreeLeaf$1__get_Key(r), SetTreeModule_mk(SetTreeNode$1__get_Right(r), SetTreeLeaf$1__get_Key(s), SetTreeNode$1__get_Right(s)))
                            } else {
                                throw new Error("internal error: Set.rebalance")
                            }
                        } else {
                            return SetTreeModule_mk(SetTreeModule_mk(e, t, SetTreeNode$1__get_Left(s)), SetTreeLeaf$1__get_Key(s), SetTreeNode$1__get_Right(s))
                        }
                    } else {
                        throw new Error("internal error: Set.rebalance")
                    }
                } else if (l > u + 2) {
                    const n = (0, i.value)(e);
                    if (n instanceof SetTreeNode$1) {
                        if ((s = SetTreeNode$1__get_Right(n), s != null ? (a = s, a instanceof SetTreeNode$1 ? SetTreeNode$1__get_Height(a) : 1) : 0) > u + 1) {
                            const e = (0, i.value)(SetTreeNode$1__get_Right(n));
                            if (e instanceof SetTreeNode$1) {
                                return SetTreeModule_mk(SetTreeModule_mk(SetTreeNode$1__get_Left(n), SetTreeLeaf$1__get_Key(n), SetTreeNode$1__get_Left(e)), SetTreeLeaf$1__get_Key(e), SetTreeModule_mk(SetTreeNode$1__get_Right(e), t, r))
                            } else {
                                throw new Error("internal error: Set.rebalance")
                            }
                        } else {
                            return SetTreeModule_mk(SetTreeNode$1__get_Left(n), SetTreeLeaf$1__get_Key(n), SetTreeModule_mk(SetTreeNode$1__get_Right(n), t, r))
                        }
                    } else {
                        throw new Error("internal error: Set.rebalance")
                    }
                } else {
                    return SetTreeModule_mk(e, t, r)
                }
            }

            function SetTreeModule_add(e, t, r) {
                if (r != null) {
                    const n = r;
                    const i = e.Compare(t, SetTreeLeaf$1__get_Key(n)) | 0;
                    if (n instanceof SetTreeNode$1) {
                        if (i < 0) {
                            return SetTreeModule_rebalance(SetTreeModule_add(e, t, SetTreeNode$1__get_Left(n)), SetTreeLeaf$1__get_Key(n), SetTreeNode$1__get_Right(n))
                        } else if (i === 0) {
                            return r
                        } else {
                            return SetTreeModule_rebalance(SetTreeNode$1__get_Left(n), SetTreeLeaf$1__get_Key(n), SetTreeModule_add(e, t, SetTreeNode$1__get_Right(n)))
                        }
                    } else {
                        const i = e.Compare(t, SetTreeLeaf$1__get_Key(n)) | 0;
                        if (i < 0) {
                            return SetTreeNode$1_$ctor_Z6E7BE5F7(t, SetTreeModule_empty(), r, 2)
                        } else if (i === 0) {
                            return r
                        } else {
                            return SetTreeNode$1_$ctor_Z6E7BE5F7(t, r, SetTreeModule_empty(), 2)
                        }
                    }
                } else {
                    return SetTreeLeaf$1_$ctor_2B595(t)
                }
            }

            function SetTreeModule_balance(e, t, r, n) {
                if (t != null) {
                    const i = t;
                    if (n != null) {
                        const o = n;
                        if (i instanceof SetTreeNode$1) {
                            if (o instanceof SetTreeNode$1) {
                                if (SetTreeNode$1__get_Height(i) + 2 < SetTreeNode$1__get_Height(o)) {
                                    return SetTreeModule_rebalance(SetTreeModule_balance(e, t, r, SetTreeNode$1__get_Left(o)), SetTreeLeaf$1__get_Key(o), SetTreeNode$1__get_Right(o))
                                } else if (SetTreeNode$1__get_Height(o) + 2 < SetTreeNode$1__get_Height(i)) {
                                    return SetTreeModule_rebalance(SetTreeNode$1__get_Left(i), SetTreeLeaf$1__get_Key(i), SetTreeModule_balance(e, SetTreeNode$1__get_Right(i), r, n))
                                } else {
                                    return SetTreeModule_mk(t, r, n)
                                }
                            } else {
                                return SetTreeModule_add(e, r, SetTreeModule_add(e, SetTreeLeaf$1__get_Key(o), t))
                            }
                        } else {
                            return SetTreeModule_add(e, r, SetTreeModule_add(e, SetTreeLeaf$1__get_Key(i), n))
                        }
                    } else {
                        return SetTreeModule_add(e, r, t)
                    }
                } else {
                    return SetTreeModule_add(e, r, n)
                }
            }

            function SetTreeModule_split(e, t, r) {
                if (r != null) {
                    const n = r;
                    if (n instanceof SetTreeNode$1) {
                        const r = e.Compare(t, SetTreeLeaf$1__get_Key(n)) | 0;
                        if (r < 0) {
                            const r = SetTreeModule_split(e, t, SetTreeNode$1__get_Left(n));
                            return [r[0], r[1], SetTreeModule_balance(e, r[2], SetTreeLeaf$1__get_Key(n), SetTreeNode$1__get_Right(n))]
                        } else if (r === 0) {
                            return [SetTreeNode$1__get_Left(n), true, SetTreeNode$1__get_Right(n)]
                        } else {
                            const r = SetTreeModule_split(e, t, SetTreeNode$1__get_Right(n));
                            return [SetTreeModule_balance(e, SetTreeNode$1__get_Left(n), SetTreeLeaf$1__get_Key(n), r[0]), r[1], r[2]]
                        }
                    } else {
                        const i = e.Compare(SetTreeLeaf$1__get_Key(n), t) | 0;
                        if (i < 0) {
                            return [r, false, SetTreeModule_empty()]
                        } else if (i === 0) {
                            return [SetTreeModule_empty(), true, SetTreeModule_empty()]
                        } else {
                            return [SetTreeModule_empty(), false, r]
                        }
                    }
                } else {
                    return [SetTreeModule_empty(), false, SetTreeModule_empty()]
                }
            }

            function SetTreeModule_spliceOutSuccessor(e) {
                if (e != null) {
                    const t = e;
                    if (t instanceof SetTreeNode$1) {
                        if (SetTreeNode$1__get_Left(t) == null) {
                            return [SetTreeLeaf$1__get_Key(t), SetTreeNode$1__get_Right(t)]
                        } else {
                            const e = SetTreeModule_spliceOutSuccessor(SetTreeNode$1__get_Left(t));
                            return [e[0], SetTreeModule_mk(e[1], SetTreeLeaf$1__get_Key(t), SetTreeNode$1__get_Right(t))]
                        }
                    } else {
                        return [SetTreeLeaf$1__get_Key(t), SetTreeModule_empty()]
                    }
                } else {
                    throw new Error("internal error: Set.spliceOutSuccessor")
                }
            }

            function SetTreeModule_remove(e, t, r) {
                if (r != null) {
                    const n = r;
                    const i = e.Compare(t, SetTreeLeaf$1__get_Key(n)) | 0;
                    if (n instanceof SetTreeNode$1) {
                        if (i < 0) {
                            return SetTreeModule_rebalance(SetTreeModule_remove(e, t, SetTreeNode$1__get_Left(n)), SetTreeLeaf$1__get_Key(n), SetTreeNode$1__get_Right(n))
                        } else if (i === 0) {
                            if (SetTreeNode$1__get_Left(n) == null) {
                                return SetTreeNode$1__get_Right(n)
                            } else if (SetTreeNode$1__get_Right(n) == null) {
                                return SetTreeNode$1__get_Left(n)
                            } else {
                                const e = SetTreeModule_spliceOutSuccessor(SetTreeNode$1__get_Right(n));
                                return SetTreeModule_mk(SetTreeNode$1__get_Left(n), e[0], e[1])
                            }
                        } else {
                            return SetTreeModule_rebalance(SetTreeNode$1__get_Left(n), SetTreeLeaf$1__get_Key(n), SetTreeModule_remove(e, t, SetTreeNode$1__get_Right(n)))
                        }
                    } else if (i === 0) {
                        return SetTreeModule_empty()
                    } else {
                        return r
                    }
                } else {
                    return r
                }
            }

            function SetTreeModule_mem(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o != null) {
                        const s = o;
                        const a = n.Compare(i, SetTreeLeaf$1__get_Key(s)) | 0;
                        if (s instanceof SetTreeNode$1) {
                            if (a < 0) {
                                e = n;
                                t = i;
                                r = SetTreeNode$1__get_Left(s);
                                continue e
                            } else if (a === 0) {
                                return true
                            } else {
                                e = n;
                                t = i;
                                r = SetTreeNode$1__get_Right(s);
                                continue e
                            }
                        } else {
                            return a === 0
                        }
                    } else {
                        return false
                    }
                    break
                }
            }

            function SetTreeModule_iter(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n != null) {
                        const i = n;
                        if (i instanceof SetTreeNode$1) {
                            SetTreeModule_iter(r, SetTreeNode$1__get_Left(i));
                            r(SetTreeLeaf$1__get_Key(i));
                            e = r;
                            t = SetTreeNode$1__get_Right(i);
                            continue e
                        } else {
                            r(SetTreeLeaf$1__get_Key(i))
                        }
                    }
                    break
                }
            }

            function SetTreeModule_foldBackOpt(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (i != null) {
                        const s = i;
                        if (s instanceof SetTreeNode$1) {
                            e = n;
                            t = SetTreeNode$1__get_Left(s);
                            r = n(SetTreeLeaf$1__get_Key(s), SetTreeModule_foldBackOpt(n, SetTreeNode$1__get_Right(s), o));
                            continue e
                        } else {
                            return n(SetTreeLeaf$1__get_Key(s), o)
                        }
                    } else {
                        return o
                    }
                    break
                }
            }

            function SetTreeModule_foldBack(e, t, r) {
                return SetTreeModule_foldBackOpt(e, t, r)
            }

            function SetTreeModule_foldOpt(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o != null) {
                        const s = o;
                        if (s instanceof SetTreeNode$1) {
                            e = n;
                            t = n(SetTreeModule_foldOpt(n, i, SetTreeNode$1__get_Left(s)), SetTreeLeaf$1__get_Key(s));
                            r = SetTreeNode$1__get_Right(s);
                            continue e
                        } else {
                            return n(i, SetTreeLeaf$1__get_Key(s))
                        }
                    } else {
                        return i
                    }
                    break
                }
            }

            function SetTreeModule_fold(e, t, r) {
                return SetTreeModule_foldOpt(e, t, r)
            }

            function SetTreeModule_forall(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n != null) {
                        const i = n;
                        if (i instanceof SetTreeNode$1) {
                            if (r(SetTreeLeaf$1__get_Key(i)) && SetTreeModule_forall(r, SetTreeNode$1__get_Left(i))) {
                                e = r;
                                t = SetTreeNode$1__get_Right(i);
                                continue e
                            } else {
                                return false
                            }
                        } else {
                            return r(SetTreeLeaf$1__get_Key(i))
                        }
                    } else {
                        return true
                    }
                    break
                }
            }

            function SetTreeModule_exists(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (n != null) {
                        const i = n;
                        if (i instanceof SetTreeNode$1) {
                            if (r(SetTreeLeaf$1__get_Key(i)) ? true : SetTreeModule_exists(r, SetTreeNode$1__get_Left(i))) {
                                return true
                            } else {
                                e = r;
                                t = SetTreeNode$1__get_Right(i);
                                continue e
                            }
                        } else {
                            return r(SetTreeLeaf$1__get_Key(i))
                        }
                    } else {
                        return false
                    }
                    break
                }
            }

            function SetTreeModule_subset(e, t, r) {
                return SetTreeModule_forall((t => SetTreeModule_mem(e, t, r)), t)
            }

            function SetTreeModule_properSubset(e, t, r) {
                if (SetTreeModule_forall((t => SetTreeModule_mem(e, t, r)), t)) {
                    return SetTreeModule_exists((r => !SetTreeModule_mem(e, r, t)), r)
                } else {
                    return false
                }
            }

            function SetTreeModule_filterAux(e, t, r, n) {
                e: while (true) {
                    const i = e,
                        o = t,
                        s = r,
                        a = n;
                    if (s != null) {
                        const l = s;
                        if (l instanceof SetTreeNode$1) {
                            const s = o(SetTreeLeaf$1__get_Key(l)) ? SetTreeModule_add(i, SetTreeLeaf$1__get_Key(l), a) : a;
                            e = i;
                            t = o;
                            r = SetTreeNode$1__get_Left(l);
                            n = SetTreeModule_filterAux(i, o, SetTreeNode$1__get_Right(l), s);
                            continue e
                        } else if (o(SetTreeLeaf$1__get_Key(l))) {
                            return SetTreeModule_add(i, SetTreeLeaf$1__get_Key(l), a)
                        } else {
                            return a
                        }
                    } else {
                        return a
                    }
                    break
                }
            }

            function SetTreeModule_filter(e, t, r) {
                return SetTreeModule_filterAux(e, t, r, SetTreeModule_empty())
            }

            function SetTreeModule_diffAux(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o == null) {
                        return o
                    } else if (i != null) {
                        const s = i;
                        if (s instanceof SetTreeNode$1) {
                            e = n;
                            t = SetTreeNode$1__get_Left(s);
                            r = SetTreeModule_diffAux(n, SetTreeNode$1__get_Right(s), SetTreeModule_remove(n, SetTreeLeaf$1__get_Key(s), o));
                            continue e
                        } else {
                            return SetTreeModule_remove(n, SetTreeLeaf$1__get_Key(s), o)
                        }
                    } else {
                        return o
                    }
                    break
                }
            }

            function SetTreeModule_diff(e, t, r) {
                return SetTreeModule_diffAux(e, r, t)
            }

            function SetTreeModule_union(e, t, r) {
                if (t != null) {
                    const n = t;
                    if (r != null) {
                        const i = r;
                        if (n instanceof SetTreeNode$1) {
                            if (i instanceof SetTreeNode$1) {
                                if (SetTreeNode$1__get_Height(n) > SetTreeNode$1__get_Height(i)) {
                                    const t = SetTreeModule_split(e, SetTreeLeaf$1__get_Key(n), r);
                                    return SetTreeModule_balance(e, SetTreeModule_union(e, SetTreeNode$1__get_Left(n), t[0]), SetTreeLeaf$1__get_Key(n), SetTreeModule_union(e, SetTreeNode$1__get_Right(n), t[2]))
                                } else {
                                    const r = SetTreeModule_split(e, SetTreeLeaf$1__get_Key(i), t);
                                    return SetTreeModule_balance(e, SetTreeModule_union(e, SetTreeNode$1__get_Left(i), r[0]), SetTreeLeaf$1__get_Key(i), SetTreeModule_union(e, SetTreeNode$1__get_Right(i), r[2]))
                                }
                            } else {
                                return SetTreeModule_add(e, SetTreeLeaf$1__get_Key(i), t)
                            }
                        } else {
                            return SetTreeModule_add(e, SetTreeLeaf$1__get_Key(n), r)
                        }
                    } else {
                        return t
                    }
                } else {
                    return r
                }
            }

            function SetTreeModule_intersectionAux(e, t, r, n) {
                e: while (true) {
                    const i = e,
                        o = t,
                        s = r,
                        a = n;
                    if (s != null) {
                        const l = s;
                        if (l instanceof SetTreeNode$1) {
                            const s = SetTreeModule_intersectionAux(i, o, SetTreeNode$1__get_Right(l), a);
                            const _ = SetTreeModule_mem(i, SetTreeLeaf$1__get_Key(l), o) ? SetTreeModule_add(i, SetTreeLeaf$1__get_Key(l), s) : s;
                            e = i;
                            t = o;
                            r = SetTreeNode$1__get_Left(l);
                            n = _;
                            continue e
                        } else if (SetTreeModule_mem(i, SetTreeLeaf$1__get_Key(l), o)) {
                            return SetTreeModule_add(i, SetTreeLeaf$1__get_Key(l), a)
                        } else {
                            return a
                        }
                    } else {
                        return a
                    }
                    break
                }
            }

            function SetTreeModule_intersection(e, t, r) {
                return SetTreeModule_intersectionAux(e, r, t, SetTreeModule_empty())
            }

            function SetTreeModule_partition1(e, t, r, n, i) {
                if (t(r)) {
                    return [SetTreeModule_add(e, r, n), i]
                } else {
                    return [n, SetTreeModule_add(e, r, i)]
                }
            }

            function SetTreeModule_partitionAux(e, t, r, n, i) {
                e: while (true) {
                    const o = e,
                        s = t,
                        a = r,
                        l = n,
                        _ = i;
                    const u = [l, _];
                    if (a != null) {
                        const l = a;
                        if (l instanceof SetTreeNode$1) {
                            const a = SetTreeModule_partitionAux(o, s, SetTreeNode$1__get_Right(l), u[0], u[1]);
                            const _ = SetTreeModule_partition1(o, s, SetTreeLeaf$1__get_Key(l), a[0], a[1]);
                            e = o;
                            t = s;
                            r = SetTreeNode$1__get_Left(l);
                            n = _[0];
                            i = _[1];
                            continue e
                        } else {
                            return SetTreeModule_partition1(o, s, SetTreeLeaf$1__get_Key(l), u[0], u[1])
                        }
                    } else {
                        return u
                    }
                    break
                }
            }

            function SetTreeModule_partition(e, t, r) {
                return SetTreeModule_partitionAux(e, t, r, SetTreeModule_empty(), SetTreeModule_empty())
            }

            function SetTreeModule_minimumElementAux(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (r != null) {
                        const n = r;
                        if (n instanceof SetTreeNode$1) {
                            e = SetTreeNode$1__get_Left(n);
                            t = SetTreeLeaf$1__get_Key(n);
                            continue e
                        } else {
                            return SetTreeLeaf$1__get_Key(n)
                        }
                    } else {
                        return n
                    }
                    break
                }
            }

            function SetTreeModule_minimumElementOpt(e) {
                if (e != null) {
                    const t = e;
                    if (t instanceof SetTreeNode$1) {
                        return (0, i.some)(SetTreeModule_minimumElementAux(SetTreeNode$1__get_Left(t), SetTreeLeaf$1__get_Key(t)))
                    } else {
                        return (0, i.some)(SetTreeLeaf$1__get_Key(t))
                    }
                } else {
                    return void 0
                }
            }

            function SetTreeModule_maximumElementAux(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (r != null) {
                        const n = r;
                        if (n instanceof SetTreeNode$1) {
                            e = SetTreeNode$1__get_Right(n);
                            t = SetTreeLeaf$1__get_Key(n);
                            continue e
                        } else {
                            return SetTreeLeaf$1__get_Key(n)
                        }
                    } else {
                        return n
                    }
                    break
                }
            }

            function SetTreeModule_maximumElementOpt(e) {
                if (e != null) {
                    const t = e;
                    if (t instanceof SetTreeNode$1) {
                        return (0, i.some)(SetTreeModule_maximumElementAux(SetTreeNode$1__get_Right(t), SetTreeLeaf$1__get_Key(t)))
                    } else {
                        return (0, i.some)(SetTreeLeaf$1__get_Key(t))
                    }
                } else {
                    return void 0
                }
            }

            function SetTreeModule_minimumElement(e) {
                const t = SetTreeModule_minimumElementOpt(e);
                if (t == null) {
                    throw new Error("Set contains no elements")
                } else {
                    return (0, i.value)(t)
                }
            }

            function SetTreeModule_maximumElement(e) {
                const t = SetTreeModule_maximumElementOpt(e);
                if (t == null) {
                    throw new Error("Set contains no elements")
                } else {
                    return (0, i.value)(t)
                }
            }
            class SetTreeModule_SetIterator$1 extends o.Record {
                constructor(e, t) {
                    super();
                    this.stack = e;
                    this.started = t
                }
            }
            t.SetTreeModule_SetIterator$1 = SetTreeModule_SetIterator$1;

            function SetTreeModule_SetIterator$1$reflection(e) {
                return (0, n.record_type)("Set.SetTreeModule.SetIterator`1", [e], SetTreeModule_SetIterator$1, (() => [
                    ["stack", (0, n.list_type)((0, n.option_type)(SetTreeLeaf$1$reflection(e)))],
                    ["started", n.bool_type]
                ]))
            }

            function SetTreeModule_collapseLHS(e) {
                e: while (true) {
                    const t = e;
                    if (!(0, s.isEmpty)(t)) {
                        const r = (0, s.head)(t);
                        const n = (0, s.tail)(t);
                        if (r != null) {
                            const i = r;
                            if (i instanceof SetTreeNode$1) {
                                e = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(i), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(i)), SetTreeNode$1__get_Right(i)], n);
                                continue e
                            } else {
                                return t
                            }
                        } else {
                            e = n;
                            continue e
                        }
                    } else {
                        return (0, s.empty)()
                    }
                    break
                }
            }

            function SetTreeModule_mkIterator(e) {
                return new SetTreeModule_SetIterator$1(SetTreeModule_collapseLHS((0, s.singleton)(e)), false)
            }

            function SetTreeModule_notStarted() {
                throw new Error("Enumeration not started")
            }

            function SetTreeModule_alreadyFinished() {
                throw new Error("Enumeration already started")
            }

            function SetTreeModule_current(e) {
                if (e.started) {
                    const t = e.stack;
                    if ((0, s.isEmpty)(t)) {
                        return SetTreeModule_alreadyFinished()
                    } else if ((0, s.head)(t) != null) {
                        const e = (0, s.head)(t);
                        return SetTreeLeaf$1__get_Key(e)
                    } else {
                        throw new Error("Please report error: Set iterator, unexpected stack for current")
                    }
                } else {
                    return SetTreeModule_notStarted()
                }
            }

            function SetTreeModule_moveNext(e) {
                if (e.started) {
                    const t = e.stack;
                    if (!(0, s.isEmpty)(t)) {
                        if ((0, s.head)(t) != null) {
                            const r = (0, s.head)(t);
                            if (r instanceof SetTreeNode$1) {
                                throw new Error("Please report error: Set iterator, unexpected stack for moveNext")
                            } else {
                                e.stack = SetTreeModule_collapseLHS((0, s.tail)(t));
                                return !(0, s.isEmpty)(e.stack)
                            }
                        } else {
                            throw new Error("Please report error: Set iterator, unexpected stack for moveNext")
                        }
                    } else {
                        return false
                    }
                } else {
                    e.started = true;
                    return !(0, s.isEmpty)(e.stack)
                }
            }

            function SetTreeModule_mkIEnumerator(e) {
                let t = SetTreeModule_mkIterator(e);
                return {
                    ["System.Collections.Generic.IEnumerator`1.get_Current"]() {
                        return SetTreeModule_current(t)
                    },
                    ["System.Collections.IEnumerator.get_Current"]() {
                        return SetTreeModule_current(t)
                    },
                    ["System.Collections.IEnumerator.MoveNext"]() {
                        return SetTreeModule_moveNext(t)
                    },
                    ["System.Collections.IEnumerator.Reset"]() {
                        t = SetTreeModule_mkIterator(e)
                    },
                    Dispose() {}
                }
            }

            function SetTreeModule_compareStacks(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    const a = [i, o];
                    if (!(0, s.isEmpty)(a[0])) {
                        if (!(0, s.isEmpty)(a[1])) {
                            if ((0, s.head)(a[1]) != null) {
                                if ((0, s.head)(a[0]) != null) {
                                    const l = (0, s.head)(a[0]);
                                    const _ = (0, s.head)(a[1]);
                                    if (l instanceof SetTreeNode$1) {
                                        if (SetTreeNode$1__get_Left(l) == null) {
                                            if (_ instanceof SetTreeNode$1) {
                                                if (SetTreeNode$1__get_Left(_) == null) {
                                                    const i = n.Compare(SetTreeLeaf$1__get_Key(l), SetTreeLeaf$1__get_Key(_)) | 0;
                                                    if (i !== 0) {
                                                        return i | 0
                                                    } else {
                                                        e = n;
                                                        t = (0, s.cons)(SetTreeNode$1__get_Right(l), (0, s.tail)(a[0]));
                                                        r = (0, s.cons)(SetTreeNode$1__get_Right(_), (0, s.tail)(a[1]));
                                                        continue e
                                                    }
                                                } else {
                                                    const a = [i, o];
                                                    let l, _, u, c, d;
                                                    if (!(0, s.isEmpty)(a[0])) {
                                                        if ((0, s.head)(a[0]) != null) {
                                                            l = 0;
                                                            _ = (0, s.tail)(a[0]);
                                                            u = (0, s.head)(a[0])
                                                        } else if (!(0, s.isEmpty)(a[1])) {
                                                            if ((0, s.head)(a[1]) != null) {
                                                                l = 1;
                                                                c = (0, s.tail)(a[1]);
                                                                d = (0, s.head)(a[1])
                                                            } else {
                                                                l = 2
                                                            }
                                                        } else {
                                                            l = 2
                                                        }
                                                    } else if (!(0, s.isEmpty)(a[1])) {
                                                        if ((0, s.head)(a[1]) != null) {
                                                            l = 1;
                                                            c = (0, s.tail)(a[1]);
                                                            d = (0, s.head)(a[1])
                                                        } else {
                                                            l = 2
                                                        }
                                                    } else {
                                                        l = 2
                                                    }
                                                    switch (l) {
                                                        case 0: {
                                                            if (u instanceof SetTreeNode$1) {
                                                                e = n;
                                                                t = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(u), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(u), SetTreeModule_empty(), SetTreeNode$1__get_Right(u), 0)], _);
                                                                r = o;
                                                                continue e
                                                            } else {
                                                                e = n;
                                                                t = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(u))], _);
                                                                r = o;
                                                                continue e
                                                            }
                                                        }
                                                        case 1: {
                                                            if (d instanceof SetTreeNode$1) {
                                                                e = n;
                                                                t = i;
                                                                r = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(d), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(d), SetTreeModule_empty(), SetTreeNode$1__get_Right(d), 0)], c);
                                                                continue e
                                                            } else {
                                                                e = n;
                                                                t = i;
                                                                r = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(d))], c);
                                                                continue e
                                                            }
                                                        }
                                                        case 2: {
                                                            throw new Error("unexpected state in SetTree.compareStacks")
                                                        }
                                                    }
                                                }
                                            } else {
                                                const i = n.Compare(SetTreeLeaf$1__get_Key(l), SetTreeLeaf$1__get_Key(_)) | 0;
                                                if (i !== 0) {
                                                    return i | 0
                                                } else {
                                                    e = n;
                                                    t = (0, s.cons)(SetTreeNode$1__get_Right(l), (0, s.tail)(a[0]));
                                                    r = (0, s.cons)(SetTreeModule_empty(), (0, s.tail)(a[1]));
                                                    continue e
                                                }
                                            }
                                        } else {
                                            const a = [i, o];
                                            let l, _, u, c, d;
                                            if (!(0, s.isEmpty)(a[0])) {
                                                if ((0, s.head)(a[0]) != null) {
                                                    l = 0;
                                                    _ = (0, s.tail)(a[0]);
                                                    u = (0, s.head)(a[0])
                                                } else if (!(0, s.isEmpty)(a[1])) {
                                                    if ((0, s.head)(a[1]) != null) {
                                                        l = 1;
                                                        c = (0, s.tail)(a[1]);
                                                        d = (0, s.head)(a[1])
                                                    } else {
                                                        l = 2
                                                    }
                                                } else {
                                                    l = 2
                                                }
                                            } else if (!(0, s.isEmpty)(a[1])) {
                                                if ((0, s.head)(a[1]) != null) {
                                                    l = 1;
                                                    c = (0, s.tail)(a[1]);
                                                    d = (0, s.head)(a[1])
                                                } else {
                                                    l = 2
                                                }
                                            } else {
                                                l = 2
                                            }
                                            switch (l) {
                                                case 0: {
                                                    if (u instanceof SetTreeNode$1) {
                                                        e = n;
                                                        t = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(u), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(u), SetTreeModule_empty(), SetTreeNode$1__get_Right(u), 0)], _);
                                                        r = o;
                                                        continue e
                                                    } else {
                                                        e = n;
                                                        t = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(u))], _);
                                                        r = o;
                                                        continue e
                                                    }
                                                }
                                                case 1: {
                                                    if (d instanceof SetTreeNode$1) {
                                                        e = n;
                                                        t = i;
                                                        r = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(d), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(d), SetTreeModule_empty(), SetTreeNode$1__get_Right(d), 0)], c);
                                                        continue e
                                                    } else {
                                                        e = n;
                                                        t = i;
                                                        r = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(d))], c);
                                                        continue e
                                                    }
                                                }
                                                case 2: {
                                                    throw new Error("unexpected state in SetTree.compareStacks")
                                                }
                                            }
                                        }
                                    } else if (_ instanceof SetTreeNode$1) {
                                        if (SetTreeNode$1__get_Left(_) == null) {
                                            const i = n.Compare(SetTreeLeaf$1__get_Key(l), SetTreeLeaf$1__get_Key(_)) | 0;
                                            if (i !== 0) {
                                                return i | 0
                                            } else {
                                                e = n;
                                                t = (0, s.cons)(SetTreeModule_empty(), (0, s.tail)(a[0]));
                                                r = (0, s.cons)(SetTreeNode$1__get_Right(_), (0, s.tail)(a[1]));
                                                continue e
                                            }
                                        } else {
                                            const a = [i, o];
                                            let l, _, u, c, d;
                                            if (!(0, s.isEmpty)(a[0])) {
                                                if ((0, s.head)(a[0]) != null) {
                                                    l = 0;
                                                    _ = (0, s.tail)(a[0]);
                                                    u = (0, s.head)(a[0])
                                                } else if (!(0, s.isEmpty)(a[1])) {
                                                    if ((0, s.head)(a[1]) != null) {
                                                        l = 1;
                                                        c = (0, s.tail)(a[1]);
                                                        d = (0, s.head)(a[1])
                                                    } else {
                                                        l = 2
                                                    }
                                                } else {
                                                    l = 2
                                                }
                                            } else if (!(0, s.isEmpty)(a[1])) {
                                                if ((0, s.head)(a[1]) != null) {
                                                    l = 1;
                                                    c = (0, s.tail)(a[1]);
                                                    d = (0, s.head)(a[1])
                                                } else {
                                                    l = 2
                                                }
                                            } else {
                                                l = 2
                                            }
                                            switch (l) {
                                                case 0: {
                                                    if (u instanceof SetTreeNode$1) {
                                                        e = n;
                                                        t = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(u), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(u), SetTreeModule_empty(), SetTreeNode$1__get_Right(u), 0)], _);
                                                        r = o;
                                                        continue e
                                                    } else {
                                                        e = n;
                                                        t = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(u))], _);
                                                        r = o;
                                                        continue e
                                                    }
                                                }
                                                case 1: {
                                                    if (d instanceof SetTreeNode$1) {
                                                        e = n;
                                                        t = i;
                                                        r = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(d), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(d), SetTreeModule_empty(), SetTreeNode$1__get_Right(d), 0)], c);
                                                        continue e
                                                    } else {
                                                        e = n;
                                                        t = i;
                                                        r = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(d))], c);
                                                        continue e
                                                    }
                                                }
                                                case 2: {
                                                    throw new Error("unexpected state in SetTree.compareStacks")
                                                }
                                            }
                                        }
                                    } else {
                                        const i = n.Compare(SetTreeLeaf$1__get_Key(l), SetTreeLeaf$1__get_Key(_)) | 0;
                                        if (i !== 0) {
                                            return i | 0
                                        } else {
                                            e = n;
                                            t = (0, s.tail)(a[0]);
                                            r = (0, s.tail)(a[1]);
                                            continue e
                                        }
                                    }
                                } else {
                                    const l = (0, s.head)(a[1]);
                                    const _ = [i, o];
                                    let u, c, d, p, f;
                                    if (!(0, s.isEmpty)(_[0])) {
                                        if ((0, s.head)(_[0]) != null) {
                                            u = 0;
                                            c = (0, s.tail)(_[0]);
                                            d = (0, s.head)(_[0])
                                        } else if (!(0, s.isEmpty)(_[1])) {
                                            if ((0, s.head)(_[1]) != null) {
                                                u = 1;
                                                p = (0, s.tail)(_[1]);
                                                f = (0, s.head)(_[1])
                                            } else {
                                                u = 2
                                            }
                                        } else {
                                            u = 2
                                        }
                                    } else if (!(0, s.isEmpty)(_[1])) {
                                        if ((0, s.head)(_[1]) != null) {
                                            u = 1;
                                            p = (0, s.tail)(_[1]);
                                            f = (0, s.head)(_[1])
                                        } else {
                                            u = 2
                                        }
                                    } else {
                                        u = 2
                                    }
                                    switch (u) {
                                        case 0: {
                                            if (d instanceof SetTreeNode$1) {
                                                e = n;
                                                t = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(d), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(d), SetTreeModule_empty(), SetTreeNode$1__get_Right(d), 0)], c);
                                                r = o;
                                                continue e
                                            } else {
                                                e = n;
                                                t = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(d))], c);
                                                r = o;
                                                continue e
                                            }
                                        }
                                        case 1: {
                                            if (f instanceof SetTreeNode$1) {
                                                e = n;
                                                t = i;
                                                r = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(f), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(f), SetTreeModule_empty(), SetTreeNode$1__get_Right(f), 0)], p);
                                                continue e
                                            } else {
                                                e = n;
                                                t = i;
                                                r = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(f))], p);
                                                continue e
                                            }
                                        }
                                        case 2: {
                                            throw new Error("unexpected state in SetTree.compareStacks")
                                        }
                                    }
                                }
                            } else if ((0, s.head)(a[0]) != null) {
                                const l = (0, s.head)(a[0]);
                                const _ = [i, o];
                                let u, c, d, p, f;
                                if (!(0, s.isEmpty)(_[0])) {
                                    if ((0, s.head)(_[0]) != null) {
                                        u = 0;
                                        c = (0, s.tail)(_[0]);
                                        d = (0, s.head)(_[0])
                                    } else if (!(0, s.isEmpty)(_[1])) {
                                        if ((0, s.head)(_[1]) != null) {
                                            u = 1;
                                            p = (0, s.tail)(_[1]);
                                            f = (0, s.head)(_[1])
                                        } else {
                                            u = 2
                                        }
                                    } else {
                                        u = 2
                                    }
                                } else if (!(0, s.isEmpty)(_[1])) {
                                    if ((0, s.head)(_[1]) != null) {
                                        u = 1;
                                        p = (0, s.tail)(_[1]);
                                        f = (0, s.head)(_[1])
                                    } else {
                                        u = 2
                                    }
                                } else {
                                    u = 2
                                }
                                switch (u) {
                                    case 0: {
                                        if (d instanceof SetTreeNode$1) {
                                            e = n;
                                            t = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(d), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(d), SetTreeModule_empty(), SetTreeNode$1__get_Right(d), 0)], c);
                                            r = o;
                                            continue e
                                        } else {
                                            e = n;
                                            t = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(d))], c);
                                            r = o;
                                            continue e
                                        }
                                    }
                                    case 1: {
                                        if (f instanceof SetTreeNode$1) {
                                            e = n;
                                            t = i;
                                            r = (0, s.ofArrayWithTail)([SetTreeNode$1__get_Left(f), SetTreeNode$1_$ctor_Z6E7BE5F7(SetTreeLeaf$1__get_Key(f), SetTreeModule_empty(), SetTreeNode$1__get_Right(f), 0)], p);
                                            continue e
                                        } else {
                                            e = n;
                                            t = i;
                                            r = (0, s.ofArrayWithTail)([SetTreeModule_empty(), SetTreeLeaf$1_$ctor_2B595(SetTreeLeaf$1__get_Key(f))], p);
                                            continue e
                                        }
                                    }
                                    case 2: {
                                        throw new Error("unexpected state in SetTree.compareStacks")
                                    }
                                }
                            } else {
                                e = n;
                                t = (0, s.tail)(a[0]);
                                r = (0, s.tail)(a[1]);
                                continue e
                            }
                        } else {
                            return 1
                        }
                    } else if ((0, s.isEmpty)(a[1])) {
                        return 0
                    } else {
                        return -1
                    }
                    break
                }
            }

            function SetTreeModule_compare(e, t, r) {
                if (t == null) {
                    if (r == null) {
                        return 0
                    } else {
                        return -1
                    }
                } else if (r == null) {
                    return 1
                } else {
                    return SetTreeModule_compareStacks(e, (0, s.singleton)(t), (0, s.singleton)(r)) | 0
                }
            }

            function SetTreeModule_choose(e) {
                return SetTreeModule_minimumElement(e)
            }

            function SetTreeModule_toList(e) {
                const loop = (e, t) => {
                    e: while (true) {
                        const r = e,
                            n = t;
                        if (r != null) {
                            const i = r;
                            if (i instanceof SetTreeNode$1) {
                                e = SetTreeNode$1__get_Left(i);
                                t = (0, s.cons)(SetTreeLeaf$1__get_Key(i), loop(SetTreeNode$1__get_Right(i), n));
                                continue e
                            } else {
                                return (0, s.cons)(SetTreeLeaf$1__get_Key(i), n)
                            }
                        } else {
                            return n
                        }
                        break
                    }
                };
                return loop(e, (0, s.empty)())
            }

            function SetTreeModule_copyToArray(e, t, r) {
                let n = r;
                SetTreeModule_iter((e => {
                    t[n] = e;
                    n = n + 1 | 0
                }), e)
            }

            function SetTreeModule_toArray(e) {
                const t = SetTreeModule_count(e) | 0;
                const r = (0, a.fill)(new Array(t), 0, t, null);
                SetTreeModule_copyToArray(e, r, 0);
                return r
            }

            function SetTreeModule_mkFromEnumerator(e, t, r) {
                e: while (true) {
                    const n = e,
                        i = t,
                        o = r;
                    if (o["System.Collections.IEnumerator.MoveNext"]()) {
                        e = n;
                        t = SetTreeModule_add(n, o["System.Collections.Generic.IEnumerator`1.get_Current"](), i);
                        r = o;
                        continue e
                    } else {
                        return i
                    }
                    break
                }
            }

            function SetTreeModule_ofArray(e, t) {
                return (0, a.fold)(((t, r) => SetTreeModule_add(e, r, t)), SetTreeModule_empty(), t)
            }

            function SetTreeModule_ofList(e, t) {
                return (0, s.fold)(((t, r) => SetTreeModule_add(e, r, t)), SetTreeModule_empty(), t)
            }

            function SetTreeModule_ofSeq(e, t) {
                if ((0, l.isArrayLike)(t)) {
                    return SetTreeModule_ofArray(e, t)
                } else if (t instanceof s.FSharpList) {
                    return SetTreeModule_ofList(e, t)
                } else {
                    const r = (0, l.getEnumerator)(t);
                    try {
                        return SetTreeModule_mkFromEnumerator(e, SetTreeModule_empty(), r)
                    } finally {
                        (0, l.disposeSafe)(r)
                    }
                }
            }
            class FSharpSet {
                constructor(e, t) {
                    this.comparer = e;
                    this.tree = t
                }
                GetHashCode() {
                    const e = this;
                    return FSharpSet__ComputeHashCode(e) | 0
                }
                Equals(e) {
                    const t = this;
                    return e instanceof FSharpSet && SetTreeModule_compare(FSharpSet__get_Comparer(t), FSharpSet__get_Tree(t), FSharpSet__get_Tree(e)) === 0
                }
                toString() {
                    const e = this;
                    return "set [" + (0, _.join)("; ", (0, u.map)((e => {
                        let t = e;
                        return (0, o.toString)(t)
                    }), e)) + "]"
                }
                get[Symbol.toStringTag]() {
                    return "FSharpSet"
                }
                toJSON(e) {
                    const t = this;
                    return Array.from(t)
                }
                CompareTo(e) {
                    const t = this;
                    return SetTreeModule_compare(FSharpSet__get_Comparer(t), FSharpSet__get_Tree(t), FSharpSet__get_Tree(e)) | 0
                } ["System.Collections.Generic.ICollection`1.Add2B595"](e) {
                    throw new Error("ReadOnlyCollection")
                } ["System.Collections.Generic.ICollection`1.Clear"]() {
                    throw new Error("ReadOnlyCollection")
                } ["System.Collections.Generic.ICollection`1.Remove2B595"](e) {
                    throw new Error("ReadOnlyCollection")
                } ["System.Collections.Generic.ICollection`1.Contains2B595"](e) {
                    const t = this;
                    return SetTreeModule_mem(FSharpSet__get_Comparer(t), e, FSharpSet__get_Tree(t))
                } ["System.Collections.Generic.ICollection`1.CopyToZ2E171D71"](e, t) {
                    const r = this;
                    SetTreeModule_copyToArray(FSharpSet__get_Tree(r), e, t)
                } ["System.Collections.Generic.ICollection`1.get_IsReadOnly"]() {
                    return true
                } ["System.Collections.Generic.ICollection`1.get_Count"]() {
                    const e = this;
                    return FSharpSet__get_Count(e) | 0
                } ["System.Collections.Generic.IReadOnlyCollection`1.get_Count"]() {
                    const e = this;
                    return FSharpSet__get_Count(e) | 0
                }
                GetEnumerator() {
                    const e = this;
                    return SetTreeModule_mkIEnumerator(FSharpSet__get_Tree(e))
                } [Symbol.iterator]() {
                    return (0, l.toIterator)(this.GetEnumerator())
                } ["System.Collections.IEnumerable.GetEnumerator"]() {
                    const e = this;
                    return SetTreeModule_mkIEnumerator(FSharpSet__get_Tree(e))
                }
                get size() {
                    const e = this;
                    return FSharpSet__get_Count(e) | 0
                }
                add(e) {
                    const t = this;
                    throw new Error("Set cannot be mutated");
                    return t
                }
                clear() {
                    throw new Error("Set cannot be mutated")
                }
                delete(e) {
                    throw new Error("Set cannot be mutated");
                    return false
                }
                has(e) {
                    const t = this;
                    return FSharpSet__Contains(t, e)
                }
                keys() {
                    const e = this;
                    return (0, u.map)((e => e), e)
                }
                values() {
                    const e = this;
                    return (0, u.map)((e => e), e)
                }
                entries() {
                    const e = this;
                    return (0, u.map)((e => [e, e]), e)
                }
                forEach(e, t) {
                    const r = this;
                    (0, u.iterate)((t => {
                        e(t, t, r)
                    }), r)
                }
            }
            t.FSharpSet = FSharpSet;

            function FSharpSet$reflection(e) {
                return (0, n.class_type)("Set.FSharpSet", [e], FSharpSet)
            }

            function FSharpSet_$ctor(e, t) {
                return new FSharpSet(e, t)
            }

            function FSharpSet__get_Comparer(e) {
                return e.comparer
            }

            function FSharpSet__get_Tree(e) {
                return e.tree
            }

            function FSharpSet_Empty(e) {
                return FSharpSet_$ctor(e, SetTreeModule_empty())
            }

            function FSharpSet__Add(e, t) {
                return FSharpSet_$ctor(FSharpSet__get_Comparer(e), SetTreeModule_add(FSharpSet__get_Comparer(e), t, FSharpSet__get_Tree(e)))
            }

            function FSharpSet__Remove(e, t) {
                return FSharpSet_$ctor(FSharpSet__get_Comparer(e), SetTreeModule_remove(FSharpSet__get_Comparer(e), t, FSharpSet__get_Tree(e)))
            }

            function FSharpSet__get_Count(e) {
                return SetTreeModule_count(FSharpSet__get_Tree(e))
            }

            function FSharpSet__Contains(e, t) {
                return SetTreeModule_mem(FSharpSet__get_Comparer(e), t, FSharpSet__get_Tree(e))
            }

            function FSharpSet__Iterate(e, t) {
                SetTreeModule_iter(t, FSharpSet__get_Tree(e))
            }

            function FSharpSet__Fold(e, t, r) {
                const n = t;
                return SetTreeModule_fold(((e, t) => n(t, e)), r, FSharpSet__get_Tree(e))
            }

            function FSharpSet__get_IsEmpty(e) {
                return FSharpSet__get_Tree(e) == null
            }

            function FSharpSet__Partition(e, t) {
                if (FSharpSet__get_Tree(e) == null) {
                    return [e, e]
                } else {
                    const r = SetTreeModule_partition(FSharpSet__get_Comparer(e), t, FSharpSet__get_Tree(e));
                    return [FSharpSet_$ctor(FSharpSet__get_Comparer(e), r[0]), FSharpSet_$ctor(FSharpSet__get_Comparer(e), r[1])]
                }
            }

            function FSharpSet__Filter(e, t) {
                if (FSharpSet__get_Tree(e) == null) {
                    return e
                } else {
                    return FSharpSet_$ctor(FSharpSet__get_Comparer(e), SetTreeModule_filter(FSharpSet__get_Comparer(e), t, FSharpSet__get_Tree(e)))
                }
            }

            function FSharpSet__Map(e, t, r) {
                return FSharpSet_$ctor(r, SetTreeModule_fold(((e, n) => SetTreeModule_add(r, t(n), e)), SetTreeModule_empty(), FSharpSet__get_Tree(e)))
            }

            function FSharpSet__Exists(e, t) {
                return SetTreeModule_exists(t, FSharpSet__get_Tree(e))
            }

            function FSharpSet__ForAll(e, t) {
                return SetTreeModule_forall(t, FSharpSet__get_Tree(e))
            }

            function FSharpSet_op_Subtraction(e, t) {
                if (FSharpSet__get_Tree(e) == null) {
                    return e
                } else if (FSharpSet__get_Tree(t) == null) {
                    return e
                } else {
                    return FSharpSet_$ctor(FSharpSet__get_Comparer(e), SetTreeModule_diff(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t)))
                }
            }

            function FSharpSet_op_Addition(e, t) {
                if (FSharpSet__get_Tree(t) == null) {
                    return e
                } else if (FSharpSet__get_Tree(e) == null) {
                    return t
                } else {
                    return FSharpSet_$ctor(FSharpSet__get_Comparer(e), SetTreeModule_union(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t)))
                }
            }

            function FSharpSet_Intersection(e, t) {
                if (FSharpSet__get_Tree(t) == null) {
                    return t
                } else if (FSharpSet__get_Tree(e) == null) {
                    return e
                } else {
                    return FSharpSet_$ctor(FSharpSet__get_Comparer(e), SetTreeModule_intersection(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t)))
                }
            }

            function FSharpSet_IntersectionMany(e) {
                return (0, u.reduce)(FSharpSet_Intersection, e)
            }

            function FSharpSet_Equality(e, t) {
                return SetTreeModule_compare(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t)) === 0
            }

            function FSharpSet_Compare(e, t) {
                return SetTreeModule_compare(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t))
            }

            function FSharpSet__get_Choose(e) {
                return SetTreeModule_choose(FSharpSet__get_Tree(e))
            }

            function FSharpSet__get_MinimumElement(e) {
                return SetTreeModule_minimumElement(FSharpSet__get_Tree(e))
            }

            function FSharpSet__get_MaximumElement(e) {
                return SetTreeModule_maximumElement(FSharpSet__get_Tree(e))
            }

            function FSharpSet__IsSubsetOf(e, t) {
                return SetTreeModule_subset(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t))
            }

            function FSharpSet__IsSupersetOf(e, t) {
                return SetTreeModule_subset(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(t), FSharpSet__get_Tree(e))
            }

            function FSharpSet__IsProperSubsetOf(e, t) {
                return SetTreeModule_properSubset(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t))
            }

            function FSharpSet__IsProperSupersetOf(e, t) {
                return SetTreeModule_properSubset(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(t), FSharpSet__get_Tree(e))
            }

            function FSharpSet__ToList(e) {
                return SetTreeModule_toList(FSharpSet__get_Tree(e))
            }

            function FSharpSet__ToArray(e) {
                return SetTreeModule_toArray(FSharpSet__get_Tree(e))
            }

            function FSharpSet__ComputeHashCode(e) {
                let t;
                let r = 0;
                const n = (0, l.getEnumerator)(e);
                try {
                    while (n["System.Collections.IEnumerator.MoveNext"]()) {
                        const e = n["System.Collections.Generic.IEnumerator`1.get_Current"]();
                        r = (t = (0, l.structuralHash)(e) | 0, (r << 1) + t + 631) | 0
                    }
                } finally {
                    (0, l.disposeSafe)(n)
                }
                return Math.abs(r) | 0
            }

            function isEmpty(e) {
                return FSharpSet__get_IsEmpty(e)
            }

            function contains(e, t) {
                return FSharpSet__Contains(t, e)
            }

            function add(e, t) {
                return FSharpSet__Add(t, e)
            }

            function singleton(e, t) {
                return FSharpSet__Add(FSharpSet_Empty(t), e)
            }

            function remove(e, t) {
                return FSharpSet__Remove(t, e)
            }

            function union(e, t) {
                return FSharpSet_op_Addition(e, t)
            }

            function unionMany(e, t) {
                return (0, u.fold)(FSharpSet_op_Addition, FSharpSet_Empty(t), e)
            }

            function intersect(e, t) {
                return FSharpSet_Intersection(e, t)
            }

            function intersectMany(e) {
                return FSharpSet_IntersectionMany(e)
            }

            function iterate(e, t) {
                FSharpSet__Iterate(t, e)
            }

            function empty(e) {
                return FSharpSet_Empty(e)
            }

            function forAll(e, t) {
                return FSharpSet__ForAll(t, e)
            }

            function exists(e, t) {
                return FSharpSet__Exists(t, e)
            }

            function filter(e, t) {
                return FSharpSet__Filter(t, e)
            }

            function partition(e, t) {
                return FSharpSet__Partition(t, e)
            }

            function fold(e, t, r) {
                return SetTreeModule_fold(e, t, FSharpSet__get_Tree(r))
            }

            function foldBack(e, t, r) {
                return SetTreeModule_foldBack(e, FSharpSet__get_Tree(t), r)
            }

            function map(e, t, r) {
                return FSharpSet__Map(t, e, r)
            }

            function count(e) {
                return FSharpSet__get_Count(e)
            }

            function ofList(e, t) {
                return FSharpSet_$ctor(t, SetTreeModule_ofSeq(t, e))
            }

            function ofArray(e, t) {
                return FSharpSet_$ctor(t, SetTreeModule_ofArray(t, e))
            }

            function toList(e) {
                return FSharpSet__ToList(e)
            }

            function toArray(e) {
                return FSharpSet__ToArray(e)
            }

            function toSeq(e) {
                return (0, u.map)((e => e), e)
            }

            function ofSeq(e, t) {
                return FSharpSet_$ctor(t, SetTreeModule_ofSeq(t, e))
            }

            function difference(e, t) {
                return FSharpSet_op_Subtraction(e, t)
            }

            function isSubset(e, t) {
                return SetTreeModule_subset(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t))
            }

            function isSuperset(e, t) {
                return SetTreeModule_subset(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(t), FSharpSet__get_Tree(e))
            }

            function isProperSubset(e, t) {
                return SetTreeModule_properSubset(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(e), FSharpSet__get_Tree(t))
            }

            function isProperSuperset(e, t) {
                return SetTreeModule_properSubset(FSharpSet__get_Comparer(e), FSharpSet__get_Tree(t), FSharpSet__get_Tree(e))
            }

            function minElement(e) {
                return FSharpSet__get_MinimumElement(e)
            }

            function maxElement(e) {
                return FSharpSet__get_MaximumElement(e)
            }

            function unionWith(e, t) {
                return (0, u.fold)(((e, t) => e.add(t)), e, t)
            }

            function newMutableSetWith(e, t) {
                if (e instanceof c.HashSet) {
                    return (0, c.HashSet_$ctor_Z6150332D)(t, (0, c.HashSet__get_Comparer)(e))
                } else {
                    return new Set(t)
                }
            }

            function intersectWith(e, t) {
                const r = newMutableSetWith(e, t);
                (0, u.iterate)((t => {
                    if (!r.has(t)) {
                        e.delete(t)
                    }
                }), e.values())
            }

            function exceptWith(e, t) {
                (0, u.iterate)((t => {
                    e.delete(t)
                }), t)
            }

            function isSubsetOf(e, t) {
                const r = newMutableSetWith(e, t);
                return (0, u.forAll)((e => r.has(e)), e.values())
            }

            function isSupersetOf(e, t) {
                return (0, u.forAll)((t => e.has(t)), t)
            }

            function isProperSubsetOf(e, t) {
                const r = newMutableSetWith(e, t);
                if (r.size > e.size) {
                    return (0, u.forAll)((e => r.has(e)), e.values())
                } else {
                    return false
                }
            }

            function isProperSupersetOf(e, t) {
                const r = (0, u.cache)(t);
                if ((0, u.exists)((t => !e.has(t)), r)) {
                    return (0, u.forAll)((t => e.has(t)), r)
                } else {
                    return false
                }
            }
        },
        9937: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.compare = compare;
            t.compareOrdinal = compareOrdinal;
            t.compareTo = compareTo;
            t.concat = concat;
            t.endsWith = endsWith;
            t.filter = filter;
            t.fmt = fmt;
            t.fmtWith = fmtWith;
            t.format = format;
            t.fromBase64String = fromBase64String;
            t.fsFormat = fsFormat;
            t.getCharAtIndex = getCharAtIndex;
            t.getFormat = getFormat;
            t.indexOfAny = indexOfAny;
            t.initialize = initialize;
            t.insert = insert;
            t.interpolate = interpolate;
            t.isNullOrEmpty = isNullOrEmpty;
            t.isNullOrWhiteSpace = isNullOrWhiteSpace;
            t.join = join;
            t.joinWithIndices = joinWithIndices;
            t.padLeft = padLeft;
            t.padRight = padRight;
            t.printf = printf;
            t.remove = remove;
            t.replace = replace;
            t.replicate = replicate;
            t.split = split;
            t.startsWith = startsWith;
            t.substring = substring;
            t.toBase64String = toBase64String;
            t.toConsole = toConsole;
            t.toConsoleError = toConsoleError;
            t.toFail = toFail;
            t.toText = toText;
            t.trim = trim;
            t.trimEnd = trimEnd;
            t.trimStart = trimStart;
            var n = r(13);
            var i = r(6468);
            var o = r(3493);
            var s = r(6638);
            const a = /(^|[^%])%([0+\- ]*)(\*|\d+)?(?:\.(\d+))?(\w)/g;
            const l = /(?:(^|[^%])%([0+\- ]*)(\d+)?(?:\.(\d+))?(\w))?%P\(\)/g;
            const _ = /\{(\d+)(,-?\d+)?(?:\:([a-zA-Z])(\d{0,2})|\:(.+?))?\}/g;

            function isLessThan(e, t) {
                return (0, i.compare)(e, t) < 0
            }

            function cmp(e, t, r) {
                function isIgnoreCase(e) {
                    return e === true || e === 1 || e === 3 || e === 5
                }

                function isOrdinal(e) {
                    return e === 4 || e === 5
                }
                if (e == null) {
                    return t == null ? 0 : -1
                }
                if (t == null) {
                    return 1
                }
                if (isOrdinal(r)) {
                    if (isIgnoreCase(r)) {
                        e = e.toLowerCase();
                        t = t.toLowerCase()
                    }
                    return e === t ? 0 : e < t ? -1 : 1
                } else {
                    if (isIgnoreCase(r)) {
                        e = e.toLocaleLowerCase();
                        t = t.toLocaleLowerCase()
                    }
                    return e.localeCompare(t)
                }
            }

            function compare(...e) {
                switch (e.length) {
                    case 2:
                        return cmp(e[0], e[1], false);
                    case 3:
                        return cmp(e[0], e[1], e[2]);
                    case 4:
                        return cmp(e[0], e[1], e[2] === true);
                    case 5:
                        return cmp(e[0].substr(e[1], e[4]), e[2].substr(e[3], e[4]), false);
                    case 6:
                        return cmp(e[0].substr(e[1], e[4]), e[2].substr(e[3], e[4]), e[5]);
                    case 7:
                        return cmp(e[0].substr(e[1], e[4]), e[2].substr(e[3], e[4]), e[5] === true);
                    default:
                        throw new Error("String.compare: Unsupported number of parameters")
                }
            }

            function compareOrdinal(e, t) {
                return cmp(e, t, 4)
            }

            function compareTo(e, t) {
                return cmp(e, t, 0)
            }

            function startsWith(e, t, r) {
                if (e.length >= t.length) {
                    return cmp(e.substr(0, t.length), t, r) === 0
                }
                return false
            }

            function indexOfAny(e, t, ...r) {
                if (e == null || e === "") {
                    return -1
                }
                const n = r.length > 0 ? r[0] : 0;
                if (n < 0) {
                    throw new Error("Start index cannot be negative")
                }
                const i = r.length > 1 ? r[1] : e.length - n;
                if (i < 0) {
                    throw new Error("Length cannot be negative")
                }
                if (i > e.length - n) {
                    throw new Error("Invalid startIndex and length")
                }
                e = e.substr(n, i);
                for (const r of t) {
                    const t = e.indexOf(r);
                    if (t > -1) {
                        return t + n
                    }
                }
                return -1
            }

            function printf(e) {
                return {
                    input: e,
                    cont: fsFormat(e)
                }
            }

            function interpolate(e, t) {
                let r = 0;
                let n = 0;
                let i = "";
                l.lastIndex = 0;
                let o = l.exec(e);
                while (o) {
                    const s = o.index + (o[1] || "").length;
                    i += e.substring(n, s).replace(/%%/g, "%");
                    const [, , a, _, u, c] = o;
                    i += formatReplacement(t[r++], a, _, u, c);
                    n = l.lastIndex;
                    l.lastIndex -= 1;
                    o = l.exec(e)
                }
                i += e.substring(n).replace(/%%/g, "%");
                return i
            }

            function continuePrint(e, t) {
                return typeof t === "string" ? e(t) : t.cont(e)
            }

            function toConsole(e) {
                return continuePrint((e => console.log(e)), e)
            }

            function toConsoleError(e) {
                return continuePrint((e => console.error(e)), e)
            }

            function toText(e) {
                return continuePrint((e => e), e)
            }

            function toFail(e) {
                return continuePrint((e => {
                    throw new Error(e)
                }), e)
            }

            function formatReplacement(e, t, r, o, a) {
                let l = "";
                t = t || "";
                a = a || "";
                if ((0, i.isNumeric)(e)) {
                    if (a.toLowerCase() !== "x") {
                        if (isLessThan(e, 0)) {
                            e = (0, i.multiply)(e, -1);
                            l = "-"
                        } else {
                            if (t.indexOf(" ") >= 0) {
                                l = " "
                            } else if (t.indexOf("+") >= 0) {
                                l = "+"
                            }
                        }
                    }
                    o = o == null ? null : parseInt(o, 10);
                    switch (a) {
                        case "f":
                        case "F":
                            o = o != null ? o : 6;
                            e = (0, i.toFixed)(e, o);
                            break;
                        case "g":
                        case "G":
                            e = o != null ? (0, i.toPrecision)(e, o) : (0, i.toPrecision)(e);
                            break;
                        case "e":
                        case "E":
                            e = o != null ? (0, i.toExponential)(e, o) : (0, i.toExponential)(e);
                            break;
                        case "x":
                            e = (0, i.toHex)(e);
                            break;
                        case "X":
                            e = (0, i.toHex)(e).toUpperCase();
                            break;
                        default:
                            e = String(e);
                            break
                    }
                } else if (e instanceof Date) {
                    e = (0, n.toString)(e)
                } else {
                    e = (0, s.toString)(e)
                }
                r = typeof r === "number" ? r : parseInt(r, 10);
                if (!isNaN(r)) {
                    const n = t.indexOf("0") >= 0;
                    const i = t.indexOf("-") >= 0;
                    const o = i || !n ? " " : "0";
                    if (o === "0") {
                        e = padLeft(e, r - l.length, o, i);
                        e = l + e
                    } else {
                        e = padLeft(l + e, r, o, i)
                    }
                } else {
                    e = l + e
                }
                return e
            }

            function createPrinter(e, t, r, n = "", i = -1) {
                return (...o) => {
                    let s = n;
                    const a = t.slice();
                    const l = r.slice();
                    for (const e of o) {
                        const [, , t, r, n, o] = l[0];
                        let _ = r;
                        if (i >= 0) {
                            _ = i;
                            i = -1
                        } else if (_ === "*") {
                            if (e < 0) {
                                throw new Error("Non-negative number required")
                            }
                            i = e;
                            continue
                        }
                        s += a[0];
                        s += formatReplacement(e, t, _, n, o);
                        a.splice(0, 1);
                        l.splice(0, 1)
                    }
                    if (l.length === 0) {
                        s += a[0];
                        return e(s)
                    } else {
                        return createPrinter(e, a, l, s, i)
                    }
                }
            }

            function fsFormat(e) {
                return t => {
                    a.lastIndex = 0;
                    const r = [];
                    const n = [];
                    let i = 0;
                    let o = a.exec(e);
                    while (o) {
                        const t = o.index + (o[1] || "").length;
                        r.push(e.substring(i, t).replace(/%%/g, "%"));
                        n.push(o);
                        i = a.lastIndex;
                        a.lastIndex -= 1;
                        o = a.exec(e)
                    }
                    if (r.length === 0) {
                        return t(e.replace(/%%/g, "%"))
                    } else {
                        r.push(e.substring(i).replace(/%%/g, "%"));
                        return createPrinter(t, r, n)
                    }
                }
            }

            function format(e, ...t) {
                if (typeof e === "object" && t.length > 0) {
                    e = t[0];
                    t.shift()
                }
                return e.replace(_, ((e, r, o, a, l, _) => {
                    if (r < 0 || r >= t.length) {
                        throw new Error("Index must be greater or equal to zero and less than the arguments' length.")
                    }
                    let u = t[r];
                    if ((0, i.isNumeric)(u)) {
                        l = l == null ? null : parseInt(l, 10);
                        switch (a) {
                            case "f":
                            case "F":
                                l = l != null ? l : 2;
                                u = (0, i.toFixed)(u, l);
                                break;
                            case "g":
                            case "G":
                                u = l != null ? (0, i.toPrecision)(u, l) : (0, i.toPrecision)(u);
                                break;
                            case "e":
                            case "E":
                                u = l != null ? (0, i.toExponential)(u, l) : (0, i.toExponential)(u);
                                break;
                            case "p":
                            case "P":
                                l = l != null ? l : 2;
                                u = (0, i.toFixed)((0, i.multiply)(u, 100), l) + " %";
                                break;
                            case "d":
                            case "D":
                                u = l != null ? padLeft(String(u), l, "0") : String(u);
                                break;
                            case "x":
                            case "X":
                                u = l != null ? padLeft((0, i.toHex)(u), l, "0") : (0, i.toHex)(u);
                                if (a === "X") {
                                    u = u.toUpperCase()
                                }
                                break;
                            default:
                                if (_) {
                                    let e = "";
                                    u = _.replace(/([0#,]+)(\.[0#]+)?/, ((t, r, n) => {
                                        if (isLessThan(u, 0)) {
                                            u = (0, i.multiply)(u, -1);
                                            e = "-"
                                        }
                                        const o = n != null ? n.length : 0;
                                        u = (0, i.toFixed)(u, Math.max(o - 1, 0));
                                        if (r.indexOf(",") > 0) {
                                            const [e, t] = u.split(".");
                                            const r = e.length % 3;
                                            const n = Math.floor(e.length / 3);
                                            let i = r > 0 ? e.substr(0, r) + (n > 0 ? "," : "") : "";
                                            for (let t = 0; t < n; t++) {
                                                i += e.substr(r + t * 3, 3) + (t < n - 1 ? "," : "")
                                            }
                                            u = t ? i + "." + t : i
                                        }
                                        r = r.replace(/,/g, "");
                                        const s = r.length > 0 && r[0] === "0" ? r.length : 0;
                                        return padLeft(u, s - e.length + o, "0")
                                    }));
                                    u = e + u
                                }
                        }
                    } else if (u instanceof Date) {
                        u = (0, n.toString)(u, _ || a)
                    } else {
                        u = (0, s.toString)(u)
                    }
                    o = parseInt((o || " ").substring(1), 10);
                    if (!isNaN(o)) {
                        u = padLeft(String(u), Math.abs(o), " ", o < 0)
                    }
                    return u
                }))
            }

            function endsWith(e, t) {
                const r = e.lastIndexOf(t);
                return r >= 0 && r === e.length - t.length
            }

            function initialize(e, t) {
                if (e < 0) {
                    throw new Error("String length must be non-negative")
                }
                const r = new Array(e);
                for (let n = 0; n < e; n++) {
                    r[n] = t(n)
                }
                return r.join("")
            }

            function insert(e, t, r) {
                if (t < 0 || t > e.length) {
                    throw new Error("startIndex is negative or greater than the length of this instance.")
                }
                return e.substring(0, t) + r + e.substring(t)
            }

            function isNullOrEmpty(e) {
                return typeof e !== "string" || e.length === 0
            }

            function isNullOrWhiteSpace(e) {
                return typeof e !== "string" || /^\s*$/.test(e)
            }

            function concat(...e) {
                return e.map((e => String(e))).join("")
            }

            function join(e, t) {
                if (Array.isArray(t)) {
                    return t.join(e)
                } else {
                    return Array.from(t).join(e)
                }
            }

            function joinWithIndices(e, t, r, n) {
                const i = r + n;
                if (i > t.length) {
                    throw new Error("Index and count must refer to a location within the buffer.")
                }
                return t.slice(r, i).join(e)
            }

            function notSupported(e) {
                throw new Error("The environment doesn't support '" + e + "', please use a polyfill.")
            }

            function toBase64String(e) {
                let t = "";
                for (let r = 0; r < e.length; r++) {
                    t += String.fromCharCode(e[r])
                }
                return typeof btoa === "function" ? btoa(t) : notSupported("btoa")
            }

            function fromBase64String(e) {
                const t = typeof atob === "function" ? atob(e) : notSupported("atob");
                const r = new Uint8Array(t.length);
                for (let e = 0; e < t.length; e++) {
                    r[e] = t.charCodeAt(e)
                }
                return r
            }

            function padLeft(e, t, r, n) {
                r = r || " ";
                t = t - e.length;
                for (let i = 0; i < t; i++) {
                    e = n ? e + r : r + e
                }
                return e
            }

            function padRight(e, t, r) {
                return padLeft(e, t, r, true)
            }

            function remove(e, t, r) {
                if (t >= e.length) {
                    throw new Error("startIndex must be less than length of string")
                }
                if (typeof r === "number" && t + r > e.length) {
                    throw new Error("Index and count must refer to a location within the string.")
                }
                return e.slice(0, t) + (typeof r === "number" ? e.substr(t + r) : "")
            }

            function replace(e, t, r) {
                return e.replace(new RegExp((0, o.escape)(t), "g"), r)
            }

            function replicate(e, t) {
                return initialize(e, (() => t))
            }

            function getCharAtIndex(e, t) {
                if (t < 0 || t >= e.length) {
                    throw new Error("Index was outside the bounds of the array.")
                }
                return e[t]
            }

            function split(e, t, r, n) {
                r = typeof r === "number" ? r : undefined;
                n = typeof n === "number" ? n : 0;
                if (r && r < 0) {
                    throw new Error("Count cannot be less than zero")
                }
                if (r === 0) {
                    return []
                }
                const i = (n & 1) === 1;
                const s = (n & 2) === 2;
                t = t || [];
                t = t.filter((e => e)).map(o.escape);
                t = t.length > 0 ? t : ["\\s"];
                const a = [];
                const l = new RegExp(t.join("|"), "g");
                let _ = true;
                let u = 0;
                do {
                    const t = l.exec(e);
                    if (t === null) {
                        const t = s ? e.substring(u).trim() : e.substring(u);
                        if (!i || t.length > 0) {
                            a.push(t)
                        }
                        _ = false
                    } else {
                        const n = s ? e.substring(u, t.index).trim() : e.substring(u, t.index);
                        if (!i || n.length > 0) {
                            if (r != null && a.length + 1 === r) {
                                a.push(s ? e.substring(u).trim() : e.substring(u));
                                _ = false
                            } else {
                                a.push(n)
                            }
                        }
                        u = l.lastIndex
                    }
                } while (_);
                return a
            }

            function trim(e, ...t) {
                if (t.length === 0) {
                    return e.trim()
                }
                const r = "[" + (0, o.escape)(t.join("")) + "]+";
                return e.replace(new RegExp("^" + r), "").replace(new RegExp(r + "$"), "")
            }

            function trimStart(e, ...t) {
                return t.length === 0 ? e.trimStart() : e.replace(new RegExp("^[" + (0, o.escape)(t.join("")) + "]+"), "")
            }

            function trimEnd(e, ...t) {
                return t.length === 0 ? e.trimEnd() : e.replace(new RegExp("[" + (0, o.escape)(t.join("")) + "]+$"), "")
            }

            function filter(e, t) {
                return t.split("").filter((t => e(t))).join("")
            }

            function substring(e, t, r) {
                if (t + (r || 0) > e.length) {
                    throw new Error("Invalid startIndex and/or length")
                }
                return r != null ? e.substr(t, r) : e.substr(t)
            }

            function fmt(e, ...t) {
                return {
                    strs: e,
                    args: t
                }
            }

            function fmtWith(e) {
                return (t, ...r) => ({
                    strs: t,
                    args: r,
                    fmts: e
                })
            }

            function getFormat(e) {
                return e.fmts ? e.strs.reduce(((t, r, n) => t + `{${String(n-1)+e.fmts[n-1]}}` + r)) : e.strs.reduce(((e, t, r) => e + `{${r-1}}` + t))
            }
        },
        8443: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.StringBuilder = void 0;
            t.StringBuilder$reflection = StringBuilder$reflection;
            t.StringBuilder_$ctor = StringBuilder_$ctor;
            t.StringBuilder_$ctor_Z18115A39 = StringBuilder_$ctor_Z18115A39;
            t.StringBuilder_$ctor_Z524259A4 = StringBuilder_$ctor_Z524259A4;
            t.StringBuilder_$ctor_Z721C83C5 = StringBuilder_$ctor_Z721C83C5;
            t.StringBuilder__AppendFormat_433E080 = StringBuilder__AppendFormat_433E080;
            t.StringBuilder__AppendLine = StringBuilder__AppendLine;
            t.StringBuilder__AppendLine_Z721C83C5 = StringBuilder__AppendLine_Z721C83C5;
            t.StringBuilder__Append_244C7CD6 = StringBuilder__Append_244C7CD6;
            t.StringBuilder__Append_43A65C09 = StringBuilder__Append_43A65C09;
            t.StringBuilder__Append_4E60E31B = StringBuilder__Append_4E60E31B;
            t.StringBuilder__Append_5E38073B = StringBuilder__Append_5E38073B;
            t.StringBuilder__Append_695F1130 = StringBuilder__Append_695F1130;
            t.StringBuilder__Append_Z1FBCCD16 = StringBuilder__Append_Z1FBCCD16;
            t.StringBuilder__Append_Z524259A4 = StringBuilder__Append_Z524259A4;
            t.StringBuilder__Append_Z721C83C5 = StringBuilder__Append_Z721C83C5;
            t.StringBuilder__Clear = StringBuilder__Clear;
            t.StringBuilder__ToString_Z37302880 = StringBuilder__ToString_Z37302880;
            t.StringBuilder__get_Length = StringBuilder__get_Length;
            var n = r(9937);
            var i = r(6356);
            var o = r(4222);
            var s = r(6638);
            class StringBuilder {
                constructor(e, t) {
                    this.buf = [];
                    if (!(0, n.isNullOrEmpty)(e)) {
                        void this.buf.push(e)
                    }
                }
                toString() {
                    const e = this;
                    return (0, n.join)("", e.buf)
                }
            }
            t.StringBuilder = StringBuilder;

            function StringBuilder$reflection() {
                return (0, i.class_type)("System.Text.StringBuilder", void 0, StringBuilder)
            }

            function StringBuilder_$ctor_Z18115A39(e, t) {
                return new StringBuilder(e, t)
            }

            function StringBuilder_$ctor_Z524259A4(e) {
                return StringBuilder_$ctor_Z18115A39("", e)
            }

            function StringBuilder_$ctor_Z721C83C5(e) {
                return StringBuilder_$ctor_Z18115A39(e, 16)
            }

            function StringBuilder_$ctor() {
                return StringBuilder_$ctor_Z18115A39("", 16)
            }

            function StringBuilder__Append_Z721C83C5(e, t) {
                void e.buf.push(t);
                return e
            }

            function StringBuilder__Append_244C7CD6(e, t) {
                void e.buf.push(t);
                return e
            }

            function StringBuilder__Append_Z524259A4(e, t) {
                void e.buf.push((0, o.int32ToString)(t));
                return e
            }

            function StringBuilder__Append_5E38073B(e, t) {
                void e.buf.push(t.toString());
                return e
            }

            function StringBuilder__Append_Z1FBCCD16(e, t) {
                void e.buf.push((0, s.toString)(t));
                return e
            }

            function StringBuilder__Append_4E60E31B(e, t) {
                void e.buf.push((0, s.toString)(t));
                return e
            }

            function StringBuilder__Append_695F1130(e, t) {
                void e.buf.push(t.join(""));
                return e
            }

            function StringBuilder__Append_43A65C09(e, t) {
                void e.buf.push((0, s.toString)(t));
                return e
            }

            function StringBuilder__AppendFormat_433E080(e, t, r) {
                void e.buf.push((0, n.format)(t, r));
                return e
            }

            function StringBuilder__AppendLine(e) {
                void e.buf.push("\n");
                return e
            }

            function StringBuilder__AppendLine_Z721C83C5(e, t) {
                void e.buf.push(t);
                void e.buf.push("\n");
                return e
            }

            function StringBuilder__get_Length(e) {
                let t = 0;
                for (let r = e.buf.length - 1; r >= 0; r--) {
                    t = t + e.buf[r].length | 0
                }
                return t | 0
            }

            function StringBuilder__ToString_Z37302880(e, t, r) {
                return (0, n.substring)((0, s.toString)(e), t, r)
            }

            function StringBuilder__Clear(e) {
                (0, o.clear)(e.buf);
                return e
            }
        },
        6638: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Union = t.Record = t.MatchFailureException = t.FSharpRef = t.FSharpException = t.Exception = t.Attribute = void 0;
            t.isException = isException;
            t.seqToString = seqToString;
            t.toString = toString;
            t.unionToString = unionToString;
            var n = r(4222);

            function seqToString(e) {
                let t = 0;
                let r = "[";
                for (const n of e) {
                    if (t === 0) {
                        r += toString(n)
                    } else if (t === 100) {
                        r += "; ...";
                        break
                    } else {
                        r += "; " + toString(n)
                    }
                    t++
                }
                return r + "]"
            }

            function toString(e, t = 0) {
                if (e != null && typeof e === "object") {
                    if (typeof e.toString === "function") {
                        return e.toString()
                    } else if (Symbol.iterator in e) {
                        return seqToString(e)
                    } else {
                        const r = Object.getPrototypeOf(e).constructor;
                        return r === Object && t < 10 ? "{ " + Object.entries(e).map((([e, r]) => e + " = " + toString(r, t + 1))).join("\n  ") + " }" : r.name
                    }
                }
                return String(e)
            }

            function unionToString(e, t) {
                if (t.length === 0) {
                    return e
                } else {
                    let r = "";
                    let n = true;
                    if (t.length === 1) {
                        r = toString(t[0]);
                        n = r.indexOf(" ") >= 0
                    } else {
                        r = t.map((e => toString(e))).join(", ")
                    }
                    return e + (n ? " (" : " ") + r + (n ? ")" : "")
                }
            }
            class Union {
                get name() {
                    return this.cases()[this.tag]
                }
                toJSON() {
                    return this.fields.length === 0 ? this.name : [this.name].concat(this.fields)
                }
                toString() {
                    return unionToString(this.name, this.fields)
                }
                GetHashCode() {
                    const e = this.fields.map((e => (0, n.structuralHash)(e)));
                    e.splice(0, 0, (0, n.numberHash)(this.tag));
                    return (0, n.combineHashCodes)(e)
                }
                Equals(e) {
                    if (this === e) {
                        return true
                    } else if (!(0, n.sameConstructor)(this, e)) {
                        return false
                    } else if (this.tag === e.tag) {
                        return (0, n.equalArrays)(this.fields, e.fields)
                    } else {
                        return false
                    }
                }
                CompareTo(e) {
                    if (this === e) {
                        return 0
                    } else if (!(0, n.sameConstructor)(this, e)) {
                        return -1
                    } else if (this.tag === e.tag) {
                        return (0, n.compareArrays)(this.fields, e.fields)
                    } else {
                        return this.tag < e.tag ? -1 : 1
                    }
                }
            }
            t.Union = Union;

            function recordToJSON(e) {
                const t = {};
                const r = Object.keys(e);
                for (let n = 0; n < r.length; n++) {
                    t[r[n]] = e[r[n]]
                }
                return t
            }

            function recordToString(e) {
                return "{ " + Object.entries(e).map((([e, t]) => e + " = " + toString(t))).join("\n  ") + " }"
            }

            function recordGetHashCode(e) {
                const t = Object.values(e).map((e => (0, n.structuralHash)(e)));
                return (0, n.combineHashCodes)(t)
            }

            function recordEquals(e, t) {
                if (e === t) {
                    return true
                } else if (!(0, n.sameConstructor)(e, t)) {
                    return false
                } else {
                    const r = Object.keys(e);
                    for (let i = 0; i < r.length; i++) {
                        if (!(0, n.equals)(e[r[i]], t[r[i]])) {
                            return false
                        }
                    }
                    return true
                }
            }

            function recordCompareTo(e, t) {
                if (e === t) {
                    return 0
                } else if (!(0, n.sameConstructor)(e, t)) {
                    return -1
                } else {
                    const r = Object.keys(e);
                    for (let i = 0; i < r.length; i++) {
                        const o = (0, n.compare)(e[r[i]], t[r[i]]);
                        if (o !== 0) {
                            return o
                        }
                    }
                    return 0
                }
            }
            class Record {
                toJSON() {
                    return recordToJSON(this)
                }
                toString() {
                    return recordToString(this)
                }
                GetHashCode() {
                    return recordGetHashCode(this)
                }
                Equals(e) {
                    return recordEquals(this, e)
                }
                CompareTo(e) {
                    return recordCompareTo(this, e)
                }
            }
            t.Record = Record;
            class FSharpRef {
                constructor(e, t) {
                    if (typeof t === "function") {
                        this.getter = e;
                        this.setter = t
                    } else {
                        this.getter = () => e;
                        this.setter = t => {
                            e = t
                        }
                    }
                }
                get contents() {
                    return this.getter()
                }
                set contents(e) {
                    this.setter(e)
                }
            }
            t.FSharpRef = FSharpRef;
            class Exception {
                constructor(e) {
                    this.message = e
                }
            }
            t.Exception = Exception;

            function isException(e) {
                return e instanceof Exception || e instanceof Error
            }
            class FSharpException extends Exception {
                toJSON() {
                    return recordToJSON(this)
                }
                toString() {
                    return recordToString(this)
                }
                GetHashCode() {
                    return recordGetHashCode(this)
                }
                Equals(e) {
                    return recordEquals(this, e)
                }
                CompareTo(e) {
                    return recordCompareTo(this, e)
                }
            }
            t.FSharpException = FSharpException;
            class MatchFailureException extends FSharpException {
                constructor(e, t, r) {
                    super();
                    this.arg1 = e;
                    this.arg2 = t | 0;
                    this.arg3 = r | 0;
                    this.message = "The match cases were incomplete"
                }
            }
            t.MatchFailureException = MatchFailureException;
            class Attribute {}
            t.Attribute = Attribute
        },
        4222: (e, t) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ObjectRef = t.Lazy = t.Enumerator = t.Comparer = void 0;
            t.arrayHash = arrayHash;
            t.assertEqual = assertEqual;
            t.assertNotEqual = assertNotEqual;
            t.checkArity = checkArity;
            t.clamp = clamp;
            t.clear = clear;
            t.combineHashCodes = combineHashCodes;
            t.compare = compare;
            t.compareArrays = compareArrays;
            t.compareArraysWith = compareArraysWith;
            t.compareDates = compareDates;
            t.comparePrimitives = comparePrimitives;
            t.comparerFromEqualityComparer = comparerFromEqualityComparer;
            t.count = count;
            t.createAtom = createAtom;
            t.createObj = createObj;
            t.curry = curry;
            t.dateHash = dateHash;
            t.dateOffset = dateOffset;
            t.disposeSafe = disposeSafe;
            t.equalArrays = equalArrays;
            t.equalArraysWith = equalArraysWith;
            t.equals = equals;
            t.escapeDataString = escapeDataString;
            t.escapeUriString = escapeUriString;
            t.fastStructuralHash = fastStructuralHash;
            t.getEnumerator = getEnumerator;
            t.identityHash = identityHash;
            t.int16ToString = int16ToString;
            t.int32ToString = int32ToString;
            t.isArrayLike = isArrayLike;
            t.isDisposable = isDisposable;
            t.isIterable = isIterable;
            t.jsOptions = jsOptions;
            t.lazyFromValue = lazyFromValue;
            t.mapCurriedArgs = mapCurriedArgs;
            t.max = max;
            t.min = min;
            t.numberHash = numberHash;
            t.padLeftAndRightWithZeros = padLeftAndRightWithZeros;
            t.padWithZeros = padWithZeros;
            t.partialApply = partialApply;
            t.physicalHash = physicalHash;
            t.round = round;
            t.safeHash = safeHash;
            t.sameConstructor = sameConstructor;
            t.sign = sign;
            t.stringHash = stringHash;
            t.structuralHash = structuralHash;
            t.toIterator = toIterator;
            t.uncurry = uncurry;
            t.unescapeDataString = unescapeDataString;

            function isIterable(e) {
                return e != null && typeof e === "object" && Symbol.iterator in e
            }

            function isArrayLike(e) {
                return Array.isArray(e) || ArrayBuffer.isView(e)
            }

            function isComparer(e) {
                return typeof e.Compare === "function"
            }

            function isComparable(e) {
                return typeof e.CompareTo === "function"
            }

            function isEquatable(e) {
                return typeof e.Equals === "function"
            }

            function isHashable(e) {
                return typeof e.GetHashCode === "function"
            }

            function isDisposable(e) {
                return e != null && typeof e.Dispose === "function"
            }

            function disposeSafe(e) {
                if (isDisposable(e)) {
                    e.Dispose()
                }
            }

            function sameConstructor(e, t) {
                return Object.getPrototypeOf(e).constructor === Object.getPrototypeOf(t).constructor
            }
            class Enumerator {
                constructor(e) {
                    this.iter = e
                } ["System.Collections.Generic.IEnumerator`1.get_Current"]() {
                    return this.current
                } ["System.Collections.IEnumerator.get_Current"]() {
                    return this.current
                } ["System.Collections.IEnumerator.MoveNext"]() {
                    const e = this.iter.next();
                    this.current = e.value;
                    return !e.done
                } ["System.Collections.IEnumerator.Reset"]() {
                    throw new Error("JS iterators cannot be reset")
                }
                Dispose() {
                    return
                }
            }
            t.Enumerator = Enumerator;

            function getEnumerator(e) {
                return typeof e.GetEnumerator === "function" ? e.GetEnumerator() : new Enumerator(e[Symbol.iterator]())
            }

            function toIterator(e) {
                return {
                    [Symbol.iterator]() {
                        return this
                    },
                    next() {
                        const t = e["System.Collections.IEnumerator.MoveNext"]();
                        const r = t ? e["System.Collections.IEnumerator.get_Current"]() : undefined;
                        return {
                            done: !t,
                            value: r
                        }
                    }
                }
            }
            class Comparer {
                constructor(e) {
                    this.Compare = e || compare
                }
            }
            t.Comparer = Comparer;

            function comparerFromEqualityComparer(e) {
                if (isComparer(e)) {
                    return new Comparer(e.Compare)
                } else {
                    return new Comparer(((t, r) => {
                        const n = e.GetHashCode(t);
                        const i = e.GetHashCode(r);
                        if (n === i) {
                            return e.Equals(t, r) ? 0 : -1
                        } else {
                            return n < i ? -1 : 1
                        }
                    }))
                }
            }

            function assertEqual(e, t, r) {
                if (!equals(e, t)) {
                    throw Object.assign(new Error(r || `Expected: ${t} - Actual: ${e}`), {
                        actual: e,
                        expected: t
                    })
                }
            }

            function assertNotEqual(e, t, r) {
                if (equals(e, t)) {
                    throw Object.assign(new Error(r || `Expected: ${t} - Actual: ${e}`), {
                        actual: e,
                        expected: t
                    })
                }
            }
            class Lazy {
                constructor(e) {
                    this.factory = e;
                    this.isValueCreated = false
                }
                get Value() {
                    if (!this.isValueCreated) {
                        this.createdValue = this.factory();
                        this.isValueCreated = true
                    }
                    return this.createdValue
                }
                get IsValueCreated() {
                    return this.isValueCreated
                }
            }
            t.Lazy = Lazy;

            function lazyFromValue(e) {
                return new Lazy((() => e))
            }

            function padWithZeros(e, t) {
                let r = e.toString(10);
                while (r.length < t) {
                    r = "0" + r
                }
                return r
            }

            function padLeftAndRightWithZeros(e, t, r) {
                let n = e.toString(10);
                while (n.length < t) {
                    n = "0" + n
                }
                while (n.length < r) {
                    n = n + "0"
                }
                return n
            }

            function dateOffset(e) {
                const t = e;
                return typeof t.offset === "number" ? t.offset : e.kind === 1 ? 0 : e.getTimezoneOffset() * -6e4
            }

            function int16ToString(e, t) {
                e = e < 0 && t != null && t !== 10 ? 65535 + e + 1 : e;
                return e.toString(t)
            }

            function int32ToString(e, t) {
                e = e < 0 && t != null && t !== 10 ? 4294967295 + e + 1 : e;
                return e.toString(t)
            }
            class ObjectRef {
                static id(e) {
                    if (!ObjectRef.idMap.has(e)) {
                        ObjectRef.idMap.set(e, ++ObjectRef.count)
                    }
                    return ObjectRef.idMap.get(e)
                }
            }
            t.ObjectRef = ObjectRef;
            ObjectRef.idMap = new WeakMap;
            ObjectRef.count = 0;

            function stringHash(e) {
                let t = 0;
                let r = 5381;
                const n = e.length;
                while (t < n) {
                    r = r * 33 ^ e.charCodeAt(t++)
                }
                return r
            }

            function numberHash(e) {
                return e * 2654435761 | 0
            }

            function combineHashCodes(e) {
                if (e.length === 0) {
                    return 0
                }
                return e.reduce(((e, t) => (e << 5) + e ^ t))
            }

            function physicalHash(e) {
                if (e == null) {
                    return 0
                }
                switch (typeof e) {
                    case "boolean":
                        return e ? 1 : 0;
                    case "number":
                        return numberHash(e);
                    case "string":
                        return stringHash(e);
                    default:
                        return numberHash(ObjectRef.id(e))
                }
            }

            function identityHash(e) {
                if (e == null) {
                    return 0
                } else if (isHashable(e)) {
                    return e.GetHashCode()
                } else {
                    return physicalHash(e)
                }
            }

            function dateHash(e) {
                return e.getTime()
            }

            function arrayHash(e) {
                const t = e.length;
                const r = new Array(t);
                for (let n = 0; n < t; n++) {
                    r[n] = structuralHash(e[n])
                }
                return combineHashCodes(r)
            }

            function structuralHash(e) {
                if (e == null) {
                    return 0
                }
                switch (typeof e) {
                    case "boolean":
                        return e ? 1 : 0;
                    case "number":
                        return numberHash(e);
                    case "string":
                        return stringHash(e);
                    default: {
                        if (isHashable(e)) {
                            return e.GetHashCode()
                        } else if (isArrayLike(e)) {
                            return arrayHash(e)
                        } else if (e instanceof Date) {
                            return dateHash(e)
                        } else if (Object.getPrototypeOf(e).constructor === Object) {
                            const t = Object.values(e).map((e => structuralHash(e)));
                            return combineHashCodes(t)
                        } else {
                            return numberHash(ObjectRef.id(e))
                        }
                    }
                }
            }

            function fastStructuralHash(e) {
                return stringHash(String(e))
            }

            function safeHash(e) {
                return e == null ? 0 : isHashable(e) ? e.GetHashCode() : numberHash(ObjectRef.id(e))
            }

            function equalArraysWith(e, t, r) {
                if (e == null) {
                    return t == null
                }
                if (t == null) {
                    return false
                }
                if (e.length !== t.length) {
                    return false
                }
                for (let n = 0; n < e.length; n++) {
                    if (!r(e[n], t[n])) {
                        return false
                    }
                }
                return true
            }

            function equalArrays(e, t) {
                return equalArraysWith(e, t, equals)
            }

            function equalObjects(e, t) {
                const r = Object.keys(e);
                const n = Object.keys(t);
                if (r.length !== n.length) {
                    return false
                }
                r.sort();
                n.sort();
                for (let i = 0; i < r.length; i++) {
                    if (r[i] !== n[i] || !equals(e[r[i]], t[n[i]])) {
                        return false
                    }
                }
                return true
            }

            function equals(e, t) {
                if (e === t) {
                    return true
                } else if (e == null) {
                    return t == null
                } else if (t == null) {
                    return false
                } else if (typeof e !== "object") {
                    return false
                } else if (isEquatable(e)) {
                    return e.Equals(t)
                } else if (isArrayLike(e)) {
                    return isArrayLike(t) && equalArrays(e, t)
                } else if (e instanceof Date) {
                    return t instanceof Date && compareDates(e, t) === 0
                } else {
                    return Object.getPrototypeOf(e).constructor === Object && equalObjects(e, t)
                }
            }

            function compareDates(e, t) {
                let r;
                let n;
                if ("offset" in e && "offset" in t) {
                    r = e.getTime();
                    n = t.getTime()
                } else {
                    r = e.getTime() + dateOffset(e);
                    n = t.getTime() + dateOffset(t)
                }
                return r === n ? 0 : r < n ? -1 : 1
            }

            function comparePrimitives(e, t) {
                return e === t ? 0 : e < t ? -1 : 1
            }

            function compareArraysWith(e, t, r) {
                if (e == null) {
                    return t == null ? 0 : 1
                }
                if (t == null) {
                    return -1
                }
                if (e.length !== t.length) {
                    return e.length < t.length ? -1 : 1
                }
                for (let n = 0, i = 0; n < e.length; n++) {
                    i = r(e[n], t[n]);
                    if (i !== 0) {
                        return i
                    }
                }
                return 0
            }

            function compareArrays(e, t) {
                return compareArraysWith(e, t, compare)
            }

            function compareObjects(e, t) {
                const r = Object.keys(e);
                const n = Object.keys(t);
                if (r.length !== n.length) {
                    return r.length < n.length ? -1 : 1
                }
                r.sort();
                n.sort();
                for (let i = 0, o = 0; i < r.length; i++) {
                    const s = r[i];
                    if (s !== n[i]) {
                        return s < n[i] ? -1 : 1
                    } else {
                        o = compare(e[s], t[s]);
                        if (o !== 0) {
                            return o
                        }
                    }
                }
                return 0
            }

            function compare(e, t) {
                if (e === t) {
                    return 0
                } else if (e == null) {
                    return t == null ? 0 : -1
                } else if (t == null) {
                    return 1
                } else if (typeof e !== "object") {
                    return e < t ? -1 : 1
                } else if (isComparable(e)) {
                    return e.CompareTo(t)
                } else if (isArrayLike(e)) {
                    return isArrayLike(t) ? compareArrays(e, t) : -1
                } else if (e instanceof Date) {
                    return t instanceof Date ? compareDates(e, t) : -1
                } else {
                    return Object.getPrototypeOf(e).constructor === Object ? compareObjects(e, t) : -1
                }
            }

            function min(e, t, r) {
                return e(t, r) < 0 ? t : r
            }

            function max(e, t, r) {
                return e(t, r) > 0 ? t : r
            }

            function clamp(e, t, r, n) {
                return e(t, r) < 0 ? r : e(t, n) > 0 ? n : t
            }

            function createAtom(e) {
                let t = e;
                return (e, r) => {
                    if (!r) {
                        return t
                    } else {
                        t = e;
                        return void 0
                    }
                }
            }

            function createObj(e) {
                const t = {};
                for (const r of e) {
                    t[r[0]] = r[1]
                }
                return t
            }

            function jsOptions(e) {
                const t = {};
                e(t);
                return t
            }

            function round(e, t = 0) {
                const r = Math.pow(10, t);
                const n = +(t ? e * r : e).toFixed(8);
                const i = Math.floor(n);
                const o = n - i;
                const s = 1e-8;
                const a = o > .5 - s && o < .5 + s ? i % 2 === 0 ? i : i + 1 : Math.round(n);
                return t ? a / r : a
            }

            function sign(e) {
                return e > 0 ? 1 : e < 0 ? -1 : 0
            }

            function unescapeDataString(e) {
                return decodeURIComponent(e.replace(/\+/g, "%20"))
            }

            function escapeDataString(e) {
                return encodeURIComponent(e).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A")
            }

            function escapeUriString(e) {
                return encodeURI(e)
            }

            function count(e) {
                if (isArrayLike(e)) {
                    return e.length
                } else {
                    let t = 0;
                    for (const r of e) {
                        t++
                    }
                    return t
                }
            }

            function clear(e) {
                if (isArrayLike(e)) {
                    e.splice(0)
                } else {
                    e.clear()
                }
            }
            const r = Symbol("curried");

            function uncurry(e, t) {
                if (t == null || t.length > 1) {
                    return t
                }
                const uncurried = (...r) => {
                    let n = t;
                    for (let t = 0; t < e; t++) {
                        n = n(r[t])
                    }
                    return n
                };
                uncurried[r] = t;
                return uncurried
            }

            function _curry(e, t, r) {
                return n => t === 1 ? r(...e.concat([n])) : _curry(e.concat([n]), t - 1, r)
            }

            function curry(e, t) {
                if (t == null || t.length === 1) {
                    return t
                } else if (r in t) {
                    return t[r]
                } else {
                    return _curry([], e, t)
                }
            }

            function checkArity(e, t) {
                return t.length > e ? (...e) => (...r) => t.apply(undefined, e.concat(r)) : t
            }

            function partialApply(e, t, n) {
                if (t == null) {
                    return undefined
                } else if (r in t) {
                    t = t[r];
                    for (let e = 0; e < n.length; e++) {
                        t = t(n[e])
                    }
                    return t
                } else {
                    return _curry(n, e, t)
                }
            }

            function mapCurriedArgs(e, t) {
                function mapArg(e, t, r, n) {
                    const i = r[n];
                    if (i !== 0) {
                        const e = i[0];
                        const r = i[1];
                        if (e > 1) {
                            t = curry(e, t)
                        }
                        if (r > 1) {
                            t = uncurry(r, t)
                        }
                    }
                    const o = e(t);
                    if (n + 1 === r.length) {
                        return o
                    } else {
                        return e => mapArg(o, e, r, n + 1)
                    }
                }
                return r => mapArg(e, r, t, 0)
            }
        },
        524: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t["default"] = t.Big = void 0;
            var n = r(4222);
            var i = r(6468);
            var o = {
                GetHashCode() {
                    return (0, n.combineHashCodes)([this.s, this.e].concat(this.c))
                },
                Equals(e) {
                    return !this.cmp(e)
                },
                CompareTo(e) {
                    return this.cmp(e)
                },
                [i.symbol]() {
                    const e = this;
                    return {
                        multiply: t => e.mul(t),
                        toPrecision: t => e.toPrecision(t),
                        toExponential: t => e.toExponential(t),
                        toFixed: t => e.toFixed(t),
                        toHex: () => (Number(e) >>> 0).toString(16)
                    }
                }
            };
            var s = 28,
                a = 1,
                l = 1e6,
                _ = 1e6,
                u = -29,
                c = 29,
                d = false,
                p = "[big.js] ",
                f = p + "Invalid ",
                h = f + "decimal places",
                g = f + "rounding mode",
                m = p + "Division by zero",
                y = void 0,
                S = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;

            function _Big_() {
                function Big(e) {
                    var t = this;
                    if (!(t instanceof Big)) return e === y ? _Big_() : new Big(e);
                    if (e instanceof Big) {
                        t.s = e.s;
                        t.e = e.e;
                        t.c = e.c.slice();
                        normalize(t)
                    } else {
                        if (typeof e !== "string") {
                            if (Big.strict === true) {
                                throw TypeError(f + "number")
                            }
                            e = e === 0 && 1 / e < 0 ? "-0" : String(e)
                        }
                        parse(t, e)
                    }
                    t.constructor = Big
                }
                Big.prototype = o;
                Big.DP = s;
                Big.RM = a;
                Big.NE = u;
                Big.PE = c;
                Big.strict = d;
                return Big
            }

            function normalize(e) {
                if (e.c.length > 1 && !e.c[0]) {
                    let t = e.c.findIndex((e => e));
                    e.c = e.c.slice(t);
                    e.e = e.e - t
                }
            }

            function parse(e, t) {
                var r, n, i;
                if (!S.test(t)) {
                    throw Error(f + "number")
                }
                e.s = t.charAt(0) == "-" ? (t = t.slice(1), -1) : 1;
                if ((r = t.indexOf(".")) > -1) t = t.replace(".", "");
                if ((n = t.search(/e/i)) > 0) {
                    if (r < 0) r = n;
                    r += +t.slice(n + 1);
                    t = t.substring(0, n)
                } else if (r < 0) {
                    r = t.length
                }
                i = t.length;
                for (n = 0; n < r && n < i && t.charAt(n) == "0";) ++n;
                if (n == i) {
                    e.c = [e.e = 0]
                } else {
                    e.e = r - n - 1;
                    e.c = [];
                    for (r = 0; n < i;) e.c[r++] = +t.charAt(n++)
                }
                e = round(e, T.DP + 1, T.RM);
                return e
            }

            function round(e, t, r, n) {
                var i = e.c;
                if (r === y) r = T.RM;
                if (r !== 0 && r !== 1 && r !== 2 && r !== 3) {
                    throw Error(g)
                }
                if (t < 1) {
                    n = r === 3 && (n || !!i[0]) || t === 0 && (r === 1 && i[0] >= 5 || r === 2 && (i[0] > 5 || i[0] === 5 && (n || i[1] !== y)));
                    i.length = 1;
                    if (n) {
                        e.e = e.e - t + 1;
                        i[0] = 1
                    } else {
                        i[0] = e.e = 0
                    }
                } else if (t < i.length) {
                    const o = i.findIndex(((e, r) => r >= t && e > 0)) < 0;
                    n = r === 1 && i[t] >= 5 || r === 2 && (i[t] > 5 || i[t] === 5 && (n || i[t + 1] !== y || i[t - 1] & 1)) || r === 3 && (n || !o);
                    i.length = t--;
                    if (n) {
                        for (; ++i[t] > 9;) {
                            i[t] = 0;
                            if (!t--) {
                                ++e.e;
                                i.unshift(1)
                            }
                        }
                    }
                    for (t = i.length; !i[--t];) i.pop()
                }
                return e
            }

            function stringify(e, t, r) {
                var n = e.e,
                    i = e.c.join(""),
                    o = i.length;
                if (t) {
                    i = i.charAt(0) + (o > 1 ? "." + i.slice(1) : "") + (n < 0 ? "e" : "e+") + n
                } else if (n < 0) {
                    for (; ++n;) i = "0" + i;
                    i = "0." + i
                } else if (n > 0) {
                    if (++n > o) {
                        for (n -= o; n--;) i += "0"
                    } else if (n < o) {
                        i = i.slice(0, n) + "." + i.slice(n)
                    }
                } else if (o > 1) {
                    i = i.charAt(0) + "." + i.slice(1)
                }
                return e.s < 0 && r ? "-" + i : i
            }
            o.abs = function() {
                var e = new this.constructor(this);
                e.s = 1;
                return e
            };
            o.cmp = function(e) {
                var t, r = this.constructor,
                    n = new r(this),
                    e = new r(e),
                    i = n.c,
                    o = e.c,
                    s = n.s,
                    a = e.s,
                    l = n.e,
                    _ = e.e;
                if (!i[0] || !o[0]) return !i[0] ? !o[0] ? 0 : -a : s;
                if (s != a) return s;
                t = s < 0;
                if (l != _) return l > _ ^ t ? 1 : -1;
                a = Math.max(i.length, o.length);
                for (s = 0; s < a; s++) {
                    l = s < i.length ? i[s] : 0;
                    _ = s < o.length ? o[s] : 0;
                    if (l != _) return l > _ ^ t ? 1 : -1
                }
                return 0
            };
            o.div = function(e) {
                var t = this.constructor,
                    r = new t(this),
                    e = new t(e),
                    n = r.c,
                    i = e.c,
                    o = r.s == e.s ? 1 : -1,
                    s = t.DP;
                if (s !== ~~s || s < 0 || s > l) {
                    throw Error(h)
                }
                if (!i[0]) {
                    throw Error(m)
                }
                if (!n[0]) {
                    e.s = o;
                    e.c = [e.e = 0];
                    return e
                }
                var a, _, u, c, d, p = i.slice(),
                    f = a = i.length,
                    g = n.length,
                    S = n.slice(0, a),
                    T = S.length,
                    x = e,
                    C = x.c = [],
                    N = 0,
                    A = s + (x.e = r.e - e.e) + 1;
                x.s = o;
                o = A < 0 ? 0 : A;
                p.unshift(0);
                for (; T++ < a;) S.push(0);
                do {
                    for (u = 0; u < 10; u++) {
                        if (a != (T = S.length)) {
                            c = a > T ? 1 : -1
                        } else {
                            for (d = -1, c = 0; ++d < a;) {
                                if (i[d] != S[d]) {
                                    c = i[d] > S[d] ? 1 : -1;
                                    break
                                }
                            }
                        }
                        if (c < 0) {
                            for (_ = T == a ? i : p; T;) {
                                if (S[--T] < _[T]) {
                                    d = T;
                                    for (; d && !S[--d];) S[d] = 9;
                                    --S[d];
                                    S[T] += 10
                                }
                                S[T] -= _[T]
                            }
                            for (; !S[0];) S.shift()
                        } else {
                            break
                        }
                    }
                    C[N++] = c ? u : ++u;
                    if (S[0] && c) S[T] = n[f] || 0;
                    else S = [n[f]]
                } while ((f++ < g || S[0] !== y) && o--);
                if (!C[0] && N != 1) {
                    C.shift();
                    x.e--;
                    A--
                }
                if (N > A) round(x, A, t.RM, S[0] !== y);
                return x
            };
            o.eq = function(e) {
                return this.cmp(e) === 0
            };
            o.gt = function(e) {
                return this.cmp(e) > 0
            };
            o.gte = function(e) {
                return this.cmp(e) > -1
            };
            o.lt = function(e) {
                return this.cmp(e) < 0
            };
            o.lte = function(e) {
                return this.cmp(e) < 1
            };
            o.minus = o.sub = function(e) {
                var t, r, n, i, o = this.constructor,
                    s = new o(this),
                    e = new o(e),
                    a = s.s,
                    l = e.s;
                if (a != l) {
                    e.s = -l;
                    return s.plus(e)
                }
                var _ = s.c.slice(),
                    u = s.e,
                    c = e.c,
                    d = e.e;
                if (!_[0] || !c[0]) {
                    if (c[0]) {
                        e.s = -l
                    } else if (_[0]) {
                        e = new o(s)
                    } else {
                        e.s = 1
                    }
                    return e
                }
                if (a = u - d) {
                    if (i = a < 0) {
                        a = -a;
                        n = _
                    } else {
                        d = u;
                        n = c
                    }
                    n.reverse();
                    for (l = a; l--;) n.push(0);
                    n.reverse()
                } else {
                    r = ((i = _.length < c.length) ? _ : c).length;
                    for (a = l = 0; l < r; l++) {
                        if (_[l] != c[l]) {
                            i = _[l] < c[l];
                            break
                        }
                    }
                }
                if (i) {
                    n = _;
                    _ = c;
                    c = n;
                    e.s = -e.s
                }
                if ((l = (r = c.length) - (t = _.length)) > 0)
                    for (; l--;) _[t++] = 0;
                for (l = t; r > a;) {
                    if (_[--r] < c[r]) {
                        for (t = r; t && !_[--t];) _[t] = 9;
                        --_[t];
                        _[r] += 10
                    }
                    _[r] -= c[r]
                }
                for (; _[--l] === 0;) _.pop();
                for (; _[0] === 0;) {
                    _.shift();
                    --d
                }
                if (!_[0]) {
                    e.s = 1;
                    _ = [d = 0]
                }
                e.c = _;
                e.e = d;
                return e
            };
            o.mod = function(e) {
                var t, r = this.constructor,
                    n = new r(this),
                    e = new r(e),
                    i = n.s,
                    o = e.s;
                if (!e.c[0]) {
                    throw Error(m)
                }
                n.s = e.s = 1;
                t = e.cmp(n) == 1;
                n.s = i;
                e.s = o;
                if (t) return new r(n);
                i = r.DP;
                o = r.RM;
                r.DP = r.RM = 0;
                n = n.div(e);
                r.DP = i;
                r.RM = o;
                return this.minus(n.times(e))
            };
            o.plus = o.add = function(e) {
                var t, r, n, i = this.constructor,
                    o = new i(this),
                    e = new i(e);
                if (o.s != e.s) {
                    e.s = -e.s;
                    return o.minus(e)
                }
                var s = o.e,
                    a = o.c,
                    l = e.e,
                    _ = e.c;
                if (!a[0] || !_[0]) {
                    if (!_[0]) {
                        if (a[0]) {
                            e = new i(o)
                        } else {
                            e.s = o.s
                        }
                    }
                    return e
                }
                a = a.slice();
                if (t = s - l) {
                    if (t > 0) {
                        l = s;
                        n = _
                    } else {
                        t = -t;
                        n = a
                    }
                    n.reverse();
                    for (; t--;) n.push(0);
                    n.reverse()
                }
                if (a.length - _.length < 0) {
                    n = _;
                    _ = a;
                    a = n
                }
                t = _.length;
                for (r = 0; t; a[t] %= 10) r = (a[--t] = a[t] + _[t] + r) / 10 | 0;
                if (r) {
                    a.unshift(r);
                    ++l
                }
                for (t = a.length; a[--t] === 0;) a.pop();
                e.c = a;
                e.e = l;
                return e
            };
            o.pow = function(e) {
                var t = this.constructor,
                    r = new t(this),
                    n = new t("1"),
                    i = new t("1"),
                    o = e < 0;
                if (e !== ~~e || e < -_ || e > _) {
                    throw Error(f + "exponent")
                }
                if (o) e = -e;
                for (;;) {
                    if (e & 1) n = n.times(r);
                    e >>= 1;
                    if (!e) break;
                    r = r.times(r)
                }
                return o ? i.div(n) : n
            };
            o.prec = function(e, t) {
                if (e !== ~~e || e < 1 || e > l) {
                    throw Error(f + "precision")
                }
                return round(new this.constructor(this), e, t)
            };
            o.round = function(e, t) {
                if (e === y) e = 0;
                else if (e !== ~~e || e < -l || e > l) {
                    throw Error(h)
                }
                return round(new this.constructor(this), e + this.e + 1, t)
            };
            o.sqrt = function() {
                var e, t, r, n = this.constructor,
                    i = new n(this),
                    o = i.s,
                    s = i.e,
                    a = new n("0.5");
                if (!i.c[0]) return new n(i);
                if (o < 0) {
                    throw Error(p + "No square root")
                }
                o = Math.sqrt(i + "");
                if (o === 0 || o === 1 / 0) {
                    t = i.c.join("");
                    if (!(t.length + s & 1)) t += "0";
                    o = Math.sqrt(t);
                    s = ((s + 1) / 2 | 0) - (s < 0 || s & 1);
                    e = new n((o == 1 / 0 ? "5e" : (o = o.toExponential()).slice(0, o.indexOf("e") + 1)) + s)
                } else {
                    e = new n(o + "")
                }
                s = e.e + (n.DP += 4);
                do {
                    r = e;
                    e = a.times(r.plus(i.div(r)))
                } while (r.c.slice(0, s).join("") !== e.c.slice(0, s).join(""));
                return round(e, (n.DP -= 4) + e.e + 1, n.RM)
            };
            o.times = o.mul = function(e) {
                var t, r = this.constructor,
                    n = new r(this),
                    e = new r(e),
                    i = n.c,
                    o = e.c,
                    s = i.length,
                    a = o.length,
                    l = n.e,
                    _ = e.e;
                e.s = n.s == e.s ? 1 : -1;
                if (!i[0] || !o[0]) {
                    e.c = [e.e = 0];
                    return e
                }
                e.e = l + _;
                if (s < a) {
                    t = i;
                    i = o;
                    o = t;
                    _ = s;
                    s = a;
                    a = _
                }
                for (t = new Array(_ = s + a); _--;) t[_] = 0;
                for (l = a; l--;) {
                    a = 0;
                    for (_ = s + l; _ > l;) {
                        a = t[_] + o[l] * i[_ - l - 1] + a;
                        t[_--] = a % 10;
                        a = a / 10 | 0
                    }
                    t[_] = a
                }
                if (a) ++e.e;
                else t.shift();
                for (l = t.length; !t[--l];) t.pop();
                e.c = t;
                return e
            };
            o.toExponential = function(e, t) {
                var r = this,
                    n = r.c[0];
                if (e !== y) {
                    if (e !== ~~e || e < 0 || e > l) {
                        throw Error(h)
                    }
                    r = round(new r.constructor(r), ++e, t);
                    for (; r.c.length < e;) r.c.push(0)
                }
                return stringify(r, true, !!n)
            };
            o.toFixed = function(e, t) {
                var r = this,
                    n = r.c[0];
                if (e !== y) {
                    if (e !== ~~e || e < 0 || e > l) {
                        throw Error(h)
                    }
                    r = round(new r.constructor(r), e + r.e + 1, t);
                    for (e = e + r.e + 1; r.c.length < e;) r.c.push(0)
                }
                return stringify(r, false, !!n)
            };
            o.toJSON = o.toString = function() {
                var e = this,
                    t = e.constructor;
                return stringify(e, e.e <= t.NE || e.e >= t.PE, !!e.c[0])
            };
            o.toNumber = function() {
                var e = Number(stringify(this, true, true));
                if (this.constructor.strict === true && !this.eq(e.toString())) {
                    throw Error(p + "Imprecise conversion")
                }
                return e
            };
            o.toPrecision = function(e, t) {
                var r = this,
                    n = r.constructor,
                    i = r.c[0];
                if (e !== y) {
                    if (e !== ~~e || e < 1 || e > l) {
                        throw Error(f + "precision")
                    }
                    r = round(new n(r), e, t);
                    for (; r.c.length < e;) r.c.push(0)
                }
                return stringify(r, e <= r.e || r.e <= n.NE || r.e >= n.PE, !!i)
            };
            o.valueOf = function() {
                var e = this,
                    t = e.constructor;
                if (t.strict === true) {
                    throw Error(p + "valueOf disallowed")
                }
                return stringify(e, e.e <= t.NE || e.e >= t.PE, true)
            };
            var T = _Big_();
            t.Big = T;
            var x = T;
            t["default"] = x
        },
        6865: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Long = Long;
            t.ZERO = t.UZERO = t.UONE = t.ONE = t.NEG_ONE = t.MIN_VALUE = t.MAX_VALUE = t.MAX_UNSIGNED_VALUE = void 0;
            t.add = add;
            t.and = and;
            t.compare = compare;
            t.divide = divide;
            t.equals = equals;
            t.fromBits = fromBits;
            t.fromBytes = fromBytes;
            t.fromBytesBE = fromBytesBE;
            t.fromBytesLE = fromBytesLE;
            t.fromInt = fromInt;
            t.fromNumber = fromNumber;
            t.fromString = fromString;
            t.fromValue = fromValue;
            t.getHighBits = getHighBits;
            t.getHighBitsUnsigned = getHighBitsUnsigned;
            t.getLowBits = getLowBits;
            t.getLowBitsUnsigned = getLowBitsUnsigned;
            t.getNumBitsAbs = getNumBitsAbs;
            t.greaterThan = greaterThan;
            t.greaterThanOrEqual = greaterThanOrEqual;
            t.isEven = isEven;
            t.isLong = isLong;
            t.isNegative = isNegative;
            t.isOdd = isOdd;
            t.isPositive = isPositive;
            t.isZero = isZero;
            t.lessThan = lessThan;
            t.lessThanOrEqual = lessThanOrEqual;
            t.modulo = modulo;
            t.multiply = multiply;
            t.negate = negate;
            t.not = not;
            t.notEquals = notEquals;
            t.or = or;
            t.rotateRight = t.rotateLeft = void 0;
            t.shiftLeft = shiftLeft;
            t.shiftRight = shiftRight;
            t.shiftRightUnsigned = shiftRightUnsigned;
            t.subtract = subtract;
            t.toBytes = toBytes;
            t.toBytesBE = toBytesBE;
            t.toBytesLE = toBytesLE;
            t.toInt = toInt;
            t.toNumber = toNumber;
            t.toSigned = toSigned;
            t.toString = toString;
            t.toUnsigned = toUnsigned;
            t.xor = xor;
            var n = r(6468);
            var i = null;
            try {
                i = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports
            } catch (e) {}

            function Long(e, t, r) {
                this.low = e | 0;
                this.high = t | 0;
                this.unsigned = !!r
            }
            Long.prototype.GetHashCode = function() {
                let e = this.unsigned ? 1 : 0;
                e = (e << 5) + e ^ this.high;
                e = (e << 5) + e ^ this.low;
                return e
            };
            Long.prototype.Equals = function(e) {
                return equals(this, e)
            };
            Long.prototype.CompareTo = function(e) {
                return compare(this, e)
            };
            Long.prototype.toString = function(e) {
                return toString(this, e)
            };
            Long.prototype.toJSON = function() {
                return toString(this)
            };
            Long.prototype[n.symbol] = function() {
                const e = this;
                return {
                    multiply: t => multiply(e, t),
                    toPrecision: t => String(e) + (0).toPrecision(t).substr(1),
                    toExponential: t => String(e) + (0).toExponential(t).substr(1),
                    toFixed: t => String(e) + (0).toFixed(t).substr(1),
                    toHex: () => toString(e.unsigned ? e : fromBytes(toBytes(e), true), 16)
                }
            };
            Long.prototype.__isLong__;
            Object.defineProperty(Long.prototype, "__isLong__", {
                value: true
            });

            function isLong(e) {
                return (e && e["__isLong__"]) === true
            }
            var o = {};
            var s = {};

            function fromInt(e, t) {
                var r, n, i;
                if (t) {
                    e >>>= 0;
                    if (i = 0 <= e && e < 256) {
                        n = s[e];
                        if (n) return n
                    }
                    r = fromBits(e, (e | 0) < 0 ? -1 : 0, true);
                    if (i) s[e] = r;
                    return r
                } else {
                    e |= 0;
                    if (i = -128 <= e && e < 128) {
                        n = o[e];
                        if (n) return n
                    }
                    r = fromBits(e, e < 0 ? -1 : 0, false);
                    if (i) o[e] = r;
                    return r
                }
            }

            function fromNumber(e, t) {
                if (isNaN(e)) return t ? h : f;
                if (t) {
                    if (e < 0) return h;
                    if (e >= c) return T
                } else {
                    if (e <= -d) return x;
                    if (e + 1 >= d) return S
                }
                if (e < 0) return negate(fromNumber(-e, t));
                return fromBits(e % u | 0, e / u | 0, t)
            }

            function fromBits(e, t, r) {
                return new Long(e, t, r)
            }
            var a = Math.pow;

            function fromString(e, t, r) {
                if (e.length === 0) throw Error("empty string");
                if (e === "NaN" || e === "Infinity" || e === "+Infinity" || e === "-Infinity") return f;
                if (typeof t === "number") {
                    r = t, t = false
                } else {
                    t = !!t
                }
                r = r || 10;
                if (r < 2 || 36 < r) throw RangeError("radix");
                var n = e.indexOf("-");
                if (n > 0) throw Error("interior hyphen");
                else if (n === 0) {
                    return negate(fromString(e.substring(1), t, r))
                }
                var i = fromNumber(a(r, 8));
                var o = f;
                for (var s = 0; s < e.length; s += 8) {
                    var l = Math.min(8, e.length - s),
                        _ = parseInt(e.substring(s, s + l), r);
                    if (l < 8) {
                        var u = fromNumber(a(r, l));
                        o = add(multiply(o, u), fromNumber(_))
                    } else {
                        o = multiply(o, i);
                        o = add(o, fromNumber(_))
                    }
                }
                o.unsigned = t;
                return o
            }

            function fromValue(e, t) {
                if (typeof e === "number") return fromNumber(e, t);
                if (typeof e === "string") return fromString(e, t);
                return fromBits(e.low, e.high, typeof t === "boolean" ? t : e.unsigned)
            }
            var l = 1 << 16;
            var _ = 1 << 24;
            var u = l * l;
            var c = u * u;
            var d = c / 2;
            var p = fromInt(_);
            var f = fromInt(0);
            t.ZERO = f;
            var h = fromInt(0, true);
            t.UZERO = h;
            var g = fromInt(1);
            t.ONE = g;
            var m = fromInt(1, true);
            t.UONE = m;
            var y = fromInt(-1);
            t.NEG_ONE = y;
            var S = fromBits(4294967295 | 0, 2147483647 | 0, false);
            t.MAX_VALUE = S;
            var T = fromBits(4294967295 | 0, 4294967295 | 0, true);
            t.MAX_UNSIGNED_VALUE = T;
            var x = fromBits(0, 2147483648 | 0, false);
            t.MIN_VALUE = x;

            function toInt(e) {
                return e.unsigned ? e.low >>> 0 : e.low
            }

            function toNumber(e) {
                if (e.unsigned) return (e.high >>> 0) * u + (e.low >>> 0);
                return e.high * u + (e.low >>> 0)
            }

            function toString(e, t) {
                t = t || 10;
                if (t < 2 || 36 < t) throw RangeError("radix");
                if (isZero(e)) return "0";
                if (isNegative(e)) {
                    if (equals(e, x)) {
                        var r = fromNumber(t),
                            n = divide(e, r),
                            i = subtract(multiply(n, r), e);
                        return toString(n, t) + toInt(i).toString(t)
                    } else return "-" + toString(negate(e), t)
                }
                var o = fromNumber(a(t, 6), e.unsigned),
                    s = e;
                var l = "";
                while (true) {
                    var _ = divide(s, o),
                        u = toInt(subtract(s, multiply(_, o))) >>> 0,
                        c = u.toString(t);
                    s = _;
                    if (isZero(s)) return c + l;
                    else {
                        while (c.length < 6) c = "0" + c;
                        l = "" + c + l
                    }
                }
            }

            function getHighBits(e) {
                return e.high
            }

            function getHighBitsUnsigned(e) {
                return e.high >>> 0
            }

            function getLowBits(e) {
                return e.low
            }

            function getLowBitsUnsigned(e) {
                return e.low >>> 0
            }

            function getNumBitsAbs(e) {
                if (isNegative(e)) return equals(e, x) ? 64 : getNumBitsAbs(negate(e));
                var t = e.high != 0 ? e.high : e.low;
                for (var r = 31; r > 0; r--)
                    if ((t & 1 << r) != 0) break;
                return e.high != 0 ? r + 33 : r + 1
            }

            function isZero(e) {
                return e.high === 0 && e.low === 0
            }

            function isNegative(e) {
                return !e.unsigned && e.high < 0
            }

            function isPositive(e) {
                return e.unsigned || e.high >= 0
            }

            function isOdd(e) {
                return (e.low & 1) === 1
            }

            function isEven(e) {
                return (e.low & 1) === 0
            }

            function equals(e, t) {
                if (!isLong(t)) t = fromValue(t);
                if (e.unsigned !== t.unsigned && e.high >>> 31 === 1 && t.high >>> 31 === 1) return false;
                return e.high === t.high && e.low === t.low
            }

            function notEquals(e, t) {
                return !equals(e, t)
            }

            function lessThan(e, t) {
                return compare(e, t) < 0
            }

            function lessThanOrEqual(e, t) {
                return compare(e, t) <= 0
            }

            function greaterThan(e, t) {
                return compare(e, t) > 0
            }

            function greaterThanOrEqual(e, t) {
                return compare(e, t) >= 0
            }

            function compare(e, t) {
                if (!isLong(t)) t = fromValue(t);
                if (equals(e, t)) return 0;
                var r = isNegative(e),
                    n = isNegative(t);
                if (r && !n) return -1;
                if (!r && n) return 1;
                if (!e.unsigned) return isNegative(subtract(e, t)) ? -1 : 1;
                return t.high >>> 0 > e.high >>> 0 || t.high === e.high && t.low >>> 0 > e.low >>> 0 ? -1 : 1
            }

            function negate(e) {
                if (!e.unsigned && equals(e, x)) return x;
                return add(not(e), g)
            }

            function add(e, t) {
                if (!isLong(t)) t = fromValue(t);
                var r = e.high >>> 16;
                var n = e.high & 65535;
                var i = e.low >>> 16;
                var o = e.low & 65535;
                var s = t.high >>> 16;
                var a = t.high & 65535;
                var l = t.low >>> 16;
                var _ = t.low & 65535;
                var u = 0,
                    c = 0,
                    d = 0,
                    p = 0;
                p += o + _;
                d += p >>> 16;
                p &= 65535;
                d += i + l;
                c += d >>> 16;
                d &= 65535;
                c += n + a;
                u += c >>> 16;
                c &= 65535;
                u += r + s;
                u &= 65535;
                return fromBits(d << 16 | p, u << 16 | c, e.unsigned)
            }

            function subtract(e, t) {
                if (!isLong(t)) t = fromValue(t);
                return add(e, negate(t))
            }

            function multiply(e, t) {
                if (isZero(e)) return e.unsigned ? h : f;
                if (!isLong(t)) t = fromValue(t);
                if (i) {
                    var r = i.mul(e.low, e.high, t.low, t.high);
                    return fromBits(r, i.get_high(), e.unsigned)
                }
                if (isZero(t)) return e.unsigned ? h : f;
                if (equals(e, x)) return isOdd(t) ? x : f;
                if (equals(t, x)) return isOdd(e) ? x : f;
                if (isNegative(e)) {
                    if (isNegative(t)) return multiply(negate(e), negate(t));
                    else return negate(multiply(negate(e), t))
                } else if (isNegative(t)) return negate(multiply(e, negate(t)));
                if (lessThan(e, p) && lessThan(t, p)) return fromNumber(toNumber(e) * toNumber(t), e.unsigned);
                var n = e.high >>> 16;
                var o = e.high & 65535;
                var s = e.low >>> 16;
                var a = e.low & 65535;
                var l = t.high >>> 16;
                var _ = t.high & 65535;
                var u = t.low >>> 16;
                var c = t.low & 65535;
                var d = 0,
                    g = 0,
                    m = 0,
                    y = 0;
                y += a * c;
                m += y >>> 16;
                y &= 65535;
                m += s * c;
                g += m >>> 16;
                m &= 65535;
                m += a * u;
                g += m >>> 16;
                m &= 65535;
                g += o * c;
                d += g >>> 16;
                g &= 65535;
                g += s * u;
                d += g >>> 16;
                g &= 65535;
                g += a * _;
                d += g >>> 16;
                g &= 65535;
                d += n * c + o * u + s * _ + a * l;
                d &= 65535;
                return fromBits(m << 16 | y, d << 16 | g, e.unsigned)
            }

            function divide(e, t) {
                if (!isLong(t)) t = fromValue(t);
                if (isZero(t)) throw Error("division by zero");
                if (i) {
                    if (!e.unsigned && e.high === -2147483648 && t.low === -1 && t.high === -1) {
                        return e
                    }
                    var r = (e.unsigned ? i.div_u : i.div_s)(e.low, e.high, t.low, t.high);
                    return fromBits(r, i.get_high(), e.unsigned)
                }
                if (isZero(e)) return e.unsigned ? h : f;
                var n, o, s;
                if (!e.unsigned) {
                    if (equals(e, x)) {
                        if (equals(t, g) || equals(t, y)) return x;
                        else if (equals(t, x)) return g;
                        else {
                            var l = shiftRight(e, 1);
                            n = shiftLeft(divide(l, t), 1);
                            if (equals(n, f)) {
                                return isNegative(t) ? g : y
                            } else {
                                o = subtract(e, multiply(t, n));
                                s = add(n, divide(o, t));
                                return s
                            }
                        }
                    } else if (equals(t, x)) return e.unsigned ? h : f;
                    if (isNegative(e)) {
                        if (isNegative(t)) return divide(negate(e), negate(t));
                        return negate(divide(negate(e), t))
                    } else if (isNegative(t)) return negate(divide(e, negate(t)));
                    s = f
                } else {
                    if (!t.unsigned) t = toUnsigned(t);
                    if (greaterThan(t, e)) return h;
                    if (greaterThan(t, shiftRightUnsigned(e, 1))) return m;
                    s = h
                }
                o = e;
                while (greaterThanOrEqual(o, t)) {
                    n = Math.max(1, Math.floor(toNumber(o) / toNumber(t)));
                    var _ = Math.ceil(Math.log(n) / Math.LN2),
                        u = _ <= 48 ? 1 : a(2, _ - 48),
                        c = fromNumber(n),
                        d = multiply(c, t);
                    while (isNegative(d) || greaterThan(d, o)) {
                        n -= u;
                        c = fromNumber(n, e.unsigned);
                        d = multiply(c, t)
                    }
                    if (isZero(c)) c = g;
                    s = add(s, c);
                    o = subtract(o, d)
                }
                return s
            }

            function modulo(e, t) {
                if (!isLong(t)) t = fromValue(t);
                if (i) {
                    var r = (e.unsigned ? i.rem_u : i.rem_s)(e.low, e.high, t.low, t.high);
                    return fromBits(r, i.get_high(), e.unsigned)
                }
                return subtract(e, multiply(divide(e, t), t))
            }

            function not(e) {
                return fromBits(~e.low, ~e.high, e.unsigned)
            }

            function and(e, t) {
                if (!isLong(t)) t = fromValue(t);
                return fromBits(e.low & t.low, e.high & t.high, e.unsigned)
            }

            function or(e, t) {
                if (!isLong(t)) t = fromValue(t);
                return fromBits(e.low | t.low, e.high | t.high, e.unsigned)
            }

            function xor(e, t) {
                if (!isLong(t)) t = fromValue(t);
                return fromBits(e.low ^ t.low, e.high ^ t.high, e.unsigned)
            }

            function shiftLeft(e, t) {
                if (isLong(t)) t = toInt(t);
                if ((t &= 63) === 0) return e;
                else if (t < 32) return fromBits(e.low << t, e.high << t | e.low >>> 32 - t, e.unsigned);
                else return fromBits(0, e.low << t - 32, e.unsigned)
            }

            function shiftRight(e, t) {
                if (isLong(t)) t = toInt(t);
                if ((t &= 63) === 0) return e;
                else if (t < 32) return fromBits(e.low >>> t | e.high << 32 - t, e.high >> t, e.unsigned);
                else return fromBits(e.high >> t - 32, e.high >= 0 ? 0 : -1, e.unsigned)
            }

            function shiftRightUnsigned(e, t) {
                if (isLong(t)) t = toInt(t);
                t &= 63;
                if (t === 0) return e;
                else {
                    var r = e.high;
                    if (t < 32) {
                        var n = e.low;
                        return fromBits(n >>> t | r << 32 - t, r >>> t, e.unsigned)
                    } else if (t === 32) return fromBits(r, 0, e.unsigned);
                    else return fromBits(r >>> t - 32, 0, e.unsigned)
                }
            }
            const C = function rotateLeft(e) {
                var t;
                if (isLong(e)) e = e.toInt();
                if ((e &= 63) === 0) return this;
                if (e === 32) return fromBits(this.high, this.low, this.unsigned);
                if (e < 32) {
                    t = 32 - e;
                    return fromBits(this.low << e | this.high >>> t, this.high << e | this.low >>> t, this.unsigned)
                }
                e -= 32;
                t = 32 - e;
                return fromBits(this.high << e | this.low >>> t, this.low << e | this.high >>> t, this.unsigned)
            };
            t.rotateLeft = C;
            const N = function rotateRight(e) {
                var t;
                if (isLong(e)) e = e.toInt();
                if ((e &= 63) === 0) return this;
                if (e === 32) return fromBits(this.high, this.low, this.unsigned);
                if (e < 32) {
                    t = 32 - e;
                    return fromBits(this.high << t | this.low >>> e, this.low << t | this.high >>> e, this.unsigned)
                }
                e -= 32;
                t = 32 - e;
                return fromBits(this.low << t | this.high >>> e, this.high << t | this.low >>> e, this.unsigned)
            };
            t.rotateRight = N;

            function toSigned(e) {
                if (!e.unsigned) return e;
                return fromBits(e.low, e.high, false)
            }

            function toUnsigned(e) {
                if (e.unsigned) return e;
                return fromBits(e.low, e.high, true)
            }

            function toBytes(e, t) {
                return t ? toBytesLE(e) : toBytesBE(e)
            }

            function toBytesLE(e) {
                var t = e.high,
                    r = e.low;
                return [r & 255, r >>> 8 & 255, r >>> 16 & 255, r >>> 24, t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24]
            }

            function toBytesBE(e) {
                var t = e.high,
                    r = e.low;
                return [t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255, r >>> 24, r >>> 16 & 255, r >>> 8 & 255, r & 255]
            }

            function fromBytes(e, t, r) {
                return r ? fromBytesLE(e, t) : fromBytesBE(e, t)
            }

            function fromBytesLE(e, t) {
                return new Long(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t)
            }

            function fromBytesBE(e, t) {
                return new Long(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t)
            }
        },
        3776: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.MK_Cell = MK_Cell;
            t.MK_Declctor = MK_Declctor;
            t.MK_Decltype = MK_Decltype;
            t.MK_Declvar = MK_Declvar;
            t.MK_Defignore = MK_Defignore;
            t.MK_Deflexer = MK_Deflexer;
            t.MK_Defmacro = MK_Defmacro;
            t.MK_Defrule = MK_Defrule;
            t.MK_EApp = MK_EApp;
            t.MK_EBool = MK_EBool;
            t.MK_EField = MK_EField;
            t.MK_EFlt = MK_EFlt;
            t.MK_EFun = MK_EFun;
            t.MK_EInt = MK_EInt;
            t.MK_ELet = MK_ELet;
            t.MK_EList = MK_EList;
            t.MK_ESlot = MK_ESlot;
            t.MK_EStr = MK_EStr;
            t.MK_ETuple = MK_ETuple;
            t.MK_EVar = MK_EVar;
            t.MK_LGroup = MK_LGroup;
            t.MK_LNot = MK_LNot;
            t.MK_LNumber = void 0;
            t.MK_LOptional = MK_LOptional;
            t.MK_LOr = MK_LOr;
            t.MK_LPlus = MK_LPlus;
            t.MK_LRange = MK_LRange;
            t.MK_LRef = MK_LRef;
            t.MK_LSeq = MK_LSeq;
            t.MK_LStar = MK_LStar;
            t.MK_LStr = MK_LStr;
            t.MK_LWildcard = void 0;
            t.MK_Macrocall = MK_Macrocall;
            t.MK_Mono = MK_Mono;
            t.MK_Nonterm = MK_Nonterm;
            t.MK_Poly = MK_Poly;
            t.MK_TApp = MK_TApp;
            t.MK_TConst = MK_TConst;
            t.MK_TFun = MK_TFun;
            t.MK_TList = MK_TList;
            t.MK_TTuple = MK_TTuple;
            t.MK_TVar = MK_TVar;
            t.MK_Term = MK_Term;
            t.MK_expr = MK_expr;
            t.MK_position = MK_position;
            t.MK_production = MK_production;
            t.build_analyzer = build_analyzer;
            var n = r(3833);
            var i = r(5359);
            var o = r(6638);
            var s = r(9054);
            var a = r(4222);
            var l = r(543);

            function MK_Cell() {
                return (0, n.Cell$1_$ctor)()
            }

            function MK_position(e, t, r) {
                return new n.position(e, t, r)
            }

            function MK_EApp(e, t) {
                return new n.node(0, e, (0, i.ofArray)(t))
            }

            function MK_ETuple(e) {
                return new n.node(1, (0, i.ofArray)(e))
            }

            function MK_EList(e) {
                return new n.node(2, (0, i.ofArray)(e))
            }

            function MK_ELet(e, t, r) {
                return new n.node(4, e, t, r)
            }

            function MK_EFun(e, t) {
                return new n.node(5, (0, i.ofArray)(e), t)
            }

            function MK_EVar(e) {
                return new n.node(6, e, new o.FSharpRef((0, i.empty)()))
            }

            function MK_ESlot(e) {
                return new n.node(7, e)
            }

            function MK_EInt(e) {
                return new n.node(8, e)
            }

            function MK_EStr(e) {
                return new n.node(9, e)
            }

            function MK_EFlt(e) {
                return new n.node(10, e)
            }

            function MK_EBool(e) {
                return new n.node(11, e)
            }

            function MK_EField(e, t) {
                return new n.node(3, e, t)
            }

            function MK_expr(e, t) {
                return new n.expr(e, t, new n.monot(1, "bot"))
            }

            function MK_TConst(e) {
                return new n.monot(1, e)
            }

            function MK_TApp(e, t) {
                return new n.monot(2, e, (0, i.ofArray)(t))
            }

            function MK_TFun(e, t) {
                return new n.monot(3, (0, i.ofArray)(e), t)
            }

            function MK_TVar(e) {
                return new n.monot(4, e)
            }

            function MK_TTuple(e) {
                if (e.length === 1) {
                    return e[0]
                } else {
                    return (0, n.TTuple)((0, i.ofArray)(e))
                }
            }

            function MK_TList(e) {
                return (0, n.TList)(e)
            }

            function MK_LStr(e) {
                return new n.lexerule(3, e)
            }
            const _ = new n.lexerule(0);
            t.MK_LNumber = _;
            const u = new n.lexerule(1);
            t.MK_LWildcard = u;

            function MK_LSeq(e) {
                if (!(0, s.equalsWith)(a.equals, e, null) && e.length === 1) {
                    return e[0]
                } else {
                    return new n.lexerule(2, (0, i.ofArray)(e))
                }
            }

            function MK_LOr(e) {
                if (!(0, s.equalsWith)(a.equals, e, null) && e.length === 1) {
                    return e[0]
                } else {
                    return new n.lexerule(4, (0, i.ofArray)(e))
                }
            }

            function MK_LNot(e) {
                return new n.lexerule(5, e)
            }

            function MK_LPlus(e) {
                return new n.lexerule(6, e)
            }

            function MK_LStar(e) {
                return new n.lexerule(7, e)
            }

            function MK_LOptional(e) {
                return new n.lexerule(8, e)
            }

            function MK_LGroup(e) {
                return new n.lexerule(9, e)
            }

            function MK_LRange(e, t) {
                return new n.lexerule(10, e, t)
            }

            function MK_LRef(e) {
                return new n.lexerule(11, e)
            }

            function MK_Defignore(e, t) {
                return new n.definition(6, {
                    ignoreList: (0, i.ofArray)(e),
                    pos: t
                })
            }

            function MK_Defmacro(e, t, r, o) {
                let s;
                return new n.definition(0, (s = (0, i.ofArray)(t), {
                    define: (0, i.ofArray)(r),
                    lhs: e,
                    parameters: s,
                    pos: o
                }))
            }

            function MK_Defrule(e, t, r) {
                return new n.definition(1, {
                    define: (0, i.ofArray)(t),
                    lhs: e,
                    pos: r
                })
            }

            function MK_Deflexer(e, t, r) {
                return new n.definition(2, {
                    define: t,
                    lhs: e,
                    pos: r
                })
            }

            function MK_Declvar(e, t, r) {
                return new n.definition(3, {
                    ident: e,
                    pos: r,
                    t: t
                })
            }

            function MK_Declctor(e, t, r) {
                return new n.definition(4, {
                    ident: e,
                    pos: r,
                    t: t
                })
            }

            function MK_Decltype(e, t, r, o, s, a) {
                let l;
                return new n.definition(5, (l = (0, i.ofArray)(o), {
                    external: e,
                    fields: (0, i.ofArray)(s),
                    hasFields: t,
                    ident: r,
                    parameters: l,
                    pos: a
                }))
            }

            function MK_production(e, t) {
                return new n.production((0, i.ofArray)(e), t)
            }

            function MK_Term(e, t) {
                return new n.symbol(0, e, t)
            }

            function MK_Nonterm(e) {
                return new n.symbol(1, e)
            }

            function MK_Macrocall(e, t, r) {
                return new n.symbol(2, e, (0, i.ofArray)(t), r)
            }

            function MK_Poly(e, t) {
                return new n.polyt(0, (0, i.ofArray)(e), t)
            }

            function MK_Mono(e) {
                return new n.polyt(1, e)
            }

            function build_analyzer(e) {
                return (0, l.build_analyzer)(e)
            }
        },
        543: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Analyzer = void 0;
            t.Analyzer$reflection = Analyzer$reflection;
            t.Shape = void 0;
            t.Shape$reflection = Shape$reflection;
            t.Sigma = void 0;
            t.Sigma$reflection = Sigma$reflection;
            t.Sigma_$ctor_3EA8CBCD = Sigma_$ctor_3EA8CBCD;
            t.Sigma__GetADTCases = Sigma__GetADTCases;
            t.Sigma__GetErrorTrace = Sigma__GetErrorTrace;
            t.Sigma__GetRecordTypes = Sigma__GetRecordTypes;
            t.Sigma__IsGlobalVariableConstructor_Z721C83C5 = Sigma__IsGlobalVariableConstructor_Z721C83C5;
            t.Sigma__KindCheckMono_Z25145215 = Sigma__KindCheckMono_Z25145215;
            t.Sigma__KindCheck_Z25145215 = Sigma__KindCheck_Z25145215;
            t.Sigma__KindCheck_Z25E5E15E = Sigma__KindCheck_Z25E5E15E;
            t.Sigma__LookupField = Sigma__LookupField;
            t.Sigma__RegisterCtorGVar = Sigma__RegisterCtorGVar;
            t.Sigma__RegisterExtGVar = Sigma__RegisterExtGVar;
            t.Sigma__RegisterType = Sigma__RegisterType;
            t.Sigma__SetCurrentDefinitionBranch_Z524259A4 = Sigma__SetCurrentDefinitionBranch_Z524259A4;
            t.Sigma__SetCurrentDefinition_Z759AB257 = Sigma__SetCurrentDefinition_Z759AB257;
            t.Sigma__SetCurrentPos_Z302187B = Sigma__SetCurrentPos_Z302187B;
            t.Sigma__WithExpr = Sigma__WithExpr;
            t.Sigma__get_CurrentPos = Sigma__get_CurrentPos;
            t.Sigma__get_GlobalVariables = Sigma__get_GlobalVariables;
            t.build_analyzer = build_analyzer;
            var n = r(6638);
            var i = r(6356);
            var o = r(3833);
            var s = r(5466);
            var a = r(1337);
            var l = r(4222);
            var _ = r(5359);
            var u = r(7362);
            var c = r(4205);
            var d = r(1697);
            var p = r(5891);
            var f = r(7936);
            var h = r(6109);
            var g = r(9054);
            class Shape extends n.Record {
                constructor(e, t) {
                    super();
                    this.parameters = e;
                    this.fields = t
                }
            }
            t.Shape = Shape;

            function Shape$reflection() {
                return (0, i.record_type)("tbnf.Analysis.Shape", [], Shape, (() => [
                    ["parameters", (0, i.list_type)(i.string_type)],
                    ["fields", (0, i.list_type)((0, i.tuple_type)(i.string_type, (0, o.monot$reflection)()))]
                ]))
            }
            class Sigma {
                constructor(e, t) {
                    this.UM = e;
                    this.errorTrace = t;
                    this.shapes = (0, s.empty)();
                    this.kinds = (0, s.ofArray)(o._predefined_typenames);
                    this.global_variables = (0, s.empty)();
                    this.constructors = (0, a.empty)({
                        Compare: l.comparePrimitives
                    });
                    this.externalTypes = (0, a.empty)({
                        Compare: l.comparePrimitives
                    });
                    this.records = (0, _.empty)();
                    this.adtCases = (0, _.empty)()
                }
            }
            t.Sigma = Sigma;

            function Sigma$reflection() {
                return (0, i.class_type)("tbnf.Analysis.Sigma", void 0, Sigma)
            }

            function Sigma_$ctor_3EA8CBCD(e, t) {
                return new Sigma(e, t)
            }

            function Sigma__WithExpr(e, t, r) {
                const n = e.errorTrace.exprStack;
                e.errorTrace.currentPos = t.pos;
                e.errorTrace.exprStack = (0, _.cons)(t, n);
                const i = r();
                e.errorTrace.currentPos = t.pos;
                e.errorTrace.exprStack = n;
                return i
            }

            function Sigma__SetCurrentPos_Z302187B(e, t) {
                e.errorTrace.currentPos = t
            }

            function Sigma__get_CurrentPos(e) {
                return e.errorTrace.currentPos
            }

            function Sigma__SetCurrentDefinition_Z759AB257(e, t) {
                e.errorTrace.whichDef = t;
                e.errorTrace.branch = 0
            }

            function Sigma__SetCurrentDefinitionBranch_Z524259A4(e, t) {
                e.errorTrace.branch = t | 0
            }

            function Sigma__GetErrorTrace(e) {
                return e.errorTrace
            }

            function Sigma__KindCheck_Z25145215(e, t) {
                Sigma__checkKind__Z25145215(e, t);
                return t
            }

            function Sigma__KindCheckMono_Z25145215(e, t) {
                return Sigma__KindCheck_Z25145215(e, t)
            }

            function Sigma__KindCheck_Z25E5E15E(e, t) {
                if (t.tag === 1) {
                    Sigma__checkKind__Z25145215(e, t.fields[0]);
                    return t
                } else {
                    Sigma__checkKind__Z25145215(e, t.fields[1]);
                    return t
                }
            }

            function Sigma__RegisterType(e, t, r, n, i, o) {
                Sigma__defineShape(e, t, r, n, i, o)
            }

            function Sigma__RegisterExtGVar(e, t, r) {
                Sigma__registerExtGVar(e, t, r)
            }

            function Sigma__RegisterCtorGVar(e, t, r) {
                Sigma__registerCtorGVar(e, t, r)
            }

            function Sigma__LookupField(e, t, r) {
                return Sigma__lookupField(e, t, r, (0, u.Manager__NewTyRef_Z721C83C5)(e.UM, "." + r))
            }

            function Sigma__get_GlobalVariables(e) {
                return e.global_variables
            }

            function Sigma__IsGlobalVariableConstructor_Z721C83C5(e, t) {
                if ((0, s.containsKey)(t, e.global_variables)) {
                    return (0, a.contains)(t, e.constructors)
                } else {
                    const e = new c.NotGlobalVariable(t);
                    throw e
                }
            }

            function Sigma__GetADTCases(e) {
                return e.adtCases
            }

            function Sigma__GetRecordTypes(e) {
                return (0, _.map)((t => [t, (0, s.FSharpMap__get_Item)(e.shapes, t)]), (0, _.reverse)(e.records))
            }

            function Sigma__checkKind__Z25145215(e, t) {
                const r = (0, o.monot__Prune)(t);
                if (r.tag === 1) {
                    const t = (0, s.tryFind)(r.fields[0], e.kinds);
                    if (t != null) {
                        if (t === 0) {} else {
                            const e = t | 0;
                            const n = 0;
                            if (e >= 0 && e !== n) {
                                const t = new c.InvalidKind({
                                    expect: e,
                                    got: n,
                                    name: r.fields[0]
                                });
                                throw t
                            }
                        }
                    } else {
                        const e = (0, c.UnboundTypeVariable)(r.fields[0]);
                        throw e
                    }
                } else if (r.tag === 2) {
                    if (r.fields[0].tag === 1) {
                        const t = (0, s.tryFind)(r.fields[0].fields[0], e.kinds);
                        if (t != null) {
                            const n = t | 0;
                            const i = (0, _.length)(r.fields[1]) | 0;
                            if (n >= 0 && n !== i) {
                                const e = new c.InvalidKind({
                                    expect: n,
                                    got: i,
                                    name: r.fields[0].fields[0]
                                });
                                throw e
                            }(0, _.iterate)((t => {
                                Sigma__checkKind__Z25145215(e, t)
                            }), r.fields[1])
                        } else {
                            const e = (0, c.UnboundTypeVariable)(r.fields[0].fields[0]);
                            throw e
                        }
                    } else {
                        const e = new c.InvalidTypeApplication(r.fields[0]);
                        throw e
                    }
                } else {
                    (0, o.monot__ApplyToChildren_Z6A62BCBF)(r, (t => {
                        Sigma__checkKind__Z25145215(e, t)
                    }))
                }
            }

            function Sigma__registerExistingVariable(e, t, r) {
                if ((0, s.containsKey)(t, e.global_variables)) {
                    const e = (0, c.DuplicateVariable)(t);
                    throw e
                } else {
                    e.global_variables = (0, s.add)(t, r, e.global_variables)
                }
            }

            function Sigma__registerType(e, t, r) {
                if ((0, s.containsKey)(t, e.kinds)) {
                    const e = (0, c.DuplicateTypeVariable)(t);
                    throw e
                } else {
                    e.kinds = (0, s.add)(t, r, e.kinds)
                }
            }

            function Sigma__addCase(e, t, r, n) {
                if ((0, a.contains)(t, e.externalTypes)) {
                    const e = new c.InvalidConstructorDefinination(r, new c.InvalidConstructorDefininationCause(0, t));
                    throw e
                }
                const i = (0, s.tryFind)(t, e.shapes);
                let o;
                if (i != null) {
                    if ((0, _.length)(i.fields) !== 0) {
                        o = 0
                    } else {
                        o = 1
                    }
                } else {
                    o = 1
                }
                switch (o) {
                    case 0: {
                        const e = new c.InvalidConstructorDefinination(r, new c.InvalidConstructorDefininationCause(1, t));
                        throw e;
                        break
                    }
                    case 1: {
                        if (i == null) {
                            Sigma__registerType(e, t, 0);
                            e.shapes = (0, s.add)(t, new Shape((0, _.empty)(), (0, _.empty)()), e.shapes)
                        } else if (!(0, _.isEmpty)(i.parameters)) {
                            const e = i.parameters;
                            const n = new c.InvalidConstructorDefinination(r, new c.InvalidConstructorDefininationCause(2, t, e));
                            throw n
                        }
                        break
                    }
                }
                let l = (0, d.List_replaceWith)(t, (e => {
                    if (e != null) {
                        if ((0, s.containsKey)(r, e)) {
                            const t = e;
                            const n = new c.InvalidConstructorDefinination(r, new c.InvalidConstructorDefininationCause(3));
                            throw n
                        } else if (e != null) {
                            return (0, s.add)(r, n, e)
                        } else {
                            throw new Error("Match failure")
                        }
                    } else {
                        return (0, s.ofArray)([
                            [r, n]
                        ])
                    }
                }), e.adtCases);
                e.adtCases = l
            }

            function Sigma__defineShape(e, t, r, n, i, l) {
                if ((0, s.containsKey)(n, e.shapes)) {
                    const e = (0, c.DuplicateTypeVariable)(n);
                    throw e
                } else {
                    const u = (0, s.tryFind)(n, e.kinds);
                    if (u == null) {
                        Sigma__registerType(e, n, (0, _.length)(i))
                    } else {
                        const e = u | 0;
                        if (e >= 0 && (0, _.length)(i) !== e) {
                            const t = new c.InvalidKind({
                                expect: e,
                                got: (0, _.length)(i),
                                name: n
                            });
                            throw t
                        }
                    }
                    if (t) {
                        e.externalTypes = (0, a.add)(n, e.externalTypes)
                    } else if (r) {
                        Sigma__registerExistingVariable(e, n, (0, _.isEmpty)(i) ? new o.polyt(1, new o.monot(3, l, new o.monot(1, n))) : new o.polyt(0, i, new o.monot(3, l, new o.monot(2, new o.monot(1, n), (0, _.map)((e => new o.monot(4, e)), i)))));
                        e.records = (0, _.cons)(n, e.records)
                    }
                    e.shapes = (0, s.add)(n, new Shape(i, l), e.shapes)
                }
            }

            function Sigma__lookupField(e, t, r, n) {
                const i = (0, p.basename)(t);
                const a = (0, s.tryFind)(i, e.shapes);
                if (a != null) {
                    const s = a;
                    const l = (0, d.List_tryLookup)(r, s.fields);
                    if (l != null) {
                        const r = l;
                        const a = (0, o.TTuple)((0, _.ofArray)([t, n]));
                        (0, u.Manager__Unify_Z1D753960)(e.UM, a, (0, u.Manager__Instantiate_Z25E5E15E)(e.UM, new o.polyt(0, s.parameters, (0, o.TTuple)((0, _.ofArray)([new o.monot(2, new o.monot(1, i), (0, _.map)((e => new o.monot(4, e)), s.parameters)), r]))))[1]);
                        Sigma__checkKind__Z25145215(e, a);
                        return (0, o.monot__Prune)(n)
                    } else {
                        const e = new c.NoField(t, r);
                        throw e
                    }
                } else {
                    const e = (0, c.UnboundTypeVariable)(i);
                    throw e
                }
            }

            function Sigma__registerExtGVar(e, t, r) {
                if ((0, s.containsKey)(t, e.global_variables)) {
                    const e = (0, c.DuplicateVariable)(t);
                    throw e
                } else {
                    e.global_variables = (0, s.add)(t, r, e.global_variables)
                }
            }

            function Sigma__registerCtorGVar(e, t, r) {
                if ((0, s.containsKey)(t, e.global_variables)) {
                    const e = (0, c.DuplicateVariable)(t);
                    throw e
                } else {
                    e.global_variables = (0, s.add)(t, new o.polyt(1, r), e.global_variables);
                    e.constructors = (0, a.add)(t, e.constructors);
                    let n, i, l;
                    if (r.tag === 3) {
                        if (r.fields[1].tag === 1) {
                            n = 0;
                            i = r.fields[0];
                            l = r.fields[1].fields[0]
                        } else {
                            n = 1
                        }
                    } else {
                        n = 1
                    }
                    switch (n) {
                        case 0: {
                            Sigma__addCase(e, l, t, i);
                            break
                        }
                        case 1: {
                            const e = new c.InvalidConstructorDefinination(t, new c.InvalidConstructorDefininationCause(4, r));
                            throw e;
                            break
                        }
                    }
                }
            }
            class Analyzer extends n.Record {
                constructor(e, t, r, n, i, o, s) {
                    super();
                    this.UM = e;
                    this.Sigma = t;
                    this.Omega = r;
                    this.LiteralTokens = n;
                    this.ReferencedNamedTokens = i;
                    this.TokenFragments = o;
                    this.IgnoreSet = s
                }
            }
            t.Analyzer = Analyzer;

            function Analyzer$reflection() {
                return (0, i.record_type)("tbnf.Analysis.Analyzer", [], Analyzer, (() => [
                    ["UM", (0, u.Manager$reflection)()],
                    ["Sigma", Sigma$reflection()],
                    ["Omega", (0, i.class_type)("Microsoft.FSharp.Collections.FSharpMap`2", [i.string_type, (0, o.monot$reflection)()])],
                    ["LiteralTokens", (0, i.class_type)("Microsoft.FSharp.Collections.FSharpSet`1", [i.string_type])],
                    ["ReferencedNamedTokens", (0, i.class_type)("Microsoft.FSharp.Collections.FSharpSet`1", [i.string_type])],
                    ["TokenFragments", (0, i.array_type)(i.string_type)],
                    ["IgnoreSet", (0, i.class_type)("Microsoft.FSharp.Collections.FSharpSet`1", [i.string_type])]
                ]))
            }

            function build_analyzer(e) {
                const t = new c.ErrorTrace(e[0], 0, (0, _.empty)(), (0, o.position_get_Fake)());
                const r = (0, u.Manager_$ctor)();
                const n = Sigma_$ctor_3EA8CBCD(r, t);
                let i = (0, s.empty)();
                let d = (0, a.empty)({
                    Compare: l.comparePrimitives
                });
                let p = (0, a.empty)({
                    Compare: l.comparePrimitives
                });
                let m = (0, _.empty)();
                let y = (0, a.empty)({
                    Compare: l.comparePrimitives
                });
                const infer_e = (e, t, i) => {
                    const a = t;
                    return Sigma__WithExpr(n, i, (() => {
                        const t = i.node;
                        switch (t.tag) {
                            case 6: {
                                const n = t.fields[0];
                                const a = (0, s.tryFind)(n, e);
                                if (a != null) {
                                    const e = (0, u.Manager__Instantiate_Z25E5E15E)(r, a);
                                    t.fields[1].contents = e[0];
                                    return new o.expr(i.node, i.pos, e[1])
                                } else {
                                    const e = (0, c.UnboundVariable)(n);
                                    throw e
                                }
                            }
                            case 9: {
                                return new o.expr(i.node, i.pos, o.TConst_str)
                            }
                            case 8: {
                                return new o.expr(i.node, i.pos, o.TConst_int)
                            }
                            case 11: {
                                return new o.expr(i.node, i.pos, o.TConst_bool)
                            }
                            case 10: {
                                return new o.expr(i.node, i.pos, o.TConst_float)
                            }
                            case 4: {
                                const r = t.fields[0];
                                const n = infer_e(e, a, t.fields[1]);
                                const l = infer_e((0, s.add)(r, new o.polyt(1, n.t), e), a, t.fields[2]);
                                return new o.expr(new o.node(4, r, n, l), i.pos, l.t)
                            }
                            case 2: {
                                const n = (0, u.Manager__NewTyRef_Z721C83C5)(r, "list");
                                return new o.expr(new o.node(2, (0, _.map)((t => {
                                    const i = infer_e(e, a, t);
                                    (0, u.Manager__Unify_Z1D753960)(r, n, i.t);
                                    return i
                                }), t.fields[0])), i.pos, (0, o.TList)((0, o.monot__Prune)(n)))
                            }
                            case 7: {
                                const e = t.fields[0] | 0;
                                const r = (0, _.tryItem)(e - 1, a);
                                if (r == null) {
                                    const t = new c.ComponentAccessingOutOfBound(e, (0, _.length)(a));
                                    throw t
                                } else {
                                    return new o.expr(i.node, i.pos, r)
                                }
                            }
                            case 0: {
                                const s = infer_e(e, a, t.fields[0]);
                                const l = s.t;
                                const c = (0, _.map)((t => infer_e(e, a, t)), t.fields[1]);
                                const d = (0, _.mapIndexed)(((e, t) => [`arg${e}`, t.t]), c);
                                const p = (0, u.Manager__NewTyRef_Z721C83C5)(r, "@ret");
                                (0, u.Manager__Unify_Z1D753960)(r, new o.monot(3, d, p), l);
                                Sigma__KindCheckMono_Z25145215(n, (0, o.monot__Prune)(l));
                                return new o.expr(new o.node(0, s, c), i.pos, (0, o.monot__Prune)(p))
                            }
                            case 3: {
                                const r = t.fields[1];
                                const s = infer_e(e, a, t.fields[0]);
                                return new o.expr(new o.node(3, s, r), i.pos, Sigma__LookupField(n, s.t, r))
                            }
                            case 5: {
                                const r = t.fields[0];
                                const l = infer_e((0, _.fold)(((e, t) => (0, s.add)(t[0], new o.polyt(1, Sigma__KindCheck_Z25145215(n, t[1])), e)), e, r), a, t.fields[1]);
                                return new o.expr(new o.node(5, r, l), i.pos, new o.monot(3, r, l.t))
                            }
                            default: {
                                const r = (0, _.map)((t => infer_e(e, a, t)), t.fields[0]);
                                return new o.expr(new o.node(1, r), i.pos, (0, o.TTuple)((0, _.map)((e => e.t), r)))
                            }
                        }
                    }))
                };
                const check_lexerule = e => {
                    e: while (true) {
                        const t = e;
                        let r, n, i;
                        if (t.tag === 10) {
                            r = 0
                        } else if (t.tag === 0) {
                            r = 0
                        } else if (t.tag === 1) {
                            r = 0
                        } else if (t.tag === 3) {
                            r = 0
                        } else if (t.tag === 2) {
                            r = 1;
                            n = t.fields[0]
                        } else if (t.tag === 4) {
                            r = 1;
                            n = t.fields[0]
                        } else if (t.tag === 9) {
                            r = 2;
                            i = t.fields[0]
                        } else if (t.tag === 8) {
                            r = 2;
                            i = t.fields[0]
                        } else if (t.tag === 7) {
                            r = 2;
                            i = t.fields[0]
                        } else if (t.tag === 6) {
                            r = 2;
                            i = t.fields[0]
                        } else if (t.tag === 11) {
                            if ((0, _.contains)(t.fields[0], m, {
                                    Equals: (e, t) => e === t,
                                    GetHashCode: l.stringHash
                                })) {
                                r = 3
                            } else {
                                r = 4
                            }
                        } else {
                            r = 0
                        }
                        switch (r) {
                            case 0: {
                                break
                            }
                            case 1: {
                                (0, _.iterate)(check_lexerule, n);
                                break
                            }
                            case 2: {
                                e = i;
                                continue e;
                                break
                            }
                            case 3: {
                                break
                            }
                            case 4: {
                                if (t.tag === 11) {
                                    const e = (0, c.UnboundLexer)(t.fields[0]);
                                    throw e
                                } else {
                                    throw new Error("Match failure")
                                }
                                break
                            }
                        }
                        break
                    }
                };
                return (0, f.withErrorHandler)((() => Sigma__GetErrorTrace(n)), (() => {
                    let t;
                    const f = (0, h.resolve_macro)((e => {
                        Sigma__SetCurrentPos_Z302187B(n, e)
                    }), (e => {
                        Sigma__SetCurrentDefinition_Z759AB257(n, e)
                    }), (e => {
                        Sigma__SetCurrentDefinitionBranch_Z524259A4(n, e)
                    }), e);
                    for (let e = 0; e <= f.length - 1; e++) {
                        const t = f[e];
                        Sigma__SetCurrentDefinition_Z759AB257(n, t);
                        let o, d, h, g, S, T;
                        if (t.tag === 6) {
                            o = 0;
                            d = t.fields[0]
                        } else if (t.tag === 3) {
                            o = 1;
                            h = t.fields[0]
                        } else if (t.tag === 4) {
                            o = 2;
                            g = t.fields[0]
                        } else if (t.tag === 5) {
                            o = 3;
                            S = t.fields[0]
                        } else if (t.tag === 0) {
                            o = 4
                        } else if (t.tag === 1) {
                            if ((0, s.containsKey)(t.fields[0].lhs, i)) {
                                o = 5;
                                T = t.fields[0]
                            } else {
                                o = 6
                            }
                        } else {
                            o = 6
                        }
                        switch (o) {
                            case 0: {
                                const e = (0, l.getEnumerator)(d.ignoreList);
                                try {
                                    while (e["System.Collections.IEnumerator.MoveNext"]()) {
                                        const t = e["System.Collections.Generic.IEnumerator`1.get_Current"]();
                                        p = (0, a.add)(t, y);
                                        y = (0, a.add)(t, y)
                                    }
                                } finally {
                                    (0, l.disposeSafe)(e)
                                }
                                break
                            }
                            case 1: {
                                Sigma__RegisterExtGVar(n, h.ident, Sigma__KindCheck_Z25E5E15E(n, h.t));
                                break
                            }
                            case 2: {
                                Sigma__RegisterCtorGVar(n, g.ident, Sigma__KindCheck_Z25145215(n, g.t));
                                break
                            }
                            case 3: {
                                Sigma__RegisterType(n, S.external, S.hasFields, S.ident, S.parameters, (0, _.map)((e => [e[0], e[1]]), S.fields));
                                const e = (0, l.getEnumerator)(S.fields);
                                try {
                                    while (e["System.Collections.IEnumerator.MoveNext"]()) {
                                        Sigma__KindCheckMono_Z25145215(n, e["System.Collections.Generic.IEnumerator`1.get_Current"]()[1])
                                    }
                                } finally {
                                    (0, l.disposeSafe)(e)
                                }
                                break
                            }
                            case 4: {
                                throw new Error("macro definition must be processed before type checking");
                                break
                            }
                            case 5: {
                                const e = (0, c.DuplicateNonterminal)(T.lhs);
                                throw e;
                                break
                            }
                            case 6: {
                                let e, n, o;
                                if (t.tag === 1) {
                                    e = 0;
                                    n = t.fields[0]
                                } else if (t.tag === 2) {
                                    if ((0, _.contains)(t.fields[0].lhs, m, {
                                            Equals: (e, t) => e === t,
                                            GetHashCode: l.stringHash
                                        })) {
                                        e = 1;
                                        o = t.fields[0]
                                    } else {
                                        e = 2
                                    }
                                } else {
                                    e = 2
                                }
                                switch (e) {
                                    case 0: {
                                        const e = (0, u.Manager__NewTyRef_Z721C83C5)(r, "'" + n.lhs);
                                        i = (0, s.add)(n.lhs, e, i);
                                        break
                                    }
                                    case 1: {
                                        const e = (0, c.DuplicateLexer)(o.lhs);
                                        throw e;
                                        break
                                    }
                                    case 2: {
                                        if (t.tag === 2) {
                                            m = (0, _.cons)(t.fields[0].lhs, m)
                                        } else {
                                            throw new Error("Match failure")
                                        }
                                        break
                                    }
                                }
                                break
                            }
                        }
                    }
                    for (let e = 0; e <= f.length - 1; e++) {
                        const t = f[e];
                        Sigma__SetCurrentDefinition_Z759AB257(n, t);
                        switch (t.tag) {
                            case 1: {
                                const e = t.fields[0];
                                const f = [e.lhs, e.define];
                                const h = (0, s.FSharpMap__get_Item)(i, f[0]);
                                let g = 0;
                                const y = (0, l.getEnumerator)(f[1]);
                                try {
                                    while (y["System.Collections.IEnumerator.MoveNext"]()) {
                                        const e = y["System.Collections.Generic.IEnumerator`1.get_Current"]();
                                        const t = e[1];
                                        Sigma__SetCurrentPos_Z302187B(n, e[0]);
                                        Sigma__SetCurrentDefinitionBranch_Z524259A4(n, g);
                                        const f = (0, _.map)((e => {
                                            if (e.tag === 0) {
                                                const t = e.fields[0];
                                                if (e.fields[1]) {
                                                    d = (0, a.add)(t, d)
                                                } else if (!(0, _.contains)(t, m, {
                                                        Equals: (e, t) => e === t,
                                                        GetHashCode: l.stringHash
                                                    })) {
                                                    const e = (0, c.UnboundLexer)(t);
                                                    throw e
                                                } else {
                                                    p = (0, a.add)(t, p)
                                                }
                                                return o.TConst_token
                                            } else if (e.tag === 1) {
                                                if ((0, s.containsKey)(e.fields[0], i)) {
                                                    return (0, s.FSharpMap__get_Item)(i, e.fields[0])
                                                } else if (e.tag === 1) {
                                                    const t = (0, c.UnboundNonterminal)(e.fields[0]);
                                                    throw t
                                                } else {
                                                    throw new Error("Match failure")
                                                }
                                            } else {
                                                let e;
                                                throw new Error("macrocall not processed");
                                                throw e
                                            }
                                        }), t.symbols);
                                        const S = infer_e(Sigma__get_GlobalVariables(n), f, t.action);
                                        (0, u.Manager__Unify_Z1D753960)(r, S.t, h);
                                        t.action = S;
                                        g = g + 1 | 0
                                    }
                                } finally {
                                    (0, l.disposeSafe)(y)
                                }
                                break
                            }
                            case 2: {
                                check_lexerule(t.fields[0].define);
                                break
                            }
                            default: {}
                        }
                    }
                    return [f, (t = (0, g.reverse)((0, _.toArray)(m)), new Analyzer(r, n, i, d, p, t, y))]
                }))
            }
        },
        9956: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CSharpKeywords = void 0;
            t.codegen = codegen;
            var n = r(6256);
            var i = r(5359);
            var o = r(1337);
            var s = r(9054);
            var a = r(4222);
            var l = r(5466);
            var _ = r(2078);
            var u = r(543);
            var c = r(1383);
            var d = r(1697);
            var p = r(3833);
            var f = r(4205);
            var h = r(9937);
            var g = r(9386);
            var m = r(7936);
            const y = ["__arglist", "__makeref", "__reftype", "__refvalue", "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "volatile", "void", "while"];
            t.CSharpKeywords = y;

            function codegen(e, t, r, S) {
                let T;
                const x = (0, n.defaultArg)(t.rename_var, (e => e));
                const C = (0, n.defaultArg)(t.rename_ctor, (e => e));
                const N = (0, n.defaultArg)(t.rename_var, (e => e));
                const A = (0, n.defaultArg)(t.rename_field, (e => e));
                const E = (0, n.defaultArg)(t.rename_type, (e => e));
                const typeParameter_mangling = e => "_GEN_" + e;
                let v = (0, i.empty)();
                let M = (0, i.empty)();
                const w = (0, o.ofArray)((0, s.append)(["result"], y), {
                    Compare: a.comparePrimitives
                });
                let b = (0, l.empty)();
                let F = (0, i.empty)();
                let B = (0, i.empty)();
                const I = (0, _.toList)((0, _.delay)((() => (0, _.map)((e => [e[0], x(e[0])]), (0, u.Sigma__get_GlobalVariables)(e.Sigma)))));
                const L = (0, c.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, c.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => {
                    const r = (((0, d.isLower)(t) ? true : (0, d.isUpper)(t)) ? true : (0, d.isUnicode)(t)) ? true : t === "_";
                    return e === 0 ? r : r ? true : (0, d.isDigit)(t)
                }), ((e, t) => (0, d.isDigit)(t) ? `_X${e}_` : `_${t.charCodeAt(0)}_`)), new c.NameMangling_nameEnv((0, o.ofList)((0, i.map)((e => e[1]), I), {
                    Compare: a.comparePrimitives
                })));
                const P = (0, c.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, c.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => e === 0 ? (0, d.isUpper)(t) : ((0, d.isUpper)(t) ? true : t === "_") ? true : (0, d.isDigit)(t)), ((e, t) => (0, d.isLower)(t) ? t.toUpperCase() : e === 0 ? (0, c.NameMangling_maskChar)(65, 90, t.charCodeAt(0)) + "_" : "_" + (0, c.NameMangling_maskChar)(65, 90, t.charCodeAt(0)) + "_")), new c.NameMangling_nameEnv((0, o.ofArray)(["EOF"], {
                    Compare: a.comparePrimitives
                })));
                const O = (0, c.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, c.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => e === 0 ? (0, d.isLower)(t) : ((0, d.isLower)(t) ? true : t === "_") ? true : (0, d.isDigit)(t)), ((e, t) => (0, d.isUpper)(t) ? t.toLowerCase() : "_" + (0, c.NameMangling_maskChar)(97, 122, t.charCodeAt(0)) + "_")), new c.NameMangling_nameEnv((0, o.ofArray)(["start"], {
                    Compare: a.comparePrimitives
                })));
                const mangle = (e, t) => (0, c.NameMangling_mangle)(w, e, t);
                const cg_symbol = e => {
                    const t = (0, l.tryFind)(e, b);
                    if (t == null) {
                        let t;
                        switch (e.tag) {
                            case 0: {
                                const r = e.fields[0];
                                t = e.fields[1] ? (0, d.escapeStringSingleQuoted)(r) : mangle(P, r);
                                break
                            }
                            case 1: {
                                t = mangle(O, e.fields[0]);
                                break
                            }
                            default: {
                                throw new Error("macro not processed")
                            }
                        }
                        b = (0, l.add)(e, t, b);
                        return t
                    } else {
                        return t
                    }
                };
                const name_of_named_term = e => cg_symbol(new p.symbol(0, e, false));
                const tryLookup = (e, t) => {
                    e: while (true) {
                        const r = e,
                            o = t;
                        if (!(0, i.isEmpty)(o)) {
                            if ((0, a.equals)((0, i.head)(o)[0], r)) {
                                return (0, n.some)((0, i.head)(o)[1])
                            } else if (!(0, i.isEmpty)(o)) {
                                e = r;
                                t = (0, i.tail)(o);
                                continue e
                            } else {
                                throw new Error("Match failure")
                            }
                        } else {
                            return void 0
                        }
                        break
                    }
                };
                const _cg_type = e => {
                    let t, r, n, o, s;
                    if (e.tag === 4) {
                        t = 1;
                        n = e.fields[0]
                    } else if (e.tag === 0) {
                        t = 2
                    } else if (e.tag === 3) {
                        t = 3;
                        o = e.fields[0];
                        s = e.fields[1]
                    } else if (e.tag === 2) {
                        if ((0, p.$007CTTuple$007C_$007C)(e.fields[0]) != null) {
                            if ((0, i.isEmpty)(e.fields[1])) {
                                t = 4
                            } else {
                                t = 5
                            }
                        } else {
                            t = 5
                        }
                    } else {
                        t = 0;
                        r = e.fields[0]
                    }
                    switch (t) {
                        case 0: {
                            return E(r)
                        }
                        case 1: {
                            return typeParameter_mangling(n)
                        }
                        case 2: {
                            const e = new f.UnsolvedTypeVariable;
                            throw e
                        }
                        case 3: {
                            return "System.Func<" + (0, h.join)(", ", (0, i.append)((0, i.map)((e => _cg_type(e[1])), o), (0, i.singleton)(_cg_type(s)))) + ">"
                        }
                        case 4: {
                            throw new Error("0-element tuple type detected")
                        }
                        case 5: {
                            let t, r;
                            if (e.tag === 2) {
                                if ((0, p.$007CTTuple$007C_$007C)(e.fields[0]) != null) {
                                    t = 0;
                                    r = e.fields[1]
                                } else {
                                    t = 1
                                }
                            } else {
                                t = 1
                            }
                            switch (t) {
                                case 0: {
                                    return "(" + (0, h.join)(", ", (0, i.map)(_cg_type, r)) + ")"
                                }
                                case 1: {
                                    if (e.tag === 2) {
                                        const t = (0, h.join)(", ", (0, i.map)(_cg_type, e.fields[1]));
                                        return _cg_type(e.fields[0]) + "<" + t + ">"
                                    } else {
                                        throw new Error("Match failure")
                                    }
                                }
                            }
                        }
                    }
                };
                const cg_type = e => _cg_type((0, p.monot__Prune)(e));
                const slotName = (e, t) => `${e}__${t}`;
                const R = "result";
                const mk_lexer = e => {
                    if (e.tag === 9) {
                        return "(" + mk_lexer(e.fields[0]) + ")"
                    } else if (e.tag === 5) {
                        return `~${mk_lexer(e.fields[0])}`
                    } else if (e.tag === 0) {
                        return "[0-9]"
                    } else if (e.tag === 6) {
                        return `${mk_lexer(e.fields[0])}+`
                    } else if (e.tag === 7) {
                        return `${mk_lexer(e.fields[0])}*`
                    } else if (e.tag === 1) {
                        return "."
                    } else if (e.tag === 11) {
                        const t = (0, d.List_tryLookup)(e.fields[0], B);
                        if (t == null) {
                            const t = (0, f.UnboundLexer)(e.fields[0]);
                            throw t
                        } else {
                            return name_of_named_term(e.fields[0])
                        }
                    } else if (e.tag === 2) {
                        return (0, h.join)(" ", (0, i.toArray)((0, i.map)(mk_lexer, e.fields[0])))
                    } else if (e.tag === 10) {
                        return `[${(0,d.iToU4)(e.fields[0])}-${(0,d.iToU4)(e.fields[1])}]`
                    } else if (e.tag === 4) {
                        if ((0, i.isEmpty)(e.fields[0])) {
                            throw new Error("impossible: alternatives cannot be empty.")
                        } else {
                            return (0, h.join)(" | ", (0, i.toArray)((0, i.map)(mk_lexer, e.fields[0])))
                        }
                    } else if (e.tag === 8) {
                        return `${mk_lexer(e.fields[0])}?`
                    } else {
                        return (0, d.escapeStringSingleQuoted)(e.fields[0])
                    }
                };
                const mk_lexer_debug = e => {
                    const t = mk_lexer_debug;
                    if (e.tag === 9) {
                        return t(e.fields[0])
                    } else if (e.tag === 5) {
                        return `pnot(${t(e.fields[0])})`
                    } else if (e.tag === 0) {
                        return "pnumber"
                    } else if (e.tag === 6) {
                        return `pplus(${t(e.fields[0])})`
                    } else if (e.tag === 7) {
                        return `pstar(${t(e.fields[0])})`
                    } else if (e.tag === 1) {
                        return "pany"
                    } else if (e.tag === 11) {
                        return e.fields[0]
                    } else if (e.tag === 2) {
                        const t = (0, h.join)(", ", (0, _.ofList)((0, i.map)(mk_lexer_debug, e.fields[0])));
                        return `pseq([${t}])`
                    } else if (e.tag === 10) {
                        return `pinterval(${e.fields[0]}, ${e.fields[1]})`
                    } else if (e.tag === 4) {
                        if (!(0, i.isEmpty)(e.fields[0])) {
                            return (0, i.fold)(((e, t) => `por(${e}, ${t})`), t((0, i.head)(e.fields[0])), (0, i.map)(mk_lexer_debug, (0, i.tail)(e.fields[0])))
                        } else {
                            throw new Error("impossible: alternatives cannot be empty.")
                        }
                    } else if (e.tag === 8) {
                        return `popt${t(e.fields[0])}`
                    } else {
                        return `pstring(${(0,d.escapeString)(e.fields[0])})`
                    }
                };
                const simplify_lexerule = e => {
                    switch (e.tag) {
                        case 1:
                        case 10:
                        case 11:
                        case 3: {
                            return e
                        }
                        case 9: {
                            return _must_be_atom_rule(e.fields[0])
                        }
                        case 5: {
                            return new p.lexerule(5, _must_be_atom_rule(e.fields[0]))
                        }
                        case 8: {
                            return new p.lexerule(8, _must_be_atom_rule(e.fields[0]))
                        }
                        case 6: {
                            return new p.lexerule(6, _must_be_atom_rule(e.fields[0]))
                        }
                        case 7: {
                            return new p.lexerule(7, _must_be_atom_rule(e.fields[0]))
                        }
                        case 4: {
                            return new p.lexerule(4, (0, i.map)(_must_be_atom_rule, e.fields[0]))
                        }
                        case 2: {
                            return new p.lexerule(2, (0, i.map)(_must_be_atom_rule, e.fields[0]))
                        }
                        default: {
                            return e
                        }
                    }
                };
                const _must_be_atom_rule = e => {
                    e: while (true) {
                        const t = e;
                        switch (t.tag) {
                            case 1:
                            case 10:
                            case 11:
                            case 3: {
                                return t
                            }
                            case 5: {
                                return new p.lexerule(5, _must_be_atom_rule(t.fields[0]))
                            }
                            case 8: {
                                return new p.lexerule(8, _must_be_atom_rule(t.fields[0]))
                            }
                            case 6: {
                                return new p.lexerule(6, _must_be_atom_rule(t.fields[0]))
                            }
                            case 7: {
                                return new p.lexerule(7, _must_be_atom_rule(t.fields[0]))
                            }
                            case 4: {
                                return new p.lexerule(9, new p.lexerule(4, (0, i.map)(_must_be_atom_rule, t.fields[0])))
                            }
                            case 2: {
                                return new p.lexerule(9, new p.lexerule(2, (0, i.map)(_must_be_atom_rule, t.fields[0])))
                            }
                            case 9: {
                                e = t.fields[0];
                                continue e
                            }
                            default: {
                                return t
                            }
                        }
                        break
                    }
                };
                let D = (0, i.empty)();
                const k = [`${r}.Constructor.` + ".cs", (0, g.vsep)((0, _.toList)((0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("using Antlr4.Runtime;")), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("using System.Collections.Generic;")), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("using System;")), (0, _.delay)((() => {
                    const t = (0, u.Sigma__GetADTCases)(e.Sigma);
                    return (0, _.append)((0, _.singleton)(g.empty), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)(`namespace ${r}{`)), (0, _.delay)((() => (0, _.append)((0, _.collect)((e => {
                        const t = E(e[0]);
                        return (0, _.append)((0, _.singleton)((0, g.word)(`public partial interface ${t} {  }`)), (0, _.delay)((() => (0, _.append)((0, _.collect)((e => {
                            const r = e[0];
                            const n = (0, i.map)((e => [(0, g.word)(A(e[0])), (0, g.word)(cg_type(e[1]))]), e[1]);
                            const o = C(r);
                            const s = (0, g.parens)((0, g.seplist)((0, g.word)(","), (0, _.toList)((0, _.delay)((() => (0, _.collect)((e => (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)(e[1], e[0]))), n))))));
                            return (0, _.append)((0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.word)(`public partial record ${o}`), s), (0, g.word)(`: ${t};`))), (0, _.delay)((() => {
                                const e = (0, g.word)(t);
                                D = (0, i.cons)(["", C(r), o, n, e], D);
                                return (0, _.empty)()
                            })))
                        }), (0, l.toArray)(e[1])), (0, _.delay)((() => (0, _.singleton)(g.empty)))))))
                    }), t), (0, _.delay)((() => (0, _.append)((0, _.collect)((e => {
                        const t = e[0];
                        const r = e[1];
                        const n = E(t);
                        const o = N(t);
                        let s;
                        if ((0, i.isEmpty)(r.parameters)) {
                            s = ["", (0, g.word)(n)]
                        } else {
                            const e = "<" + (0, h.join)(", ", (0, i.map)(typeParameter_mangling, r.parameters)) + ">";
                            s = [e, (0, g.word)(`${n}<${e}>`)]
                        }
                        const a = s[0];
                        const l = (0, _.toList)((0, _.delay)((() => (0, _.collect)((e => (0, _.singleton)([(0, g.word)(A(e[0])), (0, g.word)(cg_type(e[1]))])), r.fields))));
                        const u = (0, g.parens)((0, g.seplist)((0, g.word)(","), (0, _.toList)((0, _.delay)((() => (0, _.collect)((e => (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)(e[1], e[0]))), l))))));
                        return (0, _.append)((0, _.singleton)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.word)(`public partial record ${n}`), (0, g.word)(a)), u), (0, g.word)(";"))), (0, _.delay)((() => {
                            D = (0, i.cons)([a, o, n, l, s[1]], D);
                            return (0, _.empty)()
                        })))
                    }), (0, u.Sigma__GetRecordTypes)(e.Sigma)), (0, _.delay)((() => (0, _.singleton)((0, g.word)("}"))))))))))))))
                })))))))))))))];
                const parensIfLOr = e => {
                    if (e.tag === 4) {
                        return (0, g.parens)((0, g.word)(mk_lexer(e)))
                    } else {
                        return (0, g.word)(mk_lexer(e))
                    }
                };
                return (0, m.withErrorHandler)((T = e.Sigma, () => (0, u.Sigma__GetErrorTrace)(T)), (() => {
                    const t = (0, l.tryFind)("start", e.Omega);
                    if (t != null) {
                        const n = t;
                        const m = (0, g.vsep)((0, i.ofArray)((0, s.map)((t => {
                            (0, u.Sigma__SetCurrentDefinition_Z759AB257)(e.Sigma, t);
                            switch (t.tag) {
                                case 2: {
                                    const e = t.fields[0];
                                    B = (0, i.cons)([e.lhs, e.define], B);
                                    return g.empty
                                }
                                case 6: {
                                    return (0, g.vsep)((0, i.empty)())
                                }
                                case 4: {
                                    return (0, g.vsep)((0, i.empty)())
                                }
                                case 3: {
                                    v = (0, i.cons)(x(t.fields[0].ident), v);
                                    return (0, g.vsep)((0, i.empty)())
                                }
                                case 5: {
                                    M = (0, i.cons)(E(t.fields[0].ident), M);
                                    return (0, g.vsep)((0, i.empty)())
                                }
                                case 0: {
                                    throw new Error("macro not processed")
                                }
                                default: {
                                    const r = t.fields[0];
                                    const n = r.lhs;
                                    const s = cg_symbol(new p.symbol(1, n));
                                    let m;
                                    const y = new p.symbol(1, n);
                                    switch (y.tag) {
                                        case 0: {
                                            m = p.TConst_token;
                                            break
                                        }
                                        case 1: {
                                            m = (0, l.FSharpMap__get_Item)(e.Omega, y.fields[0]);
                                            break
                                        }
                                        default: {
                                            throw new Error("macro not processed")
                                        }
                                    }
                                    let S = 0;
                                    const T = (0, g.align)((0, g.vsep)((0, i.mapIndexed)(((e, t) => (0, g.Doc_op_Addition_Z7CFFAC00)(e === 0 ? (0, g.word)(":") : (0, g.word)("|"), t)), (0, _.toList)((0, _.delay)((() => (0, _.collect)((t => {
                                        let r, n, l, m, y, T, x;
                                        (0, u.Sigma__SetCurrentPos_Z302187B)(e.Sigma, t[0]);
                                        (0, u.Sigma__SetCurrentDefinitionBranch_Z524259A4)(e.Sigma, S);
                                        return (0, _.append)((0, _.singleton)((r = t[1], n = (l = S | 0, (0, h.toText)((0, h.printf)("%s_%i"))(s)(l)), m = (y = r.action, T = (0, _.toArray)((0, _.delay)((() => (0, _.map)((e => e.tag === 0), r.symbols)))), (0, u.Sigma__WithExpr)(e.Sigma, y, (() => {
                                            let e = (0, o.empty)({
                                                Compare: a.comparePrimitives
                                            });
                                            const cg_expr = (t, r) => (0, c.DocBuilder_Builder__Run_ZD0BB270)(c.DocBuilder_cg, (0, c.DocBuilder_Builder__Delay_Z3A9C5A06)(c.DocBuilder_cg, (() => {
                                                let s, a, l, u;
                                                const m = r.node;
                                                if (m.tag === 6) {
                                                    const e = tryLookup(m.fields[0], t);
                                                    if (e != null) {
                                                        const t = e;
                                                        return (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, i.length)(m.fields[1].contents) === 0 ? (0, g.word)(t) : (s = (a = (0, i.map)((e => (0, g.word)(cg_type(e))), (0, i.map)(p.monot__Prune, m.fields[1].contents)), (0, g.seplist)((0, g.word)(", "), a)), (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.word)(t), (0, g.word)("<")), s), (0, g.word)(">"))))
                                                    } else {
                                                        return (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (() => {
                                                            throw (0, f.UnboundVariable)(m.fields[0])
                                                        })())
                                                    }
                                                } else if (m.tag === 11) {
                                                    return m.fields[0] ? (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.word)("true")) : (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.word)("false"))
                                                } else if (m.tag === 3) {
                                                    return (0, c.DocBuilder_Builder__Bind_30A200B3)(c.DocBuilder_cg, cg_expr(t, m.fields[0]), (e => (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)(e, (0, g.word)(".")), (0, g.word)(m.fields[1])))))
                                                } else if (m.tag === 8) {
                                                    return (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.word)((0, h.toText)((0, h.printf)("%d"))(m.fields[0])))
                                                } else if (m.tag === 10) {
                                                    return (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.word)((0, h.toText)((0, h.printf)("%f"))(m.fields[0])))
                                                } else if (m.tag === 9) {
                                                    return (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.word)((0, d.escapeString)(m.fields[0])))
                                                } else if (m.tag === 5) {
                                                    const e = (0, c.DocBuilder_runCG)(cg_expr((0, i.append)((0, _.toList)((0, _.delay)((() => (0, _.collect)((e => {
                                                        const t = e[0];
                                                        return (0, _.singleton)([t, mangle(L, t)])
                                                    }), m.fields[0])))), t), m.fields[1]));
                                                    return (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (l = (0, g.vsep)((0, i.ofArray)([(0, g.vsep)(e[1]), (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("return"), (0, g.Doc_op_Multiply_Z7CFFAC00)(e[0], (0, g.word)(";")))])), u = (0, i.map)((e => (0, g.word)(cg_type(e[1]) + " " + e[0])), m.fields[0]), (0, g.parens)((0, g.vsep)((0, i.ofArray)([(0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.parens)((0, g.seplist)((0, g.word)(", "), u)), (0, g.word)("=>")), (0, g.Doc_op_RightShift_2AAA0F3C)(l, 4)])))))
                                                } else if (m.tag === 4) {
                                                    return (0, c.DocBuilder_Builder__Bind_30A200B3)(c.DocBuilder_cg, cg_expr(t, m.fields[1]), (e => {
                                                        const r = mangle(L, m.fields[0]);
                                                        return (0, c.DocBuilder_Builder__Combine_Z5C764E00)(c.DocBuilder_cg, (0, c.DocBuilder_Builder__Yield_417FD60)(c.DocBuilder_cg, (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(cg_type(m.fields[1].t)), (0, g.word)(r)), (0, g.word)("=")), (0, g.Doc_op_Multiply_Z7CFFAC00)(e, (0, g.word)(";")))), (0, c.DocBuilder_Builder__Delay_Z3A9C5A06)(c.DocBuilder_cg, (() => (0, c.DocBuilder_Builder__ReturnFrom_ZD0BB270)(c.DocBuilder_cg, cg_expr((0, i.cons)([m.fields[0], r], t), m.fields[2])))))
                                                    }))
                                                } else if (m.tag === 2) {
                                                    return (0, c.DocBuilder_Builder__Bind_30A200B3)(c.DocBuilder_cg, (0, c.DocBuilder_Builder__Run_ZD0BB270)(c.DocBuilder_cg, (0, c.DocBuilder_Builder__Delay_Z3A9C5A06)(c.DocBuilder_cg, (() => (0, c.DocBuilder_Builder__For_2B96F4AF)(c.DocBuilder_cg, m.fields[0], (e => (0, c.DocBuilder_Builder__ReturnFrom_ZD0BB270)(c.DocBuilder_cg, cg_expr(t, e))))))), (e => (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("new"), (0, g.word)(cg_type(r.t))), (0, g.word)("{")), (0, g.seplist)((0, g.word)(","), e)), (0, g.word)("}")))))
                                                } else if (m.tag === 7) {
                                                    const t = slotName(n, m.fields[0]);
                                                    e = (0, o.add)(m.fields[0], e);
                                                    const r = (0, g.word)(`_localctx.${t}`);
                                                    return (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, T[m.fields[0] - 1] ? r : (0, g.Doc_op_Multiply_Z7CFFAC00)(r, (0, g.word)(".result")))
                                                } else {
                                                    return m.tag === 1 ? (0, c.DocBuilder_Builder__Bind_30A200B3)(c.DocBuilder_cg, (0, c.DocBuilder_Builder__Run_ZD0BB270)(c.DocBuilder_cg, (0, c.DocBuilder_Builder__Delay_Z3A9C5A06)(c.DocBuilder_cg, (() => (0, c.DocBuilder_Builder__For_2B96F4AF)(c.DocBuilder_cg, m.fields[0], (e => (0, c.DocBuilder_Builder__ReturnFrom_ZD0BB270)(c.DocBuilder_cg, cg_expr(t, e))))))), (e => (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.parens)((0, g.seplist)((0, g.word)(", "), e))))) : (0, c.DocBuilder_Builder__Bind_30A200B3)(c.DocBuilder_cg, cg_expr(t, m.fields[0]), (e => (0, c.DocBuilder_Builder__Bind_30A200B3)(c.DocBuilder_cg, (0, c.DocBuilder_Builder__Run_ZD0BB270)(c.DocBuilder_cg, (0, c.DocBuilder_Builder__Delay_Z3A9C5A06)(c.DocBuilder_cg, (() => (0, c.DocBuilder_Builder__For_2B96F4AF)(c.DocBuilder_cg, m.fields[1], (e => {
                                                        const r = e;
                                                        return (0, c.DocBuilder_Builder__Bind_30A200B3)(c.DocBuilder_cg, cg_expr(t, r), (e => (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.parens)((0, g.word)(cg_type(r.t))), e))))
                                                    }))))), (t => {
                                                        const n = cg_type(r.t);
                                                        return (0, c.DocBuilder_Builder__Return_1505)(c.DocBuilder_cg, (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(`(${n})`), (0, g.Doc_op_Multiply_Z7CFFAC00)(e, (0, g.parens)((0, g.seplist)((0, g.word)(", "), t)))))
                                                    }))))
                                                }
                                            })));
                                            const t = (0, c.DocBuilder_runCG)(cg_expr(I, y));
                                            return [e, t]
                                        }))), (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((x = (0, i.mapIndexed)(((e, t) => {
                                            const r = e + 1 | 0;
                                            const i = (0, g.word)(cg_symbol(t));
                                            if ((0, o.contains)(r, m[0])) {
                                                return (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.word)(slotName(n, r)), (0, g.word)("=")), i)
                                            } else {
                                                return i
                                            }
                                        }), r.symbols), (0, g.seplist)((0, g.word)(" "), x)), (0, g.word)("{")), (0, g.Doc_op_RightShift_2AAA0F3C)((0, g.vsep)((0, i.ofArray)([g.empty, (0, g.Doc_op_RightShift_2AAA0F3C)((0, g.vsep)((0, i.ofArray)([(0, g.vsep)(m[1][1]), (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("$" + R), (0, g.word)("=")), (0, g.Doc_op_Multiply_Z7CFFAC00)(m[1][0], (0, g.word)(";")))])), 4), (0, g.word)("}")])), 12)))), (0, _.delay)((() => {
                                            S = S + 1 | 0;
                                            return (0, _.empty)()
                                        })))
                                    }), r.define)))))));
                                    return (0, g.vsep)((0, i.ofArray)([(0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(s), (0, g.word)("returns")), (0, g.bracket)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(cg_type(m)), (0, g.word)(R)))), (0, g.Doc_op_RightShift_2AAA0F3C)(T, 4), (0, g.word)(";")]))
                                }
                            }
                        }), S)));
                        const y = (0, _.toList)((0, _.delay)((() => (0, _.collect)((t => {
                            const r = t[0];
                            const n = simplify_lexerule(t[1]);
                            const i = name_of_named_term(r);
                            return (0, o.contains)(r, e.IgnoreSet) ? (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(i), (0, g.word)(":")), parensIfLOr(n)), (0, g.word)("-> channel(HIDDEN);"))) : (0, o.contains)(r, e.ReferencedNamedTokens) ? (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(i), (0, g.word)(":")), (0, g.word)(mk_lexer(n))), (0, g.word)(";"))) : (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("fragment"), (0, g.word)(i)), (0, g.word)(":")), parensIfLOr(n)), (0, g.word)(";")))
                        }), (0, i.reverse)(B)))));
                        const T = cg_symbol(new p.symbol(1, "start"));
                        return [
                            [r + ".g4", (0, g.vsep)((0, _.toList)((0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)(`grammar ${r};`)), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("options { language = CSharp; }")), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("@members {")), (0, _.delay)((() => (0, _.append)((0, _.collect)((e => {
                                const t = e[4];
                                const r = e[3];
                                const n = (0, g.parens)((0, g.seplist)((0, g.word)(","), (0, i.map)((e => (0, g.Doc_op_Addition_Z7CFFAC00)(e[1], e[0])), r)));
                                const o = (0, g.parens)((0, g.seplist)((0, g.word)(","), (0, i.map)((e => e[0]), r)));
                                return (0, _.singleton)((0, g.vsep)((0, _.toList)((0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("public static"), t), (0, g.word)(e[1])), (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.word)(e[0]), n))), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("{")), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.Doc_op_RightShift_2AAA0F3C)((0, g.vsep)((0, i.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("return"), (0, g.parens)(t)), (0, g.word)("new")), (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.word)(e[2]), o), (0, g.word)(";"))))), 4)), (0, _.delay)((() => (0, _.singleton)((0, g.word)("}"))))))))))))))))
                            }), D), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("}")), (0, _.delay)((() => {
                                let e;
                                return (0, _.append)((0, _.singleton)((0, g.word)((e = cg_type(n), (0, h.toText)((0, h.printf)("start returns [%s result]: v=%s EOF { $result = _localctx.v.result; };"))(e)(T)))), (0, _.delay)((() => (0, _.append)((0, _.singleton)(m), (0, _.delay)((() => y))))))
                            })))))))))))))))))))], k
                        ]
                    } else {
                        const e = (0, f.UnboundNonterminal)("start");
                        throw e
                    }
                }))
            }
        },
        1383: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.DocBuilder_Builder = void 0;
            t.DocBuilder_Builder$reflection = DocBuilder_Builder$reflection;
            t.DocBuilder_Builder_$ctor = DocBuilder_Builder_$ctor;
            t.DocBuilder_Builder__Bind_30A200B3 = DocBuilder_Builder__Bind_30A200B3;
            t.DocBuilder_Builder__Combine_Z5C764E00 = DocBuilder_Builder__Combine_Z5C764E00;
            t.DocBuilder_Builder__Delay_Z3A9C5A06 = DocBuilder_Builder__Delay_Z3A9C5A06;
            t.DocBuilder_Builder__For_2B96F4AF = DocBuilder_Builder__For_2B96F4AF;
            t.DocBuilder_Builder__ReturnFrom_ZD0BB270 = DocBuilder_Builder__ReturnFrom_ZD0BB270;
            t.DocBuilder_Builder__Return_1505 = DocBuilder_Builder__Return_1505;
            t.DocBuilder_Builder__Run_ZD0BB270 = DocBuilder_Builder__Run_ZD0BB270;
            t.DocBuilder_Builder__YieldFrom_38ABB44A = DocBuilder_Builder__YieldFrom_38ABB44A;
            t.DocBuilder_Builder__Yield_417FD60 = DocBuilder_Builder__Yield_417FD60;
            t.DocBuilder_Builder__Zero = DocBuilder_Builder__Zero;
            t.DocBuilder_block$1 = void 0;
            t.DocBuilder_block$1$reflection = DocBuilder_block$1$reflection;
            t.DocBuilder_cg = void 0;
            t.DocBuilder_runCG = DocBuilder_runCG;
            t.NameMangling_IdentifierDescriptor = void 0;
            t.NameMangling_IdentifierDescriptor$reflection = NameMangling_IdentifierDescriptor$reflection;
            t.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF = NameMangling_IdentifierDescriptor_Create_Z48C5CCEF;
            t.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B = NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B;
            t.NameMangling_is_valid_identifier = NameMangling_is_valid_identifier;
            t.NameMangling_mangle = NameMangling_mangle;
            t.NameMangling_maskChar = NameMangling_maskChar;
            t.NameMangling_nameEnv = void 0;
            t.NameMangling_nameEnv$reflection = NameMangling_nameEnv$reflection;
            t.NameMangling_to_valid_identifier = NameMangling_to_valid_identifier;
            var n = r(6638);
            var i = r(6356);
            var o = r(1337);
            var s = r(4222);
            var a = r(8443);
            var l = r(1697);
            var _ = r(9386);
            var u = r(5359);
            var c = r(2078);
            class NameMangling_nameEnv extends n.Record {
                constructor(e) {
                    super();
                    this.usedNames = e
                }
            }
            t.NameMangling_nameEnv = NameMangling_nameEnv;

            function NameMangling_nameEnv$reflection() {
                return (0, i.record_type)("tbnf.Backends.Common.NameMangling.nameEnv", [], NameMangling_nameEnv, (() => [
                    ["usedNames", (0, i.class_type)("Microsoft.FSharp.Collections.FSharpSet`1", [i.string_type])]
                ]))
            }
            class NameMangling_IdentifierDescriptor extends n.Record {
                constructor(e, t, r) {
                    super();
                    this.isValidChar = e;
                    this.charToValid = t;
                    this.nameEnv = r
                }
            }
            t.NameMangling_IdentifierDescriptor = NameMangling_IdentifierDescriptor;

            function NameMangling_IdentifierDescriptor$reflection() {
                return (0, i.record_type)("tbnf.Backends.Common.NameMangling.IdentifierDescriptor", [], NameMangling_IdentifierDescriptor, (() => [
                    ["isValidChar", (0, i.lambda_type)(i.int32_type, (0, i.lambda_type)(i.char_type, i.bool_type))],
                    ["charToValid", (0, i.lambda_type)(i.int32_type, (0, i.lambda_type)(i.char_type, i.string_type))],
                    ["nameEnv", NameMangling_nameEnv$reflection()]
                ]))
            }

            function NameMangling_IdentifierDescriptor_Create_Z48C5CCEF(e, t) {
                return new NameMangling_IdentifierDescriptor(e, t, new NameMangling_nameEnv((0, o.empty)({
                    Compare: s.comparePrimitives
                })))
            }

            function NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B(e, t) {
                return new NameMangling_IdentifierDescriptor(e.isValidChar, e.charToValid, t)
            }

            function NameMangling_maskChar(e, t, r) {
                return String.fromCharCode(e + r % (t - e + 1))
            }

            function NameMangling_is_valid_identifier(e, t) {
                if (t === "") {
                    return true
                } else {
                    const loop = r => {
                        e: while (true) {
                            const n = r;
                            if (n >= t.length) {
                                return true
                            } else if (e.isValidChar(n, t[n])) {
                                r = n + 1;
                                continue e
                            } else {
                                return false
                            }
                            break
                        }
                    };
                    return loop(0)
                }
            }

            function NameMangling_to_valid_identifier(e, t) {
                if (t === "") {
                    throw new Error("empty identifier")
                } else {
                    const r = (0, a.StringBuilder_$ctor)();
                    const loop = n => {
                        e: while (true) {
                            const i = n;
                            if (i >= t.length) {} else {
                                if (e.isValidChar(i, t[i])) {
                                    (0, a.StringBuilder__Append_244C7CD6)(r, t[i])
                                } else {
                                    (0, a.StringBuilder__Append_Z721C83C5)(r, e.charToValid(i, t[i]))
                                }
                                n = i + 1;
                                continue e
                            }
                            break
                        }
                    };
                    loop(0);
                    return (0, n.toString)(r)
                }
            }

            function NameMangling_mangle(e, t, r) {
                let n = NameMangling_is_valid_identifier(t, r) ? r : NameMangling_to_valid_identifier(t, r);
                while ((0, o.contains)(n, e)) {
                    const e = t.isValidChar(n.length, "_") ? "_" + t.charToValid(n.length + 1, l.lowerChars[n.length % l.lowerChars.length]) : t.charToValid(n.length, l.lowerChars[n.length % l.lowerChars.length]);
                    n = n + e
                }
                const i = t.nameEnv;
                while ((0, o.contains)(n, i.usedNames)) {
                    const e = t.isValidChar(n.length, "_") ? "_" + t.charToValid(n.length + 1, l.lowerChars[n.length % l.lowerChars.length]) : t.charToValid(n.length, l.lowerChars[n.length % l.lowerChars.length]);
                    n = n + e
                }
                i.usedNames = (0, o.add)(n, i.usedNames);
                return n
            }
            class DocBuilder_block$1 extends n.Record {
                constructor(e, t) {
                    super();
                    this.suite = e;
                    this.value = t
                }
            }
            t.DocBuilder_block$1 = DocBuilder_block$1;

            function DocBuilder_block$1$reflection(e) {
                return (0, i.record_type)("tbnf.Backends.Common.DocBuilder.block`1", [e], DocBuilder_block$1, (() => [
                    ["suite", (0, i.list_type)((0, _.Doc$reflection)())],
                    ["value", e]
                ]))
            }
            class DocBuilder_Builder {
                constructor() {}
            }
            t.DocBuilder_Builder = DocBuilder_Builder;

            function DocBuilder_Builder$reflection() {
                return (0, i.class_type)("tbnf.Backends.Common.DocBuilder.Builder", void 0, DocBuilder_Builder)
            }

            function DocBuilder_Builder_$ctor() {
                return new DocBuilder_Builder
            }

            function DocBuilder_Builder__Bind_30A200B3(e, t, r) {
                const n = r(t.value);
                return new DocBuilder_block$1((0, u.append)(n.suite, t.suite), n.value)
            }

            function DocBuilder_Builder__Return_1505(e, t) {
                return new DocBuilder_block$1((0, u.empty)(), t)
            }

            function DocBuilder_Builder__Run_ZD0BB270(e, t) {
                return t
            }

            function DocBuilder_Builder__Combine_Z5C764E00(e, t, r) {
                return new DocBuilder_block$1((0, u.append)(r.suite, t.suite), r.value)
            }

            function DocBuilder_Builder__Yield_417FD60(e, t) {
                return new DocBuilder_block$1((0, u.singleton)(t), (0, u.empty)())
            }

            function DocBuilder_Builder__YieldFrom_38ABB44A(e, t) {
                return new DocBuilder_block$1((0, u.reverse)(t), void 0)
            }

            function DocBuilder_Builder__Zero(e) {
                return new DocBuilder_block$1((0, u.empty)(), void 0)
            }

            function DocBuilder_Builder__Delay_Z3A9C5A06(e, t) {
                return t()
            }

            function DocBuilder_Builder__For_2B96F4AF(e, t, r) {
                let n = (0, u.empty)();
                const i = (0, c.toList)((0, c.delay)((() => (0, c.collect)((e => {
                    const t = r(e);
                    n = (0, u.append)(t.suite, n);
                    return (0, c.singleton)(t.value)
                }), t))));
                return new DocBuilder_block$1(n, i)
            }

            function DocBuilder_Builder__ReturnFrom_ZD0BB270(e, t) {
                return t
            }

            function DocBuilder_runCG(e) {
                return [e.value, (0, u.reverse)(e.suite)]
            }
            const d = DocBuilder_Builder_$ctor();
            t.DocBuilder_cg = d
        },
        2835: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.codegen = codegen;
            var n = r(6256);
            var i = r(5506);
            var o = r(5359);
            var s = r(1337);
            var a = r(4222);
            var l = r(5466);
            var _ = r(2078);
            var u = r(543);
            var c = r(1383);
            var d = r(1697);
            var p = r(3833);
            var f = r(4205);
            var h = r(9937);
            var g = r(9386);
            var m = r(7936);
            var y = r(9054);

            function codegen(e, t, r, S) {
                let T;
                const x = (0, n.defaultArg)(t.rename_var, (e => e));
                const C = (0, n.defaultArg)(t.rename_ctor, (e => e));
                const N = (0, n.defaultArg)(t.rename_field, (e => e));
                const A = (0, n.defaultArg)(t.rename_type, (e => e));
                const E = t.start_rule_qualified_type;
                const v = t.request_resource(i.ocaml_rts_file);
                let M = (0, o.empty)();
                let w = (0, o.empty)();
                const b = (0, s.ofArray)(["and", "as", "assert", "asr", "begin", "class", "constraint", "do", "done", "downto", "else", "end", "exception", "external", "false", "for", "fun", "function", "functor", "if", "in", "include", "inherit", "initializer", "land", "lazy", "let", "lor", "lsl", "lsr", "lxor", "match", "method", "mod", "module", "mutable", "new", "nonrec", "object", "of", "open", "or", "private", "rec", "sig", "struct", "then", "to", "true", "try", "type", "val", "virtual", "when", "while", "with"], {
                    Compare: a.comparePrimitives
                });
                let F = (0, l.empty)();
                let B = (0, o.empty)();
                let I = (0, o.empty)();
                const L = (0, _.toList)((0, _.delay)((() => (0, _.map)((e => [e[0], x(e[0])]), (0, u.Sigma__get_GlobalVariables)(e.Sigma)))));
                const P = (0, c.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, c.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => {
                    const r = ((0, d.isLower)(t) ? true : (0, d.isUnicode)(t)) ? true : t === "_";
                    return e === 0 ? r : r ? true : (0, d.isDigit)(t)
                }), ((e, t) => (0, d.isDigit)(t) ? `_X${e}_` : (0, d.isUpper)(t) ? t.toLowerCase() : `_${t.charCodeAt(0)}_`)), new c.NameMangling_nameEnv((0, s.ofList)((0, o.map)((e => e[1]), L), {
                    Compare: a.comparePrimitives
                })));
                const O = (0, c.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, c.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => e === 0 ? (0, d.isUpper)(t) : ((0, d.isUpper)(t) ? true : t === "_") ? true : (0, d.isDigit)(t)), ((e, t) => (0, d.isLower)(t) ? t.toUpperCase() : e === 0 ? (0, c.NameMangling_maskChar)(65, 90, t.charCodeAt(0)) + "_" : "_" + (0, c.NameMangling_maskChar)(65, 90, t.charCodeAt(0)) + "_")), new c.NameMangling_nameEnv((0, s.ofArray)(["EOF"], {
                    Compare: a.comparePrimitives
                })));
                const R = (0, c.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, c.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => e === 0 ? (0, d.isLower)(t) : ((0, d.isLower)(t) ? true : t === "_") ? true : (0, d.isDigit)(t)), ((e, t) => (0, d.isUpper)(t) ? t.toLowerCase() : "_" + (0, c.NameMangling_maskChar)(97, 122, t.charCodeAt(0)) + "_")), new c.NameMangling_nameEnv((0, s.ofArray)(["start"], {
                    Compare: a.comparePrimitives
                })));
                const mangle = (e, t) => (0, c.NameMangling_mangle)(b, e, t);
                const cg_symbol = e => {
                    const t = (0, l.tryFind)(e, F);
                    if (t == null) {
                        let t;
                        switch (e.tag) {
                            case 0: {
                                const r = e.fields[0];
                                t = e.fields[1] ? mangle(O, '"' + r + '"') : mangle(O, r);
                                break
                            }
                            case 1: {
                                t = mangle(R, e.fields[0]);
                                break
                            }
                            default: {
                                throw new Error("macro not processed")
                            }
                        }
                        F = (0, l.add)(e, t, F);
                        return t
                    } else {
                        return t
                    }
                };
                const name_of_named_term = e => cg_symbol(new p.symbol(0, e, false));
                const tryLookup = (e, t) => {
                    e: while (true) {
                        const r = e,
                            i = t;
                        if (!(0, o.isEmpty)(i)) {
                            if ((0, a.equals)((0, o.head)(i)[0], r)) {
                                return (0, n.some)((0, o.head)(i)[1])
                            } else if (!(0, o.isEmpty)(i)) {
                                e = r;
                                t = (0, o.tail)(i);
                                continue e
                            } else {
                                throw new Error("Match failure")
                            }
                        } else {
                            return void 0
                        }
                        break
                    }
                };
                const _cg_type = e => {
                    if (e.tag === 4) {
                        return "'" + e.fields[0]
                    } else if (e.tag === 0) {
                        const e = new f.UnsolvedTypeVariable;
                        throw e
                    } else if (e.tag === 3) {
                        return "(" + (0, h.join)(" * ", (0, o.map)((e => _cg_type(e[1])), e.fields[0])) + ") -> " + _cg_type(e.fields[1])
                    } else if (e.tag === 2) {
                        if ((0, p.$007CTTuple$007C_$007C)(e.fields[0]) != null) {
                            return "(" + (0, h.join)(" * ", (0, o.map)(_cg_type, e.fields[1])) + ")"
                        } else if (e.tag === 2) {
                            return "(" + (0, h.join)(", ", (0, o.map)(_cg_type, e.fields[1])) + ") " + _cg_type(e.fields[0])
                        } else {
                            throw new Error("Match failure")
                        }
                    } else {
                        return A(e.fields[0])
                    }
                };
                const cg_type = e => _cg_type((0, p.monot__Prune)(e));
                const cg_expr = (t, r) => (0, u.Sigma__WithExpr)(e.Sigma, r, (() => {
                    const e = r.node;
                    if (e.tag === 6) {
                        const r = tryLookup(e.fields[0], t);
                        if (r != null) {
                            return (0, g.word)(r)
                        } else {
                            throw (0, f.UnboundVariable)(e.fields[0])
                        }
                    } else if (e.tag === 11) {
                        return e.fields[0] ? (0, g.word)("true") : (0, g.word)("false")
                    } else if (e.tag === 3) {
                        return (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)(cg_expr(t, e.fields[0]), (0, g.word)(":")), (0, g.word)(cg_type(r.t))), (0, g.word)(".")), (0, g.word)(e.fields[1]))
                    } else if (e.tag === 8) {
                        return (0, g.word)((0, h.toText)((0, h.printf)("%d"))(e.fields[0]))
                    } else if (e.tag === 10) {
                        return (0, g.word)((0, h.toText)((0, h.printf)("%f"))(e.fields[0]))
                    } else if (e.tag === 9) {
                        return (0, g.word)((0, d.escapeString)(e.fields[0]))
                    } else if (e.tag === 5) {
                        const r = cg_expr((0, o.append)((0, _.toList)((0, _.delay)((() => (0, _.collect)((e => {
                            const t = e[0];
                            return (0, _.singleton)([t, mangle(P, t)])
                        }), e.fields[0])))), t), e.fields[1]);
                        const n = (0, o.map)((e => (0, g.word)(e[0] + ":" + cg_type(e[1]))), e.fields[0]);
                        return (0, g.parens)((0, g.vsep)((0, o.ofArray)([(0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("fun"), (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.parens)((0, g.seplist)((0, g.word)(", "), n)), (0, g.word)("->"))), (0, g.Doc_op_RightShift_2AAA0F3C)(r, 4)])))
                    } else if (e.tag === 4) {
                        const r = cg_expr(t, e.fields[1]);
                        const n = mangle(P, e.fields[0]);
                        const i = cg_expr((0, o.cons)([e.fields[0], n], t), e.fields[2]);
                        const s = (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.word)(n), (0, g.word)(":")), (0, g.word)(cg_type(e.fields[1].t)));
                        return (0, g.vsep)((0, o.ofArray)([(0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("let"), s), (0, g.word)("=")), r), (0, g.word)("in")), i]))
                    } else if (e.tag === 2) {
                        return (0, g.bracket)((0, g.seplist)((0, g.word)(";"), (0, o.map)((e => cg_expr(t, e)), e.fields[0])))
                    } else if (e.tag === 7) {
                        return (0, g.word)(`$${e.fields[0]}`)
                    } else if (e.tag === 1) {
                        return (0, g.parens)((0, g.seplist)((0, g.word)(", "), (0, o.map)((e => cg_expr(t, e)), e.fields[0])))
                    } else {
                        const r = cg_expr(t, e.fields[0]);
                        const n = (0, o.map)((e => cg_expr(t, e)), e.fields[1]);
                        return (0, g.Doc_op_Multiply_Z7CFFAC00)(r, (0, g.parens)((0, g.seplist)((0, g.word)(", "), n)))
                    }
                }));
                const mk_lexer = e => {
                    const t = mk_lexer;
                    let r, n, i, s, a, l, _, u, c, p, g, m;
                    if (e.tag === 9) {
                        if (e.fields[0].tag === 9) {
                            r = 1;
                            i = e.fields[0].fields[0]
                        } else {
                            r = 1;
                            i = e.fields[0]
                        }
                    } else if (e.tag === 5) {
                        r = 2;
                        s = e.fields[0]
                    } else if (e.tag === 0) {
                        r = 3
                    } else if (e.tag === 6) {
                        r = 4;
                        a = e.fields[0]
                    } else if (e.tag === 7) {
                        r = 5;
                        l = e.fields[0]
                    } else if (e.tag === 1) {
                        r = 6
                    } else if (e.tag === 11) {
                        r = 7;
                        _ = e.fields[0]
                    } else if (e.tag === 2) {
                        r = 8;
                        u = e.fields[0]
                    } else if (e.tag === 10) {
                        r = 9;
                        c = e.fields[0];
                        p = e.fields[1]
                    } else if (e.tag === 4) {
                        if ((0, o.isEmpty)(e.fields[0])) {
                            r = 10
                        } else {
                            r = 11;
                            g = e.fields[0]
                        }
                    } else if (e.tag === 8) {
                        r = 12;
                        m = e.fields[0]
                    } else {
                        r = 0;
                        n = e.fields[0]
                    }
                    switch (r) {
                        case 0: {
                            return (0, d.escapeString)(n)
                        }
                        case 1: {
                            return "(" + t(i) + ")"
                        }
                        case 2: {
                            return `Compl(${t(s)})`
                        }
                        case 3: {
                            return "('0' .. '9')"
                        }
                        case 4: {
                            return `Plus(${t(a)})`
                        }
                        case 5: {
                            return `Star(${t(l)})`
                        }
                        case 6: {
                            return "any"
                        }
                        case 7: {
                            const e = (0, d.List_tryLookup)(_, I);
                            if (e == null) {
                                const e = (0, f.UnboundLexer)(_);
                                throw e
                            } else {
                                return "rule_" + name_of_named_term(_)
                            }
                        }
                        case 8: {
                            return (0, h.join)(", ", (0, o.toArray)((0, o.map)(mk_lexer, u)))
                        }
                        case 9: {
                            return `(${c} .. ${p})`
                        }
                        case 10: {
                            throw new Error("impossible: alternatives cannot be empty.")
                        }
                        case 11: {
                            return (0, h.join)(" | ", (0, o.toArray)((0, o.map)(mk_lexer, g)))
                        }
                        case 12: {
                            return `Opt(${t(m)})`
                        }
                    }
                };
                const mk_lexer_debug = e => {
                    const t = mk_lexer_debug;
                    if (e.tag === 9) {
                        return t(e.fields[0])
                    } else if (e.tag === 5) {
                        return `pnot(${t(e.fields[0])})`
                    } else if (e.tag === 0) {
                        return "pnumber"
                    } else if (e.tag === 6) {
                        return `pplus(${t(e.fields[0])})`
                    } else if (e.tag === 7) {
                        return `pstar(${t(e.fields[0])})`
                    } else if (e.tag === 1) {
                        return "pany"
                    } else if (e.tag === 11) {
                        return e.fields[0]
                    } else if (e.tag === 2) {
                        const t = (0, h.join)(", ", (0, _.ofList)((0, o.map)(mk_lexer_debug, e.fields[0])));
                        return `pseq([${t}])`
                    } else if (e.tag === 10) {
                        return `pinterval(${e.fields[0]}, ${e.fields[1]})`
                    } else if (e.tag === 4) {
                        if (!(0, o.isEmpty)(e.fields[0])) {
                            return (0, o.fold)(((e, t) => `por(${e}, ${t})`), t((0, o.head)(e.fields[0])), (0, o.map)(mk_lexer_debug, (0, o.tail)(e.fields[0])))
                        } else {
                            throw new Error("impossible: alternatives cannot be empty.")
                        }
                    } else if (e.tag === 8) {
                        return `popt${t(e.fields[0])}`
                    } else {
                        return `pstring(${(0,d.escapeString)(e.fields[0])})`
                    }
                };
                return (0, m.withErrorHandler)((T = e.Sigma, () => (0, u.Sigma__GetErrorTrace)(T)), (() => {
                    const t = (0, g.vsep)((0, o.ofArray)((0, y.map)((t => {
                        (0, u.Sigma__SetCurrentDefinition_Z759AB257)(e.Sigma, t);
                        switch (t.tag) {
                            case 2: {
                                const e = t.fields[0];
                                I = (0, o.cons)([e.lhs, (0, g.word)(mk_lexer(e.define))], I);
                                return g.empty
                            }
                            case 6: {
                                return g.empty
                            }
                            case 3: {
                                M = (0, o.cons)(x(t.fields[0].ident), M);
                                return (0, g.vsep)((0, o.empty)())
                            }
                            case 5: {
                                w = (0, o.cons)(A(t.fields[0].ident), w);
                                return (0, g.vsep)((0, o.empty)())
                            }
                            case 4: {
                                return (0, g.vsep)((0, o.empty)())
                            }
                            case 0: {
                                throw new Error("macro not processed")
                            }
                            default: {
                                const r = t.fields[0];
                                const n = cg_symbol(new p.symbol(1, r.lhs));
                                let i = 0;
                                const s = (0, g.align)((0, g.vsep)((0, o.mapIndexed)(((e, t) => (0, g.Doc_op_Addition_Z7CFFAC00)(e === 0 ? (0, g.word)(":") : (0, g.word)("|"), t)), (0, _.toList)((0, _.delay)((() => (0, _.collect)((t => {
                                    let r;
                                    (0, u.Sigma__SetCurrentPos_Z302187B)(e.Sigma, t[0]);
                                    (0, u.Sigma__SetCurrentDefinitionBranch_Z524259A4)(e.Sigma, i);
                                    i = i + 1 | 0;
                                    return (0, _.singleton)((r = t[1], (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.seplist)((0, g.word)(" "), (0, o.map)((e => (0, g.word)(cg_symbol(e))), r.symbols)), (0, g.word)("{")), (0, g.Doc_op_RightShift_2AAA0F3C)((0, g.vsep)((0, o.ofArray)([g.empty, (0, g.Doc_op_RightShift_2AAA0F3C)(cg_expr(L, r.action), 4), (0, g.word)("}")])), 12))))
                                }), r.define)))))));
                                return (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(n), s)
                            }
                        }
                    }), S)));
                    const n = (0, h.toText)((0, h.printf)("%s_lexer"))(r);
                    const i = (0, h.toText)((0, h.printf)("%s_parser"))(r);
                    const c = (0, h.toText)((0, h.printf)("%s_construct"))(r);
                    const m = (0, h.toText)((0, h.printf)("%s_require"))(r);
                    const T = mangle(P, "tokenizer");
                    const b = mangle(P, "lexbuf");
                    const F = [c + ".ml", (0, g.vsep)((0, _.toList)((0, _.delay)((() => {
                        let t = (0, o.empty)();
                        return (0, _.append)((0, _.singleton)((0, g.word)(`open ${(0,d.capitalized)(m)};;`)), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)(`open ${(0,d.capitalized)(n)};;`)), (0, _.delay)((() => {
                            const r = (0, u.Sigma__GetADTCases)(e.Sigma);
                            return (0, _.append)((0, _.singleton)(g.empty), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("type ___used_t_head_90xasda")), (0, _.delay)((() => (0, _.append)((0, _.collect)((e => {
                                const r = A(e[0]);
                                return (0, _.append)((0, _.singleton)((0, g.word)(`and ${r} = `)), (0, _.delay)((() => (0, _.append)((0, _.collect)((e => {
                                    const n = e[0];
                                    const i = (0, o.map)((e => [N(e[0]), cg_type(e[1])]), e[1]);
                                    const s = C(n);
                                    const a = (0, g.word)(r);
                                    t = (0, o.cons)([x(n), s, i, a], t);
                                    if ((0, o.isEmpty)(i)) {
                                        return (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("|"), (0, g.word)(s)), (0, g.word)("of")), (0, g.word)("unit")))
                                    } else {
                                        const e = (0, g.seplist)((0, g.word)(";"), (0, _.toList)((0, _.delay)((() => (0, _.collect)((e => (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(e[0]), (0, g.word)(":")), (0, g.word)(e[1])))), i)))));
                                        return (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("|"), (0, g.word)(s)), (0, g.word)("of")), (0, g.word)("{")), e), (0, g.word)("}")))
                                    }
                                }), (0, l.toArray)(e[1])), (0, _.delay)((() => (0, _.singleton)(g.empty)))))))
                            }), r), (0, _.delay)((() => (0, _.append)((0, _.collect)((e => {
                                const r = e[0];
                                const n = e[1];
                                const i = A(r);
                                const s = x(r);
                                const a = (0, o.isEmpty)(n.parameters) ? (0, g.word)(i) : (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.parens)((0, g.word)((0, h.join)(", ", (0, o.map)((e => "'" + e), n.parameters)))), (0, g.word)(i));
                                const l = (0, _.toList)((0, _.delay)((() => (0, _.collect)((e => (0, _.singleton)([N(e[0]), cg_type(e[1])])), n.fields))));
                                return (0, o.isEmpty)(l) ? (0, _.append)((0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("and"), a), (0, g.word)("=")), (0, g.word)("MK_" + i)), (0, g.word)("of unit"))), (0, _.delay)((() => {
                                    t = (0, o.cons)([s, "MK_" + i, l, a], t);
                                    return (0, _.empty)()
                                }))) : (0, _.append)((0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("and"), a), (0, g.word)("=")), (0, g.word)("{"))), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.Doc_op_RightShift_2AAA0F3C)((0, g.vsep)((0, _.toList)((0, _.delay)((() => (0, _.collect)((e => (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(e[0]), (0, g.word)(":")), (0, g.Doc_op_Multiply_Z7CFFAC00)((0, g.word)(e[1]), (0, g.word)(";"))))), l))))), 4)), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("}")), (0, _.delay)((() => {
                                    t = (0, o.cons)([s, "", l, a], t);
                                    return (0, _.empty)()
                                })))))))))
                            }), (0, u.Sigma__GetRecordTypes)(e.Sigma)), (0, _.delay)((() => (0, _.collect)((e => {
                                const t = e[0];
                                const r = e[2];
                                const n = e[1];
                                if ((0, o.isEmpty)(r)) {
                                    return (0, _.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("let"), (0, g.word)(t)), (0, g.word)("()")), (0, g.word)("=")), (0, g.word)(n)), (0, g.word)("()")))
                                } else {
                                    const i = (0, o.map)((e => (0, g.word)(e[0])), r);
                                    return (0, _.singleton)((0, g.vsep)((0, o.ofArray)([(0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("let"), (0, g.word)(t)), (0, g.parens)((0, g.seplist)((0, g.word)(", "), i))), (0, g.word)(":")), e[3]), (0, g.word)("=")), (0, g.Doc_op_RightShift_2AAA0F3C)((0, g.vsep)((0, o.singleton)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)(n), (0, g.word)("{")), (0, g.seplist)((0, g.word)(";"), i)), (0, g.word)("}")))), 4)])))
                                }
                            }), t)))))))))))))
                        }))))))
                    }))))];
                    let B = (0, o.empty)();
                    const O = Array.from(e.ReferencedNamedTokens);
                    (0, y.sortInPlaceBy)((t => e.TokenFragments.findIndex((e => t === e))), O, {
                        Compare: a.comparePrimitives
                    });
                    let R = (0, o.empty)();
                    let D = (0, o.empty)();
                    const k = (0, y.sort)(Array.from(e.LiteralTokens), {
                        Compare: a.comparePrimitives
                    });
                    for (let e = 0; e <= k.length - 1; e++) {
                        const t = k[e];
                        const r = (0, g.word)(mk_lexer(new p.lexerule(3, t)));
                        const n = cg_symbol(new p.symbol(0, t, true));
                        const i = "rule_" + n;
                        const s = (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("let"), (0, g.word)(i)), (0, g.word)("=")), (0, g.bracket)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("%sedlex.regexp?"), r)));
                        R = (0, o.cons)(s, R);
                        const a = (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("|"), (0, g.word)(i)), (0, g.word)(`-> ${n} (mktoken ${b})`));
                        D = (0, o.cons)(a, D);
                        B = (0, o.cons)(n, B)
                    }
                    const $ = (0, a.getEnumerator)(I);
                    try {
                        while ($["System.Collections.IEnumerator.MoveNext"]()) {
                            const t = $["System.Collections.Generic.IEnumerator`1.get_Current"]();
                            const r = t[1];
                            const n = t[0];
                            if ((0, s.contains)(n, e.IgnoreSet)) {
                                const e = "rule_" + name_of_named_term(n);
                                const t = (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("let"), (0, g.word)(e)), (0, g.word)("=")), (0, g.bracket)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("%sedlex.regexp?"), r)));
                                R = (0, o.cons)(t, R);
                                const i = (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("|"), (0, g.word)(e)), (0, g.word)(`-> ${T} ${b}`));
                                D = (0, o.cons)(i, D)
                            } else {
                                const e = name_of_named_term(n);
                                const t = "rule_" + e;
                                const i = (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("let"), (0, g.word)(t)), (0, g.word)("=")), (0, g.bracket)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("%sedlex.regexp?"), r)));
                                R = (0, o.cons)(i, R);
                                if ((0, y.contains)(n, O, {
                                        Equals: (e, t) => e === t,
                                        GetHashCode: a.stringHash
                                    })) {
                                    const r = (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("|"), (0, g.word)(t)), (0, g.word)(`-> ${e} (mktoken ${b})`));
                                    D = (0, o.cons)(r, D);
                                    B = (0, o.cons)(e, B)
                                }
                            }
                        }
                    } finally {
                        (0, a.disposeSafe)($)
                    }
                    D = (0, o.ofArrayWithTail)([(0, g.word)(`| _ -> _unknown_token ${b}`), (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("|"), (0, g.word)("eof ->")), (0, g.word)("EOF"))], D);
                    const j = (0, o.reverse)(B);
                    const U = (0, o.reverse)(D);
                    const Z = [n + ".ml", (0, g.vsep)((0, o.ofArray)([(0, g.word)(v), g.empty, (0, g.word)("type token ="), (0, g.vsep)((0, _.toList)((0, _.delay)((() => (0, _.append)((0, _.map)((e => (0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("|"), (0, g.word)(e)), (0, g.word)("of")), (0, g.word)("tbnf_token"))), j), (0, _.delay)((() => (0, _.singleton)((0, g.word)("| EOF"))))))))), g.empty, (0, g.vsep)(R), g.empty, (0, g.vsep)((0, o.ofArray)([(0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.Doc_op_Addition_Z7CFFAC00)((0, g.word)("let rec"), (0, g.word)(T)), (0, g.word)(b)), (0, g.word)("=")), (0, g.align)((0, g.indent)(4, (0, g.vsep)((0, o.cons)((0, g.word)(`match%sedlex ${b} with`), U))))]))]))];
                    const q = (0, l.tryFind)("start", e.Omega);
                    if (q != null) {
                        const e = q;
                        const r = cg_symbol(new p.symbol(1, "start"));
                        const o = cg_type((0, p.monot__Prune)(e));
                        return [F, [i + ".mly", (0, g.vsep)((0, _.toList)((0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("%{")), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)(`open ${(0,d.capitalized)(m)};;`)), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)(`open ${(0,d.capitalized)(n)};;`)), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)(`open ${(0,d.capitalized)(c)};;`)), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("%}")), (0, _.delay)((() => (0, _.append)((0, _.map)((e => (0, g.word)(`%token<tbnf_token> ${e}`)), j), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("%token EOF")), (0, _.delay)((() => {
                            let e;
                            return (0, _.append)(E != null ? (e = E, (0, _.singleton)((0, g.word)(`%start <${e}> start`))) : (0, _.singleton)((0, g.word)(`%start <${o}> start`)), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)("%%")), (0, _.delay)((() => (0, _.append)((0, _.singleton)(g.empty), (0, _.delay)((() => (0, _.append)((0, _.singleton)((0, g.word)((0, h.toText)((0, h.printf)("start : %s EOF { $1 }"))(r))), (0, _.delay)((() => (0, _.singleton)(t)))))))))))))
                        })))))))))))))))))))))))))], Z]
                    } else {
                        const e = (0, f.UnboundNonterminal)("start");
                        throw e
                    }
                }))
            }
        },
        3474: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.codegen = codegen;
            var n = r(6256);
            var i = r(5359);
            var o = r(1337);
            var s = r(4222);
            var a = r(5466);
            var l = r(2078);
            var _ = r(543);
            var u = r(1383);
            var c = r(1697);
            var d = r(3833);
            var p = r(9386);
            var f = r(4205);
            var h = r(9937);
            var g = r(417);
            var m = r(7936);
            var y = r(9054);
            var S = r(8203);

            function codegen(e, t, r, T) {
                let x;
                const C = (0, n.defaultArg)(t.rename_var, (e => e));
                const N = (0, n.defaultArg)(t.rename_ctor, (e => e));
                const A = (0, n.defaultArg)(t.rename_field, (e => e));
                const E = (0, n.defaultArg)(t.rename_type, (e => e));
                const v = "_tbnf.FableSedlex";
                let M = (0, i.empty)();
                const w = "parser";
                const b = "grammar";
                const F = (0, o.ofArray)([w, b], {
                    Compare: s.comparePrimitives
                });
                const B = "tokenmaps";
                const I = "tokenreprs";
                const L = (0, o.ofArray)([B, I, "False", "None", "True", "and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "nonlocal", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield", "match", "case"], {
                    Compare: s.comparePrimitives
                });
                let P = (0, a.empty)();
                let O = (0, i.empty)();
                let R = (0, a.empty)();
                let D = (0, i.empty)();
                const k = (0, l.toList)((0, l.delay)((() => (0, l.map)((t => (0, _.Sigma__IsGlobalVariableConstructor_Z721C83C5)(e.Sigma, t[0]) ? [t[0], N(t[0])] : [t[0], C(t[0])]), (0, _.Sigma__get_GlobalVariables)(e.Sigma)))));
                const $ = (0, u.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, u.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => {
                    const r = (((0, c.isLower)(t) ? true : (0, c.isUnicode)(t)) ? true : (0, c.isUpper)(t)) ? true : t === "_";
                    return e === 0 ? r : r ? true : (0, c.isDigit)(t)
                }), ((e, t) => (0, c.isDigit)(t) ? `_${e*t.charCodeAt(0)+7}_` : `_${t.charCodeAt(0)}_`)), new u.NameMangling_nameEnv((0, o.ofList)((0, i.map)((e => e[1]), k), {
                    Compare: s.comparePrimitives
                })));
                const j = (0, u.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, u.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => e === 0 ? (0, c.isUpper)(t) : ((0, c.isUpper)(t) ? true : t === "_") ? true : (0, c.isDigit)(t)), ((e, t) => (0, c.isLower)(t) ? t.toUpperCase() : "_" + (0, u.NameMangling_maskChar)(65, 90, t.charCodeAt(0)) + "_")), new u.NameMangling_nameEnv((0, o.ofArray)(["UNKNOWN"], {
                    Compare: s.comparePrimitives
                })));
                const U = (0, u.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, u.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => e === 0 ? (0, c.isLower)(t) : ((0, c.isLower)(t) ? true : t === "_") ? true : (0, c.isDigit)(t)), ((e, t) => (0, c.isUpper)(t) ? t.toLowerCase() : "_" + (0, u.NameMangling_maskChar)(97, 122, t.charCodeAt(0)) + "_")), new u.NameMangling_nameEnv((0, o.ofArray)(["start"], {
                    Compare: s.comparePrimitives
                })));
                let Z;
                const q = (0, o.union)(L, F);
                Z = e => t => (0, u.NameMangling_mangle)(q, e, t);
                const cg_symbol = e => {
                    const t = (0, a.tryFind)(e, P);
                    if (t == null) {
                        let t;
                        if (e.tag === 0) {
                            t = e.fields[1] ? Z(j)('"' + e.fields[0] + '"') : e.fields[0] === "EOF" ? "EOF" : Z(j)(e.fields[0])
                        } else if (e.tag === 1) {
                            t = e.fields[0] === "start" ? "start" : Z(U)(e.fields[0])
                        } else {
                            throw new Error("macro not processed")
                        }
                        P = (0, a.add)(e, t, P);
                        return t
                    } else {
                        return t
                    }
                };
                const name_of_named_term = e => cg_symbol(new d.symbol(0, e, false));
                const definePyFunc = (e, t, r) => (0, p.vsep)((0, i.ofArray)([(0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)("def"), (0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.Doc_op_Multiply_Z7CFFAC00)(e, (0, p.parens)((0, p.seplist)((0, p.word)(", "), t))), (0, p.word)(":"))), (0, p.Doc_op_RightShift_2AAA0F3C)(r, 4)]));
                const H = "__tbnf_COMPONENTS";
                const cg_expr = (t, r, n) => (0, _.Sigma__WithExpr)(e.Sigma, n, (() => (0, u.DocBuilder_Builder__Run_ZD0BB270)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Delay_Z3A9C5A06)(u.DocBuilder_cg, (() => {
                    let e;
                    const o = n.node;
                    if (o.tag === 6) {
                        const e = (0, c.List_tryLookup)(o.fields[0], r);
                        return e != null ? (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.word)(e)) : (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (() => {
                            throw (0, f.UnboundVariable)(o.fields[0])
                        })())
                    } else if (o.tag === 11) {
                        return o.fields[0] ? (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.word)("True")) : (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.word)("False"))
                    } else if (o.tag === 3) {
                        return (0, u.DocBuilder_Builder__Bind_30A200B3)(u.DocBuilder_cg, cg_expr(t, r, o.fields[0]), (e => (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.Doc_op_Multiply_Z7CFFAC00)(e, (0, p.word)(".")), (0, p.word)(A(o.fields[1]))))))
                    } else if (o.tag === 8) {
                        return (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.word)((0, h.toText)((0, h.printf)("%d"))(o.fields[0])))
                    } else if (o.tag === 10) {
                        return (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.word)((0, h.toText)((0, h.printf)("%f"))(o.fields[0])))
                    } else if (o.tag === 9) {
                        return (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.word)((0, c.escapeString)(o.fields[0])))
                    } else if (o.tag === 5) {
                        const e = (0, i.map)((e => e[0]), o.fields[0]);
                        const n = (0, u.DocBuilder_runCG)(cg_expr(t, (0, i.append)((0, l.toList)((0, l.delay)((() => (0, l.map)((e => [e, Z($)(e)]), e)))), r), o.fields[1]));
                        const s = Z($)("lambda");
                        return (0, u.DocBuilder_Builder__Combine_Z5C764E00)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Yield_417FD60)(u.DocBuilder_cg, definePyFunc((0, p.word)(s), (0, i.map)(p.word, e), (0, p.vsep)((0, i.ofArray)([(0, p.vsep)(n[1]), (0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)("return"), n[0])])))), (0, u.DocBuilder_Builder__Delay_Z3A9C5A06)(u.DocBuilder_cg, (() => (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.word)(s)))))
                    } else {
                        return o.tag === 4 ? (0, u.DocBuilder_Builder__Bind_30A200B3)(u.DocBuilder_cg, cg_expr(t, r, o.fields[1]), (e => {
                            const n = Z($)(o.fields[0]);
                            return (0, u.DocBuilder_Builder__Combine_Z5C764E00)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Yield_417FD60)(u.DocBuilder_cg, (0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(n), (0, p.word)("=")), e)), (0, u.DocBuilder_Builder__Delay_Z3A9C5A06)(u.DocBuilder_cg, (() => (0, u.DocBuilder_Builder__ReturnFrom_ZD0BB270)(u.DocBuilder_cg, cg_expr(t, (0, i.cons)([o.fields[0], n], r), o.fields[2])))))
                        })) : o.tag === 2 ? (0, u.DocBuilder_Builder__Bind_30A200B3)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Run_ZD0BB270)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Delay_Z3A9C5A06)(u.DocBuilder_cg, (() => (0, u.DocBuilder_Builder__For_2B96F4AF)(u.DocBuilder_cg, o.fields[0], (e => (0, u.DocBuilder_Builder__ReturnFrom_ZD0BB270)(u.DocBuilder_cg, cg_expr(t, r, e))))))), (e => (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.bracket)((0, p.seplist)((0, p.word)(", "), e))))) : o.tag === 7 ? (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.word)((e = o.fields[0] - 1 | 0, (0, h.toText)((0, h.printf)("%s[%d]"))(H)(e)))) : o.tag === 1 ? (0, u.DocBuilder_Builder__Bind_30A200B3)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Run_ZD0BB270)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Delay_Z3A9C5A06)(u.DocBuilder_cg, (() => (0, u.DocBuilder_Builder__For_2B96F4AF)(u.DocBuilder_cg, o.fields[0], (e => (0, u.DocBuilder_Builder__ReturnFrom_ZD0BB270)(u.DocBuilder_cg, cg_expr(t, r, e))))))), (e => {
                            const t = e;
                            return !(0, i.isEmpty)(t) ? (0, i.isEmpty)((0, i.tail)(t)) ? (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.parens)((0, p.Doc_op_Addition_Z7CFFAC00)((0, i.head)(t), (0, p.word)(",")))) : (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.parens)((0, p.seplist)((0, p.word)(", "), t))) : (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.parens)(p.empty))
                        })) : (0, u.DocBuilder_Builder__Bind_30A200B3)(u.DocBuilder_cg, cg_expr(t, r, o.fields[0]), (e => (0, u.DocBuilder_Builder__Bind_30A200B3)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Run_ZD0BB270)(u.DocBuilder_cg, (0, u.DocBuilder_Builder__Delay_Z3A9C5A06)(u.DocBuilder_cg, (() => (0, u.DocBuilder_Builder__For_2B96F4AF)(u.DocBuilder_cg, o.fields[1], (e => (0, u.DocBuilder_Builder__ReturnFrom_ZD0BB270)(u.DocBuilder_cg, cg_expr(t, r, e))))))), (t => (0, u.DocBuilder_Builder__Return_1505)(u.DocBuilder_cg, (0, p.Doc_op_Multiply_Z7CFFAC00)(e, (0, p.parens)((0, p.seplist)((0, p.word)(", "), t))))))))
                    }
                })))));
                const mk_lexer = e => {
                    const t = mk_lexer;
                    if (e.tag === 9) {
                        return t(e.fields[0])
                    } else if (e.tag === 5) {
                        return (0, g.pcompl)(t(e.fields[0]))
                    } else if (e.tag === 0) {
                        return (0, g.pinterval)(48, 57)
                    } else if (e.tag === 6) {
                        return (0, g.pplus)(t(e.fields[0]))
                    } else if (e.tag === 7) {
                        return (0, g.pstar)(t(e.fields[0]))
                    } else if (e.tag === 1) {
                        return g.pany
                    } else if (e.tag === 11) {
                        const t = (0, a.tryFind)(e.fields[0], R);
                        if (t == null) {
                            const t = (0, f.UnboundLexer)(e.fields[0]);
                            throw t
                        } else {
                            return t
                        }
                    } else if (e.tag === 2) {
                        return (0, g.pseq)((0, i.toArray)((0, i.map)(mk_lexer, e.fields[0])))
                    } else if (e.tag === 10) {
                        return (0, g.pinterval)(e.fields[0], e.fields[1])
                    } else if (e.tag === 4) {
                        if (!(0, i.isEmpty)(e.fields[0])) {
                            return (0, i.fold)(g.por, t((0, i.head)(e.fields[0])), (0, i.map)(mk_lexer, (0, i.tail)(e.fields[0])))
                        } else {
                            throw new Error("impossible: alternatives cannot be empty.")
                        }
                    } else if (e.tag === 8) {
                        return (0, g.popt)(t(e.fields[0]))
                    } else {
                        return (0, g.pstring)(e.fields[0])
                    }
                };
                const mk_lexer_debug = e => {
                    const t = mk_lexer_debug;
                    if (e.tag === 9) {
                        return t(e.fields[0])
                    } else if (e.tag === 5) {
                        return `pnot(${t(e.fields[0])})`
                    } else if (e.tag === 0) {
                        return "pnumber"
                    } else if (e.tag === 6) {
                        return `pplus(${t(e.fields[0])})`
                    } else if (e.tag === 7) {
                        return `pstar(${t(e.fields[0])})`
                    } else if (e.tag === 1) {
                        return "pany"
                    } else if (e.tag === 11) {
                        return e.fields[0]
                    } else if (e.tag === 2) {
                        const t = (0, h.join)(", ", (0, l.ofList)((0, i.map)(mk_lexer_debug, e.fields[0])));
                        return `pseq([${t}])`
                    } else if (e.tag === 10) {
                        return `pinterval(${e.fields[0]}, ${e.fields[1]})`
                    } else if (e.tag === 4) {
                        if (!(0, i.isEmpty)(e.fields[0])) {
                            return (0, i.fold)(((e, t) => `por(${e}, ${t})`), t((0, i.head)(e.fields[0])), (0, i.map)(mk_lexer_debug, (0, i.tail)(e.fields[0])))
                        } else {
                            throw new Error("impossible: alternatives cannot be empty.")
                        }
                    } else if (e.tag === 8) {
                        return `popt${t(e.fields[0])}`
                    } else {
                        return `pstring(${(0,c.escapeString)(e.fields[0])})`
                    }
                };
                const z = (0, h.toText)((0, h.printf)("%s_lexer"))(r);
                const K = (0, h.toText)((0, h.printf)("%s_require"))(r);
                const G = (0, h.toText)((0, h.printf)("%s_parser"))(r);
                const V = (0, h.toText)((0, h.printf)("%s_construct"))(r);
                const W = B;
                const Y = Z($)("Lexer");
                const X = Z($)("Sedlex");
                const Q = E("token");
                const J = Z($)("is_eof");
                const ee = Z($)("construct_token");
                const te = Z($)("lexall");
                const re = Z($)("from_ustring");
                const ne = Z($)("Transformer");
                const ie = Z($)("RBNFTransformer");
                const oe = Z($)("Lark");
                const se = Z($)("dataclasses");
                const ae = Z($)("typing");
                const _cg_type = e => {
                    let t, r, n, o;
                    if (e.tag === 4) {
                        t = 1
                    } else if (e.tag === 0) {
                        t = 2
                    } else if (e.tag === 3) {
                        t = 3;
                        n = e.fields[0];
                        o = e.fields[1]
                    } else if (e.tag === 2) {
                        if ((0, d.$007CTTuple$007C_$007C)(e.fields[0]) != null) {
                            if ((0, i.isEmpty)(e.fields[1])) {
                                t = 4
                            } else {
                                t = 5
                            }
                        } else {
                            t = 5
                        }
                    } else {
                        t = 0;
                        r = e.fields[0]
                    }
                    switch (t) {
                        case 0: {
                            return E(r)
                        }
                        case 1: {
                            return "object"
                        }
                        case 2: {
                            const e = new f.UnsolvedTypeVariable;
                            throw e
                        }
                        case 3: {
                            const e = _cg_type(o);
                            const t = (0, h.join)(", ", (0, i.map)((e => _cg_type(e[1])), n));
                            return `${ae}.Callable[[${t}], ${e}]`
                        }
                        case 4: {
                            throw new Error("0-element tuple type detected")
                        }
                        case 5: {
                            let t, r;
                            if (e.tag === 2) {
                                if ((0, d.$007CTTuple$007C_$007C)(e.fields[0]) != null) {
                                    t = 0;
                                    r = e.fields[1]
                                } else {
                                    t = 1
                                }
                            } else {
                                t = 1
                            }
                            switch (t) {
                                case 0: {
                                    const e = (0, h.join)(", ", (0, i.map)(_cg_type, r));
                                    return `${ae}.Tuple[` + e + "]"
                                }
                                case 1: {
                                    if (e.tag === 2) {
                                        const t = (0, h.join)(", ", (0, i.map)(_cg_type, e.fields[1]));
                                        return _cg_type(e.fields[0]) + "[" + t + "]"
                                    } else {
                                        throw new Error("Match failure")
                                    }
                                }
                            }
                        }
                    }
                };
                const cg_type = e => _cg_type((0, d.monot__Prune)(e));
                return (0, m.withErrorHandler)((x = e.Sigma, () => (0, _.Sigma__GetErrorTrace)(x)), (() => {
                    const t = (0, p.vsep)((0, i.ofArray)((0, y.map)((t => {
                        (0, _.Sigma__SetCurrentDefinition_Z759AB257)(e.Sigma, t);
                        switch (t.tag) {
                            case 2: {
                                const r = t.fields[0];
                                R = (0, a.add)(r.lhs, mk_lexer(r.define), R);
                                if ((0, o.contains)(r.lhs, e.ReferencedNamedTokens)) {
                                    const e = name_of_named_term(r.lhs);
                                    D = (0, i.cons)(e, D)
                                }
                                return p.empty
                            }
                            case 6: {
                                return p.empty
                            }
                            case 3: {
                                M = (0, i.cons)(C(t.fields[0].ident), M);
                                return p.empty
                            }
                            case 4: {
                                return p.empty
                            }
                            case 5: {
                                const e = t.fields[0];
                                if (e.external) {
                                    M = (0, i.cons)(E(e.ident), M)
                                }
                                return p.empty
                            }
                            case 0: {
                                throw new Error("macro not processed")
                            }
                            default: {
                                const r = t.fields[0];
                                const n = cg_symbol(new d.symbol(1, r.lhs));
                                let o = 0;
                                const s = (0, p.align)((0, p.vsep)((0, i.mapIndexed)(((e, t) => (0, p.Doc_op_Addition_Z7CFFAC00)(e === 0 ? (0, p.word)(":") : (0, p.word)("|"), t)), (0, l.toList)((0, l.delay)((() => (0, l.collect)((t => {
                                    const r = t[1];
                                    (0, _.Sigma__SetCurrentPos_Z302187B)(e.Sigma, t[0]);
                                    (0, _.Sigma__SetCurrentDefinitionBranch_Z524259A4)(e.Sigma, o);
                                    let s;
                                    const a = o | 0;
                                    s = (0, h.toText)((0, h.printf)("%s_%i"))(n)(a);
                                    return (0, l.append)((0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.seplist)((0, p.word)(" "), (0, i.map)((e => (0, p.word)(cg_symbol(e))), r.symbols)), (0, p.word)("->")), (0, p.word)(s))), (0, l.delay)((() => {
                                        const e = (0, u.DocBuilder_runCG)(cg_expr(s, k, r.action));
                                        const t = definePyFunc((0, p.word)(s), (0, i.ofArray)([(0, p.word)("self"), (0, p.word)(H)]), (0, p.vsep)((0, i.ofArray)([(0, p.vsep)(e[1]), (0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)("return"), e[0])])));
                                        O = (0, i.ofArrayWithTail)([t, p.empty], O);
                                        o = o + 1 | 0;
                                        return (0, l.empty)()
                                    })))
                                }), r.define)))))));
                                return (0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(n), s)
                            }
                        }
                    }), T)));
                    const n = (0, p.parens)((0, p.seplist)((0, p.word)(","), (0, i.map)(p.word, M)));
                    const f = [V + ".py", (0, p.vsep)((0, l.toList)((0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)("from __future__ import annotations as __01asda1ha")), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`from lark import Token as ${Q}`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`import dataclasses as ${se}`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`import typing as ${ae}`)), (0, l.delay)((() => {
                        const t = (0, _.Sigma__GetADTCases)(e.Sigma);
                        return (0, l.append)(!(0, i.isEmpty)(M) ? (0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(`from .${K} import`), n)) : (0, l.empty)(), (0, l.delay)((() => (0, l.append)((0, l.singleton)(p.empty), (0, l.delay)((() => (0, l.append)((0, l.collect)((e => {
                            const t = E(e[0]);
                            let r = (0, i.empty)();
                            return (0, l.append)((0, l.collect)((e => {
                                const t = e[1];
                                const n = N(e[0]);
                                r = (0, i.cons)((0, p.word)(n), r);
                                return (0, l.append)((0, l.singleton)((0, p.word)(`@${se}.dataclass`)), (0, l.delay)((() => (0, l.append)((0, i.length)(t) === 0 ? (0, l.append)((0, l.singleton)((0, p.word)(`class ${n}:`)), (0, l.delay)((() => (0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.word)("pass"), 4))))) : (0, l.append)((0, l.singleton)((0, p.word)(`class ${n}:`)), (0, l.delay)((() => (0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.vsep)((0, l.toList)((0, l.delay)((() => (0, l.collect)((e => (0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.word)(A(e[0])), (0, p.word)(":")), (0, p.word)(cg_type(e[1]))))), t))))), 4))))), (0, l.delay)((() => (0, l.singleton)(p.empty)))))))
                            }), (0, a.toArray)(e[1])), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`if ${ae}.TYPE_CHECKING:`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.vsep)((0, l.toList)((0, l.delay)((() => {
                                let e;
                                return !(0, i.isEmpty)(r) ? (0, i.isEmpty)((0, i.tail)(r)) ? (e = (0, i.head)(r), (0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(t), (0, p.word)("=")), e))) : (0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(t), (0, p.word)("=")), (0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.word)(`${ae}.Union[`), (0, p.seplist)((0, p.word)(","), r)), (0, p.word)("]")))) : (0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(t), (0, p.word)("=")), (0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.word)(`${ae}.Union[`), (0, p.seplist)((0, p.word)(","), r)), (0, p.word)("]"))))
                            })))), 4)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)("else:")), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.vsep)((0, i.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(t), (0, p.word)("=")), (0, p.parens)((0, p.seplist)((0, p.word)(","), r))))), 4)), (0, l.delay)((() => (0, l.singleton)(p.empty))))))))))))))))
                        }), t), (0, l.delay)((() => (0, l.collect)((e => {
                            const t = e[0];
                            const r = e[1];
                            const n = E(t);
                            const o = C(t);
                            return (0, l.append)((0, l.singleton)((0, p.word)(`@${se}.dataclass`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`class ${n}:`)), (0, l.delay)((() => (0, l.append)((0, i.isEmpty)(r.fields) ? (0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.word)("pass"), 4)) : (0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.vsep)((0, l.toList)((0, l.delay)((() => (0, l.collect)((e => {
                                const t = A(e[0]);
                                const r = cg_type(e[1]);
                                return (0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.word)(t), (0, p.word)(":")), (0, p.word)(r)))
                            }), r.fields))))), 4)), (0, l.delay)((() => (0, l.append)((0, l.singleton)(p.empty), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(o), (0, p.word)("=")), (0, p.word)(n))), (0, l.delay)((() => (0, l.singleton)(p.empty))))))))))))))))
                        }), (0, _.Sigma__GetRecordTypes)(e.Sigma)))))))))))
                    }))))))))))))))))];
                    let m = (0, i.empty)();
                    let x = (0, i.empty)();
                    let F = (0, i.empty)();
                    let B = 0;
                    let L = 0;
                    const P = Array.from(e.ReferencedNamedTokens);
                    (0, y.sortInPlaceBy)((t => e.TokenFragments.findIndex((e => t === e))), P, {
                        Compare: s.comparePrimitives
                    });
                    const $ = (0, y.sort)(Array.from(e.LiteralTokens), {
                        Compare: s.comparePrimitives
                    });
                    for (let e = 0; e <= $.length - 1; e++) {
                        const t = $[e];
                        const r = (0, g.pstring)(t);
                        m = (0, i.cons)([r, new g.keep_token(1, L)], m);
                        x = (0, i.cons)(cg_symbol(new d.symbol(0, t, true)), x);
                        F = (0, i.cons)((0, c.escapeString)(t), F);
                        L = L + 1 | 0;
                        B = B + 1 | 0
                    }
                    for (let t = 0; t <= P.length - 1; t++) {
                        const r = P[t];
                        const n = (0, a.FSharpMap__get_Item)(R, r);
                        if ((0, o.contains)(r, e.IgnoreSet)) {
                            m = (0, i.cons)([n, new g.keep_token(0)], m)
                        } else {
                            m = (0, i.cons)([n, new g.keep_token(1, L)], m);
                            x = (0, i.cons)(name_of_named_term(r), x);
                            F = (0, i.cons)(r, F);
                            L = L + 1 | 0
                        }
                        B = B + 1 | 0
                    }
                    m = (0, i.cons)([g.pany, new g.keep_token(1, L)], m);
                    x = (0, i.cons)("UNKNOWN", x);
                    F = (0, i.cons)("UNKNOWN", F);
                    const j = (0, i.reverse)(x);
                    const U = (0, i.reverse)(F);
                    const Z = (0, i.toArray)((0, i.reverse)((0, i.cons)([g.peof, new g.keep_token(1, -1)], m)));
                    return [f, [r + ".lark", (0, p.vsep)((0, i.ofArray)([t, (0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)("%declare"), (0, p.seplist)((0, p.word)(" "), (0, i.map)(p.word, j)))]))],
                        [z + ".py", (0, S.codegen_python)(v, (0, g.build)(Z, "the last branch must be a catch-all error case!"))],
                        [G + ".py", (0, p.vsep)((0, l.toList)((0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)("from __future__ import annotations")), (0, l.delay)((() => (0, l.append)(!(0, i.isEmpty)(M) ? (0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(`from .${K} import`), n)) : (0, l.empty)(), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`from .${z} import lexall as ${te}`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`from .${V} import *`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`from lark.lexer import Lexer as ${Y}`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`from lark import Transformer as ${ne}`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`from lark import Lark as ${oe}`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`from ${v}.sedlex import from_ustring as ${re}`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(W), (0, p.word)("=")), (0, p.bracket)((0, p.seplist)((0, p.word)(", "), (0, i.map)((e => (0, p.word)((0, c.escapeString)(e))), j))))), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(I), (0, p.word)("=")), (0, p.bracket)((0, p.seplist)((0, p.word)(", "), (0, i.map)((e => (0, p.word)((0, c.escapeString)(e))), U))))), (0, l.delay)((() => (0, l.append)((0, l.singleton)(p.empty), (0, l.delay)((() => (0, l.append)((0, l.singleton)(definePyFunc((0, p.word)(ee), (0, i.ofArray)([(0, p.word)("token_id"), (0, p.word)("lexeme"), (0, p.word)("line"), (0, p.word)("col"), (0, p.word)("span"), (0, p.word)("offset"), (0, p.word)("file")]), (0, p.vsep)((0, i.ofArray)([(0, p.word)(`if token_id == -1: return ${Q}("EOF", "")`), (0, p.word)(`return ${Q}(${W}[token_id], lexeme, offset, line, col, None, None, span + offset)`)])))), (0, l.delay)((() => (0, l.append)((0, l.singleton)(p.empty), (0, l.delay)((() => (0, l.append)((0, l.singleton)(definePyFunc((0, p.word)(J), (0, i.singleton)((0, p.word)("token")), (0, p.word)('return token.type == "EOF"'))), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`class ${X}(${Y}):`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.vsep)((0, i.ofArray)([definePyFunc((0, p.word)("__init__"), (0, i.ofArray)([(0, p.word)("self"), (0, p.word)("lex_conf")]), (0, p.word)("pass")), definePyFunc((0, p.word)("lex"), (0, i.ofArray)([(0, p.word)("self"), (0, p.word)("raw_string")]), (0, p.vsep)((0, i.ofArray)([(0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)("lexbuf"), (0, p.word)("=")), (0, p.word)(`${re}(raw_string)`)), (0, p.word)(`return ${te}(lexbuf, ${ee}, ${J})`)])))])), 4)), (0, l.delay)((() => (0, l.append)((0, l.singleton)(p.empty), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`class ${ie}(${ne}):`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.vsep)(O), 4)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.word)("pass"), 4)), (0, l.delay)((() => (0, l.append)((0, l.singleton)(p.empty), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.word)(`with (__import__('pathlib').Path(__file__).parent /'${r}.lark').open(encoding='utf8') as __0123fx9:`)), (0, l.delay)((() => (0, l.append)((0, l.singleton)((0, p.Doc_op_RightShift_2AAA0F3C)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(b), (0, p.word)("= __0123fx9.read()")), 4)), (0, l.delay)((() => (0, l.append)((0, l.singleton)(p.empty), (0, l.delay)((() => (0, l.singleton)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.Doc_op_Addition_Z7CFFAC00)((0, p.word)(w), (0, p.word)("=")), (0, p.Doc_op_Multiply_Z7CFFAC00)((0, p.word)(oe), (0, p.parens)((0, p.seplist)((0, p.word)(", "), (0, i.ofArray)([(0, p.word)(b), (0, p.word)("start='start'"), (0, p.word)("parser='lalr'"), (0, p.word)(`lexer=${X}`), (0, p.word)(`transformer=${ie}()`), (0, p.word)("keep_all_tokens=True")]))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))]
                    ]
                }))
            }
        },
        1500: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CSharpKeywords = void 0;
            t.angled = angled;
            t.codegen = codegen;
            var n = r(9386);
            var i = r(6256);
            var o = r(5359);
            var s = r(1337);
            var a = r(9054);
            var l = r(4222);
            var _ = r(5466);
            var u = r(2078);
            var c = r(543);
            var d = r(1383);
            var p = r(1697);
            var f = r(3833);
            var h = r(4205);
            var g = r(9937);
            var m = r(7936);
            const y = ["__arglist", "__makeref", "__reftype", "__refvalue", "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "volatile", "void", "while", "lexer", "parser"];
            t.CSharpKeywords = y;

            function angled(e) {
                return (0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.word)("<"), e), (0, n.word)(">"))
            }

            function codegen(e, t, r, S) {
                let T;
                const x = (0, i.defaultArg)(t.rename_var, (e => e));
                const C = (0, i.defaultArg)(t.rename_ctor, (e => e));
                const N = (0, i.defaultArg)(t.rename_var, (e => e));
                const A = (0, i.defaultArg)(t.rename_field, (e => e));
                const E = (0, i.defaultArg)(t.rename_type, (e => e));
                let v = (0, o.empty)();
                let M = (0, o.empty)();
                const w = (0, s.ofArray)((0, a.append)(["result"], y), {
                    Compare: l.comparePrimitives
                });
                let b = (0, _.empty)();
                let F = (0, o.empty)();
                const B = (0, u.toList)((0, u.delay)((() => (0, u.map)((e => [e[0], x(e[0])]), (0, c.Sigma__get_GlobalVariables)(e.Sigma)))));
                const I = (0, d.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, d.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => {
                    const r = (((0, p.isLower)(t) ? true : (0, p.isUpper)(t)) ? true : (0, p.isUnicode)(t)) ? true : t === "_";
                    return e === 0 ? r : r ? true : (0, p.isDigit)(t)
                }), ((e, t) => (0, p.isDigit)(t) ? `_X${e}_` : `_${t.charCodeAt(0)}_`)), new d.NameMangling_nameEnv((0, s.ofList)((0, o.map)((e => e[1]), B), {
                    Compare: l.comparePrimitives
                })));
                const L = (0, d.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, d.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => e === 0 ? (0, p.isUpper)(t) : ((0, p.isUpper)(t) ? true : t === "_") ? true : (0, p.isDigit)(t)), ((e, t) => (0, p.isLower)(t) ? t.toUpperCase() : e === 0 ? (0, d.NameMangling_maskChar)(65, 90, t.charCodeAt(0)) + "_" : "_" + (0, d.NameMangling_maskChar)(65, 90, t.charCodeAt(0)) + "_")), new d.NameMangling_nameEnv((0, s.ofArray)(["EOF"], {
                    Compare: l.comparePrimitives
                })));
                const P = (0, d.NameMangling_IdentifierDescriptor__WithNameEnv_Z7613F24B)((0, d.NameMangling_IdentifierDescriptor_Create_Z48C5CCEF)(((e, t) => e === 0 ? (0, p.isLower)(t) : ((0, p.isLower)(t) ? true : t === "_") ? true : (0, p.isDigit)(t)), ((e, t) => (0, p.isUpper)(t) ? t.toLowerCase() : "_" + (0, d.NameMangling_maskChar)(97, 122, t.charCodeAt(0)) + "_")), new d.NameMangling_nameEnv((0, s.ofArray)(["start"], {
                    Compare: l.comparePrimitives
                })));
                const mangle = (e, t) => (0, d.NameMangling_mangle)(w, e, t);
                const cg_symbol = e => {
                    const t = (0, _.tryFind)(e, b);
                    if (t == null) {
                        let t;
                        switch (e.tag) {
                            case 0: {
                                const r = e.fields[0];
                                t = e.fields[1] ? (0, p.escapeStringSingleQuoted)(r) : mangle(L, r);
                                break
                            }
                            case 1: {
                                t = mangle(P, e.fields[0]);
                                break
                            }
                            default: {
                                throw new Error("macro not processed")
                            }
                        }
                        b = (0, _.add)(e, t, b);
                        return t
                    } else {
                        return t
                    }
                };
                const name_of_named_term = e => cg_symbol(new f.symbol(0, e, false));
                const tryLookup = (e, t) => {
                    e: while (true) {
                        const r = e,
                            n = t;
                        if (!(0, o.isEmpty)(n)) {
                            if ((0, l.equals)((0, o.head)(n)[0], r)) {
                                return (0, i.some)((0, o.head)(n)[1])
                            } else if (!(0, o.isEmpty)(n)) {
                                e = r;
                                t = (0, o.tail)(n);
                                continue e
                            } else {
                                throw new Error("Match failure")
                            }
                        } else {
                            return void 0
                        }
                        break
                    }
                };
                const _cg_type = e => {
                    let t, r, n, i, s;
                    if (e.tag === 4) {
                        t = 1;
                        n = e.fields[0]
                    } else if (e.tag === 0) {
                        t = 2
                    } else if (e.tag === 3) {
                        t = 3;
                        i = e.fields[0];
                        s = e.fields[1]
                    } else if (e.tag === 2) {
                        if ((0, f.$007CTTuple$007C_$007C)(e.fields[0]) != null) {
                            if ((0, o.isEmpty)(e.fields[1])) {
                                t = 4
                            } else {
                                t = 5
                            }
                        } else {
                            t = 5
                        }
                    } else {
                        t = 0;
                        r = e.fields[0]
                    }
                    switch (t) {
                        case 0: {
                            return E(r)
                        }
                        case 1: {
                            return "_GEN_" + n
                        }
                        case 2: {
                            const e = new h.UnsolvedTypeVariable;
                            throw e
                        }
                        case 3: {
                            return (0, g.join)(", ", (0, o.map)((e => e[0] + ":" + _cg_type(e[1])), i)) + " => " + _cg_type(s)
                        }
                        case 4: {
                            throw new Error("[]")
                        }
                        case 5: {
                            let t, r;
                            if (e.tag === 2) {
                                if ((0, f.$007CTTuple$007C_$007C)(e.fields[0]) != null) {
                                    t = 0;
                                    r = e.fields[1]
                                } else {
                                    t = 1
                                }
                            } else {
                                t = 1
                            }
                            switch (t) {
                                case 0: {
                                    return "[" + (0, g.join)(", ", (0, o.map)(_cg_type, r)) + "]"
                                }
                                case 1: {
                                    if (e.tag === 2) {
                                        const t = (0, g.join)(", ", (0, o.map)(_cg_type, e.fields[1]));
                                        return _cg_type(e.fields[0]) + "<" + t + ">"
                                    } else {
                                        throw new Error("Match failure")
                                    }
                                }
                            }
                        }
                    }
                };
                const cg_type = e => _cg_type((0, f.monot__Prune)(e));
                const slotName = (e, t) => `${e}__${t}`;
                const O = "result";
                const mk_lexer = e => {
                    if (e.tag === 9) {
                        return "(" + mk_lexer(e.fields[0]) + ")"
                    } else if (e.tag === 5) {
                        return `~${mk_lexer(e.fields[0])}`
                    } else if (e.tag === 0) {
                        return "[0-9]"
                    } else if (e.tag === 6) {
                        return `${mk_lexer(e.fields[0])}+`
                    } else if (e.tag === 7) {
                        return `${mk_lexer(e.fields[0])}*`
                    } else if (e.tag === 1) {
                        return "."
                    } else if (e.tag === 11) {
                        const t = (0, p.List_tryLookup)(e.fields[0], F);
                        if (t == null) {
                            const t = (0, h.UnboundLexer)(e.fields[0]);
                            throw t
                        } else {
                            return name_of_named_term(e.fields[0])
                        }
                    } else if (e.tag === 2) {
                        return (0, g.join)(" ", (0, o.toArray)((0, o.map)(mk_lexer, e.fields[0])))
                    } else if (e.tag === 10) {
                        return `[${(0,p.iToU4)(e.fields[0])}-${(0,p.iToU4)(e.fields[1])}]`
                    } else if (e.tag === 4) {
                        if ((0, o.isEmpty)(e.fields[0])) {
                            throw new Error("impossible: alternatives cannot be empty.")
                        } else {
                            return (0, g.join)(" | ", (0, o.toArray)((0, o.map)(mk_lexer, e.fields[0])))
                        }
                    } else if (e.tag === 8) {
                        return `${mk_lexer(e.fields[0])}?`
                    } else {
                        return (0, p.escapeStringSingleQuoted)(e.fields[0])
                    }
                };
                const mk_lexer_debug = e => {
                    const t = mk_lexer_debug;
                    if (e.tag === 9) {
                        return t(e.fields[0])
                    } else if (e.tag === 5) {
                        return `pnot(${t(e.fields[0])})`
                    } else if (e.tag === 0) {
                        return "pnumber"
                    } else if (e.tag === 6) {
                        return `pplus(${t(e.fields[0])})`
                    } else if (e.tag === 7) {
                        return `pstar(${t(e.fields[0])})`
                    } else if (e.tag === 1) {
                        return "pany"
                    } else if (e.tag === 11) {
                        return e.fields[0]
                    } else if (e.tag === 2) {
                        const t = (0, g.join)(", ", (0, u.ofList)((0, o.map)(mk_lexer_debug, e.fields[0])));
                        return `pseq([${t}])`
                    } else if (e.tag === 10) {
                        return `pinterval(${e.fields[0]}, ${e.fields[1]})`
                    } else if (e.tag === 4) {
                        if (!(0, o.isEmpty)(e.fields[0])) {
                            return (0, o.fold)(((e, t) => `por(${e}, ${t})`), t((0, o.head)(e.fields[0])), (0, o.map)(mk_lexer_debug, (0, o.tail)(e.fields[0])))
                        } else {
                            throw new Error("impossible: alternatives cannot be empty.")
                        }
                    } else if (e.tag === 8) {
                        return `popt${t(e.fields[0])}`
                    } else {
                        return `pstring(${(0,p.escapeString)(e.fields[0])})`
                    }
                };
                const simplify_lexerule = e => {
                    switch (e.tag) {
                        case 1:
                        case 10:
                        case 11:
                        case 3: {
                            return e
                        }
                        case 9: {
                            return _must_be_atom_rule(e.fields[0])
                        }
                        case 5: {
                            return new f.lexerule(5, _must_be_atom_rule(e.fields[0]))
                        }
                        case 8: {
                            return new f.lexerule(8, _must_be_atom_rule(e.fields[0]))
                        }
                        case 6: {
                            return new f.lexerule(6, _must_be_atom_rule(e.fields[0]))
                        }
                        case 7: {
                            return new f.lexerule(7, _must_be_atom_rule(e.fields[0]))
                        }
                        case 4: {
                            return new f.lexerule(4, (0, o.map)(_must_be_atom_rule, e.fields[0]))
                        }
                        case 2: {
                            return new f.lexerule(2, (0, o.map)(_must_be_atom_rule, e.fields[0]))
                        }
                        default: {
                            return e
                        }
                    }
                };
                const _must_be_atom_rule = e => {
                    e: while (true) {
                        const t = e;
                        switch (t.tag) {
                            case 1:
                            case 10:
                            case 11:
                            case 3: {
                                return t
                            }
                            case 5: {
                                return new f.lexerule(5, _must_be_atom_rule(t.fields[0]))
                            }
                            case 8: {
                                return new f.lexerule(8, _must_be_atom_rule(t.fields[0]))
                            }
                            case 6: {
                                return new f.lexerule(6, _must_be_atom_rule(t.fields[0]))
                            }
                            case 7: {
                                return new f.lexerule(7, _must_be_atom_rule(t.fields[0]))
                            }
                            case 4: {
                                return new f.lexerule(9, new f.lexerule(4, (0, o.map)(_must_be_atom_rule, t.fields[0])))
                            }
                            case 2: {
                                return new f.lexerule(9, new f.lexerule(2, (0, o.map)(_must_be_atom_rule, t.fields[0])))
                            }
                            case 9: {
                                e = t.fields[0];
                                continue e
                            }
                            default: {
                                return t
                            }
                        }
                        break
                    }
                };
                return (0, m.withErrorHandler)((T = e.Sigma, () => (0, c.Sigma__GetErrorTrace)(T)), (() => {
                    if (!(0, o.isEmpty)((0, c.Sigma__GetADTCases)(e.Sigma))) {
                        throw new Error("typescript backend does not support defining ADTs yet.")
                    }
                    if (!(0, o.isEmpty)((0, c.Sigma__GetRecordTypes)(e.Sigma))) {
                        throw new Error("typescript backend does not support defining records yet.")
                    }
                    const parensIfLOr = e => {
                        if (e.tag === 4) {
                            return (0, n.parens)((0, n.word)(mk_lexer(e)))
                        } else {
                            return (0, n.word)(mk_lexer(e))
                        }
                    };
                    const t = (0, _.tryFind)("start", e.Omega);
                    if (t != null) {
                        const i = t;
                        const m = (0, n.vsep)((0, o.ofArray)((0, a.map)((t => {
                            (0, c.Sigma__SetCurrentDefinition_Z759AB257)(e.Sigma, t);
                            switch (t.tag) {
                                case 2: {
                                    const e = t.fields[0];
                                    F = (0, o.cons)([e.lhs, e.define], F);
                                    return n.empty
                                }
                                case 6: {
                                    return (0, n.vsep)((0, o.empty)())
                                }
                                case 4: {
                                    return (0, n.vsep)((0, o.empty)())
                                }
                                case 3: {
                                    v = (0, o.cons)(x(t.fields[0].ident), v);
                                    return (0, n.vsep)((0, o.empty)())
                                }
                                case 5: {
                                    const e = t.fields[0];
                                    if (e.external) {
                                        M = (0, o.cons)(E(e.ident), M)
                                    }
                                    return (0, n.vsep)((0, o.empty)())
                                }
                                case 0: {
                                    throw new Error("macro not processed")
                                }
                                default: {
                                    const r = t.fields[0];
                                    const i = r.lhs;
                                    const a = cg_symbol(new f.symbol(1, i));
                                    let m;
                                    const y = new f.symbol(1, i);
                                    switch (y.tag) {
                                        case 0: {
                                            m = f.TConst_token;
                                            break
                                        }
                                        case 1: {
                                            m = (0, _.FSharpMap__get_Item)(e.Omega, y.fields[0]);
                                            break
                                        }
                                        default: {
                                            throw new Error("macro not processed")
                                        }
                                    }
                                    let S = 0;
                                    const T = (0, n.align)((0, n.vsep)((0, o.mapIndexed)(((e, t) => (0, n.Doc_op_Addition_Z7CFFAC00)(e === 0 ? (0, n.word)(":") : (0, n.word)("|"), t)), (0, u.toList)((0, u.delay)((() => (0, u.collect)((t => {
                                        let r, i, _, m, y, T;
                                        let x;
                                        const C = S | 0;
                                        x = (0, g.toText)((0, g.printf)("%s_%i"))(a)(C);
                                        (0, c.Sigma__SetCurrentPos_Z302187B)(e.Sigma, t[0]);
                                        (0, c.Sigma__SetCurrentDefinitionBranch_Z524259A4)(e.Sigma, S);
                                        S = S + 1 | 0;
                                        return (0, u.append)((0, u.singleton)((r = t[1], i = x, _ = (m = r.action, y = (0, u.toArray)((0, u.delay)((() => (0, u.map)((e => e.tag === 0), r.symbols)))), (0, c.Sigma__WithExpr)(e.Sigma, m, (() => {
                                            let e = (0, s.empty)({
                                                Compare: l.comparePrimitives
                                            });
                                            const cg_expr = (t, r) => (0, d.DocBuilder_Builder__Run_ZD0BB270)(d.DocBuilder_cg, (0, d.DocBuilder_Builder__Delay_Z3A9C5A06)(d.DocBuilder_cg, (() => {
                                                let a, l, _, c;
                                                const m = r.node;
                                                if (m.tag === 6) {
                                                    const e = tryLookup(m.fields[0], t);
                                                    if (e != null) {
                                                        const t = e;
                                                        return (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, o.length)(m.fields[1].contents) === 0 ? (0, n.word)(t) : (a = (l = (0, o.map)((e => (0, n.word)(cg_type(e))), (0, o.map)(f.monot__Prune, m.fields[1].contents)), (0, n.seplist)((0, n.word)(", "), l)), (0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.word)(t), (0, n.word)("<")), a), (0, n.word)(">"))))
                                                    } else {
                                                        return (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (() => {
                                                            throw (0, h.UnboundVariable)(m.fields[0])
                                                        })())
                                                    }
                                                } else if (m.tag === 11) {
                                                    return m.fields[0] ? (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.word)("true")) : (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.word)("false"))
                                                } else if (m.tag === 3) {
                                                    return (0, d.DocBuilder_Builder__Bind_30A200B3)(d.DocBuilder_cg, cg_expr(t, m.fields[0]), (e => (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.Doc_op_Multiply_Z7CFFAC00)(e, (0, n.word)(".")), (0, n.word)(m.fields[1])))))
                                                } else if (m.tag === 8) {
                                                    return (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.word)((0, g.toText)((0, g.printf)("%d"))(m.fields[0])))
                                                } else if (m.tag === 10) {
                                                    return (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.word)((0, g.toText)((0, g.printf)("%f"))(m.fields[0])))
                                                } else if (m.tag === 9) {
                                                    return (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.word)((0, p.escapeString)(m.fields[0])))
                                                } else if (m.tag === 5) {
                                                    const e = (0, d.DocBuilder_runCG)(cg_expr((0, o.append)((0, u.toList)((0, u.delay)((() => (0, u.collect)((e => {
                                                        const t = e[0];
                                                        return (0, u.singleton)([t, mangle(I, t)])
                                                    }), m.fields[0])))), t), m.fields[1]));
                                                    return (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (_ = (0, n.vsep)((0, o.ofArray)([(0, n.vsep)(e[1]), (0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)("return"), (0, n.Doc_op_Multiply_Z7CFFAC00)(e[0], (0, n.word)(";")))])), c = (0, o.map)((e => (0, n.word)(cg_type(e[1]) + " " + e[0])), m.fields[0]), (0, n.parens)((0, n.vsep)((0, o.ofArray)([(0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)("function"), (0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.parens)((0, n.seplist)((0, n.word)(", "), c)), (0, n.word)("{"))), (0, n.Doc_op_RightShift_2AAA0F3C)(_, 4), (0, n.word)("}")])))))
                                                } else if (m.tag === 4) {
                                                    return (0, d.DocBuilder_Builder__Bind_30A200B3)(d.DocBuilder_cg, cg_expr(t, m.fields[1]), (e => {
                                                        const r = mangle(I, m.fields[0]);
                                                        return (0, d.DocBuilder_Builder__Combine_Z5C764E00)(d.DocBuilder_cg, (0, d.DocBuilder_Builder__Yield_417FD60)(d.DocBuilder_cg, (0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)("let"), (0, n.word)(r)), (0, n.word)(":")), (0, n.word)(cg_type(m.fields[1].t))), (0, n.word)("=")), (0, n.Doc_op_Multiply_Z7CFFAC00)(e, (0, n.word)(";")))), (0, d.DocBuilder_Builder__Delay_Z3A9C5A06)(d.DocBuilder_cg, (() => (0, d.DocBuilder_Builder__ReturnFrom_ZD0BB270)(d.DocBuilder_cg, cg_expr((0, o.cons)([m.fields[0], r], t), m.fields[2])))))
                                                    }))
                                                } else if (m.tag === 2) {
                                                    return (0, d.DocBuilder_Builder__Bind_30A200B3)(d.DocBuilder_cg, (0, d.DocBuilder_Builder__Run_ZD0BB270)(d.DocBuilder_cg, (0, d.DocBuilder_Builder__Delay_Z3A9C5A06)(d.DocBuilder_cg, (() => (0, d.DocBuilder_Builder__For_2B96F4AF)(d.DocBuilder_cg, m.fields[0], (e => (0, d.DocBuilder_Builder__ReturnFrom_ZD0BB270)(d.DocBuilder_cg, cg_expr(t, e))))))), (e => (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.word)(`<${cg_type(r.t)}>`), (0, n.word)("[")), (0, n.seplist)((0, n.word)(","), e)), (0, n.word)("]")))))
                                                } else if (m.tag === 7) {
                                                    const t = slotName(i, m.fields[0]);
                                                    e = (0, s.add)(m.fields[0], e);
                                                    const r = (0, n.word)(`_localctx._${t}`);
                                                    return (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, y[m.fields[0] - 1] ? r : (0, n.Doc_op_Multiply_Z7CFFAC00)(r, (0, n.word)(".result")))
                                                } else {
                                                    return m.tag === 1 ? (0, d.DocBuilder_Builder__Bind_30A200B3)(d.DocBuilder_cg, (0, d.DocBuilder_Builder__Run_ZD0BB270)(d.DocBuilder_cg, (0, d.DocBuilder_Builder__Delay_Z3A9C5A06)(d.DocBuilder_cg, (() => (0, d.DocBuilder_Builder__For_2B96F4AF)(d.DocBuilder_cg, m.fields[0], (e => (0, d.DocBuilder_Builder__ReturnFrom_ZD0BB270)(d.DocBuilder_cg, cg_expr(t, e))))))), (e => (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.word)(`<${cg_type(r.t)}>`), (0, n.bracket)((0, n.seplist)((0, n.word)(", "), e)))))) : (0, d.DocBuilder_Builder__Bind_30A200B3)(d.DocBuilder_cg, cg_expr(t, m.fields[0]), (e => (0, d.DocBuilder_Builder__Bind_30A200B3)(d.DocBuilder_cg, (0, d.DocBuilder_Builder__Run_ZD0BB270)(d.DocBuilder_cg, (0, d.DocBuilder_Builder__Delay_Z3A9C5A06)(d.DocBuilder_cg, (() => (0, d.DocBuilder_Builder__For_2B96F4AF)(d.DocBuilder_cg, m.fields[1], (e => {
                                                        const r = e;
                                                        return (0, d.DocBuilder_Builder__Bind_30A200B3)(d.DocBuilder_cg, cg_expr(t, r), (e => (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.Doc_op_Addition_Z7CFFAC00)(angled((0, n.word)(cg_type(r.t))), e))))
                                                    }))))), (t => {
                                                        const i = cg_type(r.t);
                                                        return (0, d.DocBuilder_Builder__Return_1505)(d.DocBuilder_cg, (0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)(`<${i}>`), (0, n.Doc_op_Multiply_Z7CFFAC00)(e, (0, n.parens)((0, n.seplist)((0, n.word)(", "), t)))))
                                                    }))))
                                                }
                                            })));
                                            const t = (0, d.DocBuilder_runCG)(cg_expr(B, m));
                                            return [e, t]
                                        }))), (0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((T = (0, o.mapIndexed)(((e, t) => {
                                            const r = e + 1 | 0;
                                            const o = (0, n.word)(cg_symbol(t));
                                            if ((0, s.contains)(r, _[0])) {
                                                return (0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.Doc_op_Multiply_Z7CFFAC00)((0, n.word)(slotName(i, r)), (0, n.word)("=")), o)
                                            } else {
                                                return o
                                            }
                                        }), r.symbols), (0, n.seplist)((0, n.word)(" "), T)), (0, n.word)("{")), (0, n.Doc_op_RightShift_2AAA0F3C)((0, n.vsep)((0, o.ofArray)([n.empty, (0, n.Doc_op_RightShift_2AAA0F3C)((0, n.vsep)((0, o.ofArray)([(0, n.vsep)(_[1][1]), (0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)("$" + O), (0, n.word)("=")), (0, n.Doc_op_Multiply_Z7CFFAC00)(_[1][0], (0, n.word)(";")))])), 4), (0, n.word)("}")])), 12)))), (0, u.delay)((() => {
                                            S = S + 1 | 0;
                                            return (0, u.empty)()
                                        })))
                                    }), r.define)))))));
                                    return (0, n.vsep)((0, o.ofArray)([(0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)(a), (0, n.word)("returns")), (0, n.bracket)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)(cg_type(m)), (0, n.word)(O)))), (0, n.Doc_op_RightShift_2AAA0F3C)(T, 4), (0, n.word)(";")]))
                                }
                            }
                        }), S)));
                        const y = (0, u.toList)((0, u.delay)((() => (0, u.collect)((t => {
                            const r = t[0];
                            const i = simplify_lexerule(t[1]);
                            const o = name_of_named_term(r);
                            return (0, s.contains)(r, e.IgnoreSet) ? (0, u.singleton)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)(o), (0, n.word)(":")), parensIfLOr(i)), (0, n.word)("-> channel(HIDDEN);"))) : (0, s.contains)(r, e.ReferencedNamedTokens) ? (0, u.singleton)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)(o), (0, n.word)(":")), (0, n.word)(mk_lexer(i))), (0, n.word)(";"))) : (0, u.singleton)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.Doc_op_Addition_Z7CFFAC00)((0, n.word)("fragment"), (0, n.word)(o)), (0, n.word)(":")), parensIfLOr(i)), (0, n.word)(";")))
                        }), (0, o.reverse)(F)))));
                        const T = cg_symbol(new f.symbol(1, "start"));
                        const C = (0, o.append)(M, v);
                        return [
                            [r + ".g4", (0, n.vsep)((0, u.toList)((0, u.delay)((() => (0, u.append)((0, u.singleton)((0, n.word)(`grammar ${r};`)), (0, u.delay)((() => (0, u.append)((0, u.singleton)((0, n.word)("@header {")), (0, u.delay)((() => {
                                let e, t;
                                return (0, u.append)(!(0, o.isEmpty)(C) ? (e = (0, g.join)(", ", C), t = (0, p.escapeString)(`./${r}_require`), (0, u.singleton)((0, n.word)(`import { ${e} } from ${t}`))) : (0, u.empty)(), (0, u.delay)((() => (0, u.append)((0, u.singleton)((0, n.word)("}")), (0, u.delay)((() => {
                                    let e;
                                    return (0, u.append)((0, u.singleton)((0, n.word)((e = cg_type(i), (0, g.toText)((0, g.printf)("start returns [result: %s]: v=%s EOF { $result = _localctx._v.result; };"))(e)(T)))), (0, u.delay)((() => (0, u.append)((0, u.singleton)(m), (0, u.delay)((() => y))))))
                                }))))))
                            }))))))))))]
                        ]
                    } else {
                        const e = (0, h.UnboundNonterminal)("start");
                        throw e
                    }
                }))
            }
        },
        7936: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.errorToReadableString = errorToReadableString;
            t.exitFunc = void 0;
            t.renderTypeKind = renderTypeKind;
            t.setExitFunc = setExitFunc;
            t.withErrorHandler = withErrorHandler;
            var n = r(9937);
            var i = r(5359);
            var o = r(4205);
            var s = r(380);
            var a = r(3833);
            var l = r(6638);
            var _ = r(6256);

            function renderTypeKind(e) {
                if (e === 0) {
                    return "type"
                } else {
                    const t = (0, n.join)(", ", (0, i.replicate)(e, "_"));
                    return `type<${t}>`
                }
            }

            function errorToReadableString(e) {
                let t = true;
                let r;
                if (e instanceof o.IllFormedType) {
                    const t = (0, s.inspectMonoType)((0, a.monot__Prune)(e.Data0));
                    const n = (0, s.inspectMonoType)((0, a.monot__Prune)(e.Data1));
                    r = `recursive types are invalid: ${t} ~ ${n}`
                } else if (e instanceof o.TypeMismatch) {
                    const t = (0, s.inspectMonoType)((0, a.monot__Prune)(e.Data0));
                    const n = (0, s.inspectMonoType)((0, a.monot__Prune)(e.Data1));
                    r = `type mismatch: ${t} ~ ${n}`
                } else if (e instanceof o.TypeUnexpected) {
                    const t = (0, s.inspectMonoType)((0, a.monot__Prune)(e.got));
                    const n = (0, s.inspectMonoType)((0, a.monot__Prune)(e.expected));
                    r = `expected ${t} ~ ${n}`
                } else if (e instanceof o.InvalidTypeApplication) {
                    const t = (0, s.inspectMonoType)((0, a.monot__Prune)(e.Data0));
                    r = `invalid type application: ${t}`
                } else if (e instanceof o.InvalidKind) {
                    const t = e.Data0.expect | 0;
                    const n = renderTypeKind(t);
                    const i = e.Data0.got | 0;
                    const o = renderTypeKind(i);
                    r = `invalid kind: type constructor '${e.Data0.name}' expects kind ${t} (${n}) but got kind ${i} ('${o}')`
                } else if (e instanceof o.NoField) {
                    const t = (0, s.inspectMonoType)((0, a.monot__Prune)(e.Data0));
                    r = `no field '${e.Data1}' in type ${t}`
                } else if (e instanceof o.CannotInferField) {
                    const t = (0, s.inspectMonoType)((0, a.monot__Prune)(e.Data0));
                    r = `cannot infer field type for type ${t}, please give annotations.`
                } else if (e instanceof o.NoBaseName) {
                    const t = (0, s.inspectMonoType)((0, a.monot__Prune)(e.Data0));
                    r = `type ${t} has no object base name, and might not take fields.`
                } else if (e instanceof o.NameError) {
                    r = e.Data1.tag === 1 ? e.Data2.tag === 1 ? `unbound variable '${e.Data0}'` : `duplicate variable '${e.Data0}'` : e.Data1.tag === 2 ? e.Data2.tag === 1 ? `unbound nonterminal '${e.Data0}'` : `duplicate nonterminal '${e.Data0}'` : e.Data1.tag === 3 ? e.Data2.tag === 1 ? `unbound lexical rule '${e.Data0}'` : `duplicate lexical rule '${e.Data0}'` : e.Data2.tag === 1 ? `unbound type variable '${e.Data0}'` : `duplicate type variable '${e.Data0}'`
                } else if (e instanceof o.ComponentAccessingOutOfBound) {
                    const t = e.access === 1 ? "1-st" : e.access === 2 ? "2-nd" : e.access === 3 ? "3-rd" : `${e.access}-th`;
                    r = `${t} semantic value is out of bound (maxsize: ${e.maxsize})`
                } else if (e instanceof o.MacroResolveError) {
                    r = `cannot resolve macro '${e.Data0}'`
                } else if (e instanceof o.UnsolvedTypeVariable) {
                    r = "find unsolved type variable"
                } else if (e instanceof o.NotGlobalVariable) {
                    r = `'${e.Data0}' is not global when checking if it is a constructor.`
                } else if (e instanceof o.InvalidConstructorDefinination) {
                    if (e.cause.tag === 1) {
                        r = `constructor '${e.ctorName}' is defined for record type '${e.cause.fields[0]}'`
                    } else if (e.cause.tag === 2) {
                        const t = (0, n.join)(", ", e.cause.fields[1]);
                        const i = `${e.cause.fields[0]}<${t}>`;
                        r = `GADT constructor is not supported in Typed BNF, but '${e.ctorName}' is meant to be a GADT constructor for type '${i}'`
                    } else if (e.cause.tag === 3) {
                        r = `duplicate constructor name '${e.ctorName}'`
                    } else if (e.cause.tag === 4) {
                        const t = (0, s.inspectMonoType)((0, a.monot__Prune)(e.cause.fields[0]));
                        r = `invalid constructor type '${t}', expect a function type!`
                    } else {
                        r = `constructor '${e.ctorName}' is defined for external type '${e.cause.fields[0]}'`
                    }
                } else {
                    t = false;
                    r = `uncognised error (${(0,l.toString)(e)})`
                }
                return [t, r]
            }
            const u = new l.FSharpRef((e => {
                throw new Error("exit function not set")
            }));
            t.exitFunc = u;

            function setExitFunc(e) {
                u.contents = e
            }

            function withErrorHandler(e, t) {
                try {
                    return t()
                } catch (t) {
                    const r = errorToReadableString(t);
                    const o = r[1];
                    const l = e();
                    const c = l.currentPos;
                    const d = l.whichDef;
                    const p = l.branch | 0;
                    let f;
                    const h = (0, _.map)(s.showExpr, (0, i.tryHead)(l.exprStack));
                    if (h != null) {
                        const e = h;
                        f = `  in ${e}\n`
                    } else {
                        f = ""
                    }
                    let g;
                    const m = c.filename;
                    const y = c.line | 0;
                    const S = c.col | 0;
                    let T;
                    switch (d.tag) {
                        case 0: {
                            const e = d.fields[0];
                            const t = (0, i.item)(p, e.define)[1];
                            const r = (0, n.join)(", ", e.parameters);
                            const o = (0, n.join)(" ", (0, i.map)(a.symbol__Inspect, t.symbols));
                            const l = (0, s.showExpr)(t.action);
                            T = [e.lhs, `${e.lhs}(${r}) : ${o} { ${l} }`];
                            break
                        }
                        case 5: {
                            T = [`type declaration for ${d.fields[0].ident}`, ""];
                            break
                        }
                        case 3: {
                            T = [`variable declaration for ${d.fields[0].ident}`, ""];
                            break
                        }
                        case 4: {
                            T = [`constructor declaration for ${d.fields[0].ident}`, ""];
                            break
                        }
                        case 2: {
                            T = [`lexer declaration for ${d.fields[0].lhs}`, ""];
                            break
                        }
                        case 6: {
                            T = [`ignore declaration for ${d.fields[0].ignoreList}`, ""];
                            break
                        }
                        default: {
                            const e = d.fields[0];
                            const t = (0, i.item)(p, e.define)[1];
                            const r = (0, s.showExpr)(t.action);
                            const o = (0, n.join)(" ", (0, i.map)(a.symbol__Inspect, t.symbols));
                            T = [e.lhs, `${e.lhs}: ${o} { ${r} }`]
                        }
                    }
                    const x = T[1];
                    const C = T[0];
                    g = x === "" ? `File '${m}', line ${y}, character ${S}\n` + `  at '${C}'\n` + `  ${o}\n` : `File '${m}', line ${y}, character ${S}\n` + `  at rule '${C}':\n  '${x}'\n` + f + `  ${o}\n`;
                    if (r[0]) {
                        (0, n.toConsole)((0, n.printf)("%s"))(g);
                        u.contents(1);
                        throw new Error("exit function not set")
                    } else {
                        throw new Error(g)
                    }
                }
            }
        },
        4205: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.CannotInferField = void 0;
            t.CannotInferField$reflection = CannotInferField$reflection;
            t.ComponentAccessingOutOfBound = void 0;
            t.ComponentAccessingOutOfBound$reflection = ComponentAccessingOutOfBound$reflection;
            t.DuplicateLexer = DuplicateLexer;
            t.DuplicateNonterminal = DuplicateNonterminal;
            t.DuplicateTypeVariable = DuplicateTypeVariable;
            t.DuplicateVariable = DuplicateVariable;
            t.ErrorTrace = void 0;
            t.ErrorTrace$reflection = ErrorTrace$reflection;
            t.IllFormedType = void 0;
            t.IllFormedType$reflection = IllFormedType$reflection;
            t.InvalidConstructorDefinination = void 0;
            t.InvalidConstructorDefinination$reflection = InvalidConstructorDefinination$reflection;
            t.InvalidConstructorDefininationCause = void 0;
            t.InvalidConstructorDefininationCause$reflection = InvalidConstructorDefininationCause$reflection;
            t.InvalidKind = void 0;
            t.InvalidKind$reflection = InvalidKind$reflection;
            t.InvalidTypeApplication = void 0;
            t.InvalidTypeApplication$reflection = InvalidTypeApplication$reflection;
            t.MacroResolveError = void 0;
            t.MacroResolveError$reflection = MacroResolveError$reflection;
            t.NameError = void 0;
            t.NameError$reflection = NameError$reflection;
            t.NameErrorKind = void 0;
            t.NameErrorKind$reflection = NameErrorKind$reflection;
            t.NameErrorScope = void 0;
            t.NameErrorScope$reflection = NameErrorScope$reflection;
            t.NoBaseName = void 0;
            t.NoBaseName$reflection = NoBaseName$reflection;
            t.NoField = void 0;
            t.NoField$reflection = NoField$reflection;
            t.NotGlobalVariable = void 0;
            t.NotGlobalVariable$reflection = NotGlobalVariable$reflection;
            t.TypeMismatch = void 0;
            t.TypeMismatch$reflection = TypeMismatch$reflection;
            t.TypeUnexpected = void 0;
            t.TypeUnexpected$reflection = TypeUnexpected$reflection;
            t.UnboundLexer = UnboundLexer;
            t.UnboundNonterminal = UnboundNonterminal;
            t.UnboundTypeVariable = UnboundTypeVariable;
            t.UnboundVariable = UnboundVariable;
            t.UnsolvedTypeVariable = void 0;
            t.UnsolvedTypeVariable$reflection = UnsolvedTypeVariable$reflection;
            var n = r(6638);
            var i = r(3833);
            var o = r(6356);
            var s = r(4222);
            class ErrorTrace extends n.Record {
                constructor(e, t, r, n) {
                    super();
                    this.whichDef = e;
                    this.branch = t | 0;
                    this.exprStack = r;
                    this.currentPos = n
                }
            }
            t.ErrorTrace = ErrorTrace;

            function ErrorTrace$reflection() {
                return (0, o.record_type)("tbnf.Exceptions.ErrorTrace", [], ErrorTrace, (() => [
                    ["whichDef", (0, i.definition$reflection)()],
                    ["branch", o.int32_type],
                    ["exprStack", (0, o.list_type)((0, i.expr$reflection)())],
                    ["currentPos", (0, i.position$reflection)()]
                ]))
            }
            class NameErrorScope extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["TYPE", "VAR", "NONTERM", "LEXER"]
                }
            }
            t.NameErrorScope = NameErrorScope;

            function NameErrorScope$reflection() {
                return (0, o.union_type)("tbnf.Exceptions.NameErrorScope", [], NameErrorScope, (() => [
                    [],
                    [],
                    [],
                    []
                ]))
            }
            class NameErrorKind extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["Duplicate", "Unbound"]
                }
            }
            t.NameErrorKind = NameErrorKind;

            function NameErrorKind$reflection() {
                return (0, o.union_type)("tbnf.Exceptions.NameErrorKind", [], NameErrorKind, (() => [
                    [],
                    []
                ]))
            }
            class IllFormedType extends n.FSharpException {
                constructor(e, t) {
                    super();
                    this.Data0 = e;
                    this.Data1 = t
                }
            }
            t.IllFormedType = IllFormedType;

            function IllFormedType$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.IllFormedType", void 0, IllFormedType, (0, o.class_type)("System.Exception"))
            }

            function IllFormedType__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof IllFormedType) {
                            if ((0, s.equals)(e.Data0, t.Data0)) {
                                return (0, s.equals)(e.Data1, t.Data1)
                            } else {
                                return false
                            }
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class TypeMismatch extends n.FSharpException {
                constructor(e, t) {
                    super();
                    this.Data0 = e;
                    this.Data1 = t
                }
            }
            t.TypeMismatch = TypeMismatch;

            function TypeMismatch$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.TypeMismatch", void 0, TypeMismatch, (0, o.class_type)("System.Exception"))
            }

            function TypeMismatch__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof TypeMismatch) {
                            if ((0, s.equals)(e.Data0, t.Data0)) {
                                return (0, s.equals)(e.Data1, t.Data1)
                            } else {
                                return false
                            }
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class TypeUnexpected extends n.FSharpException {
                constructor(e, t) {
                    super();
                    this.got = e;
                    this.expected = t
                }
            }
            t.TypeUnexpected = TypeUnexpected;

            function TypeUnexpected$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.TypeUnexpected", void 0, TypeUnexpected, (0, o.class_type)("System.Exception"))
            }

            function TypeUnexpected__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof TypeUnexpected) {
                            if ((0, s.equals)(e.got, t.got)) {
                                return (0, s.equals)(e.expected, t.expected)
                            } else {
                                return false
                            }
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class InvalidTypeApplication extends n.FSharpException {
                constructor(e) {
                    super();
                    this.Data0 = e
                }
            }
            t.InvalidTypeApplication = InvalidTypeApplication;

            function InvalidTypeApplication$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.InvalidTypeApplication", void 0, InvalidTypeApplication, (0, o.class_type)("System.Exception"))
            }

            function InvalidTypeApplication__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof InvalidTypeApplication) {
                            return (0, s.equals)(e.Data0, t.Data0)
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class InvalidKind extends n.FSharpException {
                constructor(e) {
                    super();
                    this.Data0 = e
                }
            }
            t.InvalidKind = InvalidKind;

            function InvalidKind$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.InvalidKind", void 0, InvalidKind, (0, o.class_type)("System.Exception"))
            }

            function InvalidKind__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof InvalidKind) {
                            return (0, s.equals)(e.Data0, t.Data0)
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class NoField extends n.FSharpException {
                constructor(e, t) {
                    super();
                    this.Data0 = e;
                    this.Data1 = t
                }
            }
            t.NoField = NoField;

            function NoField$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.NoField", void 0, NoField, (0, o.class_type)("System.Exception"))
            }

            function NoField__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof NoField) {
                            if ((0, s.equals)(e.Data0, t.Data0)) {
                                return e.Data1 === t.Data1
                            } else {
                                return false
                            }
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class CannotInferField extends n.FSharpException {
                constructor(e) {
                    super();
                    this.Data0 = e
                }
            }
            t.CannotInferField = CannotInferField;

            function CannotInferField$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.CannotInferField", void 0, CannotInferField, (0, o.class_type)("System.Exception"))
            }

            function CannotInferField__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof CannotInferField) {
                            return (0, s.equals)(e.Data0, t.Data0)
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class NoBaseName extends n.FSharpException {
                constructor(e) {
                    super();
                    this.Data0 = e
                }
            }
            t.NoBaseName = NoBaseName;

            function NoBaseName$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.NoBaseName", void 0, NoBaseName, (0, o.class_type)("System.Exception"))
            }

            function NoBaseName__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof NoBaseName) {
                            return (0, s.equals)(e.Data0, t.Data0)
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class NameError extends n.FSharpException {
                constructor(e, t, r) {
                    super();
                    this.Data0 = e;
                    this.Data1 = t;
                    this.Data2 = r
                }
            }
            t.NameError = NameError;

            function NameError$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.NameError", void 0, NameError, (0, o.class_type)("System.Exception"))
            }

            function NameError__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof NameError) {
                            if (e.Data0 === t.Data0) {
                                if ((0, s.equals)(e.Data1, t.Data1)) {
                                    return (0, s.equals)(e.Data2, t.Data2)
                                } else {
                                    return false
                                }
                            } else {
                                return false
                            }
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }

            function UnboundTypeVariable(e) {
                return new NameError(e, new NameErrorScope(0), new NameErrorKind(1))
            }

            function DuplicateTypeVariable(e) {
                return new NameError(e, new NameErrorScope(0), new NameErrorKind(0))
            }

            function UnboundVariable(e) {
                return new NameError(e, new NameErrorScope(1), new NameErrorKind(1))
            }

            function DuplicateVariable(e) {
                return new NameError(e, new NameErrorScope(1), new NameErrorKind(0))
            }

            function UnboundNonterminal(e) {
                return new NameError(e, new NameErrorScope(2), new NameErrorKind(1))
            }

            function DuplicateNonterminal(e) {
                return new NameError(e, new NameErrorScope(2), new NameErrorKind(0))
            }

            function UnboundLexer(e) {
                return new NameError(e, new NameErrorScope(3), new NameErrorKind(1))
            }

            function DuplicateLexer(e) {
                return new NameError(e, new NameErrorScope(3), new NameErrorKind(0))
            }
            class ComponentAccessingOutOfBound extends n.FSharpException {
                constructor(e, t) {
                    super();
                    this.access = e | 0;
                    this.maxsize = t | 0
                }
            }
            t.ComponentAccessingOutOfBound = ComponentAccessingOutOfBound;

            function ComponentAccessingOutOfBound$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.ComponentAccessingOutOfBound", void 0, ComponentAccessingOutOfBound, (0, o.class_type)("System.Exception"))
            }

            function ComponentAccessingOutOfBound__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof ComponentAccessingOutOfBound) {
                            if (e.access === t.access) {
                                return e.maxsize === t.maxsize
                            } else {
                                return false
                            }
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class MacroResolveError extends n.FSharpException {
                constructor(e) {
                    super();
                    this.Data0 = e
                }
            }
            t.MacroResolveError = MacroResolveError;

            function MacroResolveError$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.MacroResolveError", void 0, MacroResolveError, (0, o.class_type)("System.Exception"))
            }

            function MacroResolveError__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof MacroResolveError) {
                            return e.Data0 === t.Data0
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class UnsolvedTypeVariable extends n.FSharpException {
                constructor() {
                    super()
                }
            }
            t.UnsolvedTypeVariable = UnsolvedTypeVariable;

            function UnsolvedTypeVariable$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.UnsolvedTypeVariable", void 0, UnsolvedTypeVariable, (0, o.class_type)("System.Exception"))
            }

            function UnsolvedTypeVariable__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof UnsolvedTypeVariable) {
                            return 1
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class NotGlobalVariable extends n.FSharpException {
                constructor(e) {
                    super();
                    this.Data0 = e
                }
            }
            t.NotGlobalVariable = NotGlobalVariable;

            function NotGlobalVariable$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.NotGlobalVariable", void 0, NotGlobalVariable, (0, o.class_type)("System.Exception"))
            }

            function NotGlobalVariable__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof NotGlobalVariable) {
                            return e.Data0 === t.Data0
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
            class InvalidConstructorDefininationCause extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["CauseExternalType", "CauseRecordType", "CauseGenericADTType", "CauseDuplicateConstructorName", "CauseInvalidConstructorType"]
                }
            }
            t.InvalidConstructorDefininationCause = InvalidConstructorDefininationCause;

            function InvalidConstructorDefininationCause$reflection() {
                return (0, o.union_type)("tbnf.Exceptions.InvalidConstructorDefininationCause", [], InvalidConstructorDefininationCause, (() => [
                    [
                        ["typename", o.string_type]
                    ],
                    [
                        ["typename", o.string_type]
                    ],
                    [
                        ["typename", o.string_type],
                        ["parameters", (0, o.list_type)(o.string_type)]
                    ],
                    [],
                    [
                        ["Item", (0, i.monot$reflection)()]
                    ]
                ]))
            }
            class InvalidConstructorDefinination extends n.FSharpException {
                constructor(e, t) {
                    super();
                    this.ctorName = e;
                    this.cause = t
                }
            }
            t.InvalidConstructorDefinination = InvalidConstructorDefinination;

            function InvalidConstructorDefinination$reflection() {
                return (0, o.class_type)("tbnf.Exceptions.InvalidConstructorDefinination", void 0, InvalidConstructorDefinination, (0, o.class_type)("System.Exception"))
            }

            function InvalidConstructorDefinination__Equals_229D3F39(e, t) {
                if (!(0, s.equals)(e, null)) {
                    if (!(0, s.equals)(t, null)) {
                        if (t instanceof InvalidConstructorDefinination) {
                            if (e.ctorName === t.ctorName) {
                                return (0, s.equals)(e.cause, t.cause)
                            } else {
                                return false
                            }
                        } else {
                            return false
                        }
                    } else {
                        return false
                    }
                } else if (!(0, s.equals)(t, null)) {
                    return false
                } else {
                    return true
                }
            }
        },
        3833: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.$007CTTuple$007C_$007C = $007CTTuple$007C_$007C;
            t.Cell$1 = void 0;
            t.Cell$1$reflection = Cell$1$reflection;
            t.Cell$1_$ctor = Cell$1_$ctor;
            t.Cell$1__Set_2B595 = Cell$1__Set_2B595;
            t.Cell$1__get_Get = Cell$1__get_Get;
            t.Cell$1__get_IsNull = Cell$1__get_IsNull;
            t.TConst_tuple = t.TConst_token = t.TConst_str = t.TConst_list = t.TConst_int = t.TConst_float = t.TConst_bool = void 0;
            t.TList = TList;
            t.TTuple = TTuple;
            t.definition = t._predefined_typenames = void 0;
            t.definition$reflection = definition$reflection;
            t.definition__Inspect = definition__Inspect;
            t.definition__get_Position = definition__get_Position;
            t.expr = void 0;
            t.expr$reflection = expr$reflection;
            t.expr_WithNode = expr_WithNode;
            t.expr__DeepCopy = expr__DeepCopy;
            t.expr__TransformChildren_Z51B8244A = expr__TransformChildren_Z51B8244A;
            t.lexerule = void 0;
            t.lexerule$reflection = lexerule$reflection;
            t.monot = void 0;
            t.monot$reflection = monot$reflection;
            t.monot__ApplyToChildren_Z6A62BCBF = monot__ApplyToChildren_Z6A62BCBF;
            t.monot__FindAnyChildren_Z23D07CE9 = monot__FindAnyChildren_Z23D07CE9;
            t.monot__Prune = monot__Prune;
            t.monot__TransformChildren_Z2CAB662A = monot__TransformChildren_Z2CAB662A;
            t.node = void 0;
            t.node$reflection = node$reflection;
            t.polyt = void 0;
            t.polyt$reflection = polyt$reflection;
            t.position = void 0;
            t.position$reflection = position$reflection;
            t.position_get_Fake = position_get_Fake;
            t.production = void 0;
            t.production$reflection = production$reflection;
            t.symbol = void 0;
            t.symbol$reflection = symbol$reflection;
            t.symbol__Inspect = symbol__Inspect;
            var n = r(6638);
            var i = r(6356);
            var o = r(5359);
            var s = r(9937);
            var a = r(1697);
            var l = r(6256);
            class Cell$1 {
                constructor() {
                    this._cell = null
                }
                toString() {
                    const e = this;
                    if (Cell$1__get_IsNull(e)) {
                        return "<null>"
                    } else {
                        let t = Cell$1__get_Get(e);
                        return (0, n.toString)(t)
                    }
                }
            }
            t.Cell$1 = Cell$1;

            function Cell$1$reflection(e) {
                return (0, i.class_type)("tbnf.Grammar.Cell`1", [e], Cell$1)
            }

            function Cell$1_$ctor() {
                return new Cell$1
            }

            function Cell$1__Set_2B595(e, t) {
                e._cell = t
            }

            function Cell$1__get_Get(e) {
                return e._cell
            }

            function Cell$1__get_IsNull(e) {
                return e._cell === null
            }
            class position extends n.Record {
                constructor(e, t, r) {
                    super();
                    this.line = e | 0;
                    this.col = t | 0;
                    this.filename = r
                }
            }
            t.position = position;

            function position$reflection() {
                return (0, i.record_type)("tbnf.Grammar.position", [], position, (() => [
                    ["line", i.int32_type],
                    ["col", i.int32_type],
                    ["filename", i.string_type]
                ]))
            }
            class node extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["EApp", "ETuple", "EList", "EField", "ELet", "EFun", "EVar", "ESlot", "EInt", "EStr", "EFlt", "EBool"]
                }
            }
            t.node = node;

            function node$reflection() {
                return (0, i.union_type)("tbnf.Grammar.node", [], node, (() => [
                    [
                        ["Item1", expr$reflection()],
                        ["Item2", (0, i.list_type)(expr$reflection())]
                    ],
                    [
                        ["Item", (0, i.list_type)(expr$reflection())]
                    ],
                    [
                        ["Item", (0, i.list_type)(expr$reflection())]
                    ],
                    [
                        ["Item1", expr$reflection()],
                        ["Item2", i.string_type]
                    ],
                    [
                        ["Item1", i.string_type],
                        ["Item2", expr$reflection()],
                        ["Item3", expr$reflection()]
                    ],
                    [
                        ["Item1", (0, i.list_type)((0, i.tuple_type)(i.string_type, monot$reflection()))],
                        ["Item2", expr$reflection()]
                    ],
                    [
                        ["Item1", i.string_type],
                        ["Item2", (0, i.record_type)("Microsoft.FSharp.Core.FSharpRef`1", [(0, i.list_type)(monot$reflection())], n.FSharpRef, (() => [
                            ["contents", (0, i.list_type)(monot$reflection())]
                        ]))]
                    ],
                    [
                        ["Item", i.int32_type]
                    ],
                    [
                        ["Item", i.int32_type]
                    ],
                    [
                        ["Item", i.string_type]
                    ],
                    [
                        ["Item", i.float64_type]
                    ],
                    [
                        ["Item", i.bool_type]
                    ]
                ]))
            }
            class expr extends n.Record {
                constructor(e, t, r) {
                    super();
                    this.node = e;
                    this.pos = t;
                    this.t = r
                }
            }
            t.expr = expr;

            function expr$reflection() {
                return (0, i.record_type)("tbnf.Grammar.expr", [], expr, (() => [
                    ["node", node$reflection()],
                    ["pos", position$reflection()],
                    ["t", monot$reflection()]
                ]))
            }
            class monot extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["TRef", "TConst", "TApp", "TFun", "TVar"]
                }
            }
            t.monot = monot;

            function monot$reflection() {
                return (0, i.union_type)("tbnf.Grammar.monot", [], monot, (() => [
                    [
                        ["Item", Cell$1$reflection(monot$reflection())]
                    ],
                    [
                        ["Item", i.string_type]
                    ],
                    [
                        ["Item1", monot$reflection()],
                        ["Item2", (0, i.list_type)(monot$reflection())]
                    ],
                    [
                        ["Item1", (0, i.list_type)((0, i.tuple_type)(i.string_type, monot$reflection()))],
                        ["Item2", monot$reflection()]
                    ],
                    [
                        ["Item", i.string_type]
                    ]
                ]))
            }
            class polyt extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["Poly", "Mono"]
                }
            }
            t.polyt = polyt;

            function polyt$reflection() {
                return (0, i.union_type)("tbnf.Grammar.polyt", [], polyt, (() => [
                    [
                        ["Item1", (0, i.list_type)(i.string_type)],
                        ["Item2", monot$reflection()]
                    ],
                    [
                        ["Item", monot$reflection()]
                    ]
                ]))
            }
            class production extends n.Record {
                constructor(e, t) {
                    super();
                    this.symbols = e;
                    this.action = t
                }
            }
            t.production = production;

            function production$reflection() {
                return (0, i.record_type)("tbnf.Grammar.production", [], production, (() => [
                    ["symbols", (0, i.list_type)(symbol$reflection())],
                    ["action", expr$reflection()]
                ]))
            }
            class symbol extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["Term", "Nonterm", "Macrocall"]
                }
            }
            t.symbol = symbol;

            function symbol$reflection() {
                return (0, i.union_type)("tbnf.Grammar.symbol", [], symbol, (() => [
                    [
                        ["Item1", i.string_type],
                        ["Item2", i.bool_type]
                    ],
                    [
                        ["Item", i.string_type]
                    ],
                    [
                        ["Item1", i.string_type],
                        ["Item2", (0, i.list_type)(symbol$reflection())],
                        ["Item3", position$reflection()]
                    ]
                ]))
            }
            class definition extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["Defmacro", "Defrule", "Deflexer", "Declvar", "Declctor", "Decltype", "Defignore"]
                }
            }
            t.definition = definition;

            function definition$reflection() {
                return (0, i.union_type)("tbnf.Grammar.definition", [], definition, (() => [
                    [
                        ["Item", (0, i.anonRecord_type)(["define", (0, i.list_type)((0, i.tuple_type)(position$reflection(), production$reflection()))], ["lhs", i.string_type], ["parameters", (0, i.list_type)(i.string_type)], ["pos", position$reflection()])]
                    ],
                    [
                        ["Item", (0, i.anonRecord_type)(["define", (0, i.list_type)((0, i.tuple_type)(position$reflection(), production$reflection()))], ["lhs", i.string_type], ["pos", position$reflection()])]
                    ],
                    [
                        ["Item", (0, i.anonRecord_type)(["define", lexerule$reflection()], ["lhs", i.string_type], ["pos", position$reflection()])]
                    ],
                    [
                        ["Item", (0, i.anonRecord_type)(["ident", i.string_type], ["pos", position$reflection()], ["t", polyt$reflection()])]
                    ],
                    [
                        ["Item", (0, i.anonRecord_type)(["ident", i.string_type], ["pos", position$reflection()], ["t", monot$reflection()])]
                    ],
                    [
                        ["Item", (0, i.anonRecord_type)(["external", i.bool_type], ["fields", (0, i.list_type)((0, i.tuple_type)(i.string_type, monot$reflection(), position$reflection()))], ["hasFields", i.bool_type], ["ident", i.string_type], ["parameters", (0, i.list_type)(i.string_type)], ["pos", position$reflection()])]
                    ],
                    [
                        ["Item", (0, i.anonRecord_type)(["ignoreList", (0, i.list_type)(i.string_type)], ["pos", position$reflection()])]
                    ]
                ]))
            }
            class lexerule extends n.Union {
                constructor(e, ...t) {
                    super();
                    this.tag = e | 0;
                    this.fields = t
                }
                cases() {
                    return ["LNumber", "LWildcard", "LSeq", "LStr", "LOr", "LNot", "LPlus", "LStar", "LOptional", "LGroup", "LRange", "LRef"]
                }
            }
            t.lexerule = lexerule;

            function lexerule$reflection() {
                return (0, i.union_type)("tbnf.Grammar.lexerule", [], lexerule, (() => [
                    [],
                    [],
                    [
                        ["Item", (0, i.list_type)(lexerule$reflection())]
                    ],
                    [
                        ["Item", i.string_type]
                    ],
                    [
                        ["Item", (0, i.list_type)(lexerule$reflection())]
                    ],
                    [
                        ["Item", lexerule$reflection()]
                    ],
                    [
                        ["Item", lexerule$reflection()]
                    ],
                    [
                        ["Item", lexerule$reflection()]
                    ],
                    [
                        ["Item", lexerule$reflection()]
                    ],
                    [
                        ["Item", lexerule$reflection()]
                    ],
                    [
                        ["Item1", i.int32_type],
                        ["Item2", i.int32_type]
                    ],
                    [
                        ["Item", i.string_type]
                    ]
                ]))
            }

            function position_get_Fake() {
                return new position(0, 0, "")
            }

            function expr_WithNode(e, t) {
                return new expr(t, e.pos, e.t)
            }

            function expr__TransformChildren_Z51B8244A(e, t) {
                let r;
                return expr_WithNode(e, (r = e.node, r.tag === 1 ? new node(1, (0, o.map)(t, r.fields[0])) : r.tag === 2 ? new node(2, (0, o.map)(t, r.fields[0])) : r.tag === 3 ? new node(3, t(r.fields[0]), r.fields[1]) : r.tag === 4 ? new node(4, r.fields[0], t(r.fields[1]), t(r.fields[2])) : r.tag === 5 ? new node(5, r.fields[0], r.fields[1]) : r.tag === 7 ? r : r.tag === 6 ? r : r.tag === 9 ? r : r.tag === 8 ? r : r.tag === 10 ? r : r.tag === 11 ? r : new node(0, t(r.fields[0]), (0, o.map)(t, r.fields[1]))))
            }

            function expr__DeepCopy(e) {
                const transformer = e => {
                    const t = e.node;
                    if (t.tag === 6) {
                        return expr_WithNode(e, new node(6, t.fields[0], new n.FSharpRef(t.fields[1].contents)))
                    } else {
                        return expr__TransformChildren_Z51B8244A(e, transformer)
                    }
                };
                return transformer(e)
            }

            function monot__FindAnyChildren_Z23D07CE9(e, t) {
                switch (e.tag) {
                    case 4:
                    case 0: {
                        return false
                    }
                    case 2: {
                        if (t(e.fields[0])) {
                            return true
                        } else {
                            return (0, o.exists)(t, e.fields[1])
                        }
                    }
                    case 3: {
                        if ((0, o.exists)((e => t(e[1])), e.fields[0])) {
                            return true
                        } else {
                            return t(e.fields[1])
                        }
                    }
                    default: {
                        return false
                    }
                }
            }

            function monot__TransformChildren_Z2CAB662A(e, t) {
                let r, n;
                switch (e.tag) {
                    case 4: {
                        r = 0;
                        n = e;
                        break
                    }
                    case 0: {
                        r = 0;
                        n = e;
                        break
                    }
                    case 2: {
                        r = 1;
                        break
                    }
                    case 3: {
                        r = 2;
                        break
                    }
                    default: {
                        r = 0;
                        n = e
                    }
                }
                switch (r) {
                    case 0: {
                        return n
                    }
                    case 1: {
                        return new monot(2, t(e.fields[0]), (0, o.map)(t, e.fields[1]))
                    }
                    case 2: {
                        return new monot(3, (0, o.map)((e => [e[0], t(e[1])]), e.fields[0]), t(e.fields[1]))
                    }
                }
            }

            function monot__ApplyToChildren_Z6A62BCBF(e, t) {
                switch (e.tag) {
                    case 4:
                    case 0: {
                        break
                    }
                    case 2: {
                        t(e.fields[0]);
                        (0, o.iterate)(t, e.fields[1]);
                        break
                    }
                    case 3: {
                        (0, o.iterate)((e => {
                            t(e[1])
                        }), e.fields[0]);
                        t(e.fields[1]);
                        break
                    }
                    default: {}
                }
            }

            function monot__Prune(e) {
                const prune = e => {
                    let t;
                    if (e.tag === 0) {
                        if (Cell$1__get_IsNull(e.fields[0])) {
                            t = 0
                        } else {
                            t = 1
                        }
                    } else {
                        t = 1
                    }
                    switch (t) {
                        case 0: {
                            return e
                        }
                        case 1: {
                            if (e.tag === 0) {
                                const t = e.fields[0];
                                const r = prune(Cell$1__get_Get(t));
                                Cell$1__Set_2B595(t, r);
                                return r
                            } else {
                                return monot__TransformChildren_Z2CAB662A(e, prune)
                            }
                        }
                    }
                };
                return prune(e)
            }

            function symbol__Inspect(e) {
                if (e.tag === 1) {
                    return e.fields[0]
                } else if (e.tag === 2) {
                    return e.fields[0] + "(" + (0, s.join)(", ", (0, o.map)(symbol__Inspect, e.fields[1])) + ")"
                } else if (e.fields[1]) {
                    return (0, a.escapeString)(e.fields[0])
                } else {
                    return "<" + e.fields[0] + ">"
                }
            }

            function definition__get_Position(e) {
                switch (e.tag) {
                    case 1: {
                        return e.fields[0].pos
                    }
                    case 2: {
                        return e.fields[0].pos
                    }
                    case 3: {
                        return e.fields[0].pos
                    }
                    case 4: {
                        return e.fields[0].pos
                    }
                    case 5: {
                        return e.fields[0].pos
                    }
                    case 6: {
                        return e.fields[0].pos
                    }
                    default: {
                        return e.fields[0].pos
                    }
                }
            }

            function definition__Inspect(e) {
                if (e.tag === 1) {
                    const t = e.fields[0];
                    return t.lhs + " :\n " + (0, s.join)("\n| ", (0, o.map)((e => (0, s.join)(" ", (0, o.map)(symbol__Inspect, e[1].symbols))), t.define))
                } else {
                    return "omit"
                }
            }
            const _ = new monot(1, "token");
            t.TConst_token = _;
            const u = new monot(1, "tuple");
            t.TConst_tuple = u;
            const c = new monot(1, "list");
            t.TConst_list = c;
            const d = new monot(1, "int");
            t.TConst_int = d;
            const p = new monot(1, "float");
            t.TConst_float = p;
            const f = new monot(1, "str");
            t.TConst_str = f;
            const h = new monot(1, "bool");
            t.TConst_bool = h;
            const g = [
                ["token", 0],
                ["tuple", -1],
                ["list", 1],
                ["int", 0],
                ["float", 0],
                ["str", 0],
                ["bool", 0]
            ];
            t._predefined_typenames = g;

            function TTuple(e) {
                return new monot(2, u, e)
            }

            function TList(e) {
                return new monot(2, c, (0, o.singleton)(e))
            }

            function $007CTTuple$007C_$007C(e) {
                let t;
                if (e.tag === 1) {
                    if (e.fields[0] === "tuple") {
                        t = 0
                    } else {
                        t = 1
                    }
                } else {
                    t = 1
                }
                switch (t) {
                    case 0: {
                        return (0, l.some)(void 0)
                    }
                    case 1: {
                        return void 0
                    }
                }
            }
        },
        380: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.inspectMonoType = inspectMonoType;
            t.showExpr = showExpr;
            var n = r(6638);
            var i = r(9937);
            var o = r(5359);
            var s = r(3833);
            var a = r(4222);
            var l = r(1697);

            function inspectMonoType(e) {
                let t, r, a, l;
                if (e.tag === 0) {
                    t = 0;
                    r = e.fields[0]
                } else if (e.tag === 1) {
                    t = 1;
                    a = e.fields[0]
                } else if (e.tag === 2) {
                    if ((0, s.$007CTTuple$007C_$007C)(e.fields[0]) != null) {
                        t = 2;
                        l = e.fields[1]
                    } else {
                        t = 3
                    }
                } else {
                    t = 3
                }
                switch (t) {
                    case 0: {
                        return (0, n.toString)(r)
                    }
                    case 1: {
                        return a
                    }
                    case 2: {
                        return "(" + (0, i.join)(" * ", (0, o.map)(inspectMonoType, l)) + ")"
                    }
                    case 3: {
                        switch (e.tag) {
                            case 2: {
                                return inspectMonoType(e.fields[0]) + "<" + (0, i.join)(", ", (0, o.map)(inspectMonoType, e.fields[1])) + ">"
                            }
                            case 3: {
                                return "(" + (0, i.join)(", ", (0, o.map)((e => e[0] + ": " + inspectMonoType(e[1])), e.fields[0])) + ") ->" + inspectMonoType(e.fields[1])
                            }
                            case 4: {
                                return "'" + e.fields[0]
                            }
                            default: {
                                throw new Error("Match failure: tbnf.Grammar.monot")
                            }
                        }
                    }
                }
            }

            function showExpr(e) {
                const t = e.node;
                if (t.tag === 6) {
                    if ((0, o.isEmpty)(t.fields[1].contents)) {
                        return t.fields[0]
                    } else {
                        const e = t.fields[1].contents;
                        return t.fields[0] + "<" + (0, i.join)(", ", (0, o.map)(inspectMonoType, e)) + ">"
                    }
                } else if (t.tag === 11) {
                    if (t.fields[0]) {
                        return "true"
                    } else {
                        return "false"
                    }
                } else if (t.tag === 10) {
                    return t.fields[0].toString()
                } else if (t.tag === 8) {
                    return (0, a.int32ToString)(t.fields[0])
                } else if (t.tag === 1) {
                    return "(" + (0, i.join)(", ", (0, o.map)(showExpr, t.fields[0])) + ")"
                } else if (t.tag === 2) {
                    return "[" + (0, i.join)(", ", (0, o.map)(showExpr, t.fields[0])) + "]"
                } else if (t.tag === 3) {
                    return showExpr(t.fields[0]) + "." + t.fields[1]
                } else if (t.tag === 7) {
                    return "$ " + (0, a.int32ToString)(t.fields[0])
                } else if (t.tag === 4) {
                    return "let " + t.fields[0] + " = " + showExpr(t.fields[1]) + " in " + showExpr(t.fields[2])
                } else if (t.tag === 5) {
                    return "fun " + (0, i.join)(" ", (0, o.map)((e => "(" + e[0] + ": " + inspectMonoType(e[1]) + ")"), t.fields[0])) + " -> " + showExpr(t.fields[1])
                } else if (t.tag === 9) {
                    return (0, l.escapeString)(t.fields[0])
                } else {
                    return showExpr(t.fields[0]) + "(" + (0, i.join)(", ", (0, o.map)(showExpr, t.fields[1])) + ")"
                }
            }
        },
        6109: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.resolve_macro = resolve_macro;
            t.toPositionIndependent = toPositionIndependent;
            t.toPositionIndependentString = toPositionIndependentString;
            var n = r(5359);
            var i = r(3833);
            var o = r(9937);
            var s = r(1697);
            var a = r(5466);
            var l = r(2078);
            var _ = r(4205);

            function toPositionIndependent(e) {
                switch (e.tag) {
                    case 0: {
                        return e
                    }
                    case 2: {
                        return new i.symbol(2, e.fields[0], (0, n.map)(toPositionIndependent, e.fields[1]), (0, i.position_get_Fake)())
                    }
                    default: {
                        return e
                    }
                }
            }

            function toPositionIndependentString(e) {
                if (e.tag === 1) {
                    return e.fields[0]
                } else if (e.tag === 2) {
                    const t = (0, o.join)(",", (0, n.map)(toPositionIndependentString, e.fields[1]));
                    return (0, o.toText)((0, o.printf)("%s(%s)"))(e.fields[0])(t)
                } else if (e.fields[1]) {
                    return (0, s.escapeString)(e.fields[0])
                } else {
                    return "<" + e.fields[0] + ">"
                }
            }

            function resolve_macro(e, t, r, s) {
                let u = (0, a.empty)();
                let c = (0, n.empty)();
                let d = (0, n.empty)();
                for (let e = 0; e <= s.length - 1; e++) {
                    const t = s[e];
                    switch (t.tag) {
                        case 0: {
                            const e = t.fields[0];
                            u = (0, a.add)(e.lhs, e, u);
                            break
                        }
                        case 1: {
                            const e = (0, a.empty)();
                            c = (0, n.cons)([t.fields[0], e], c);
                            break
                        }
                        default: {
                            d = (0, n.cons)(t, d)
                        }
                    }
                }
                let p;
                let f = c;
                let h = (0, n.empty)();
                let g = (0, a.empty)();
                const solve_specialization = o => {
                    const s = o[0];
                    t(new i.definition(1, s));
                    let a = (0, n.mapIndexed)(((t, s) => {
                        const a = s[0];
                        const l = s[1];
                        e(a);
                        r(t);
                        return [a, new i.production((0, n.map)((e => solve_sym(e)(o[1])), l.symbols), (0, i.expr__DeepCopy)(l.action))]
                    }), s.define);
                    h = (0, n.cons)(new i.definition(1, {
                        define: a,
                        lhs: s.lhs,
                        pos: s.pos
                    }), h)
                };
                const solve_sym = t => r => {
                    let s, c, d, p, h, m, y, S, T;
                    switch (t.tag) {
                        case 1: {
                            const e = (0, a.tryFind)(t.fields[0], r);
                            return e == null ? t : e
                        }
                        case 2: {
                            const x = t.fields[2];
                            const C = t.fields[0];
                            e(x);
                            const N = (0, l.toList)((0, l.delay)((() => (0, l.map)((e => solve_sym(e)(r)), t.fields[1]))));
                            let A = new i.symbol(2, C, N, x);
                            const E = toPositionIndependent(A);
                            return new i.symbol(1, (s = (0, a.tryFind)(E, g), s == null ? (c = (0, a.tryFind)(C, u), c != null ? (d = c, p = d.parameters, (0, n.length)(p) !== (0, n.length)(N) ? (h = (0, o.join)(", ", p), m = new _.MacroResolveError(`macro ${C} expects ${(0,n.length)(p)} argument(s): (${h}); got ${(0,n.length)(N)}`), (() => {
                                throw m
                            })()) : void 0, y = (0, a.ofList)((0, n.map2)(((e, t) => [e, t]), p, N)), S = toPositionIndependentString(A), g = (0, a.add)(E, S, g), f = (0, n.cons)([{
                                define: d.define,
                                lhs: S,
                                pos: x
                            }, y], f), S) : (T = new _.MacroResolveError(`macro definition ${C} not found.`), (() => {
                                throw T
                            })())) : s))
                        }
                        default: {
                            return t
                        }
                    }
                };
                while (!(0, n.isEmpty)(f)) {
                    const e = (0, n.head)(f);
                    f = (0, n.tail)(f);
                    solve_specialization(e)
                }
                p = h;
                return (0, n.toArray)((0, n.append)((0, n.reverse)(d), p))
            }
        },
        5891: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.basename = basename;
            var n = r(4205);

            function basename(e) {
                e: while (true) {
                    const t = e;
                    switch (t.tag) {
                        case 3:
                        case 0:
                        case 4: {
                            const e = new n.NoBaseName(t);
                            throw e
                        }
                        case 2: {
                            e = t.fields[0];
                            continue e
                        }
                        default: {
                            return t.fields[0]
                        }
                    }
                    break
                }
            }
        },
        5506: (e, t) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.ocaml_rts_file = void 0;
            const r = "ocaml.rts_file";
            t.ocaml_rts_file = r
        },
        7362: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.Manager = void 0;
            t.Manager$reflection = Manager$reflection;
            t.Manager_$ctor = Manager_$ctor;
            t.Manager__CellRepr_7A2426C3 = Manager__CellRepr_7A2426C3;
            t.Manager__Instantiate_Z25E5E15E = Manager__Instantiate_Z25E5E15E;
            t.Manager__NewTyRef_Z721C83C5 = Manager__NewTyRef_Z721C83C5;
            t.Manager__Unify_Z1D753960 = Manager__Unify_Z1D753960;
            var n = r(6356);
            var i = r(4205);
            var o = r(3833);
            var s = r(5359);
            var a = r(4222);
            var l = r(5466);
            class Manager {
                constructor() {}
            }
            t.Manager = Manager;

            function Manager$reflection() {
                return (0, n.class_type)("tbnf.Unification.Manager", void 0, Manager)
            }

            function Manager_$ctor() {
                return new Manager
            }

            function Manager__Instantiate_Z25E5E15E(e, t) {
                return Manager__instantiate_Z25E5E15E(e, t)
            }

            function Manager__Unify_Z1D753960(e, t, r) {
                try {
                    Manager__unify(e, t, r)
                } catch (e) {
                    if (e instanceof i.TypeMismatch) {
                        throw new i.TypeMismatch(t, r)
                    } else {
                        throw e
                    }
                }
            }

            function Manager__NewTyRef_Z721C83C5(e, t) {
                return Manager__newTyRef_Z721C83C5(e, t)
            }

            function Manager__CellRepr_7A2426C3(e, t) {
                throw new Error("access repr of unknown typeref.")
            }

            function Manager__newTyRef_Z721C83C5(e, t) {
                return new o.monot(0, (0, o.Cell$1_$ctor)())
            }

            function Manager__occur_in(e, t, r) {
                let n;
                if (r.tag === 0) {
                    if (r.fields[0] === t) {
                        n = 0
                    } else {
                        n = 1
                    }
                } else {
                    n = 1
                }
                switch (n) {
                    case 0: {
                        return true
                    }
                    case 1: {
                        return (0, o.monot__FindAnyChildren_Z23D07CE9)(r, (r => Manager__occur_in(e, t, r)))
                    }
                }
            }

            function Manager__op_AtEqualsAt(e, t, r) {
                return (0, s.length)(t) === (0, s.length)(r)
            }

            function Manager__unify(e, t, r) {
                e: while (true) {
                    const n = e,
                        l = t,
                        _ = r;
                    const u = (0, o.monot__Prune)(l);
                    const c = (0, o.monot__Prune)(_);
                    const d = [u, c];
                    let p, f;
                    if (d[0].tag === 0) {
                        p = 0;
                        f = d[0].fields[0]
                    } else if (d[0].tag === 1) {
                        if (d[1].tag === 0) {
                            p = 1
                        } else if (d[1].tag === 1) {
                            if (d[0].fields[0] === d[1].fields[0]) {
                                p = 2
                            } else {
                                p = 3
                            }
                        } else {
                            p = 3
                        }
                    } else if (d[1].tag === 0) {
                        p = 1
                    } else {
                        p = 3
                    }
                    switch (p) {
                        case 0: {
                            if ((0, a.equals)(u, c)) {} else if (Manager__occur_in(n, f, c)) {
                                const e = new i.IllFormedType(u, c);
                                throw e
                            } else {
                                (0, o.Cell$1__Set_2B595)(f, c)
                            }
                            break
                        }
                        case 1: {
                            e = n;
                            t = c;
                            r = u;
                            continue e;
                            break
                        }
                        case 2: {
                            break
                        }
                        case 3: {
                            let o;
                            if (d[0].tag === 4) {
                                if (d[1].tag === 4) {
                                    if (d[0].fields[0] === d[1].fields[0]) {
                                        o = 0
                                    } else {
                                        o = 1
                                    }
                                } else {
                                    o = 1
                                }
                            } else {
                                o = 1
                            }
                            switch (o) {
                                case 0: {
                                    break
                                }
                                case 1: {
                                    let o, a, l, _, p;
                                    if (d[0].tag === 2) {
                                        if (d[1].tag === 2) {
                                            if (Manager__op_AtEqualsAt(n, d[0].fields[1], d[1].fields[1])) {
                                                o = 0;
                                                a = d[0].fields[0];
                                                l = d[0].fields[1];
                                                _ = d[1].fields[0];
                                                p = d[1].fields[1]
                                            } else {
                                                o = 1
                                            }
                                        } else {
                                            o = 1
                                        }
                                    } else {
                                        o = 1
                                    }
                                    switch (o) {
                                        case 0: {
                                            Manager__unify(n, a, _);
                                            (0, s.iterate2)(((e, t) => {
                                                Manager__unify(n, e, t)
                                            }), l, p);
                                            break
                                        }
                                        case 1: {
                                            let o, a, l, _, p;
                                            if (d[0].tag === 3) {
                                                if (d[1].tag === 3) {
                                                    if (Manager__op_AtEqualsAt(n, d[0].fields[0], d[1].fields[0])) {
                                                        o = 0;
                                                        a = d[0].fields[1];
                                                        l = d[0].fields[0];
                                                        _ = d[1].fields[1];
                                                        p = d[1].fields[0]
                                                    } else {
                                                        o = 1
                                                    }
                                                } else {
                                                    o = 1
                                                }
                                            } else {
                                                o = 1
                                            }
                                            switch (o) {
                                                case 0: {
                                                    (0, s.iterate2)(((e, t) => {
                                                        Manager__unify(n, e[1], t[1])
                                                    }), l, p);
                                                    e = n;
                                                    t = a;
                                                    r = _;
                                                    continue e;
                                                    break
                                                }
                                                case 1: {
                                                    const e = new i.TypeMismatch(u, c);
                                                    throw e;
                                                    break
                                                }
                                            }
                                            break
                                        }
                                    }
                                    break
                                }
                            }
                            break
                        }
                    }
                    break
                }
            }

            function Manager__instantiate_Z25E5E15E(e, t) {
                let r, n, a, _;
                if (t.tag === 0) {
                    if ((0, s.isEmpty)(t.fields[0])) {
                        r = 0;
                        n = t.fields[1]
                    } else {
                        r = 1;
                        a = t.fields[1];
                        _ = t.fields[0]
                    }
                } else {
                    r = 0;
                    n = t.fields[0]
                }
                switch (r) {
                    case 0: {
                        return [(0, s.empty)(), n]
                    }
                    case 1: {
                        const t = (0, s.map)((t => [t, Manager__newTyRef_Z721C83C5(e, t)]), _);
                        const r = (0, l.ofList)(t);
                        const instantiate = e => {
                            if (e.tag === 4) {
                                const t = e.fields[0];
                                const n = (0, l.tryFind)(t, r);
                                if (n != null) {
                                    return n
                                } else {
                                    const e = (0, i.UnboundTypeVariable)(t);
                                    throw e
                                }
                            } else {
                                return (0, o.monot__TransformChildren_Z2CAB662A)(e, instantiate)
                            }
                        };
                        return [(0, s.unzip)(t)[1], instantiate(a)]
                    }
                }
            }
        },
        1697: (e, t, r) => {
            Object.defineProperty(t, "__esModule", {
                value: true
            });
            t.List_lookup = List_lookup;
            t.List_replaceWith = List_replaceWith;
            t.List_tryLookup = List_tryLookup;
            t._escapeString = _escapeString;
            t._escapeStringSingleQuoted = _escapeStringSingleQuoted;
            t.capitalized = capitalized;
            t.digitRange = void 0;
            t.escapeString = escapeString;
            t.escapeStringSingleQuoted = escapeStringSingleQuoted;
            t.iToU4 = iToU4;
            t.isDigit = isDigit;
            t.isLower = isLower;
            t.isUnicode = isUnicode;
            t.isUpper = isUpper;
            t.upperRange = t.upperChars = t.unicodeRange = t.sampleUnicodes = t.lowerRange = t.lowerChars = void 0;
            var n = r(2078);
            var i = r(857);
            var o = r(8443);
            var s = r(6638);
            var a = r(9937);
            var l = r(5359);
            var _ = r(4222);
            var u = r(6256);
            const c = (0, n.toArray)((0, n.delay)((() => (0, n.map)((e => e), (0, i.rangeChar)("a", "z")))));
            t.lowerChars = c;
            const d = (0, n.toArray)((0, n.delay)((() => (0, n.map)((e => e), (0, i.rangeChar)("A", "Z")))));
            t.upperChars = d;
            const p = [20320, 26159, 22612, 33778, 21527];
            t.sampleUnicodes = p;
            const f = ["a", "z"];
            t.lowerRange = f;
            const h = ["A", "Z"];
            t.upperRange = h;
            const g = ["", ""];
            t.unicodeRange = g;
            const m = ["0", "9"];
            t.digitRange = m;

            function isDigit(e) {
                if ("0" <= e) {
                    return e <= "9"
                } else {
                    return false
                }
            }

            function isUpper(e) {
                if ("A" <= e) {
                    return e <= "Z"
                } else {
                    return false
                }
            }

            function isLower(e) {
                if ("a" <= e) {
                    return e <= "z"
                } else {
                    return false
                }
            }

            function isUnicode(e) {
                if ("" <= e) {
                    return e <= ""
                } else {
                    return false
                }
            }

            function _escapeString(e) {
                let t;
                const r = (0, o.StringBuilder_$ctor_Z721C83C5)('"');
                for (let n = 0; n <= e.length - 1; n++) {
                    t = e[n], t === "\t" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\t") : t === "\n" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\n") : t === "\r" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\r") : t === '"' ? (0, o.StringBuilder__Append_Z721C83C5)(r, '\\"') : t === "\\" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\\\") : (0, o.StringBuilder__Append_244C7CD6)(r, t)
                }(0, o.StringBuilder__Append_Z721C83C5)(r, '"');
                return (0, s.toString)(r)
            }

            function iToU4(e) {
                return "\\u" + (0, a.replace)((0, a.toText)((0, a.printf)("%4X"))(e), " ", "0")
            }

            function _escapeStringSingleQuoted(e) {
                let t;
                const r = (0, o.StringBuilder_$ctor_Z721C83C5)("'");
                for (let n = 0; n <= e.length - 1; n++) {
                    t = e[n], t === "\t" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\t") : t === "\n" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\n") : t === "\r" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\r") : t === "'" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\'") : t === "\\" ? (0, o.StringBuilder__Append_Z721C83C5)(r, "\\\\") : (0, o.StringBuilder__Append_244C7CD6)(r, t)
                }(0, o.StringBuilder__Append_Z721C83C5)(r, "'");
                return (0, s.toString)(r)
            }

            function escapeStringSingleQuoted(e) {
                return _escapeStringSingleQuoted(e)
            }

            function escapeString(e) {
                return _escapeString(e)
            }

            function capitalized(e) {
                if (e === "") {
                    return e
                } else {
                    return e[0].toUpperCase() + e.slice(1, e.length - 1 + 1)
                }
            }

            function List_tryLookup(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (!(0, l.isEmpty)(n)) {
                        if ((0, _.equals)((0, l.head)(n)[0], r)) {
                            return (0, u.some)((0, l.head)(n)[1])
                        } else if (!(0, l.isEmpty)(n)) {
                            e = r;
                            t = (0, l.tail)(n);
                            continue e
                        } else {
                            throw new Error("Match failure")
                        }
                    } else {
                        return void 0
                    }
                    break
                }
            }

            function List_lookup(e, t) {
                e: while (true) {
                    const r = e,
                        n = t;
                    if (!(0, l.isEmpty)(n)) {
                        if ((0, _.equals)((0, l.head)(n)[0], r)) {
                            return (0, l.head)(n)[1]
                        } else if (!(0, l.isEmpty)(n)) {
                            e = r;
                            t = (0, l.tail)(n);
                            continue e
                        } else {
                            throw new Error("Match failure")
                        }
                    } else {
                        throw new Error("key not found")
                    }
                    break
                }
            }

            function List_replaceWith(e, t, r) {
                if (!(0, l.isEmpty)(r)) {
                    if ((0, _.equals)((0, l.head)(r)[0], e)) {
                        return (0, l.cons)([(0, l.head)(r)[0], t((0, u.some)((0, l.head)(r)[1]))], (0, l.tail)(r))
                    } else if (!(0, l.isEmpty)(r)) {
                        return (0, l.cons)((0, l.head)(r), List_replaceWith(e, t, (0, l.tail)(r)))
                    } else {
                        throw new Error("Match failure")
                    }
                } else {
                    return (0, l.singleton)([e, t(void 0)])
                }
            }
        }
    };
    var t = {};

    function __nccwpck_require__(r) {
        var n = t[r];
        if (n !== undefined) {
            return n.exports
        }
        var i = t[r] = {
            exports: {}
        };
        var o = true;
        try {
            e[r].call(i.exports, i, i.exports, __nccwpck_require__);
            o = false
        } finally {
            if (o) delete t[r]
        }
        return i.exports
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var r = {};
    (() => {
        var e = __nccwpck_require__(7688);
        var t = __nccwpck_require__(1515);
        var r = _interopRequireWildcard(__nccwpck_require__(7147));
        var n = _interopRequireWildcard(__nccwpck_require__(1017));
        var i = _interopRequireWildcard(__nccwpck_require__(5506));
        var o = _interopRequireWildcard(__nccwpck_require__(3776));
        var s = _interopRequireWildcard(__nccwpck_require__(3474));
        var a = _interopRequireWildcard(__nccwpck_require__(2835));
        var l = _interopRequireWildcard(__nccwpck_require__(9956));
        var _ = _interopRequireWildcard(__nccwpck_require__(1500));
        var u = __nccwpck_require__(9386);
        var c = __nccwpck_require__(7936);

        function _getRequireWildcardCache(e) {
            if (typeof WeakMap !== "function") return null;
            var t = new WeakMap;
            var r = new WeakMap;
            return (_getRequireWildcardCache = function(e) {
                return e ? r : t
            })(e)
        }

        function _interopRequireWildcard(e, t) {
            if (!t && e && e.__esModule) {
                return e
            }
            if (e === null || typeof e !== "object" && typeof e !== "function") {
                return {
                    default: e
                }
            }
            var r = _getRequireWildcardCache(t);
            if (r && r.has(e)) {
                return r.get(e)
            }
            var n = {};
            var i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in e) {
                if (o !== "default" && Object.prototype.hasOwnProperty.call(e, o)) {
                    var s = i ? Object.getOwnPropertyDescriptor(e, o) : null;
                    if (s && (s.get || s.set)) {
                        Object.defineProperty(n, o, s)
                    } else {
                        n[o] = e[o]
                    }
                }
            }
            n.default = e;
            if (r) {
                r.set(e, n)
            }
            return n
        }
        const d = {
            "python-lark": s.codegen,
            "ocaml-menhir": a.codegen,
            "csharp-antlr": l.codegen,
            "typescript-antlr": _.codegen
        }; {
            let e = c.setExitFunc;
            e((e => process.exit(e)))
        }
        const p = new t.ArgumentParser({
            description: "Argparse example"
        });
        p.add_argument("tbnfSourcePath");
        p.add_argument("-o", "--outDir", {
            default: ""
        });
        p.add_argument("-lang", "--language", {
            help: "name of your own language",
            default: "mylang"
        });
        p.add_argument("-be", "--backend", {
            choices: Object.keys(d),
            default: "python-lark"
        });
        p.add_argument("-conf", "--configPath", {
            help: "path to a config file",
            default: ""
        });
        const f = new Map;

        function getDefaultScope() {
            return {
                request_resource: e => {
                    let t = f.get(e);
                    if (t === undefined) {
                        throw new Error("Resource not found: " + e)
                    }
                    return t
                },
                start_rule_qualified_type: null,
                rename_var: e => e,
                rename_constructor: e => e,
                rename_type: e => e,
                rename_field: e => e
            }
        }

        function runcommand() {
            let t = p.parse_args();
            let i = t.tbnfSourcePath;
            let s = t.outDir;
            let a = t.language;
            let l = t.backend;
            let _ = t.configPath;
            let c = r.readFileSync(i, "utf8");
            var f = (0, e.parse_tbnf)(c, i);
            let h = getDefaultScope();
            if (s == "") {
                s = n.dirname(i)
            }
            if (_ == "") {
                _ = n.join(s, "tbnf.config.js")
            }
            if (r.existsSync(_)) {
                let e = n.relative(r.realpathSync(__dirname), process.cwd());
                let t = n.join(e, _);
                t = "./" + t.replace(/\\/g, "/");
                let i = require(t);
                for (let e in i) {
                    h[e] = i[e]
                }
            }
            var [f, g] = o.build_analyzer(f);
            let m = d[l];
            if (m == undefined) {
                throw new Error("Backend not found: " + l)
            }
            let y = m(g, h, a, f);
            for (let [e, t] of y) {
                let i = n.join(s, e);
                let o = [];
                var writeToFile = function(e) {
                    if (typeof e == "string") {
                        o.push(e);
                        return
                    }
                    throw new Error("Expected string, got " + typeof e)
                };
                (0, u.genDoc)(t, writeToFile);
                r.writeFileSync(i, o.join(""))
            }
        }
        const h = `\nmodule TBNF_Utf8 = struct\nexception UnicodeEncodeError of int\nlet uft8_encode_unchecked : (int * Buffer.t) -> unit = fun (code, buffer) ->\n    if (code <= 0x7F) then\n        Buffer.add_int8 buffer code\n    else if code > 0x10FFFF then begin\n      Buffer.add_int8 buffer 0xEF;\n      Buffer.add_int8 buffer 0xBF;\n      Buffer.add_int8 buffer 0xBD;\n      Buffer.add_int8 buffer 0;\n      end\n    else\n    let count =\n      if code <= 0x7FF then 1\n      else if code <= 0xFFFF then 2\n      else 3;\n    in\n    let chars = Bytes.make (count + 1) @@ Char.chr 0 in\n    let code = ref code in\n    let _  = for i = 0 to count - 1 do\n        Bytes.set chars (count - i) @@ Char.chr @@  0x80 lor (!code land 0x3F);\n        code := !code lsr 6;\n      done\n    in\n    let first_code = (0x1E lsl (6-count)) lor (!code land (0x3F lsr count)) in\n    let first_code = first_code land 0xFF in\n    let _ = Bytes.set chars 0 @@ Char.chr first_code   in Buffer.add_bytes buffer chars\n\nlet utf8_encode (code, buffer) =\n  if code > 0xd7ff && code < 0xe000 then\n    raise @@ UnicodeEncodeError code\n  else uft8_encode_unchecked (code, buffer)\n\n\nlet to_out (io: out_channel) (unicode: Uchar.t array) =\n    let buffer = Buffer.create 1024 in\n    let n = Array.length unicode in\n    let _ = for i = 0 to n - 1 do\n      utf8_encode (Uchar.to_int (Array.get unicode i), buffer);\n      if i mod 512 = 511 then\n          begin\n            Buffer.output_buffer io buffer;\n            Buffer.clear buffer\n          end;\n    done in\n    Buffer.output_buffer io buffer\n\nlet to_string (unicode: Uchar.t array) =\n  let buffer = Buffer.create 80 in\n  let n = Array.length unicode in\n  let _ = for i = 0 to n - 1 do\n    utf8_encode (Uchar.to_int (Array.get unicode i), buffer);\n  done in\n  Buffer.contents buffer\n\nend\n\nlet _unknown_token lexbuf =\n    let start, _ = Sedlexing.lexing_positions lexbuf in\n    let m = TBNF_Utf8.to_string (Sedlexing.lexeme lexbuf) in\n    raise (Invalid_argument (Printf.sprintf "%s:%d:%d: codepoints %s not recognised" start.pos_fname start.pos_lnum start.pos_cnum m))\n\n\ntype tbnf_token = {\n    lexeme : string;\n    line: int;\n    col: int;\n    offset : int;\n    span: int;\n    file : string;\n}\n\nlet mktoken (buf: Sedlexing.lexbuf): tbnf_token =\n  let open Sedlexing in\n  let start_pos, _ = Sedlexing.lexing_positions buf in\n  { lexeme = TBNF_Utf8.to_string (Sedlexing.lexeme buf);\n    line = start_pos.pos_lnum;\n    col = start_pos.pos_cnum - start_pos.pos_bol;\n    offset = Sedlexing.lexeme_start buf;\n    span = lexeme_end buf - lexeme_start buf;\n    file = start_pos.pos_fname }\n`;
        f.set(i.ocaml_rts_file, h);
        runcommand()
    })();
    module.exports = r
})();